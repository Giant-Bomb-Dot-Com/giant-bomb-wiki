<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.11/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.11/ http://www.mediawiki.org/xml/export-0.11.xsd" version="0.11" xml:lang="en">
  <siteinfo>
    <sitename>gb</sitename>
    <dbname>gb_wiki</dbname>
    <base>http://localhost:8080/index.php/Main_Page</base>
    <generator>MediaWiki 1.43.1</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Gb</namespace>
      <namespace key="5" case="first-letter">Gb talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="102" case="first-letter">Property</namespace>
      <namespace key="103" case="first-letter">Property talk</namespace>
      <namespace key="108" case="first-letter">Concept</namespace>
      <namespace key="109" case="first-letter">Concept talk</namespace>
      <namespace key="112" case="first-letter">smw/schema</namespace>
      <namespace key="113" case="first-letter">smw/schema talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Main Page</title>
    <ns>0</ns>
    <id>1</id>
    <revision>
      <id>1</id>
      <timestamp>2025-07-09T04:25:45Z</timestamp>
      <contributor>
        <username>MediaWiki default</username>
        <id>2</id>
      </contributor>
      <origin>1</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="755" sha1="22vz5zlxa2zctewimaum2bf1due8hkl" xml:space="preserve">&lt;strong&gt;MediaWiki has been installed.&lt;/strong&gt;

Consult the [https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents User's Guide] for information on using the wiki software.

== Getting started ==
* [https://www.mediawiki.org/wiki/Special:MyLanguage/Manual:Configuration_settings Configuration settings list]
* [https://www.mediawiki.org/wiki/Special:MyLanguage/Manual:FAQ MediaWiki FAQ]
* [https://lists.wikimedia.org/postorius/lists/mediawiki-announce.lists.wikimedia.org/ MediaWiki release mailing list]
* [https://www.mediawiki.org/wiki/Special:MyLanguage/Localisation#Translation_resources Localise MediaWiki for your language]
* [https://www.mediawiki.org/wiki/Special:MyLanguage/Manual:Combating_spam Learn how to combat spam on your wiki]</text>
      <sha1>22vz5zlxa2zctewimaum2bf1due8hkl</sha1>
    </revision>
  </page>
  <page>
    <title>smw/schema:Profile:Facetedsearch default profile</title>
    <ns>112</ns>
    <id>2</id>
    <revision>
      <id>2</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki search import</comment>
      <origin>2</origin>
      <model>smw/schema</model>
      <format>application/json</format>
      <text bytes="1237" sha1="oe05mef0yezdf657s58cufrxzaj24u0" xml:space="preserve">{
    "type": "FACETEDSEARCH_PROFILE_SCHEMA",
    "profiles": {
        "default_profile": {
            "message_key": "smw-facetedsearch-profile-label-default",
            "debug_output": false,
            "theme": "default-theme",
            "result": {
                "default_limit": 50,
                "paging_limit": [
                    10,
                    20,
                    50,
                    250,
                    500
                ]
            },
            "filters": {
                "property_filter": {
                    "hierarchy_tree": false,
                    "filter_input": {
                        "min_item": 10
                    }
                },
                "category_filter": {
                    "hierarchy_tree": false,
                    "filter_input": {
                        "min_item": 10
                    }
                },
                "value_filter": {
                    "default_filter": "list_filter",
                    "condition_field": false,
                    "filter_input": {
                        "min_item": 10
                    }
                }
            }
        }
    },
    "tags": [
        "faceted search"
    ]
}</text>
      <sha1>oe05mef0yezdf657s58cufrxzaj24u0</sha1>
    </revision>
  </page>
  <page>
    <title>MediaWiki:Smw import schema</title>
    <ns>8</ns>
    <id>3</id>
    <revision>
      <id>3</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki default vocabulary import</comment>
      <origin>3</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="73365" sha1="khnz66z361edmu7hwoy0ozcc3hrwi7r" xml:space="preserve">https://schema.org/ | [https://schema.org/version/latest Schema.org], V 28.0
 about|Type:Text
 abridged|Type:Boolean
 abstract|Type:Text
 accelerationTime|Type:Quantity
 acceptedAnswer|Type:Text
 acceptedOffer|Type:Text
 acceptedPaymentMethod|Type:Text
 acceptsReservations|Type:Text
 accessCode|Type:Text
 accessMode|Type:Text
 accessModeSufficient|Type:Text
 accessibilityAPI|Type:Text
 accessibilityControl|Type:Text
 accessibilityFeature|Type:Text
 accessibilityHazard|Type:Text
 accessibilitySummary|Type:Text
 accommodationCategory|Type:Text
 accommodationFloorPlan|Type:Text
 accountId|Type:Text
 accountMinimumInflow|Type:Text
 accountOverdraftLimit|Type:Text
 accountablePerson|Type:Text
 acquireLicensePage|Type:Text
 acquiredFrom|Type:Text
 acrissCode|Type:Text
 actionAccessibilityRequirement|Type:Text
 actionApplication|Type:Text
 actionOption|Type:Text
 actionPlatform|Type:Text
 actionStatus|Type:Text
 actionableFeedbackPolicy|Type:Text
 activeIngredient|Type:Text
 activityDuration|Type:Text
 activityFrequency|Type:Text
 actor|Type:Text
 actors|Type:Text
 addOn|Type:Text
 additionalName|Type:Text
 additionalNumberOfGuests|Type:Number
 additionalProperty|Type:Page
 additionalType|Type:Text
 additionalVariable|Type:Text
 address|Type:Text
 addressCountry|Type:Text
 addressLocality|Type:Text
 addressRegion|Type:Text
 administrationRoute|Type:Text
 advanceBookingRequirement|Type:Text
 adverseOutcome|Type:Text
 affectedBy|Type:Text
 affiliation|Type:Text
 afterMedia|Type:Text
 agent|Type:Text
 agentInteractionStatistic|Type:Text
 aggregateRating|Type:Text
 aircraft|Type:Text
 album|Type:Text
 albumProductionType|Type:Text
 albumRelease|Type:Text
 albumReleaseType|Type:Text
 albums|Type:Text
 alcoholWarning|Type:Text
 algorithm|Type:Text
 alignmentType|Type:Text
 alternateName|Type:Text
 alternativeHeadline|Type:Text
 alternativeOf|Type:Text
 alumni|Type:Text
 alumniOf|Type:Text
 amenityFeature|Type:Text
 amount|Type:Text
 amountOfThisGood|Type:Number
 announcementLocation|Type:Text
 annualPercentageRate|Type:Text
 answerCount|Type:Number
 answerExplanation|Type:Text
 antagonist|Type:Text
 appearance|Type:Text
 applicableCountry|Type:Text
 applicableLocation|Type:Text
 applicantLocationRequirements|Type:Text
 application|Type:Text
 applicationCategory|Type:Text
 applicationContact|Type:Text
 applicationDeadline|Type:Date
 applicationStartDate|Type:Date
 applicationSubCategory|Type:Text
 applicationSuite|Type:Text
 appliesToDeliveryMethod|Type:Text
 appliesToPaymentMethod|Type:Text
 archiveHeld|Type:Text
 archivedAt|Type:URL
 area|Type:Text
 areaServed|Type:Text
 arrivalAirport|Type:Text
 arrivalBoatTerminal|Type:Text
 arrivalBusStop|Type:Text
 arrivalGate|Type:Text
 arrivalPlatform|Type:Text
 arrivalStation|Type:Text
 arrivalTerminal|Type:Text
 arrivalTime|Type:Date
 artEdition|Type:Text
 artMedium|Type:Text
 arterialBranch|Type:Text
 artform|Type:Text
 articleBody|Type:Text
 articleSection|Type:Text
 artist|Type:Text
 artworkSurface|Type:Text
 asin|Type:Text
 aspect|Type:Text
 assembly|Type:Text
 assemblyVersion|Type:Text
 assesses|Type:Text
 associatedAnatomy|Type:Text
 associatedArticle|Type:Text
 associatedClaimReview|Type:Text
 associatedDisease|Type:Text
 associatedMedia|Type:Text
 associatedMediaReview|Type:Text
 associatedPathophysiology|Type:Text
 associatedReview|Type:Text
 athlete|Type:Text
 attendee|Type:Text
 attendees|Type:Text
 audience|Type:Text
 audienceType|Type:Text
 audio|Type:Text
 auditDate|Type:Date
 authenticator|Type:Text
 author|Type:Text
 availability|Type:Text
 availabilityEnds|Type:Date
 availabilityStarts|Type:Date
 availableAtOrFrom|Type:Text
 availableChannel|Type:Text
 availableDeliveryMethod|Type:Text
 availableFrom|Type:Date
 availableIn|Type:Text
 availableLanguage|Type:Text
 availableOnDevice|Type:Text
 availableService|Type:Text
 availableStrength|Type:Text
 availableTest|Type:Text
 availableThrough|Type:Date
 award|Type:Text
 awards|Type:Text
 awayTeam|Type:Text
 backstory|Type:Text
 bankAccountType|Type:Text
 baseSalary|Type:Text
 bccRecipient|Type:Text
 bed|Type:Text
 beforeMedia|Type:Text
 beneficiaryBank|Type:Text
 benefits|Type:Text
 benefitsSummaryUrl|Type:URL
 bestRating|Type:Text
 billingAddress|Type:Text
 billingDuration|Type:Text
 billingIncrement|Type:Number
 billingPeriod|Type:Text
 billingStart|Type:Number
 bioChemInteraction|Type:Text
 bioChemSimilarity|Type:Text
 biologicalRole|Type:Text
 biomechnicalClass|Type:Text
 birthDate|Type:Date
 birthPlace|Type:Text
 bitrate|Type:Text
 blogPost|Type:Text
 blogPosts|Type:Text
 bloodSupply|Type:Text
 boardingGroup|Type:Text
 boardingPolicy|Type:Text
 bodyLocation|Type:Text
 bodyType|Type:Text
 bookEdition|Type:Text
 bookFormat|Type:Text
 bookingAgent|Type:Text
 bookingTime|Type:Date
 borrower|Type:Text
 box|Type:Text
 branch|Type:Text
 branchCode|Type:Text
 branchOf|Type:Text
 brand|Type:Text
 breadcrumb|Type:Text
 breastfeedingWarning|Type:Text
 broadcastAffiliateOf|Type:Text
 broadcastChannelId|Type:Text
 broadcastDisplayName|Type:Text
 broadcastFrequency|Type:Text
 broadcastFrequencyValue|Type:Number
 broadcastOfEvent|Type:Text
 broadcastServiceTier|Type:Text
 broadcastSignalModulation|Type:Text
 broadcastSubChannel|Type:Text
 broadcastTimezone|Type:Text
 broadcaster|Type:Text
 broker|Type:Text
 browserRequirements|Type:Text
 busName|Type:Text
 busNumber|Type:Text
 businessDays|Type:Text
 businessFunction|Type:Text
 buyer|Type:Text
 byArtist|Type:Text
 byDay|Type:Text
 byMonth|Type:Number
 byMonthDay|Type:Number
 byMonthWeek|Type:Number
 callSign|Type:Text
 calories|Type:Text
 candidate|Type:Text
 caption|Type:Text
 carbohydrateContent|Type:Text
 cargoVolume|Type:Text
 carrier|Type:Text
 carrierRequirements|Type:Text
 cashBack|Type:Boolean
 catalog|Type:Text
 catalogNumber|Type:Text
 category|Type:Text
 causeOf|Type:Text
 ccRecipient|Type:Text
 certificationIdentification|Type:Text
 certificationRating|Type:Text
 certificationStatus|Type:Text
 character|Type:Text
 characterAttribute|Type:Text
 characterName|Type:Text
 cheatCode|Type:Text
 checkinTime|Type:Date
 checkoutPageURLTemplate|Type:Text
 checkoutTime|Type:Date
 chemicalComposition|Type:Text
 chemicalRole|Type:Text
 childMaxAge|Type:Number
 childMinAge|Type:Number
 childTaxon|Type:Text
 children|Type:Text
 cholesterolContent|Type:Text
 circle|Type:Text
 citation|Type:Text
 claimInterpreter|Type:Text
 claimReviewed|Type:Text
 clincalPharmacology|Type:Text
 clinicalPharmacology|Type:Text
 clipNumber|Type:Text
 closes|Type:Text
 coach|Type:Text
 code|Type:Text
 codeRepository|Type:URL
 codeSampleType|Type:Text
 codeValue|Type:Text
 codingSystem|Type:Text
 colleague|Type:Text
 colleagues|Type:Text
 collection|Type:Text
 collectionSize|Type:Number
 color|Type:Text
 colorSwatch|Type:URL
 colorist|Type:Text
 comment|Type:Text
 commentCount|Type:Number
 commentText|Type:Text
 commentTime|Type:Date
 competencyRequired|Type:Text
 competitor|Type:Text
 composer|Type:Text
 comprisedOf|Type:Text
 conditionsOfAccess|Type:Text
 confirmationNumber|Type:Text
 connectedTo|Type:Text
 constraintProperty|Type:Page
 contactOption|Type:Text
 contactPoint|Type:Text
 contactPoints|Type:Text
 contactType|Type:Text
 contactlessPayment|Type:Boolean
 containedIn|Type:Text
 containedInPlace|Type:Text
 containsPlace|Type:Text
 containsSeason|Type:Text
 contentLocation|Type:Text
 contentRating|Type:Text
 contentReferenceTime|Type:Date
 contentSize|Type:Text
 contentType|Type:Text
 contentUrl|Type:URL
 contraindication|Type:Text
 contributor|Type:Text
 cookTime|Type:Text
 cookingMethod|Type:Text
 copyrightHolder|Type:Text
 copyrightNotice|Type:Text
 copyrightYear|Type:Number
 correction|Type:Text
 correctionsPolicy|Type:URL
 costCategory|Type:Text
 costCurrency|Type:Text
 costOrigin|Type:Text
 costPerUnit|Type:Number
 countriesNotSupported|Type:Text
 countriesSupported|Type:Text
 countryOfAssembly|Type:Text
 countryOfLastProcessing|Type:Text
 countryOfOrigin|Type:Text
 course|Type:Text
 courseCode|Type:Text
 courseMode|Type:Text
 coursePrerequisites|Type:Text
 courseSchedule|Type:Text
 courseWorkload|Type:Text
 coverageEndTime|Type:Date
 coverageStartTime|Type:Date
 creativeWorkStatus|Type:Text
 creator|Type:Text
 credentialCategory|Type:Text
 creditText|Type:Text
 creditedTo|Type:Text
 cssSelector|Type:Text
 currenciesAccepted|Type:Text
 currency|Type:Text
 currentExchangeRate|Type:Text
 customer|Type:Text
 customerRemorseReturnFees|Type:Text
 customerRemorseReturnLabelSource|Type:Text
 customerRemorseReturnShippingFeesAmount|Type:Text
 cutoffTime|Type:Time
 cvdCollectionDate|Type:Date
 cvdFacilityCounty|Type:Text
 cvdFacilityId|Type:Text
 cvdNumBeds|Type:Number
 cvdNumBedsOcc|Type:Number
 cvdNumC19Died|Type:Number
 cvdNumC19HOPats|Type:Number
 cvdNumC19HospPats|Type:Number
 cvdNumC19MechVentPats|Type:Number
 cvdNumC19OFMechVentPats|Type:Number
 cvdNumC19OverflowPats|Type:Number
 cvdNumICUBeds|Type:Number
 cvdNumICUBedsOcc|Type:Number
 cvdNumTotBeds|Type:Number
 cvdNumVent|Type:Number
 cvdNumVentUse|Type:Number
 dataFeedElement|Type:Text
 dataset|Type:Text
 datasetTimeInterval|Type:Date
 dateCreated|Type:Date
 dateDeleted|Type:Date
 dateIssued|Type:Date
 dateModified|Type:Date
 datePosted|Type:Date
 datePublished|Type:Date
 dateRead|Type:Date
 dateReceived|Type:Date
 dateSent|Type:Date
 dateVehicleFirstRegistered|Type:Date
 dateline|Type:Text
 dayOfWeek|Type:Text
 deathDate|Type:Date
 deathPlace|Type:Text
 defaultValue|Type:Text
 deliveryAddress|Type:Text
 deliveryLeadTime|Type:Text
 deliveryMethod|Type:Text
 deliveryStatus|Type:Text
 deliveryTime|Type:Text
 department|Type:Text
 departureAirport|Type:Text
 departureBoatTerminal|Type:Text
 departureBusStop|Type:Text
 departureGate|Type:Text
 departurePlatform|Type:Text
 departureStation|Type:Text
 departureTerminal|Type:Text
 departureTime|Type:Date
 dependencies|Type:Text
 depth|Type:Text
 description|Type:Text
 device|Type:Text
 diagnosis|Type:Text
 diagram|Type:Text
 diet|Type:Text
 dietFeatures|Type:Text
 differentialDiagnosis|Type:Text
 digitalSourceType|Type:Text
 directApply|Type:Boolean
 director|Type:Text
 directors|Type:Text
 disambiguatingDescription|Type:Text
 discount|Type:Number
 discountCode|Type:Text
 discountCurrency|Type:Text
 discusses|Type:Text
 discussionUrl|Type:URL
 diseasePreventionInfo|Type:URL
 diseaseSpreadStatistics|Type:Text
 dissolutionDate|Type:Date
 distance|Type:Text
 distinguishingSign|Type:Text
 distribution|Type:Text
 diversityPolicy|Type:URL
 diversityStaffingReport|Type:URL
 documentation|Type:URL
 doesNotShip|Type:Boolean
 domainIncludes|Type:Text
 domiciledMortgage|Type:Boolean
 doorTime|Type:Date
 dosageForm|Type:Text
 doseSchedule|Type:Text
 doseUnit|Type:Text
 doseValue|Type:Number
 downPayment|Type:Number
 downloadUrl|Type:URL
 downvoteCount|Type:Number
 drainsTo|Type:Text
 driveWheelConfiguration|Type:Text
 dropoffLocation|Type:Text
 dropoffTime|Type:Date
 drug|Type:Text
 drugClass|Type:Text
 drugUnit|Type:Text
 duns|Type:Text
 duplicateTherapy|Type:Text
 duration|Type:Text
 durationOfWarranty|Type:Text
 duringMedia|Type:URL
 earlyPrepaymentPenalty|Type:Text
 editEIDR|Type:Text
 editor|Type:Text
 eduQuestionType|Type:Text
 educationRequirements|Type:Text
 educationalAlignment|Type:Text
 educationalCredentialAwarded|Type:Text
 educationalFramework|Type:Text
 educationalLevel|Type:Text
 educationalProgramMode|Type:Text
 educationalRole|Type:Text
 educationalUse|Type:Text
 elevation|Type:Number
 eligibilityToWorkRequirement|Type:Text
 eligibleCustomerType|Type:Text
 eligibleDuration|Type:Text
 eligibleQuantity|Type:Text
 eligibleRegion|Type:Text
 eligibleTransactionVolume|Type:Text
 email|Type:Text
 embedUrl|Type:URL
 embeddedTextCaption|Type:Text
 emissionsCO2|Type:Number
 employee|Type:Text
 employees|Type:Text
 employerOverview|Type:Text
 employmentType|Type:Text
 employmentUnit|Type:Text
 encodesBioChemEntity|Type:Text
 encodesCreativeWork|Type:Text
 encoding|Type:Text
 encodingFormat|Type:Text
 encodingType|Type:Text
 encodings|Type:Text
 endDate|Type:Date
 endOffset|Type:Text
 endTime|Type:Date
 endorsee|Type:Text
 endorsers|Type:Text
 energyEfficiencyScaleMax|Type:Text
 energyEfficiencyScaleMin|Type:Text
 engineDisplacement|Type:Quantity
 enginePower|Type:Quantity
 engineType|Type:Text
 entertainmentBusiness|Type:Text
 epidemiology|Type:Text
 episode|Type:Text
 episodeNumber|Type:Number
 episodes|Type:Text
 equal|Type:Text
 error|Type:Text
 estimatedCost|Type:Text
 estimatedFlightDuration|Type:Text
 estimatedSalary|Type:Text
 estimatesRiskOf|Type:Text
 ethicsPolicy|Type:Text
 event|Type:Text
 eventAttendanceMode|Type:Text
 eventSchedule|Type:Text
 eventStatus|Type:Text
 events|Type:Text
 evidenceLevel|Type:Text
 evidenceOrigin|Type:Text
 exampleOfWork|Type:Text
 exceptDate|Type:Date
 exchangeRateSpread|Type:Text
 executableLibraryName|Type:Text
 exerciseCourse|Type:Text
 exercisePlan|Type:Text
 exerciseRelatedDiet|Type:Text
 exerciseType|Type:Text
 exifData|Type:Text
 expectedArrivalFrom|Type:Date
 expectedArrivalUntil|Type:Date
 expectedPrognosis|Type:Text
 expectsAcceptanceOf|Type:Text
 experienceInPlaceOfEducation|Type:Boolean
 experienceRequirements|Type:Text
 expertConsiderations|Type:Text
 expires|Type:Date
 expressedIn|Type:Text
 familyName|Type:Text
 fatContent|Type:Quantity
 faxNumber|Type:Text
 featureList|Type:Text
 feesAndCommissionsSpecification|Type:Text
 fiberContent|Type:Quantity
 fileFormat|Type:Text
 fileSize|Type:Text
 financialAidEligible|Type:Text
 firstAppearance|Type:Text
 firstPerformance|Type:Text
 flightDistance|Type:Text
 flightNumber|Type:Text
 floorLevel|Type:Text
 floorLimit|Type:Text
 floorSize|Type:Quantity
 followee|Type:Text
 follows|Type:Text
 followup|Type:Text
 foodEstablishment|Type:Text
 foodEvent|Type:Text
 foodWarning|Type:Text
 founder|Type:Text
 founders|Type:Text
 foundingDate|Type:Date
 foundingLocation|Type:Text
 free|Type:Boolean
 freeShippingThreshold|Type:Text
 frequency|Type:Text
 fromLocation|Type:Text
 fuelCapacity|Type:Quantity
 fuelConsumption|Type:Quantity
 fuelEfficiency|Type:Quantity
 fuelType|Type:Text
 functionalClass|Type:Text
 fundedItem|Type:Text
 funder|Type:Text
 funding|Type:Text
 game|Type:Text
 gameAvailabilityType|Type:Text
 gameEdition|Type:Text
 gameItem|Type:Text
 gameLocation|Type:Text
 gamePlatform|Type:Text
 gameServer|Type:Text
 gameTip|Type:Text
 gender|Type:Text
 genre|Type:Text
 geo|Type:Geographic coordinates
 geoContains|Type:Text
 geoCoveredBy|Type:Text
 geoCovers|Type:Text
 geoCrosses|Type:Text
 geoDisjoint|Type:Text
 geoEquals|Type:Text
 geoIntersects|Type:Text
 geoMidpoint|Type:Geographic coordinates
 geoOverlaps|Type:Text
 geoRadius|Type:Text
 geoTouches|Type:Text
 geoWithin|Type:Text
 geographicArea|Type:Text
 gettingTestedInfo|Type:URL
 givenName|Type:Text
 globalLocationNumber|Type:Text
 governmentBenefitsInfo|Type:Text
 gracePeriod|Type:Text
 grantee|Type:Text
 greater|Type:Text
 greaterOrEqual|Type:Text
 gtin|Type:Text
 gtin12|Type:Text
 gtin13|Type:Text
 gtin14|Type:Text
 gtin8|Type:Text
 guideline|Type:Text
 guidelineDate|Type:Date
 guidelineSubject|Type:Text
 handlingTime|Type:Quantity
 hasAdultConsideration|Type:Text
 hasBioChemEntityPart|Type:Text
 hasBioPolymerSequence|Type:Text
 hasBroadcastChannel|Type:Text
 hasCategoryCode|Type:Text
 hasCertification|Type:Text
 hasCourse|Type:Text
 hasCourseInstance|Type:Text
 hasCredential|Type:Text
 hasDefinedTerm|Type:Text
 hasDeliveryMethod|Type:Text
 hasDigitalDocumentPermission|Type:Text
 hasDriveThroughService|Type:Boolean
 hasEnergyConsumptionDetails|Type:Text
 hasEnergyEfficiencyCategory|Type:Text
 hasGS1DigitalLink|Type:URL
 hasHealthAspect|Type:Text
 hasMap|Type:Text
 hasMeasurement|Type:Quantity
 hasMemberProgram|Type:Text
 hasMenu|Type:Text
 hasMenuItem|Type:Text
 hasMenuSection|Type:Text
 hasMerchantReturnPolicy|Type:Text
 hasMolecularFunction|Type:Text
 hasOccupation|Type:Text
 hasOfferCatalog|Type:Text
 hasPOS|Type:Text
 hasPart|Type:Text
 hasRepresentation|Type:Text
 hasTierBenefit|Type:Text
 hasTierRequirement|Type:Text
 hasTiers|Type:Text
 hasVariant|Type:Text
 headline|Type:Text
 healthCondition|Type:Text
 healthPlanCoinsuranceOption|Type:Text
 healthPlanCoinsuranceRate|Type:Number
 healthPlanCopay|Type:Text
 healthPlanCopayOption|Type:Text
 healthPlanCostSharing|Type:Boolean
 healthPlanDrugOption|Type:Text
 healthPlanDrugTier|Type:Text
 healthPlanId|Type:Text
 healthPlanMarketingUrl|Type:URL
 healthPlanNetworkId|Type:Text
 healthPlanNetworkTier|Type:Text
 healthPlanPharmacyCategory|Type:Text
 healthcareReportingData|Type:Text
 height|Type:Text
 highPrice|Type:Number
 hiringOrganization|Type:Text
 holdingArchive|Type:Text
 homeLocation|Type:Text
 homeTeam|Type:Text
 honorificPrefix|Type:Text
 honorificSuffix|Type:Text
 hospitalAffiliation|Type:Text
 hostingOrganization|Type:Text
 hoursAvailable|Type:Text
 howPerformed|Type:Text
 httpMethod|Type:Text
 iataCode|Type:Text
 icaoCode|Type:Text
 identifier|Type:Text
 identifyingExam|Type:Text
 identifyingTest|Type:Text
 illustrator|Type:Text
 image|Type:Text
 imagingTechnique|Type:Text
 inAlbum|Type:Text
 inBroadcastLineup|Type:Text
 inChI|Type:Text
 inChIKey|Type:Text
 inCodeSet|Type:URL
 inDefinedTermSet|Type:URL
 inLanguage|Type:Text
 inPlaylist|Type:Text
 inProductGroupWithID|Type:Text
 inStoreReturnsOffered|Type:Boolean
 inSupportOf|Type:Text
 incentiveCompensation|Type:Text
 incentives|Type:Text
 includedComposition|Type:Text
 includedDataCatalog|Type:Text
 includedInDataCatalog|Type:Text
 includedInHealthInsurancePlan|Type:Text
 includedRiskFactor|Type:Text
 includesAttraction|Type:Text
 includesHealthPlanFormulary|Type:Text
 includesHealthPlanNetwork|Type:Text
 includesObject|Type:Text
 increasesRiskOf|Type:Text
 industry|Type:Text
 ineligibleRegion|Type:Text
 infectiousAgent|Type:Text
 infectiousAgentClass|Type:Text
 ingredients|Type:Text
 inker|Type:Text
 insertion|Type:Text
 installUrl|Type:URL
 instructor|Type:Text
 instrument|Type:Text
 intensity|Type:Quantity
 interactingDrug|Type:Text
 interactionCount|Type:Text
 interactionService|Type:Text
 interactionStatistic|Type:Text
 interactionType|Type:Text
 interactivityType|Type:Text
 interestRate|Type:Number
 interpretedAsClaim|Type:Text
 inventoryLevel|Type:Quantity
 inverseOf|Type:Page
 isAcceptingNewPatients|Type:Boolean
 isAccessibleForFree|Type:Boolean
 isAccessoryOrSparePartFor|Type:Text
 isAvailableGenerically|Type:Boolean
 isBasedOn|Type:URL
 isBasedOnUrl|Type:URL
 isConsumableFor|Type:Text
 isEncodedByBioChemEntity|Type:Text
 isFamilyFriendly|Type:Boolean
 isGift|Type:Boolean
 isInvolvedInBiologicalProcess|Type:URL
 isLiveBroadcast|Type:Boolean
 isLocatedInSubcellularLocation|Type:Text
 isPartOf|Type:URL
 isPartOfBioChemEntity|Type:Text
 isPlanForApartment|Type:Text
 isProprietary|Type:Boolean
 isRelatedTo|Type:Text
 isResizable|Type:Boolean
 isSimilarTo|Type:Text
 isTierOf|Type:Text
 isUnlabelledFallback|Type:Boolean
 isVariantOf|Type:Text
 isbn|Type:Text
 isicV4|Type:Text
 iso6523Code|Type:Text
 isrcCode|Type:Text
 issn|Type:Text
 issueNumber|Type:Number
 issuedBy|Type:Text
 issuedThrough|Type:Text
 iswcCode|Type:Text
 item|Type:Text
 itemCondition|Type:Text
 itemDefectReturnFees|Type:Text
 itemDefectReturnLabelSource|Type:Text
 itemDefectReturnShippingFeesAmount|Type:Text
 itemListElement|Type:Text
 itemListOrder|Type:Text
 itemLocation|Type:Text
 itemOffered|Type:Text
 itemReviewed|Type:Text
 itemShipped|Type:Text
 itinerary|Type:Text
 iupacName|Type:Text
 jobBenefits|Type:Text
 jobImmediateStart|Type:Boolean
 jobLocation|Type:Text
 jobLocationType|Type:Text
 jobStartDate|Type:Date
 jobTitle|Type:Text
 jurisdiction|Type:Text
 keywords|Type:Text
 knownVehicleDamages|Type:Text
 knows|Type:Text
 knowsAbout|Type:Text
 knowsLanguage|Type:Text
 labelDetails|Type:URL
 landlord|Type:Text
 language|Type:Text
 lastReviewed|Type:Date
 latitude|Type:Number
 layoutImage|Type:URL
 learningResourceType|Type:Text
 leaseLength|Type:Text
 legalName|Type:Text
 legalStatus|Type:Text
 legislationApplies|Type:Text
 legislationChanges|Type:Text
 legislationConsolidates|Type:Text
 legislationDate|Type:Date
 legislationDateVersion|Type:Date
 legislationIdentifier|Type:Text
 legislationJurisdiction|Type:Text
 legislationLegalForce|Type:Text
 legislationLegalValue|Type:Text
 legislationPassedBy|Type:Text
 legislationResponsible|Type:Text
 legislationTransposes|Type:Text
 legislationType|Type:Text
 leiCode|Type:Text
 lender|Type:Text
 lesser|Type:Text
 lesserOrEqual|Type:Text
 letterer|Type:Text
 license|Type:URL
 line|Type:Text
 linkRelationship|Type:Text
 liveBlogUpdate|Type:Text
 loanMortgageMandateAmount|Type:Text
 loanPaymentAmount|Type:Text
 loanPaymentFrequency|Type:Number
 loanRepaymentForm|Type:Text
 loanTerm|Type:Quantity
 loanType|Type:Text
 location|Type:Text
 locationCreated|Type:Text
 lodgingUnitDescription|Type:Text
 lodgingUnitType|Type:Text
 logo|Type:URL
 longitude|Type:Number
 loser|Type:Text
 lowPrice|Type:Number
 lyricist|Type:Text
 lyrics|Type:Text
 mainContentOfPage|Type:Text
 mainEntity|Type:Text
 mainEntityOfPage|Type:URL
 maintainer|Type:Text
 makesOffer|Type:Text
 manufacturer|Type:Text
 map|Type:URL
 mapType|Type:Text
 maps|Type:URL
 marginOfError|Type:Quantity
 masthead|Type:URL
 material|Type:URL
 materialExtent|Type:Text
 mathExpression|Type:Text
 maxPrice|Type:Number
 maxValue|Type:Number
 maximumAttendeeCapacity|Type:Number
 maximumEnrollment|Type:Number
 maximumIntake|Type:Text
 maximumPhysicalAttendeeCapacity|Type:Number
 maximumVirtualAttendeeCapacity|Type:Number
 mealService|Type:Text
 measuredProperty|Type:Text
 measurementDenominator|Type:Text
 measurementMethod|Type:Text
 measurementQualifier|Type:Text
 measurementTechnique|Type:Text
 mechanismOfAction|Type:Text
 mediaAuthenticityCategory|Type:Text
 mediaItemAppearance|Type:Text
 median|Type:Number
 medicalAudience|Type:Text
 medicalSpecialty|Type:Text
 medicineSystem|Type:Text
 meetsEmissionStandard|Type:Text
 member|Type:Text
 memberOf|Type:Text
 members|Type:Text
 membershipNumber|Type:Text
 membershipPointsEarned|Type:Number
 memoryRequirements|Type:Text
 mentions|Type:Text
 menu|Type:Text
 menuAddOn|Type:Text
 merchant|Type:Text
 merchantReturnDays|Type:Date
 merchantReturnLink|Type:URL
 messageAttachment|Type:Text
 mileageFromOdometer|Type:Quantity
 minPrice|Type:Number
 minValue|Type:Number
 minimumPaymentDue|Type:Text
 missionCoveragePrioritiesPolicy|Type:URL
 mobileUrl|Type:Text
 model|Type:Text
 modelDate|Type:Date
 modifiedTime|Type:Date
 molecularFormula|Type:Text
 molecularWeight|Type:Quantity
 monoisotopicMolecularWeight|Type:Quantity
 monthlyMinimumRepaymentAmount|Type:Number
 monthsOfExperience|Type:Number
 mpn|Type:Text
 multipleValues|Type:Boolean
 muscleAction|Type:Text
 musicArrangement|Type:Text
 musicBy|Type:Text
 musicCompositionForm|Type:Text
 musicGroupMember|Type:Text
 musicReleaseFormat|Type:Text
 musicalKey|Type:Text
 naics|Type:Text
 name|Type:Text
 namedPosition|Type:Text
 nationality|Type:Text
 naturalProgression|Type:Text
 negativeNotes|Type:Text
 nerve|Type:Text
 nerveMotor|Type:Text
 netWorth|Type:Text
 newsUpdatesAndGuidelines|Type:URL
 nextItem|Type:Text
 noBylinesPolicy|Type:Text
 nonEqual|Type:Text
 nonProprietaryName|Type:Text
 nonprofitStatus|Type:Text
 normalRange|Type:Text
 nsn|Type:Text
 numAdults|Type:Number
 numChildren|Type:Number
 numConstraints|Type:Number
 numTracks|Type:Number
 numberOfAccommodationUnits|Type:Quantity
 numberOfAirbags|Type:Number
 numberOfAvailableAccommodationUnits|Type:Quantity
 numberOfAxles|Type:Number
 numberOfBathroomsTotal|Type:Number
 numberOfBedrooms|Type:Number
 numberOfBeds|Type:Number
 numberOfCredits|Type:Number
 numberOfDoors|Type:Number
 numberOfEmployees|Type:Quantity
 numberOfEpisodes|Type:Number
 numberOfForwardGears|Type:Number
 numberOfFullBathrooms|Type:Number
 numberOfItems|Type:Number
 numberOfLoanPayments|Type:Number
 numberOfPages|Type:Number
 numberOfPartialBathrooms|Type:Number
 numberOfPlayers|Type:Quantity
 numberOfPreviousOwners|Type:Number
 numberOfRooms|Type:Number
 numberOfSeasons|Type:Number
 numberedPosition|Type:Number
 nutrition|Type:Text
 object|Type:Text
 observationAbout|Type:Text
 observationDate|Type:Date
 observationPeriod|Type:Text
 occupancy|Type:Quantity
 occupationLocation|Type:Text
 occupationalCategory|Type:Text
 occupationalCredentialAwarded|Type:Text
 offerCount|Type:Number
 offeredBy|Type:Text
 offers|Type:Text
 offersPrescriptionByMail|Type:Boolean
 openingHours|Type:Text
 openingHoursSpecification|Type:Text
 opens|Type:Text
 operatingSystem|Type:Text
 opponent|Type:Text
 option|Type:Text
 orderDate|Type:Date
 orderDelivery|Type:Text
 orderItemNumber|Type:Text
 orderItemStatus|Type:Text
 orderNumber|Type:Text
 orderQuantity|Type:Number
 orderStatus|Type:Text
 orderedItem|Type:Text
 organizer|Type:Text
 originAddress|Type:Text
 originalMediaContextDescription|Type:Text
 originalMediaLink|Type:URL
 originatesFrom|Type:Text
 overdosage|Type:Text
 ownedFrom|Type:Date
 ownedThrough|Type:Date
 ownershipFundingInfo|Type:Text
 owns|Type:Text
 pageEnd|Type:Number
 pageStart|Type:Number
 pagination|Type:Text
 parent|Type:Text
 parentItem|Type:Text
 parentOrganization|Type:Text
 parentService|Type:Text
 parentTaxon|Type:Text
 parents|Type:Text
 partOfEpisode|Type:Text
 partOfInvoice|Type:Text
 partOfOrder|Type:Text
 partOfSeason|Type:Text
 partOfSeries|Type:Text
 partOfSystem|Type:Text
 partOfTVSeries|Type:Text
 partOfTrip|Type:Text
 participant|Type:Text
 partySize|Type:Number
 passengerPriorityStatus|Type:Text
 passengerSequenceNumber|Type:Text
 pathophysiology|Type:Text
 pattern|Type:Text
 payload|Type:Quantity
 paymentAccepted|Type:Text
 paymentDue|Type:Date
 paymentDueDate|Type:Date
 paymentMethod|Type:Text
 paymentMethodId|Type:Text
 paymentMethodType|Type:Text
 paymentStatus|Type:Text
 paymentUrl|Type:URL
 penciler|Type:Text
 percentile10|Type:Number
 percentile25|Type:Number
 percentile75|Type:Number
 percentile90|Type:Number
 performTime|Type:Text
 performer|Type:Text
 performerIn|Type:Text
 performers|Type:Text
 permissionType|Type:Text
 permissions|Type:Text
 permitAudience|Type:Text
 permittedUsage|Type:Text
 petsAllowed|Type:Boolean
 phoneticText|Type:Text
 photo|Type:Text
 photos|Type:Text
 physicalRequirement|Type:Text
 physiologicalBenefits|Type:Text
 pickupLocation|Type:Text
 pickupTime|Type:Date
 playMode|Type:Text
 playerType|Type:Text
 playersOnline|Type:Number
 polygon|Type:Text
 populationType|Type:Text
 position|Type:Number
 positiveNotes|Type:Text
 possibleComplication|Type:Text
 possibleTreatment|Type:Text
 postOfficeBoxNumber|Type:Text
 postOp|Type:Text
 postalCode|Type:Text
 postalCodeBegin|Type:Text
 postalCodeEnd|Type:Text
 postalCodePrefix|Type:Text
 postalCodeRange|Type:Text
 potentialAction|Type:Text
 potentialUse|Type:Text
 practicesAt|Type:Text
 preOp|Type:Text
 predecessorOf|Type:Text
 pregnancyCategory|Type:Text
 pregnancyWarning|Type:Text
 prepTime|Type:Text
 preparation|Type:Text
 prescribingInfo|Type:URL
 prescriptionStatus|Type:Text
 previousItem|Type:Text
 previousStartDate|Type:Date
 price|Type:Number
 priceComponent|Type:Text
 priceComponentType|Type:Text
 priceCurrency|Type:Text
 priceRange|Type:Text
 priceSpecification|Type:Text
 priceType|Type:Text
 priceValidUntil|Type:Date
 primaryImageOfPage|Type:Text
 primaryPrevention|Type:Text
 printColumn|Type:Text
 printEdition|Type:Text
 printPage|Type:Text
 printSection|Type:Text
 procedure|Type:Text
 procedureType|Type:Text
 processingTime|Type:Text
 processorRequirements|Type:Text
 producer|Type:Text
 produces|Type:Text
 productGroupID|Type:Text
 productID|Type:Text
 productSupported|Type:Text
 productionCompany|Type:Text
 productionDate|Type:Date
 proficiencyLevel|Type:Text
 program|Type:Text
 programMembershipUsed|Type:Text
 programName|Type:Text
 programPrerequisites|Type:Text
 programType|Type:Text
 programmingLanguage|Type:Text
 programmingModel|Type:Text
 propertyID|Type:Text
 proprietaryName|Type:Text
 proteinContent|Type:Text
 provider|Type:Text
 providerMobility|Type:Text
 providesBroadcastService|Type:Text
 providesService|Type:Text
 publicAccess|Type:Boolean
 publicTransportClosuresInfo|Type:URL
 publication|Type:Text
 publicationType|Type:Text
 publishedBy|Type:Text
 publishedOn|Type:Text
 publisher|Type:Text
 publisherImprint|Type:Text
 publishingPrinciples|Type:Text
 purchaseDate|Type:Date
 qualifications|Type:Text
 quarantineGuidelines|Type:URL
 query|Type:Text
 quest|Type:Text
 question|Type:Text
 rangeIncludes|Type:Text
 ratingCount|Type:Number
 ratingExplanation|Type:Text
 ratingValue|Type:Number
 readBy|Type:Text
 readonlyValue|Type:Boolean
 realEstateAgent|Type:Text
 recipe|Type:Text
 recipeCategory|Type:Text
 recipeCuisine|Type:Text
 recipeIngredient|Type:Text
 recipeInstructions|Type:Text
 recipeYield|Type:Quantity
 recipient|Type:Text
 recognizedBy|Type:Text
 recognizingAuthority|Type:Text
 recommendationStrength|Type:Text
 recommendedIntake|Type:Text
 recordLabel|Type:Text
 recordedAs|Type:Text
 recordedAt|Type:Text
 recordedIn|Type:Text
 recordingOf|Type:Text
 recourseLoan|Type:Boolean
 referenceQuantity|Type:Quantity
 referencesOrder|Type:Text
 refundType|Type:Text
 regionDrained|Type:Text
 regionsAllowed|Type:Text
 relatedAnatomy|Type:Text
 relatedCondition|Type:Text
 relatedDrug|Type:Text
 relatedLink|Type:URL
 relatedStructure|Type:Text
 relatedTherapy|Type:Text
 relatedTo|Type:Text
 releaseDate|Type:Date
 releaseNotes|Type:Text
 releaseOf|Type:Text
 releasedEvent|Type:Text
 relevantOccupation|Type:Text
 relevantSpecialty|Type:Text
 remainingAttendeeCapacity|Type:Number
 renegotiableLoan|Type:Boolean
 repeatCount|Type:Number
 repeatFrequency|Type:Text
 repetitions|Type:Number
 replacee|Type:Text
 replacer|Type:Text
 replyToUrl|Type:URL
 reportNumber|Type:Text
 representativeOfPage|Type:Boolean
 requiredCollateral|Type:Text
 requiredGender|Type:Text
 requiredMaxAge|Type:Number
 requiredMinAge|Type:Number
 requiredQuantity|Type:Number
 requirements|Type:Text
 requiresSubscription|Type:Boolean
 reservationFor|Type:Thing
 reservationId|Type:Text
 reservationStatus|Type:Text
 reservedTicket|Type:Text
 responsibilities|Type:Text
 restPeriods|Type:Quantity
 restockingFee|Type:Number
 result|Type:Text
 resultComment|Type:Text
 resultReview|Type:Text
 returnFees|Type:Text
 returnLabelSource|Type:Text
 returnMethod|Type:Text
 returnPolicyCategory|Type:Text
 returnPolicyCountry|Type:Text
 returnPolicySeasonalOverride|Type:Text
 returnShippingFeesAmount|Type:Text
 review|Type:Text
 reviewAspect|Type:Text
 reviewBody|Type:Text
 reviewCount|Type:Number
 reviewRating|Type:Text
 reviewedBy|Type:Text
 reviews|Type:Text
 riskFactor|Type:Text
 risks|Type:Text
 roleName|Type:Text
 roofLoad|Type:Quantity
 rsvpResponse|Type:Text
 runsTo|Type:Text
 runtime|Type:Text
 runtimePlatform|Type:Text
 rxcui|Type:Text
 safetyConsideration|Type:Text
 salaryCurrency|Type:Text
 salaryUponCompletion|Type:Text
 sameAs|Type:URL
 sampleType|Type:Text
 saturatedFatContent|Type:Text
 scheduleTimezone|Type:Text
 scheduledPaymentDate|Type:Date
 scheduledTime|Type:Date
 schemaVersion|Type:Text
 schoolClosuresInfo|Type:URL
 screenCount|Type:Number
 screenshot|Type:URL
 sdDatePublished|Type:Date
 sdLicense|Type:URL
 sdPublisher|Type:Text
 season|Type:Text
 seasonNumber|Type:Number
 seasons|Type:Text
 seatNumber|Type:Text
 seatRow|Type:Text
 seatSection|Type:Text
 seatingCapacity|Type:Number
 seatingType|Type:Text
 secondaryPrevention|Type:Text
 securityClearanceRequirement|Type:Text
 securityScreening|Type:Text
 seeks|Type:Text
 seller|Type:Text
 sender|Type:Text
 sensoryRequirement|Type:Text
 sensoryUnit|Type:Text
 serialNumber|Type:Text
 seriousAdverseOutcome|Type:Text
 serverStatus|Type:Text
 servesCuisine|Type:Text
 serviceArea|Type:Text
 serviceAudience|Type:Text
 serviceLocation|Type:Text
 serviceOperator|Type:Text
 serviceOutput|Type:Text
 servicePhone|Type:Text
 servicePostalAddress|Type:Text
 serviceSmsNumber|Type:Text
 serviceType|Type:Text
 serviceUrl|Type:URL
 servingSize|Type:Text
 sha256|Type:Text
 sharedContent|Type:Text
 shippingDestination|Type:Text
 shippingDetails|Type:Text
 shippingLabel|Type:Text
 shippingOrigin|Type:Text
 shippingRate|Type:Text
 shippingSettingsLink|Type:URL
 sibling|Type:Text
 siblings|Type:Text
 signDetected|Type:Text
 signOrSymptom|Type:Text
 significance|Type:Text
 significantLink|Type:URL
 significantLinks|Type:URL
 size|Type:Text
 sizeGroup|Type:Text
 sizeSystem|Type:Text
 skills|Type:Text
 sku|Type:Text
 slogan|Type:Text
 smiles|Type:Text
 smokingAllowed|Type:Boolean
 sodiumContent|Type:Text
 softwareAddOn|Type:Text
 softwareHelp|Type:Text
 softwareRequirements|Type:Text
 softwareVersion|Type:Text
 sourceOrganization|Type:Text
 sourcedFrom|Type:Text
 spatial|Type:Text
 spatialCoverage|Type:Text
 speakable|Type:URL
 specialCommitments|Type:Text
 specialOpeningHoursSpecification|Type:Text
 specialty|Type:Text
 speechToTextMarkup|Type:Text
 speed|Type:Quantity
 spokenByCharacter|Type:Text
 sponsor|Type:Text
 sport|Type:Text
 sportsActivityLocation|Type:Text
 sportsEvent|Type:Text
 sportsTeam|Type:Text
 spouse|Type:Text
 stage|Type:Text
 stageAsNumber|Type:Number
 starRating|Type:Text
 startDate|Type:Date
 startOffset|Type:Text
 startTime|Type:Date
 statType|Type:Text
 status|Type:Text
 steeringPosition|Type:Text
 step|Type:Text
 stepValue|Type:Number
 steps|Type:Text
 storageRequirements|Type:Text
 streetAddress|Type:Text
 strengthUnit|Type:Text
 strengthValue|Type:Number
 structuralClass|Type:Text
 study|Type:Text
 studyDesign|Type:Text
 studyLocation|Type:Text
 studySubject|Type:Text
 subEvent|Type:Text
 subEvents|Type:Text
 subOrganization|Type:Text
 subReservation|Type:Text
 subStageSuffix|Type:Text
 subStructure|Type:Text
 subTest|Type:Text
 subTrip|Type:Text
 subjectOf|Type:Text
 subtitleLanguage|Type:Text
 successorOf|Type:Text
 sugarContent|Type:Text
 suggestedAge|Type:Quantity
 suggestedAnswer|Type:Text
 suggestedGender|Type:Text
 suggestedMaxAge|Type:Number
 suggestedMeasurement|Type:Quantity
 suggestedMinAge|Type:Number
 suitableForDiet|Type:Text
 superEvent|Type:Text
 supersededBy|Type:Text
 supply|Type:Text
 supplyTo|Type:Text
 supportingData|Type:Text
 surface|Type:Text
 syllabusSections|Type:Text
 target|Type:URL
 targetCollection|Type:Text
 targetDescription|Type:Text
 targetName|Type:Text
 targetPlatform|Type:Text
 targetPopulation|Type:Text
 targetProduct|Type:Text
 targetUrl|Type:URL
 taxID|Type:Text
 taxonRank|Type:Text
 taxonomicRange|Type:Text
 teaches|Type:Text
 telephone|Type:Text
 temporal|Type:Date
 temporalCoverage|Type:Date
 termCode|Type:Text
 termDuration|Type:Text
 termsOfService|Type:Text
 termsPerYear|Type:Number
 text|Type:Text
 textValue|Type:Text
 thumbnail|Type:Text
 thumbnailUrl|Type:URL
 tickerSymbol|Type:Text
 ticketNumber|Type:Text
 ticketToken|Type:Text
 ticketedSeat|Type:Text
 timeOfDay|Type:Text
 timeRequired|Type:Text
 timeToComplete|Type:Text
 tissueSample|Type:Text
 title|Type:Text
 titleEIDR|Type:Text
 toLocation|Type:Text
 toRecipient|Type:Text
 tocContinuation|Type:Text
 tocEntry|Type:Text
 tongueWeight|Type:Quantity
 tool|Type:Text
 torque|Type:Quantity
 totalHistoricalEnrollment|Type:Number
 totalJobOpenings|Type:Number
 totalPaymentDue|Type:Text
 totalPrice|Type:Number
 totalTime|Type:Text
 tourBookingPage|Type:URL
 touristType|Type:Text
 track|Type:Text
 trackingNumber|Type:Text
 trackingUrl|Type:URL
 tracks|Type:Text
 trailer|Type:Text
 trailerWeight|Type:Quantity
 trainName|Type:Text
 trainNumber|Type:Text
 trainingSalary|Type:Text
 transFatContent|Type:Text
 transcript|Type:Text
 transitTime|Type:Quantity
 transitTimeLabel|Type:Text
 translationOfWork|Type:Text
 translator|Type:Text
 transmissionMethod|Type:Text
 travelBans|Type:URL
 trialDesign|Type:Text
 tributary|Type:Text
 tripOrigin|Type:Text
 typeOfBed|Type:Text
 typeOfGood|Type:Text
 typicalAgeRange|Type:Text
 typicalCreditsPerTerm|Type:Number
 typicalTest|Type:Text
 underName|Type:Text
 unitCode|Type:Text
 unitText|Type:Text
 unnamedSourcesPolicy|Type:URL
 unsaturatedFatContent|Type:Text
 uploadDate|Type:Date
 upvoteCount|Type:Number
 url|Type:URL
 urlTemplate|Type:Text
 usNPI|Type:Text
 usageInfo|Type:URL
 usedToDiagnose|Type:Text
 userInteractionCount|Type:Number
 usesDevice|Type:Text
 usesHealthPlanIdStandard|Type:Text
 utterances|Type:Text
 validFor|Type:Text
 validForMemberTier|Type:Text
 validFrom|Type:Date
 validIn|Type:Text
 validThrough|Type:Date
 validUntil|Type:Date
 value|Type:Boolean
 valueAddedTaxIncluded|Type:Boolean
 valueMaxLength|Type:Number
 valueMinLength|Type:Number
 valueName|Type:Text
 valuePattern|Type:Text
 valueReference|Type:Text
 valueRequired|Type:Boolean
 variableMeasured|Type:Text
 variantCover|Type:Text
 variesBy|Type:Text
 vatID|Type:Text
 vehicleConfiguration|Type:Text
 vehicleEngine|Type:Text
 vehicleIdentificationNumber|Type:Text
 vehicleInteriorColor|Type:Text
 vehicleInteriorType|Type:Text
 vehicleModelDate|Type:Date
 vehicleSeatingCapacity|Type:Number
 vehicleSpecialUsage|Type:Text
 vehicleTransmission|Type:Text
 vendor|Type:Text
 verificationFactCheckingPolicy|Type:URL
 version|Type:Number
 video|Type:Text
 videoFormat|Type:Text
 videoFrameSize|Type:Text
 videoQuality|Type:Text
 volumeNumber|Type:Number
 warning|Type:Text
 warranty|Type:Text
 warrantyPromise|Type:Text
 warrantyScope|Type:Text
 webCheckinTime|Type:Date
 webFeed|Type:URL
 weight|Type:Quantity
 weightTotal|Type:Quantity
 wheelbase|Type:Quantity
 width|Type:Quantity
 winner|Type:Text
 wordCount|Type:Number
 workExample|Type:Text
 workFeatured|Type:Text
 workHours|Type:Text
 workLocation|Type:Text
 workPerformed|Type:Text
 workPresented|Type:Text
 workTranslation|Type:Text
 workload|Type:Quantity
 worksFor|Type:Text
 worstRating|Type:Number
 xpath|Type:Text
 yearBuilt|Type:Number
 yearlyRevenue|Type:Quantity
 yearsInOperation|Type:Quantity
 yield|Type:Quantity
 3DModel|Category
 AMRadioChannel|Category
 APIReference|Category
 Abdomen|Category
 AboutPage|Category
 AcceptAction|Category
 Accommodation|Category
 AccountingService|Category
 AchieveAction|Category
 Action|Category
 ActionAccessSpecification|Category
 ActionStatusType|Category
 ActivateAction|Category
 ActivationFee|Category
 ActiveActionStatus|Category
 ActiveNotRecruiting|Category
 AddAction|Category
 AdministrativeArea|Category
 AdultEntertainment|Category
 AdultOrientedEnumeration|Category
 AdvertiserContentArticle|Category
 AerobicActivity|Category
 AggregateOffer|Category
 AggregateRating|Category
 AgreeAction|Category
 Airline|Category
 Airport|Category
 AlbumRelease|Category
 AlcoholConsideration|Category
 AlgorithmicMediaDigitalSource|Category
 AlgorithmicallyEnhancedDigitalSource|Category
 AlignmentObject|Category
 AllWheelDriveConfiguration|Category
 AllergiesHealthAspect|Category
 AllocateAction|Category
 AmpStory|Category
 AmusementPark|Category
 AnaerobicActivity|Category
 AnalysisNewsArticle|Category
 AnatomicalStructure|Category
 AnatomicalSystem|Category
 AndroidPlatform|Category
 Anesthesia|Category
 AnimalShelter|Category
 Answer|Category
 Apartment|Category
 ApartmentComplex|Category
 Appearance|Category
 AppendAction|Category
 ApplyAction|Category
 ApprovedIndication|Category
 Aquarium|Category
 ArchiveComponent|Category
 ArchiveOrganization|Category
 ArriveAction|Category
 ArtGallery|Category
 Artery|Category
 Article|Category
 AskAction|Category
 AskPublicNewsArticle|Category
 AssessAction|Category
 AssignAction|Category
 Atlas|Category
 Attorney|Category
 Audience|Category
 AudioObject|Category
 AudioObjectSnapshot|Category
 Audiobook|Category
 AudiobookFormat|Category
 AuthoritativeLegalValue|Category
 AuthorizeAction|Category
 AutoBodyShop|Category
 AutoDealer|Category
 AutoPartsStore|Category
 AutoRental|Category
 AutoRepair|Category
 AutoWash|Category
 AutomatedTeller|Category
 AutomotiveBusiness|Category
 Ayurvedic|Category
 BackOrder|Category
 BackgroundNewsArticle|Category
 Bacteria|Category
 Bakery|Category
 Balance|Category
 BankAccount|Category
 BankOrCreditUnion|Category
 BarOrPub|Category
 Barcode|Category
 BasicIncome|Category
 Beach|Category
 BeautySalon|Category
 BedAndBreakfast|Category
 BedDetails|Category
 BedType|Category
 BefriendAction|Category
 BenefitsHealthAspect|Category
 BikeStore|Category
 BioChemEntity|Category
 Blog|Category
 BlogPosting|Category
 BloodTest|Category
 BoardingPolicyType|Category
 BoatReservation|Category
 BoatTerminal|Category
 BoatTrip|Category
 BodyMeasurementArm|Category
 BodyMeasurementBust|Category
 BodyMeasurementChest|Category
 BodyMeasurementFoot|Category
 BodyMeasurementHand|Category
 BodyMeasurementHead|Category
 BodyMeasurementHeight|Category
 BodyMeasurementHips|Category
 BodyMeasurementInsideLeg|Category
 BodyMeasurementNeck|Category
 BodyMeasurementTypeEnumeration|Category
 BodyMeasurementUnderbust|Category
 BodyMeasurementWaist|Category
 BodyMeasurementWeight|Category
 BodyOfWater|Category
 Bone|Category
 Book|Category
 BookFormatType|Category
 BookSeries|Category
 BookStore|Category
 BookmarkAction|Category
 Boolean|Category
 BorrowAction|Category
 BowlingAlley|Category
 BrainStructure|Category
 Brand|Category
 BreadcrumbList|Category
 Brewery|Category
 Bridge|Category
 BroadcastChannel|Category
 BroadcastEvent|Category
 BroadcastFrequencySpecification|Category
 BroadcastRelease|Category
 BroadcastService|Category
 BrokerageAccount|Category
 BuddhistTemple|Category
 BusOrCoach|Category
 BusReservation|Category
 BusStation|Category
 BusStop|Category
 BusTrip|Category
 BusinessAudience|Category
 BusinessEntityType|Category
 BusinessEvent|Category
 BusinessFunction|Category
 BusinessSupport|Category
 BuyAction|Category
 ByBankTransferInAdvance|Category
 ByInvoice|Category
 CDCPMDRecord|Category
 CDFormat|Category
 COD|Category
 CT|Category
 CableOrSatelliteService|Category
 CafeOrCoffeeShop|Category
 Campground|Category
 CampingPitch|Category
 Canal|Category
 CancelAction|Category
 Car|Category
 CarUsageType|Category
 Cardiovascular|Category
 CardiovascularExam|Category
 CaseSeries|Category
 Cash|Category
 Casino|Category
 CassetteFormat|Category
 CategoryCode|Category
 CategoryCodeSet|Category
 CatholicChurch|Category
 CausesHealthAspect|Category
 Cemetery|Category
 Certification|Category
 CertificationActive|Category
 CertificationInactive|Category
 CertificationStatusEnumeration|Category
 Chapter|Category
 CharitableIncorporatedOrganization|Category
 CheckAction|Category
 CheckInAction|Category
 CheckInAdvance|Category
 CheckOutAction|Category
 CheckoutPage|Category
 ChemicalSubstance|Category
 ChildCare|Category
 ChildrensEvent|Category
 Chiropractic|Category
 ChooseAction|Category
 Church|Category
 City|Category
 CityHall|Category
 CivicStructure|Category
 Claim|Category
 ClaimReview|Category
 Class|Category
 CleaningFee|Category
 Clinician|Category
 Clip|Category
 ClothingStore|Category
 CoOp|Category
 Code|Category
 CohortStudy|Category
 Collection|Category
 CollectionPage|Category
 CollegeOrUniversity|Category
 ComedyClub|Category
 ComedyEvent|Category
 ComicCoverArt|Category
 ComicIssue|Category
 ComicSeries|Category
 ComicStory|Category
 Comment|Category
 CommentAction|Category
 CommentPermission|Category
 CommunicateAction|Category
 CommunityHealth|Category
 CompilationAlbum|Category
 CompleteDataFeed|Category
 Completed|Category
 CompletedActionStatus|Category
 CompositeCaptureDigitalSource|Category
 CompositeSyntheticDigitalSource|Category
 CompositeWithTrainedAlgorithmicMediaDigitalSource|Category
 CompoundPriceSpecification|Category
 ComputerLanguage|Category
 ComputerStore|Category
 ConfirmAction|Category
 Consortium|Category
 ConstraintNode|Category
 ConsumeAction|Category
 ContactPage|Category
 ContactPoint|Category
 ContactPointOption|Category
 ContagiousnessHealthAspect|Category
 Continent|Category
 ControlAction|Category
 ConvenienceStore|Category
 Conversation|Category
 CookAction|Category
 Corporation|Category
 CorrectionComment|Category
 Country|Category
 Course|Category
 CourseInstance|Category
 Courthouse|Category
 CoverArt|Category
 CovidTestingFacility|Category
 CreateAction|Category
 CreativeWork|Category
 CreativeWorkSeason|Category
 CreativeWorkSeries|Category
 CreditCard|Category
 Crematorium|Category
 CriticReview|Category
 CrossSectional|Category
 CssSelectorType|Category
 CurrencyConversionService|Category
 DDxElement|Category
 DJMixAlbum|Category
 DVDFormat|Category
 DamagedCondition|Category
 DanceEvent|Category
 DanceGroup|Category
 DangerousGoodConsideration|Category
 DataCatalog|Category
 DataDownload|Category
 DataDrivenMediaDigitalSource|Category
 DataFeed|Category
 DataFeedItem|Category
 DataType|Category
 Dataset|Category
 Date|Category
 DateTime|Category
 DatedMoneySpecification|Category
 DayOfWeek|Category
 DaySpa|Category
 DeactivateAction|Category
 DecontextualizedContent|Category
 DefenceEstablishment|Category
 DefinedRegion|Category
 DefinedTerm|Category
 DefinedTermSet|Category
 DefinitiveLegalValue|Category
 DeleteAction|Category
 DeliveryChargeSpecification|Category
 DeliveryEvent|Category
 DeliveryMethod|Category
 DeliveryTimeSettings|Category
 Demand|Category
 DemoAlbum|Category
 DemoGameAvailability|Category
 Dentist|Category
 Dentistry|Category
 DepartAction|Category
 DepartmentStore|Category
 DepositAccount|Category
 Dermatologic|Category
 Dermatology|Category
 DesktopWebPlatform|Category
 DiabeticDiet|Category
 Diagnostic|Category
 DiagnosticLab|Category
 DiagnosticProcedure|Category
 Diet|Category
 DietNutrition|Category
 DietarySupplement|Category
 DigitalArtDigitalSource|Category
 DigitalAudioTapeFormat|Category
 DigitalCaptureDigitalSource|Category
 DigitalDocument|Category
 DigitalDocumentPermission|Category
 DigitalDocumentPermissionType|Category
 DigitalFormat|Category
 DigitalPlatformEnumeration|Category
 DirectDebit|Category
 DisabilitySupport|Category
 DisagreeAction|Category
 Discontinued|Category
 DiscoverAction|Category
 DiscussionForumPosting|Category
 DislikeAction|Category
 Distance|Category
 DistanceFee|Category
 Distillery|Category
 DonateAction|Category
 DoseSchedule|Category
 DoubleBlindedTrial|Category
 DownloadAction|Category
 Downpayment|Category
 DrawAction|Category
 Drawing|Category
 DrinkAction|Category
 DriveWheelConfigurationValue|Category
 DrivingSchoolVehicleUsage|Category
 Drug|Category
 DrugClass|Category
 DrugCost|Category
 DrugCostCategory|Category
 DrugLegalStatus|Category
 DrugPregnancyCategory|Category
 DrugPrescriptionStatus|Category
 DrugStrength|Category
 DryCleaningOrLaundry|Category
 Duration|Category
 EBook|Category
 EPRelease|Category
 EUEnergyEfficiencyCategoryA|Category
 EUEnergyEfficiencyCategoryA1Plus|Category
 EUEnergyEfficiencyCategoryA2Plus|Category
 EUEnergyEfficiencyCategoryA3Plus|Category
 EUEnergyEfficiencyCategoryB|Category
 EUEnergyEfficiencyCategoryC|Category
 EUEnergyEfficiencyCategoryD|Category
 EUEnergyEfficiencyCategoryE|Category
 EUEnergyEfficiencyCategoryF|Category
 EUEnergyEfficiencyCategoryG|Category
 EUEnergyEfficiencyEnumeration|Category
 Ear|Category
 EatAction|Category
 EditedOrCroppedContent|Category
 EducationEvent|Category
 EducationalAudience|Category
 EducationalOccupationalCredential|Category
 EducationalOccupationalProgram|Category
 EducationalOrganization|Category
 EffectivenessHealthAspect|Category
 Electrician|Category
 ElectronicsStore|Category
 ElementarySchool|Category
 EmailMessage|Category
 Embassy|Category
 Emergency|Category
 EmergencyService|Category
 EmployeeRole|Category
 EmployerAggregateRating|Category
 EmployerReview|Category
 EmploymentAgency|Category
 Endocrine|Category
 EndorseAction|Category
 EndorsementRating|Category
 Energy|Category
 EnergyConsumptionDetails|Category
 EnergyEfficiencyEnumeration|Category
 EnergyStarCertified|Category
 EnergyStarEnergyEfficiencyEnumeration|Category
 EngineSpecification|Category
 EnrollingByInvitation|Category
 EntertainmentBusiness|Category
 EntryPoint|Category
 Enumeration|Category
 Episode|Category
 Event|Category
 EventAttendanceModeEnumeration|Category
 EventCancelled|Category
 EventMovedOnline|Category
 EventPostponed|Category
 EventRescheduled|Category
 EventReservation|Category
 EventScheduled|Category
 EventSeries|Category
 EventStatusType|Category
 EventVenue|Category
 EvidenceLevelA|Category
 EvidenceLevelB|Category
 EvidenceLevelC|Category
 ExampleMeasurementMethodEnum|Category
 ExchangeRateSpecification|Category
 ExchangeRefund|Category
 ExerciseAction|Category
 ExerciseGym|Category
 ExercisePlan|Category
 ExhibitionEvent|Category
 Eye|Category
 FAQPage|Category
 FDAcategoryA|Category
 FDAcategoryB|Category
 FDAcategoryC|Category
 FDAcategoryD|Category
 FDAcategoryX|Category
 FDAnotEvaluated|Category
 FMRadioChannel|Category
 FailedActionStatus|Category
 False|Category
 FastFoodRestaurant|Category
 Female|Category
 Festival|Category
 FilmAction|Category
 FinancialProduct|Category
 FinancialService|Category
 FindAction|Category
 FireStation|Category
 Flexibility|Category
 Flight|Category
 FlightReservation|Category
 Float|Category
 FloorPlan|Category
 Florist|Category
 FollowAction|Category
 FoodEstablishment|Category
 FoodEstablishmentReservation|Category
 FoodEvent|Category
 FoodService|Category
 FourWheelDriveConfiguration|Category
 FreeReturn|Category
 Friday|Category
 FrontWheelDriveConfiguration|Category
 FullGameAvailability|Category
 FullRefund|Category
 FundingAgency|Category
 FundingScheme|Category
 Fungus|Category
 FurnitureStore|Category
 Game|Category
 GameAvailabilityEnumeration|Category
 GamePlayMode|Category
 GameServer|Category
 GameServerStatus|Category
 GardenStore|Category
 GasStation|Category
 Gastroenterologic|Category
 GatedResidenceCommunity|Category
 GenderType|Category
 Gene|Category
 GeneralContractor|Category
 GenericWebPlatform|Category
 Genetic|Category
 Genitourinary|Category
 GeoCircle|Category
 GeoCoordinates|Category
 GeoShape|Category
 GeospatialGeometry|Category
 Geriatric|Category
 GettingAccessHealthAspect|Category
 GiveAction|Category
 GlutenFreeDiet|Category
 GolfCourse|Category
 GovernmentBenefitsType|Category
 GovernmentBuilding|Category
 GovernmentOffice|Category
 GovernmentOrganization|Category
 GovernmentPermit|Category
 GovernmentService|Category
 Grant|Category
 GraphicNovel|Category
 GroceryStore|Category
 GroupBoardingPolicy|Category
 Guide|Category
 Gynecologic|Category
 HVACBusiness|Category
 Hackathon|Category
 HairSalon|Category
 HalalDiet|Category
 Hardcover|Category
 HardwareStore|Category
 Head|Category
 HealthAndBeautyBusiness|Category
 HealthAspectEnumeration|Category
 HealthCare|Category
 HealthClub|Category
 HealthInsurancePlan|Category
 HealthPlanCostSharingSpecification|Category
 HealthPlanFormulary|Category
 HealthPlanNetwork|Category
 HealthTopicContent|Category
 HealthcareConsideration|Category
 HearingImpairedSupported|Category
 Hematologic|Category
 HighSchool|Category
 HinduDiet|Category
 HinduTemple|Category
 HobbyShop|Category
 HomeAndConstructionBusiness|Category
 HomeGoodsStore|Category
 Homeopathic|Category
 Hospital|Category
 Hostel|Category
 Hotel|Category
 HotelRoom|Category
 House|Category
 HousePainter|Category
 HowItWorksHealthAspect|Category
 HowOrWhereHealthAspect|Category
 HowTo|Category
 HowToDirection|Category
 HowToItem|Category
 HowToSection|Category
 HowToStep|Category
 HowToSupply|Category
 HowToTip|Category
 HowToTool|Category
 HyperToc|Category
 HyperTocEntry|Category
 IOSPlatform|Category
 IPTCDigitalSourceEnumeration|Category
 IceCreamShop|Category
 IgnoreAction|Category
 ImageGallery|Category
 ImageObject|Category
 ImageObjectSnapshot|Category
 ImagingTest|Category
 InForce|Category
 InStock|Category
 InStoreOnly|Category
 InStorePrepay|Category
 IndividualPhysician|Category
 IndividualProduct|Category
 Infectious|Category
 InfectiousAgentClass|Category
 InfectiousDisease|Category
 InformAction|Category
 IngredientsHealthAspect|Category
 InsertAction|Category
 InstallAction|Category
 Installment|Category
 InsuranceAgency|Category
 Intangible|Category
 Integer|Category
 InteractAction|Category
 InteractionCounter|Category
 InternationalTrial|Category
 InternetCafe|Category
 InvestmentFund|Category
 InvestmentOrDeposit|Category
 InviteAction|Category
 Invoice|Category
 InvoicePrice|Category
 ItemAvailability|Category
 ItemList|Category
 ItemListOrderAscending|Category
 ItemListOrderDescending|Category
 ItemListOrderType|Category
 ItemListUnordered|Category
 ItemPage|Category
 JewelryStore|Category
 JobPosting|Category
 JoinAction|Category
 Joint|Category
 KeepProduct|Category
 KosherDiet|Category
 LaboratoryScience|Category
 LakeBodyOfWater|Category
 Landform|Category
 LandmarksOrHistoricalBuildings|Category
 Language|Category
 LaserDiscFormat|Category
 LearningResource|Category
 LeaveAction|Category
 LeftHandDriving|Category
 LegalForceStatus|Category
 LegalService|Category
 LegalValueLevel|Category
 Legislation|Category
 LegislationObject|Category
 LegislativeBuilding|Category
 LeisureTimeActivity|Category
 LendAction|Category
 Library|Category
 LibrarySystem|Category
 LifestyleModification|Category
 Ligament|Category
 LikeAction|Category
 LimitedAvailability|Category
 LimitedByGuaranteeCharity|Category
 LinkRole|Category
 LiquorStore|Category
 ListItem|Category
 ListPrice|Category
 ListenAction|Category
 LiteraryEvent|Category
 LiveAlbum|Category
 LiveBlogPosting|Category
 LivingWithHealthAspect|Category
 LoanOrCredit|Category
 LocalBusiness|Category
 LocationFeatureSpecification|Category
 LockerDelivery|Category
 Locksmith|Category
 LodgingBusiness|Category
 LodgingReservation|Category
 Longitudinal|Category
 LoseAction|Category
 LowCalorieDiet|Category
 LowFatDiet|Category
 LowLactoseDiet|Category
 LowSaltDiet|Category
 Lung|Category
 LymphaticVessel|Category
 MRI|Category
 MSRP|Category
 MadeToOrder|Category
 Male|Category
 Manuscript|Category
 Map|Category
 MapCategoryType|Category
 MarryAction|Category
 Mass|Category
 MathSolver|Category
 MaximumDoseSchedule|Category
 MayTreatHealthAspect|Category
 MeasurementMethodEnum|Category
 MeasurementTypeEnumeration|Category
 MediaEnumeration|Category
 MediaGallery|Category
 MediaManipulationRatingEnumeration|Category
 MediaObject|Category
 MediaReview|Category
 MediaReviewItem|Category
 MediaSubscription|Category
 MedicalAudience|Category
 MedicalAudienceType|Category
 MedicalBusiness|Category
 MedicalCause|Category
 MedicalClinic|Category
 MedicalCode|Category
 MedicalCondition|Category
 MedicalConditionStage|Category
 MedicalContraindication|Category
 MedicalDevice|Category
 MedicalDevicePurpose|Category
 MedicalEntity|Category
 MedicalEnumeration|Category
 MedicalEvidenceLevel|Category
 MedicalGuideline|Category
 MedicalGuidelineContraindication|Category
 MedicalGuidelineRecommendation|Category
 MedicalImagingTechnique|Category
 MedicalIndication|Category
 MedicalIntangible|Category
 MedicalObservationalStudy|Category
 MedicalObservationalStudyDesign|Category
 MedicalOrganization|Category
 MedicalProcedure|Category
 MedicalProcedureType|Category
 MedicalResearcher|Category
 MedicalRiskCalculator|Category
 MedicalRiskEstimator|Category
 MedicalRiskFactor|Category
 MedicalRiskScore|Category
 MedicalScholarlyArticle|Category
 MedicalSign|Category
 MedicalSignOrSymptom|Category
 MedicalSpecialty|Category
 MedicalStudy|Category
 MedicalStudyStatus|Category
 MedicalSymptom|Category
 MedicalTest|Category
 MedicalTestPanel|Category
 MedicalTherapy|Category
 MedicalTrial|Category
 MedicalTrialDesign|Category
 MedicalWebPage|Category
 MedicineSystem|Category
 MeetingRoom|Category
 MemberProgram|Category
 MemberProgramTier|Category
 MensClothingStore|Category
 Menu|Category
 MenuItem|Category
 MenuSection|Category
 MerchantReturnEnumeration|Category
 MerchantReturnFiniteReturnWindow|Category
 MerchantReturnNotPermitted|Category
 MerchantReturnPolicy|Category
 MerchantReturnPolicySeasonalOverride|Category
 MerchantReturnUnlimitedWindow|Category
 MerchantReturnUnspecified|Category
 Message|Category
 MiddleSchool|Category
 Midwifery|Category
 MinimumAdvertisedPrice|Category
 MinorHumanEditsDigitalSource|Category
 MisconceptionsHealthAspect|Category
 MixedEventAttendanceMode|Category
 MixtapeAlbum|Category
 MobileApplication|Category
 MobilePhoneStore|Category
 MobileWebPlatform|Category
 MolecularEntity|Category
 Monday|Category
 MonetaryAmount|Category
 MonetaryAmountDistribution|Category
 MonetaryGrant|Category
 MoneyTransfer|Category
 MortgageLoan|Category
 Mosque|Category
 Motel|Category
 Motorcycle|Category
 MotorcycleDealer|Category
 MotorcycleRepair|Category
 MotorizedBicycle|Category
 Mountain|Category
 MoveAction|Category
 Movie|Category
 MovieClip|Category
 MovieRentalStore|Category
 MovieSeries|Category
 MovieTheater|Category
 MovingCompany|Category
 MultiCenterTrial|Category
 MultiPlayer|Category
 MulticellularParasite|Category
 Muscle|Category
 Musculoskeletal|Category
 MusculoskeletalExam|Category
 Museum|Category
 MusicAlbum|Category
 MusicAlbumProductionType|Category
 MusicAlbumReleaseType|Category
 MusicComposition|Category
 MusicEvent|Category
 MusicGroup|Category
 MusicPlaylist|Category
 MusicRecording|Category
 MusicRelease|Category
 MusicReleaseFormatType|Category
 MusicStore|Category
 MusicVenue|Category
 MusicVideoObject|Category
 NGO|Category
 NLNonprofitType|Category
 NailSalon|Category
 NarcoticConsideration|Category
 Neck|Category
 NegativeFilmDigitalSource|Category
 Nerve|Category
 Neuro|Category
 Neurologic|Category
 NewCondition|Category
 NewsArticle|Category
 NewsMediaOrganization|Category
 Newspaper|Category
 NightClub|Category
 NoninvasiveProcedure|Category
 Nonprofit501a|Category
 Nonprofit501c1|Category
 Nonprofit501c10|Category
 Nonprofit501c11|Category
 Nonprofit501c12|Category
 Nonprofit501c13|Category
 Nonprofit501c14|Category
 Nonprofit501c15|Category
 Nonprofit501c16|Category
 Nonprofit501c17|Category
 Nonprofit501c18|Category
 Nonprofit501c19|Category
 Nonprofit501c2|Category
 Nonprofit501c20|Category
 Nonprofit501c21|Category
 Nonprofit501c22|Category
 Nonprofit501c23|Category
 Nonprofit501c24|Category
 Nonprofit501c25|Category
 Nonprofit501c26|Category
 Nonprofit501c27|Category
 Nonprofit501c28|Category
 Nonprofit501c3|Category
 Nonprofit501c4|Category
 Nonprofit501c5|Category
 Nonprofit501c6|Category
 Nonprofit501c7|Category
 Nonprofit501c8|Category
 Nonprofit501c9|Category
 Nonprofit501d|Category
 Nonprofit501e|Category
 Nonprofit501f|Category
 Nonprofit501k|Category
 Nonprofit501n|Category
 Nonprofit501q|Category
 Nonprofit527|Category
 NonprofitANBI|Category
 NonprofitSBBI|Category
 NonprofitType|Category
 Nose|Category
 NotInForce|Category
 NotYetRecruiting|Category
 Notary|Category
 NoteDigitalDocument|Category
 Number|Category
 Nursing|Category
 NutritionInformation|Category
 OTC|Category
 Observation|Category
 Observational|Category
 Obstetric|Category
 Occupation|Category
 OccupationalActivity|Category
 OccupationalExperienceRequirements|Category
 OccupationalTherapy|Category
 OceanBodyOfWater|Category
 Offer|Category
 OfferCatalog|Category
 OfferForLease|Category
 OfferForPurchase|Category
 OfferItemCondition|Category
 OfferShippingDetails|Category
 OfficeEquipmentStore|Category
 OfficialLegalValue|Category
 OfflineEventAttendanceMode|Category
 OfflinePermanently|Category
 OfflineTemporarily|Category
 OnDemandEvent|Category
 OnSitePickup|Category
 Oncologic|Category
 OneTimePayments|Category
 Online|Category
 OnlineBusiness|Category
 OnlineEventAttendanceMode|Category
 OnlineFull|Category
 OnlineOnly|Category
 OnlineStore|Category
 OpenTrial|Category
 OpeningHoursSpecification|Category
 OpinionNewsArticle|Category
 Optician|Category
 Optometric|Category
 Order|Category
 OrderAction|Category
 OrderCancelled|Category
 OrderDelivered|Category
 OrderInTransit|Category
 OrderItem|Category
 OrderPaymentDue|Category
 OrderPickupAvailable|Category
 OrderProblem|Category
 OrderProcessing|Category
 OrderReturned|Category
 OrderStatus|Category
 Organization|Category
 OrganizationRole|Category
 OrganizeAction|Category
 OriginalMediaContent|Category
 OriginalShippingFees|Category
 Osteopathic|Category
 Otolaryngologic|Category
 OutOfStock|Category
 OutletStore|Category
 OverviewHealthAspect|Category
 OwnershipInfo|Category
 PET|Category
 PaidLeave|Category
 PaintAction|Category
 Painting|Category
 PalliativeProcedure|Category
 Paperback|Category
 ParcelDelivery|Category
 ParcelService|Category
 ParentAudience|Category
 ParentalSupport|Category
 Park|Category
 ParkingFacility|Category
 ParkingMap|Category
 PartiallyInForce|Category
 Pathology|Category
 PathologyTest|Category
 Patient|Category
 PatientExperienceHealthAspect|Category
 PawnShop|Category
 PayAction|Category
 PaymentAutomaticallyApplied|Category
 PaymentCard|Category
 PaymentChargeSpecification|Category
 PaymentComplete|Category
 PaymentDeclined|Category
 PaymentDue|Category
 PaymentMethod|Category
 PaymentMethodType|Category
 PaymentPastDue|Category
 PaymentService|Category
 PaymentStatusType|Category
 Pediatric|Category
 PeopleAudience|Category
 PercutaneousProcedure|Category
 PerformAction|Category
 PerformanceRole|Category
 PerformingArtsTheater|Category
 PerformingGroup|Category
 Periodical|Category
 Permit|Category
 Person|Category
 PetStore|Category
 Pharmacy|Category
 PharmacySpecialty|Category
 PhoneCarrierPayment|Category
 Photograph|Category
 PhotographAction|Category
 PhysicalActivity|Category
 PhysicalActivityCategory|Category
 PhysicalExam|Category
 PhysicalTherapy|Category
 Physician|Category
 PhysiciansOffice|Category
 Physiotherapy|Category
 Place|Category
 PlaceOfWorship|Category
 PlaceboControlledTrial|Category
 PlanAction|Category
 PlasticSurgery|Category
 Play|Category
 PlayAction|Category
 PlayGameAction|Category
 Playground|Category
 Plumber|Category
 PodcastEpisode|Category
 PodcastSeason|Category
 PodcastSeries|Category
 Podiatric|Category
 PoliceStation|Category
 PoliticalParty|Category
 Pond|Category
 PositiveFilmDigitalSource|Category
 PostOffice|Category
 PostalAddress|Category
 PostalCodeRangeSpecification|Category
 Poster|Category
 PotentialActionStatus|Category
 PreOrder|Category
 PreOrderAction|Category
 PreSale|Category
 PregnancyHealthAspect|Category
 PrependAction|Category
 Preschool|Category
 PrescriptionOnly|Category
 PresentationDigitalDocument|Category
 PreventionHealthAspect|Category
 PreventionIndication|Category
 PriceComponentTypeEnumeration|Category
 PriceSpecification|Category
 PriceTypeEnumeration|Category
 PrimaryCare|Category
 PrintDigitalSource|Category
 Prion|Category
 Product|Category
 ProductCollection|Category
 ProductGroup|Category
 ProductModel|Category
 ProfessionalService|Category
 ProfilePage|Category
 PrognosisHealthAspect|Category
 ProgramMembership|Category
 Project|Category
 PronounceableText|Category
 Property|Category
 PropertyValue|Category
 PropertyValueSpecification|Category
 Protein|Category
 Protozoa|Category
 Psychiatric|Category
 PsychologicalTreatment|Category
 PublicHealth|Category
 PublicHolidays|Category
 PublicSwimmingPool|Category
 PublicToilet|Category
 PublicationEvent|Category
 PublicationIssue|Category
 PublicationVolume|Category
 Pulmonary|Category
 QAPage|Category
 QualitativeValue|Category
 QuantitativeValue|Category
 QuantitativeValueDistribution|Category
 Quantity|Category
 Question|Category
 Quiz|Category
 Quotation|Category
 QuoteAction|Category
 RVPark|Category
 RadiationTherapy|Category
 RadioBroadcastService|Category
 RadioChannel|Category
 RadioClip|Category
 RadioEpisode|Category
 RadioSeason|Category
 RadioSeries|Category
 RadioStation|Category
 Radiography|Category
 RandomizedTrial|Category
 Rating|Category
 ReactAction|Category
 ReadAction|Category
 ReadPermission|Category
 RealEstateAgent|Category
 RealEstateListing|Category
 RearWheelDriveConfiguration|Category
 ReceiveAction|Category
 Recipe|Category
 Recommendation|Category
 RecommendedDoseSchedule|Category
 Recruiting|Category
 RecyclingCenter|Category
 ReducedRelevanceForChildrenConsideration|Category
 RefundTypeEnumeration|Category
 RefurbishedCondition|Category
 RegisterAction|Category
 Registry|Category
 RegularPrice|Category
 ReimbursementCap|Category
 RejectAction|Category
 RelatedTopicsHealthAspect|Category
 RemixAlbum|Category
 Renal|Category
 RentAction|Category
 RentalCarReservation|Category
 RentalVehicleUsage|Category
 RepaymentSpecification|Category
 ReplaceAction|Category
 ReplyAction|Category
 Report|Category
 ReportageNewsArticle|Category
 ReportedDoseSchedule|Category
 ResearchOrganization|Category
 ResearchProject|Category
 Researcher|Category
 Reservation|Category
 ReservationCancelled|Category
 ReservationConfirmed|Category
 ReservationHold|Category
 ReservationPackage|Category
 ReservationPending|Category
 ReservationStatusType|Category
 ReserveAction|Category
 Reserved|Category
 Reservoir|Category
 Residence|Category
 Resort|Category
 RespiratoryTherapy|Category
 Restaurant|Category
 RestockingFees|Category
 RestrictedDiet|Category
 ResultsAvailable|Category
 ResultsNotAvailable|Category
 ResumeAction|Category
 Retail|Category
 ReturnAction|Category
 ReturnAtKiosk|Category
 ReturnByMail|Category
 ReturnFeesCustomerResponsibility|Category
 ReturnFeesEnumeration|Category
 ReturnInStore|Category
 ReturnLabelCustomerResponsibility|Category
 ReturnLabelDownloadAndPrint|Category
 ReturnLabelInBox|Category
 ReturnLabelSourceEnumeration|Category
 ReturnMethodEnumeration|Category
 ReturnShippingFees|Category
 Review|Category
 ReviewAction|Category
 ReviewNewsArticle|Category
 Rheumatologic|Category
 RightHandDriving|Category
 RisksOrComplicationsHealthAspect|Category
 RiverBodyOfWater|Category
 Role|Category
 RoofingContractor|Category
 Room|Category
 RsvpAction|Category
 RsvpResponseMaybe|Category
 RsvpResponseNo|Category
 RsvpResponseType|Category
 RsvpResponseYes|Category
 SRP|Category
 SafetyHealthAspect|Category
 SaleEvent|Category
 SalePrice|Category
 SatireOrParodyContent|Category
 SatiricalArticle|Category
 Saturday|Category
 Schedule|Category
 ScheduleAction|Category
 ScholarlyArticle|Category
 School|Category
 SchoolDistrict|Category
 ScreeningEvent|Category
 ScreeningHealthAspect|Category
 Sculpture|Category
 SeaBodyOfWater|Category
 SearchAction|Category
 SearchRescueOrganization|Category
 SearchResultsPage|Category
 Season|Category
 Seat|Category
 SeatingMap|Category
 SeeDoctorHealthAspect|Category
 SeekToAction|Category
 SelfCareHealthAspect|Category
 SelfStorage|Category
 SellAction|Category
 SendAction|Category
 Series|Category
 Service|Category
 ServiceChannel|Category
 SexualContentConsideration|Category
 ShareAction|Category
 SheetMusic|Category
 ShippingDeliveryTime|Category
 ShippingRateSettings|Category
 ShoeStore|Category
 ShoppingCenter|Category
 ShortStory|Category
 SideEffectsHealthAspect|Category
 SingleBlindedTrial|Category
 SingleCenterTrial|Category
 SingleFamilyResidence|Category
 SinglePlayer|Category
 SingleRelease|Category
 SiteNavigationElement|Category
 SizeGroupEnumeration|Category
 SizeSpecification|Category
 SizeSystemEnumeration|Category
 SizeSystemImperial|Category
 SizeSystemMetric|Category
 SkiResort|Category
 Skin|Category
 SocialEvent|Category
 SocialMediaPosting|Category
 SoftwareApplication|Category
 SoftwareSourceCode|Category
 SoldOut|Category
 SolveMathAction|Category
 SomeProducts|Category
 SoundtrackAlbum|Category
 SpeakableSpecification|Category
 SpecialAnnouncement|Category
 Specialty|Category
 SpeechPathology|Category
 SpokenWordAlbum|Category
 SportingGoodsStore|Category
 SportsActivityLocation|Category
 SportsClub|Category
 SportsEvent|Category
 SportsOrganization|Category
 SportsTeam|Category
 SpreadsheetDigitalDocument|Category
 StadiumOrArena|Category
 StagedContent|Category
 StagesHealthAspect|Category
 State|Category
 Statement|Category
 StatisticalPopulation|Category
 StatisticalVariable|Category
 StatusEnumeration|Category
 SteeringPositionValue|Category
 Store|Category
 StoreCreditRefund|Category
 StrengthTraining|Category
 StructuredValue|Category
 StudioAlbum|Category
 SubscribeAction|Category
 Subscription|Category
 Substance|Category
 SubwayStation|Category
 Suite|Category
 Sunday|Category
 SuperficialAnatomy|Category
 Surgical|Category
 SurgicalProcedure|Category
 SuspendAction|Category
 Suspended|Category
 Syllabus|Category
 SymptomsHealthAspect|Category
 Synagogue|Category
 TVClip|Category
 TVEpisode|Category
 TVSeason|Category
 TVSeries|Category
 Table|Category
 TakeAction|Category
 TattooParlor|Category
 Taxi|Category
 TaxiReservation|Category
 TaxiService|Category
 TaxiStand|Category
 TaxiVehicleUsage|Category
 Taxon|Category
 TechArticle|Category
 TelevisionChannel|Category
 TelevisionStation|Category
 TennisComplex|Category
 Terminated|Category
 Text|Category
 TextDigitalDocument|Category
 TextObject|Category
 TheaterEvent|Category
 TheaterGroup|Category
 Therapeutic|Category
 TherapeuticProcedure|Category
 Thesis|Category
 Thing|Category
 Throat|Category
 Thursday|Category
 Ticket|Category
 TieAction|Category
 TierBenefitEnumeration|Category
 TierBenefitLoyaltyPoints|Category
 TierBenefitLoyaltyPrice|Category
 TierBenefitLoyaltyReturns|Category
 TierBenefitLoyaltyShipping|Category
 Time|Category
 TipAction|Category
 TireShop|Category
 TobaccoNicotineConsideration|Category
 TollFree|Category
 TouristAttraction|Category
 TouristDestination|Category
 TouristInformationCenter|Category
 TouristTrip|Category
 Toxicologic|Category
 ToyStore|Category
 TrackAction|Category
 TradeAction|Category
 TraditionalChinese|Category
 TrainReservation|Category
 TrainStation|Category
 TrainTrip|Category
 TrainedAlgorithmicMediaDigitalSource|Category
 TransferAction|Category
 TransformedContent|Category
 TransitMap|Category
 TravelAction|Category
 TravelAgency|Category
 TreatmentIndication|Category
 TreatmentsHealthAspect|Category
 Trip|Category
 TripleBlindedTrial|Category
 True|Category
 Tuesday|Category
 TypeAndQuantityNode|Category
 TypesHealthAspect|Category
 UKNonprofitType|Category
 UKTrust|Category
 URL|Category
 USNonprofitType|Category
 Ultrasound|Category
 UnRegisterAction|Category
 UnclassifiedAdultConsideration|Category
 UnemploymentSupport|Category
 UnincorporatedAssociationCharity|Category
 UnitPriceSpecification|Category
 UnofficialLegalValue|Category
 UpdateAction|Category
 Urologic|Category
 UsageOrScheduleHealthAspect|Category
 UseAction|Category
 UsedCondition|Category
 UserBlocks|Category
 UserCheckins|Category
 UserComments|Category
 UserDownloads|Category
 UserInteraction|Category
 UserLikes|Category
 UserPageVisits|Category
 UserPlays|Category
 UserPlusOnes|Category
 UserReview|Category
 UserTweets|Category
 VacationRental|Category
 VeganDiet|Category
 VegetarianDiet|Category
 Vehicle|Category
 Vein|Category
 VenueMap|Category
 Vessel|Category
 VeterinaryCare|Category
 VideoGallery|Category
 VideoGame|Category
 VideoGameClip|Category
 VideoGameSeries|Category
 VideoObject|Category
 VideoObjectSnapshot|Category
 ViewAction|Category
 VinylFormat|Category
 ViolenceConsideration|Category
 VirtualLocation|Category
 VirtualRecordingDigitalSource|Category
 Virus|Category
 VisualArtsEvent|Category
 VisualArtwork|Category
 VitalSign|Category
 Volcano|Category
 VoteAction|Category
 WPAdBlock|Category
 WPFooter|Category
 WPHeader|Category
 WPSideBar|Category
 WantAction|Category
 WarrantyPromise|Category
 WarrantyScope|Category
 WatchAction|Category
 Waterfall|Category
 WeaponConsideration|Category
 WearAction|Category
 WearableMeasurementBack|Category
 WearableMeasurementChestOrBust|Category
 WearableMeasurementCollar|Category
 WearableMeasurementCup|Category
 WearableMeasurementHeight|Category
 WearableMeasurementHips|Category
 WearableMeasurementInseam|Category
 WearableMeasurementLength|Category
 WearableMeasurementOutsideLeg|Category
 WearableMeasurementSleeve|Category
 WearableMeasurementTypeEnumeration|Category
 WearableMeasurementWaist|Category
 WearableMeasurementWidth|Category
 WearableSizeGroupBig|Category
 WearableSizeGroupBoys|Category
 WearableSizeGroupEnumeration|Category
 WearableSizeGroupExtraShort|Category
 WearableSizeGroupExtraTall|Category
 WearableSizeGroupGirls|Category
 WearableSizeGroupHusky|Category
 WearableSizeGroupInfants|Category
 WearableSizeGroupJuniors|Category
 WearableSizeGroupMaternity|Category
 WearableSizeGroupMens|Category
 WearableSizeGroupMisses|Category
 WearableSizeGroupPetite|Category
 WearableSizeGroupPlus|Category
 WearableSizeGroupRegular|Category
 WearableSizeGroupShort|Category
 WearableSizeGroupTall|Category
 WearableSizeGroupWomens|Category
 WearableSizeSystemAU|Category
 WearableSizeSystemBR|Category
 WearableSizeSystemCN|Category
 WearableSizeSystemContinental|Category
 WearableSizeSystemDE|Category
 WearableSizeSystemEN13402|Category
 WearableSizeSystemEnumeration|Category
 WearableSizeSystemEurope|Category
 WearableSizeSystemFR|Category
 WearableSizeSystemGS1|Category
 WearableSizeSystemIT|Category
 WearableSizeSystemJP|Category
 WearableSizeSystemMX|Category
 WearableSizeSystemUK|Category
 WearableSizeSystemUS|Category
 WebAPI|Category
 WebApplication|Category
 WebContent|Category
 WebPage|Category
 WebPageElement|Category
 WebSite|Category
 Wednesday|Category
 WesternConventional|Category
 Wholesale|Category
 WholesaleStore|Category
 WinAction|Category
 Winery|Category
 Withdrawn|Category
 WorkBasedProgram|Category
 WorkersUnion|Category
 WriteAction|Category
 WritePermission|Category
 XPathType|Category
 XRay|Category
 ZoneBoardingPolicy|Category
 Zoo|Category

[[Category:Imported vocabulary]]</text>
      <sha1>khnz66z361edmu7hwoy0ozcc3hrwi7r</sha1>
    </revision>
  </page>
  <page>
    <title>MediaWiki:Smw import skos</title>
    <ns>8</ns>
    <id>4</id>
    <revision>
      <id>4</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki default vocabulary import</comment>
      <origin>4</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1112" sha1="j87eq2dhugtzw7lrt6hgwgu0plzxevz" xml:space="preserve">http://www.w3.org/2004/02/skos/core# | [http://www.w3.org/TR/skos-reference Simple Knowledge Organization System (SKOS)]
 altLabel|Type:Monolingual text
 broader|Type:Annotation URI
 broaderTransitive|Type:Annotation URI
 broadMatch|Type:Annotation URI
 changeNote|Type:Monolingual text
 closeMatch|Type:Annotation URI
 definition|Type:Monolingual text
 editorialNote|Type:Monolingual text
 exactMatch|Type:Annotation URI
 example|Type:Monolingual text
 hasTopConcept|Type:Page
 hiddenLabel|Type:Monolingual text
 historyNote|Type:Monolingual text
 inScheme|Type:Page
 mappingRelation|Type:Annotation URI
 member|Type:Page
 memberList|Type:Page
 narrower|Type:Annotation URI
 narrowerTransitive|Type:Annotation URI
 narrowMatch|Type:Annotation URI
 notation|Type:Text
 note|Type:Monolingual text
 prefLabel|Type:Monolingual text
 related|Type:Annotation URI
 relatedMatch|Type:Annotation URI
 scopeNote|Type:Monolingual text
 semanticRelation|Type:Annotation URI
 topConceptOf|Type:Page

 Collection|Category
 Concept|Category
 ConceptScheme|Category
 OrderedCollection|Category

[[Category:Imported_vocabulary]]</text>
      <sha1>j87eq2dhugtzw7lrt6hgwgu0plzxevz</sha1>
    </revision>
  </page>
  <page>
    <title>MediaWiki:Smw import foaf</title>
    <ns>8</ns>
    <id>5</id>
    <revision>
      <id>5</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki default vocabulary import</comment>
      <origin>5</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1118" sha1="4j4wd40n8aofykqsfjo9y02ohyzy88n" xml:space="preserve">http://xmlns.com/foaf/0.1/ | [https://en.wikipedia.org/wiki/FOAF_(ontology) Friend Of A Friend]
 aimChatID|Type:External identifier
 currentProject|Type:Page
 depiction|Type:Page
 depicts|Type:Page
 dnaChecksum|Type:Text
 family_name|Type:Text
 firstName|Type:Text
 fundedBy|Type:Page
 geekcode|Type:Text
 givenname|Type:Text
 homepage|Type:URL
 iChatID|Type:External identifier
 img|Type:Page
 interest|Type:Page
 jabberID|Type:External identifier
 knows|Type:Page
 linkedWith|Type:Page
 logo|Type:Page
 made|Type:Page
 mbox|Type:Email
 mbox_sha1sum|Type:Text
 msnChatID|Type:External identifier
 myersBriggs|Type:Text
 name|Type:Text
 nick|Type:Text
 page|Type:Page
 pastProject|Type:Page
 phone|Type:Telephone number
 plan|Type:Text
 publications|Type:Page
 schoolHomepage|Type:URL
 sha1|Type:Text
 surname|Type:Text
 theme|Type:Page
 thumbnail|Type:URL
 title|Type:Text
 topic|Type:Page
 topic_interest|Type:Page
 weblog|Type:Page
 workInfoHomepage|Type:URL
 workplaceHomepage|Type:URL

 Document|Category
 Image|Category
 Organization|Category
 Person|Category
 Project |Category

[[Category:Imported vocabulary]]</text>
      <sha1>4j4wd40n8aofykqsfjo9y02ohyzy88n</sha1>
    </revision>
  </page>
  <page>
    <title>MediaWiki:Smw import owl</title>
    <ns>8</ns>
    <id>6</id>
    <revision>
      <id>6</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki default vocabulary import</comment>
      <origin>6</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1203" sha1="969sfdrvc0naujabwwu021srfzt9m4w" xml:space="preserve">https://www.w3.org/TR/owl2-syntax/ | [https://www.w3.org/TR/owl2-syntax/ Web Ontology Language (OWL)]
 AllDifferent|Category
 allValuesFrom|Type:Page
 AnnotationProperty|Category
 backwardCompatibleWith|Type:Page
 cardinality|Type:Number
 Class|Category
 comment|Type:Page
 complementOf|Type:Page
 DataRange|Category
 DatatypeProperty|Category
 DeprecatedClass|Category
 DeprecatedProperty|Category
 differentFrom|Type:Page
 disjointWith|Type:Page
 distinctMembers|Type:Page
 equivalentClass|Type:Page
 equivalentProperty|Type:Page
 FunctionalProperty|Category
 hasValue|Type:Page
 imports|Type:Page
 incompatibleWith|Type:Page
 intersectionOf|Type:Page
 InverseFunctionalProperty|Category
 inverseOf|Type:Page
 label|Type:Page
 maxCardinality|Type:Number
 Members|Type:Page
 minCardinality|Type:Number
 Nothing|Category
 ObjectProperty|Category
 oneOf|Type:Page
 onProperty|Type:Page
 Ontology|Category
 OntologyProperty|Category
 owl|Type:Page
 priorVersion|Type:Page
 Restriction|Category
 sameAs|Type:Page
 seeAlso|Type:Page
 someValuesFrom|Type:Page
 SymmetricProperty|Category
 Thing|Category
 TransitiveProperty|Category
 unionOf|Type:Page
 versionInfo|Type:Page

[[Category:Imported vocabulary]]</text>
      <sha1>969sfdrvc0naujabwwu021srfzt9m4w</sha1>
    </revision>
  </page>
  <page>
    <title>Property:Foaf:knows</title>
    <ns>102</ns>
    <id>7</id>
    <revision>
      <id>7</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki default vocabulary import</comment>
      <origin>7</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="227" sha1="r84n0cewys8sf532il1jpkj3virql2i" xml:space="preserve">* [[Imported from::foaf:knows]]
* [[Property description::A person known by this person (indicating some level of reciprocated interaction between the parties).@en]]

[[Category:Imported vocabulary]] {{DISPLAYTITLE:foaf:knows}}</text>
      <sha1>r84n0cewys8sf532il1jpkj3virql2i</sha1>
    </revision>
  </page>
  <page>
    <title>Property:Foaf:name</title>
    <ns>102</ns>
    <id>8</id>
    <revision>
      <id>8</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki default vocabulary import</comment>
      <origin>8</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="154" sha1="4ywl3swqwhp0fsjdfg6poaq2d6n77xf" xml:space="preserve">* [[Imported from::foaf:name]]
* [[Property description::A name for some thing or agent.@en]]

[[Category:Imported vocabulary]] {{DISPLAYTITLE:foaf:name}}</text>
      <sha1>4ywl3swqwhp0fsjdfg6poaq2d6n77xf</sha1>
    </revision>
  </page>
  <page>
    <title>Property:Foaf:homepage</title>
    <ns>102</ns>
    <id>9</id>
    <revision>
      <id>9</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki default vocabulary import</comment>
      <origin>9</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="198" sha1="0yfosgdiyxnbl3w8m6h2o3nd5ehtb6u" xml:space="preserve">* [[Imported from::foaf:homepage]]
* [[Property description::URL of the homepage of something, which is a general web resource.@en]] 

[[Category:Imported vocabulary]] {{DISPLAYTITLE:foaf:homepage}}</text>
      <sha1>0yfosgdiyxnbl3w8m6h2o3nd5ehtb6u</sha1>
    </revision>
  </page>
  <page>
    <title>Property:Owl:differentFrom</title>
    <ns>102</ns>
    <id>10</id>
    <revision>
      <id>10</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki default vocabulary import</comment>
      <origin>10</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="209" sha1="p482vcrjzqtstzps5n3lp9i5hzy2scs" xml:space="preserve">* [[Imported from::owl:differentFrom]]
* [[Property description::The property that determines that two given individuals are different.@en]]

[[Category:Imported vocabulary]] {{DISPLAYTITLE:owl:differentFrom}}</text>
      <sha1>p482vcrjzqtstzps5n3lp9i5hzy2scs</sha1>
    </revision>
  </page>
  <page>
    <title>smw/schema:Group:Schema properties</title>
    <ns>112</ns>
    <id>11</id>
    <revision>
      <id>11</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki group import</comment>
      <origin>11</origin>
      <model>smw/schema</model>
      <format>application/json</format>
      <text bytes="589" sha1="tmz3l2uctisu9w7umutjhmul9gs7lzh" xml:space="preserve">{
    "type": "PROPERTY_GROUP_SCHEMA",
    "groups": {
        "schema_group": {
            "canonical_name": "Schema properties",
            "message_key": "smw-property-group-label-schema-group",
            "property_keys": [
                "_SCHEMA_TYPE",
                "_SCHEMA_DEF",
                "_SCHEMA_DESC",
                "_SCHEMA_TAG",
                "_SCHEMA_LINK",
                "_FORMAT_SCHEMA",
                "_CONSTRAINT_SCHEMA",
                "_PROFILE_SCHEMA"
            ]
        }
    },
    "tags": [
        "group",
        "property group"
    ]
}</text>
      <sha1>tmz3l2uctisu9w7umutjhmul9gs7lzh</sha1>
    </revision>
  </page>
  <page>
    <title>smw/schema:Group:Predefined properties</title>
    <ns>112</ns>
    <id>12</id>
    <revision>
      <id>12</id>
      <timestamp>2025-07-09T04:30:40Z</timestamp>
      <contributor>
        <username>Maintenance script</username>
        <id>3</id>
      </contributor>
      <comment>Semantic MediaWiki group import</comment>
      <origin>12</origin>
      <model>smw/schema</model>
      <format>application/json</format>
      <text bytes="2156" sha1="962lpuwo1modz3ciohhq3n6j26vnhc9" xml:space="preserve">{
    "type": "PROPERTY_GROUP_SCHEMA",
    "groups": {
        "administrative_group": {
            "canonical_name": "Administrative properties",
            "message_key": "smw-property-group-label-administrative-properties",
            "property_keys": [
                "_MDAT",
                "_CDAT",
                "_NEWP",
                "_LEDT",
                "_DTITLE",
                "_CHGPRO",
                "_EDIP",
                "_ERRC"
            ]
        },
        "classification_group": {
            "canonical_name": "Classification properties",
            "message_key": "smw-property-group-label-classification-properties",
            "property_keys": [
                "_INST",
                "_PPGR",
                "_SUBP",
                "_SUBC"
            ]
        },
        "content_group": {
            "canonical_name": "Content properties",
            "message_key": "smw-property-group-label-content-properties",
            "property_keys": [
                "_SOBJ",
                "_ASK",
                "_MEDIA",
                "_MIME",
                "_ATTCH_LINK",
                "_FILE_ATTCH",
                "_CONT_TYPE",
                "_CONT_AUTHOR",
                "_CONT_LEN",
                "_CONT_LANG",
                "_CONT_TITLE",
                "_CONT_DATE",
                "_CONT_KEYW",
                "_TRANS",
                "_TRANS_SOURCE",
                "_TRANS_GROUP"
            ]
        },
        "declarative_group": {
            "canonical_name": "Declarative properties",
            "message_key": "smw-property-group-label-declarative-properties",
            "property_keys": [
                "_TYPE",
                "_UNIT",
                "_IMPO",
                "_CONV",
                "_SERV",
                "_PVAL",
                "_LIST",
                "_PREC",
                "_PDESC",
                "_PPLB",
                "_PVAP",
                "_PVALI",
                "_PVUC",
                "_PEID",
                "_PEFU"
            ]
        }
    },
    "tags": [
        "group",
        "property group"
    ]
}</text>
      <sha1>962lpuwo1modz3ciohhq3n6j26vnhc9</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikidata</title>
    <ns>10</ns>
    <id>13</id>
    <revision>
      <id>14</id>
      <parentid>13</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>13</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="98" sha1="aqnmh4azo4jle51xny4knl3b1hl9873" xml:space="preserve">&lt;includeonly&gt;{{safesubst:#invoke:Wd|main}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>aqnmh4azo4jle51xny4knl3b1hl9873</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Nowrap</title>
    <ns>10</ns>
    <id>14</id>
    <revision>
      <id>16</id>
      <parentid>15</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>15</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="145" sha1="avb5tcymgupik1ikutqclidkj9tnitx" xml:space="preserve">&lt;span class="nowrap"&gt;{{{1}}}&lt;/span&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc page; interwikis go to Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>avb5tcymgupik1ikutqclidkj9tnitx</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Yesno</title>
    <ns>828</ns>
    <id>15</id>
    <revision>
      <id>18</id>
      <parentid>17</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>17</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="745" sha1="swdskn7svew8i9wuydn9uj5l3r2ghcs" xml:space="preserve">-- Function allowing for consistent treatment of boolean-like wikitext input.
-- It works similarly to the template {{yesno}}.

return function (val, default)
	-- If your wiki uses non-ascii characters for any of "yes", "no", etc., you
	-- should replace "val:lower()" with "mw.ustring.lower(val)" in the
	-- following line.
	val = type(val) == 'string' and val:lower() or val
	if val == nil then
		return nil
	elseif val == true 
		or val == 'yes'
		or val == 'y'
		or val == 'true'
		or val == 't'
		or val == 'on'
		or tonumber(val) == 1
	then
		return true
	elseif val == false
		or val == 'no'
		or val == 'n'
		or val == 'false'
		or val == 'f'
		or val == 'off'
		or tonumber(val) == 0
	then
		return false
	else
		return default
	end
end</text>
      <sha1>swdskn7svew8i9wuydn9uj5l3r2ghcs</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Arguments</title>
    <ns>828</ns>
    <id>16</id>
    <revision>
      <id>20</id>
      <parentid>19</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>19</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="10054" sha1="5qx9tzlul9ser30uxj9nbasjt92cevn" xml:space="preserve">-- This module provides easy processing of arguments passed to Scribunto from
-- #invoke. It is intended for use by other Lua modules, and should not be
-- called from #invoke directly.

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType

local arguments = {}

-- Generate four different tidyVal functions, so that we don't have to check the
-- options every time we call it.

local function tidyValDefault(key, val)
	if type(val) == 'string' then
		val = val:match('^%s*(.-)%s*$')
		if val == '' then
			return nil
		else
			return val
		end
	else
		return val
	end
end

local function tidyValTrimOnly(key, val)
	if type(val) == 'string' then
		return val:match('^%s*(.-)%s*$')
	else
		return val
	end
end

local function tidyValRemoveBlanksOnly(key, val)
	if type(val) == 'string' then
		if val:find('%S') then
			return val
		else
			return nil
		end
	else
		return val
	end
end

local function tidyValNoChange(key, val)
	return val
end

local function matchesTitle(given, title)
	local tp = type( given )
	return (tp == 'string' or tp == 'number') and mw.title.new( given ).prefixedText == title
end

local translate_mt = { __index = function(t, k) return k end }

function arguments.getArgs(frame, options)
	checkType('getArgs', 1, frame, 'table', true)
	checkType('getArgs', 2, options, 'table', true)
	frame = frame or {}
	options = options or {}

	--[[
	-- Set up argument translation.
	--]]
	options.translate = options.translate or {}
	if getmetatable(options.translate) == nil then
		setmetatable(options.translate, translate_mt)
	end
	if options.backtranslate == nil then
		options.backtranslate = {}
		for k,v in pairs(options.translate) do
			options.backtranslate[v] = k
		end
	end
	if options.backtranslate and getmetatable(options.backtranslate) == nil then
		setmetatable(options.backtranslate, {
			__index = function(t, k)
				if options.translate[k] ~= k then
					return nil
				else
					return k
				end
			end
		})
	end

	--[[
	-- Get the argument tables. If we were passed a valid frame object, get the
	-- frame arguments (fargs) and the parent frame arguments (pargs), depending
	-- on the options set and on the parent frame's availability. If we weren't
	-- passed a valid frame object, we are being called from another Lua module
	-- or from the debug console, so assume that we were passed a table of args
	-- directly, and assign it to a new variable (luaArgs).
	--]]
	local fargs, pargs, luaArgs
	if type(frame.args) == 'table' and type(frame.getParent) == 'function' then
		if options.wrappers then
			--[[
			-- The wrappers option makes Module:Arguments look up arguments in
			-- either the frame argument table or the parent argument table, but
			-- not both. This means that users can use either the #invoke syntax
			-- or a wrapper template without the loss of performance associated
			-- with looking arguments up in both the frame and the parent frame.
			-- Module:Arguments will look up arguments in the parent frame
			-- if it finds the parent frame's title in options.wrapper;
			-- otherwise it will look up arguments in the frame object passed
			-- to getArgs.
			--]]
			local parent = frame:getParent()
			if not parent then
				fargs = frame.args
			else
				local title = parent:getTitle():gsub('/sandbox$', '')
				local found = false
				if matchesTitle(options.wrappers, title) then
					found = true
				elseif type(options.wrappers) == 'table' then
					for _,v in pairs(options.wrappers) do
						if matchesTitle(v, title) then
							found = true
							break
						end
					end
				end

				-- We test for false specifically here so that nil (the default) acts like true.
				if found or options.frameOnly == false then
					pargs = parent.args
				end
				if not found or options.parentOnly == false then
					fargs = frame.args
				end
			end
		else
			-- options.wrapper isn't set, so check the other options.
			if not options.parentOnly then
				fargs = frame.args
			end
			if not options.frameOnly then
				local parent = frame:getParent()
				pargs = parent and parent.args or nil
			end
		end
		if options.parentFirst then
			fargs, pargs = pargs, fargs
		end
	else
		luaArgs = frame
	end

	-- Set the order of precedence of the argument tables. If the variables are
	-- nil, nothing will be added to the table, which is how we avoid clashes
	-- between the frame/parent args and the Lua args.
	local argTables = {fargs}
	argTables[#argTables + 1] = pargs
	argTables[#argTables + 1] = luaArgs

	--[[
	-- Generate the tidyVal function. If it has been specified by the user, we
	-- use that; if not, we choose one of four functions depending on the
	-- options chosen. This is so that we don't have to call the options table
	-- every time the function is called.
	--]]
	local tidyVal = options.valueFunc
	if tidyVal then
		if type(tidyVal) ~= 'function' then
			error(
				"bad value assigned to option 'valueFunc'"
					.. '(function expected, got '
					.. type(tidyVal)
					.. ')',
				2
			)
		end
	elseif options.trim ~= false then
		if options.removeBlanks ~= false then
			tidyVal = tidyValDefault
		else
			tidyVal = tidyValTrimOnly
		end
	else
		if options.removeBlanks ~= false then
			tidyVal = tidyValRemoveBlanksOnly
		else
			tidyVal = tidyValNoChange
		end
	end

	--[[
	-- Set up the args, metaArgs and nilArgs tables. args will be the one
	-- accessed from functions, and metaArgs will hold the actual arguments. Nil
	-- arguments are memoized in nilArgs, and the metatable connects all of them
	-- together.
	--]]
	local args, metaArgs, nilArgs, metatable = {}, {}, {}, {}
	setmetatable(args, metatable)

	local function mergeArgs(tables)
		--[[
		-- Accepts multiple tables as input and merges their keys and values
		-- into one table. If a value is already present it is not overwritten;
		-- tables listed earlier have precedence. We are also memoizing nil
		-- values, which can be overwritten if they are 's' (soft).
		--]]
		for _, t in ipairs(tables) do
			for key, val in pairs(t) do
				if metaArgs[key] == nil and nilArgs[key] ~= 'h' then
					local tidiedVal = tidyVal(key, val)
					if tidiedVal == nil then
						nilArgs[key] = 's'
					else
						metaArgs[key] = tidiedVal
					end
				end
			end
		end
	end

	--[[
	-- Define metatable behaviour. Arguments are memoized in the metaArgs table,
	-- and are only fetched from the argument tables once. Fetching arguments
	-- from the argument tables is the most resource-intensive step in this
	-- module, so we try and avoid it where possible. For this reason, nil
	-- arguments are also memoized, in the nilArgs table. Also, we keep a record
	-- in the metatable of when pairs and ipairs have been called, so we do not
	-- run pairs and ipairs on the argument tables more than once. We also do
	-- not run ipairs on fargs and pargs if pairs has already been run, as all
	-- the arguments will already have been copied over.
	--]]

	metatable.__index = function (t, key)
		--[[
		-- Fetches an argument when the args table is indexed. First we check
		-- to see if the value is memoized, and if not we try and fetch it from
		-- the argument tables. When we check memoization, we need to check
		-- metaArgs before nilArgs, as both can be non-nil at the same time.
		-- If the argument is not present in metaArgs, we also check whether
		-- pairs has been run yet. If pairs has already been run, we return nil.
		-- This is because all the arguments will have already been copied into
		-- metaArgs by the mergeArgs function, meaning that any other arguments
		-- must be nil.
		--]]
		if type(key) == 'string' then
			key = options.translate[key]
		end
		local val = metaArgs[key]
		if val ~= nil then
			return val
		elseif metatable.donePairs or nilArgs[key] then
			return nil
		end
		for _, argTable in ipairs(argTables) do
			local argTableVal = tidyVal(key, argTable[key])
			if argTableVal ~= nil then
				metaArgs[key] = argTableVal
				return argTableVal
			end
		end
		nilArgs[key] = 'h'
		return nil
	end

	metatable.__newindex = function (t, key, val)
		-- This function is called when a module tries to add a new value to the
		-- args table, or tries to change an existing value.
		if type(key) == 'string' then
			key = options.translate[key]
		end
		if options.readOnly then
			error(
				'could not write to argument table key "'
					.. tostring(key)
					.. '"; the table is read-only',
				2
			)
		elseif options.noOverwrite and args[key] ~= nil then
			error(
				'could not write to argument table key "'
					.. tostring(key)
					.. '"; overwriting existing arguments is not permitted',
				2
			)
		elseif val == nil then
			--[[
			-- If the argument is to be overwritten with nil, we need to erase
			-- the value in metaArgs, so that __index, __pairs and __ipairs do
			-- not use a previous existing value, if present; and we also need
			-- to memoize the nil in nilArgs, so that the value isn't looked
			-- up in the argument tables if it is accessed again.
			--]]
			metaArgs[key] = nil
			nilArgs[key] = 'h'
		else
			metaArgs[key] = val
		end
	end

	local function translatenext(invariant)
		local k, v = next(invariant.t, invariant.k)
		invariant.k = k
		if k == nil then
			return nil
		elseif type(k) ~= 'string' or not options.backtranslate then
			return k, v
		else
			local backtranslate = options.backtranslate[k]
			if backtranslate == nil then
				-- Skip this one. This is a tail call, so this won't cause stack overflow
				return translatenext(invariant)
			else
				return backtranslate, v
			end
		end
	end

	metatable.__pairs = function ()
		-- Called when pairs is run on the args table.
		if not metatable.donePairs then
			mergeArgs(argTables)
			metatable.donePairs = true
		end
		return translatenext, { t = metaArgs }
	end

	local function inext(t, i)
		-- This uses our __index metamethod
		local v = t[i + 1]
		if v ~= nil then
			return i + 1, v
		end
	end

	metatable.__ipairs = function (t)
		-- Called when ipairs is run on the args table.
		return inext, t, 0
	end

	return args
end

return arguments</text>
      <sha1>5qx9tzlul9ser30uxj9nbasjt92cevn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Tl</title>
    <ns>10</ns>
    <id>17</id>
    <redirect title="Template:Template link" />
    <revision>
      <id>22</id>
      <parentid>21</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>21</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="83" sha1="p1dn3i2ckb7gtckkrbn0xh6ckx8nei1" xml:space="preserve">#REDIRECT [[Template:Template link]]

{{Redirect category shell|
{{R from move}}
}}</text>
      <sha1>p1dn3i2ckb7gtckkrbn0xh6ckx8nei1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Template link</title>
    <ns>10</ns>
    <id>18</id>
    <revision>
      <id>24</id>
      <parentid>23</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>23</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="224" sha1="kkhg4xclyf9r0bcl7ypdd0yuh41mfu9" xml:space="preserve">&lt;span class="nowrap"&gt;&amp;#123;&amp;#123;&lt;/span&gt;[[Template:{{{1}}}|{{{1}}}]]&lt;span class="nowrap"&gt;&amp;#125;&amp;#125;&lt;/span&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>kkhg4xclyf9r0bcl7ypdd0yuh41mfu9</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Message box</title>
    <ns>828</ns>
    <id>19</id>
    <revision>
      <id>26</id>
      <parentid>25</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>25</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="18961" sha1="qjedtq8k5rp7pkaeftelylik87u0bva" xml:space="preserve">require('strict')
local getArgs
local yesno = require('Module:Yesno')
local lang = mw.language.getContentLanguage()

local CONFIG_MODULE = 'Module:Message box/configuration'
local DEMOSPACES = {talk = 'tmbox', image = 'imbox', file = 'imbox', category = 'cmbox', article = 'ambox', main = 'ambox'}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function getTitleObject(...)
	-- Get the title object, passing the function through pcall
	-- in case we are over the expensive function count limit.
	local success, title = pcall(mw.title.new, ...)
	if success then
		return title
	end
end

local function union(t1, t2)
	-- Returns the union of two arrays.
	local vals = {}
	for i, v in ipairs(t1) do
		vals[v] = true
	end
	for i, v in ipairs(t2) do
		vals[v] = true
	end
	local ret = {}
	for k in pairs(vals) do
		table.insert(ret, k)
	end
	table.sort(ret)
	return ret
end

local function getArgNums(args, prefix)
	local nums = {}
	for k, v in pairs(args) do
		local num = mw.ustring.match(tostring(k), '^' .. prefix .. '([1-9]%d*)$')
		if num then
			table.insert(nums, tonumber(num))
		end
	end
	table.sort(nums)
	return nums
end

--------------------------------------------------------------------------------
-- Box class definition
--------------------------------------------------------------------------------

local MessageBox = {}
MessageBox.__index = MessageBox

function MessageBox.new(boxType, args, cfg)
	args = args or {}
	local obj = {}

	-- Set the title object and the namespace.
	obj.title = getTitleObject(args.page) or mw.title.getCurrentTitle()

	-- Set the config for our box type.
	obj.cfg = cfg[boxType]
	if not obj.cfg then
		local ns = obj.title.namespace
		-- boxType is "mbox" or invalid input
		if args.demospace and args.demospace ~= '' then
			-- implement demospace parameter of mbox
			local demospace = string.lower(args.demospace)
			if DEMOSPACES[demospace] then
				-- use template from DEMOSPACES
				obj.cfg = cfg[DEMOSPACES[demospace]]
			elseif string.find( demospace, 'talk' ) then
				-- demo as a talk page
				obj.cfg = cfg.tmbox
			else
				-- default to ombox
				obj.cfg = cfg.ombox
			end
		elseif ns == 0 then
			obj.cfg = cfg.ambox -- main namespace
		elseif ns == 6 then
			obj.cfg = cfg.imbox -- file namespace
		elseif ns == 14 then
			obj.cfg = cfg.cmbox -- category namespace
		else
			local nsTable = mw.site.namespaces[ns]
			if nsTable and nsTable.isTalk then
				obj.cfg = cfg.tmbox -- any talk namespace
			else
				obj.cfg = cfg.ombox -- other namespaces or invalid input
			end
		end
	end

	-- Set the arguments, and remove all blank arguments except for the ones
	-- listed in cfg.allowBlankParams.
	do
		local newArgs = {}
		for k, v in pairs(args) do
			if v ~= '' then
				newArgs[k] = v
			end
		end
		for i, param in ipairs(obj.cfg.allowBlankParams or {}) do
			newArgs[param] = args[param]
		end
		obj.args = newArgs
	end

	-- Define internal data structure.
	obj.categories = {}
	obj.classes = {}
	-- For lazy loading of [[Module:Category handler]].
	obj.hasCategories = false

	return setmetatable(obj, MessageBox)
end

function MessageBox:addCat(ns, cat, sort)
	if not cat then
		return nil
	end
	if sort then
		cat = string.format('[[Category:%s|%s]]', cat, sort)
	else
		cat = string.format('[[Category:%s]]', cat)
	end
	self.hasCategories = true
	self.categories[ns] = self.categories[ns] or {}
	table.insert(self.categories[ns], cat)
end

function MessageBox:addClass(class)
	if not class then
		return nil
	end
	table.insert(self.classes, class)
end

function MessageBox:setParameters()
	local args = self.args
	local cfg = self.cfg

	-- Get type data.
	self.type = args.type
	local typeData = cfg.types[self.type]
	self.invalidTypeError = cfg.showInvalidTypeError
		and self.type
		and not typeData
	typeData = typeData or cfg.types[cfg.default]
	self.typeClass = typeData.class
	self.typeImage = typeData.image
	self.typeImageNeedsLink = typeData.imageNeedsLink

	-- Find if the box has been wrongly substituted.
	self.isSubstituted = cfg.substCheck and args.subst == 'SUBST'

	-- Find whether we are using a small message box.
	self.isSmall = cfg.allowSmall and (
		cfg.smallParam and args.small == cfg.smallParam
		or not cfg.smallParam and yesno(args.small)
	)

	-- Add attributes, classes and styles.
	self.id = args.id
	self.name = args.name
	if self.name then
		self:addClass('box-' .. string.gsub(self.name,' ','_'))
	end
	if yesno(args.plainlinks) ~= false then
		self:addClass('plainlinks')
	end
	for _, class in ipairs(cfg.classes or {}) do
		self:addClass(class)
	end
	if self.isSmall then
		self:addClass(cfg.smallClass or 'mbox-small')
	end
	self:addClass(self.typeClass)
	self:addClass(args.class)
	self.style = args.style
	self.attrs = args.attrs

	-- Set text style.
	self.textstyle = args.textstyle
	
	-- Set image classes.
	self.imageRightClass = args.imagerightclass or args.imageclass
	self.imageLeftClass = args.imageleftclass or args.imageclass

	-- Find if we are on the template page or not. This functionality is only
	-- used if useCollapsibleTextFields is set, or if both cfg.templateCategory
	-- and cfg.templateCategoryRequireName are set.
	self.useCollapsibleTextFields = cfg.useCollapsibleTextFields
	if self.useCollapsibleTextFields
		or cfg.templateCategory
		and cfg.templateCategoryRequireName
	then
		if self.name then
			local templateName = mw.ustring.match(
				self.name,
				'^[tT][eE][mM][pP][lL][aA][tT][eE][%s_]*:[%s_]*(.*)$'
			) or self.name
			templateName = 'Template:' .. templateName
			self.templateTitle = getTitleObject(templateName)
		end
		self.isTemplatePage = self.templateTitle
			and mw.title.equals(self.title, self.templateTitle)
	end
	
	-- Process data for collapsible text fields. At the moment these are only
	-- used in {{ambox}}.
	if self.useCollapsibleTextFields then
		-- Get the self.issue value.
		if self.isSmall and args.smalltext then
			self.issue = args.smalltext
		else
			local sect
			if args.sect == '' then
				sect = 'This ' .. (cfg.sectionDefault or 'page')
			elseif type(args.sect) == 'string' then
				sect = 'This ' .. args.sect
			end
			local issue = args.issue
			issue = type(issue) == 'string' and issue ~= '' and issue or nil
			local text = args.text
			text = type(text) == 'string' and text or nil
			local issues = {}
			table.insert(issues, sect)
			table.insert(issues, issue)
			table.insert(issues, text)
			self.issue = table.concat(issues, ' ')
		end

		-- Get the self.talk value.
		local talk = args.talk
		-- Show talk links on the template page or template subpages if the talk
		-- parameter is blank.
		if talk == ''
			and self.templateTitle
			and (
				mw.title.equals(self.templateTitle, self.title)
				or self.title:isSubpageOf(self.templateTitle)
			)
		then
			talk = '#'
		elseif talk == '' then
			talk = nil
		end
		if talk then
			-- If the talk value is a talk page, make a link to that page. Else
			-- assume that it's a section heading, and make a link to the talk
			-- page of the current page with that section heading.
			local talkTitle = getTitleObject(talk)
			local talkArgIsTalkPage = true
			if not talkTitle or not talkTitle.isTalkPage then
				talkArgIsTalkPage = false
				talkTitle = getTitleObject(
					self.title.text,
					mw.site.namespaces[self.title.namespace].talk.id
				)
			end
			if talkTitle and talkTitle.exists then
                local talkText
                if self.isSmall then
                    local talkLink = talkArgIsTalkPage and talk or (talkTitle.prefixedText .. (talk == '#' and '' or '#') .. talk)
                    talkText = string.format('([[%s|talk]])', talkLink)
                else
                    talkText = 'Relevant discussion may be found on'
                    if talkArgIsTalkPage then
                        talkText = string.format(
                            '%s [[%s|%s]].',
                            talkText,
                            talk,
                            talkTitle.prefixedText
                        )
                    else
                        talkText = string.format(
                            '%s the [[%s' .. (talk == '#' and '' or '#') .. '%s|talk page]].',
                            talkText,
                            talkTitle.prefixedText,
                            talk
                        )
                    end
                end
				self.talk = talkText
			end
		end

		-- Get other values.
		self.fix = args.fix ~= '' and args.fix or nil
		local date
		if args.date and args.date ~= '' then
			date = args.date
		elseif args.date == '' and self.isTemplatePage then
			date = lang:formatDate('F Y')
		end
		if date then
			self.date = string.format(" &lt;span class='date-container'&gt;&lt;i&gt;(&lt;span class='date'&gt;%s&lt;/span&gt;)&lt;/i&gt;&lt;/span&gt;", date)
		end
		self.info = args.info
		if yesno(args.removalnotice) then
			self.removalNotice = cfg.removalNotice
		end
	end

	-- Set the non-collapsible text field. At the moment this is used by all box
	-- types other than ambox, and also by ambox when small=yes.
	if self.isSmall then
		self.text = args.smalltext or args.text
	else
		self.text = args.text
	end

	-- Set the below row.
	self.below = cfg.below and args.below

	-- General image settings.
	self.imageCellDiv = not self.isSmall and cfg.imageCellDiv
	self.imageEmptyCell = cfg.imageEmptyCell

	-- Left image settings.
	local imageLeft = self.isSmall and args.smallimage or args.image
	if cfg.imageCheckBlank and imageLeft ~= 'blank' and imageLeft ~= 'none'
		or not cfg.imageCheckBlank and imageLeft ~= 'none'
	then
		self.imageLeft = imageLeft
		if not imageLeft then
			local imageSize = self.isSmall
				and (cfg.imageSmallSize or '30x30px')
				or '40x40px'
			self.imageLeft = string.format('[[File:%s|%s%s|alt=]]', self.typeImage
				or 'Information icon4.svg', imageSize, self.typeImageNeedsLink and "" or "|link=" )
		end
	end

	-- Right image settings.
	local imageRight = self.isSmall and args.smallimageright or args.imageright
	if not (cfg.imageRightNone and imageRight == 'none') then
		self.imageRight = imageRight
	end
	
	-- set templatestyles
	self.base_templatestyles = cfg.templatestyles
	self.templatestyles = args.templatestyles
end

function MessageBox:setMainspaceCategories()
	local args = self.args
	local cfg = self.cfg

	if not cfg.allowMainspaceCategories then
		return nil
	end

	local nums = {}
	for _, prefix in ipairs{'cat', 'category', 'all'} do
		args[prefix .. '1'] = args[prefix]
		nums = union(nums, getArgNums(args, prefix))
	end

	-- The following is roughly equivalent to the old {{Ambox/category}}.
	local date = args.date
	date = type(date) == 'string' and date
	local preposition = 'from'
	for _, num in ipairs(nums) do
		local mainCat = args['cat' .. tostring(num)]
			or args['category' .. tostring(num)]
		local allCat = args['all' .. tostring(num)]
		mainCat = type(mainCat) == 'string' and mainCat
		allCat = type(allCat) == 'string' and allCat
		if mainCat and date and date ~= '' then
			local catTitle = string.format('%s %s %s', mainCat, preposition, date)
			self:addCat(0, catTitle)
			catTitle = getTitleObject('Category:' .. catTitle)
			if not catTitle or not catTitle.exists then
				self:addCat(0, 'Articles with invalid date parameter in template')
			end
		elseif mainCat and (not date or date == '') then
			self:addCat(0, mainCat)
		end
		if allCat then
			self:addCat(0, allCat)
		end
	end
end

function MessageBox:setTemplateCategories()
	local args = self.args
	local cfg = self.cfg

	-- Add template categories.
	if cfg.templateCategory then
		if cfg.templateCategoryRequireName then
			if self.isTemplatePage then
				self:addCat(10, cfg.templateCategory)
			end
		elseif not self.title.isSubpage then
			self:addCat(10, cfg.templateCategory)
		end
	end

	-- Add template error categories.
	if cfg.templateErrorCategory then
		local templateErrorCategory = cfg.templateErrorCategory
		local templateCat, templateSort
		if not self.name and not self.title.isSubpage then
			templateCat = templateErrorCategory
		elseif self.isTemplatePage then
			local paramsToCheck = cfg.templateErrorParamsToCheck or {}
			local count = 0
			for i, param in ipairs(paramsToCheck) do
				if not args[param] then
					count = count + 1
				end
			end
			if count &gt; 0 then
				templateCat = templateErrorCategory
				templateSort = tostring(count)
			end
			if self.categoryNums and #self.categoryNums &gt; 0 then
				templateCat = templateErrorCategory
				templateSort = 'C'
			end
		end
		self:addCat(10, templateCat, templateSort)
	end
end

function MessageBox:setAllNamespaceCategories()
	-- Set categories for all namespaces.
	if self.invalidTypeError then
		local allSort = (self.title.namespace == 0 and 'Main:' or '') .. self.title.prefixedText
		self:addCat('all', 'Wikipedia message box parameter needs fixing', allSort)
	end
	if self.isSubstituted then
		self:addCat('all', 'Pages with incorrectly substituted templates')
	end
end

function MessageBox:setCategories()
	if self.title.namespace == 0 then
		self:setMainspaceCategories()
	elseif self.title.namespace == 10 then
		self:setTemplateCategories()
	end
	self:setAllNamespaceCategories()
end

function MessageBox:renderCategories()
	if not self.hasCategories then
		-- No categories added, no need to pass them to Category handler so,
		-- if it was invoked, it would return the empty string.
		-- So we shortcut and return the empty string.
		return ""
	end
	-- Convert category tables to strings and pass them through
	-- [[Module:Category handler]].
	return require('Module:Category handler')._main{
		main = table.concat(self.categories[0] or {}),
		template = table.concat(self.categories[10] or {}),
		all = table.concat(self.categories.all or {}),
		nocat = self.args.nocat,
		page = self.args.page
	}
end

function MessageBox:export()
	local root = mw.html.create()

	-- Add the subst check error.
	if self.isSubstituted and self.name then
		root:tag('b')
			:addClass('error')
			:wikitext(string.format(
				'Template &lt;code&gt;%s[[Template:%s|%s]]%s&lt;/code&gt; has been incorrectly substituted.',
				mw.text.nowiki('{{'), self.name, self.name, mw.text.nowiki('}}')
			))
	end

	local frame = mw.getCurrentFrame()
	root:wikitext(frame:extensionTag{
		name = 'templatestyles',
		args = { src = self.base_templatestyles },
	})
	-- Add support for a single custom templatestyles sheet. Undocumented as
	-- need should be limited and many templates using mbox are substed; we
	-- don't want to spread templatestyles sheets around to arbitrary places
	if self.templatestyles then
		root:wikitext(frame:extensionTag{
			name = 'templatestyles',
			args = { src = self.templatestyles },
		})
	end

	-- Create the box table.
	local boxTable = root:tag('table')
	boxTable:attr('id', self.id or nil)
	for i, class in ipairs(self.classes or {}) do
		boxTable:addClass(class or nil)
	end
	boxTable
		:cssText(self.style or nil)
		:attr('role', 'presentation')

	if self.attrs then
		boxTable:attr(self.attrs)
	end

	-- Add the left-hand image.
	local row = boxTable:tag('tr')
	if self.imageLeft then
		local imageLeftCell = row:tag('td'):addClass('mbox-image')
		if self.imageCellDiv then
			-- If we are using a div, redefine imageLeftCell so that the image
			-- is inside it. Divs use style="width: 52px;", which limits the
			-- image width to 52px. If any images in a div are wider than that,
			-- they may overlap with the text or cause other display problems.
			imageLeftCell = imageLeftCell:tag('div'):addClass('mbox-image-div')
		end
		imageLeftCell
			:addClass(self.imageLeftClass)
			:wikitext(self.imageLeft or nil)
	elseif self.imageEmptyCell then
		-- Some message boxes define an empty cell if no image is specified, and
		-- some don't. The old template code in templates where empty cells are
		-- specified gives the following hint: "No image. Cell with some width
		-- or padding necessary for text cell to have 100% width."
		row:tag('td')
			:addClass('mbox-empty-cell')
	end

	-- Add the text.
	local textCell = row:tag('td'):addClass('mbox-text')
	if self.useCollapsibleTextFields then
		-- The message box uses advanced text parameters that allow things to be
		-- collapsible. At the moment, only ambox uses this.
		textCell:cssText(self.textstyle or nil)
		local textCellDiv = textCell:tag('div')
		textCellDiv
			:addClass('mbox-text-span')
			:wikitext(self.issue or nil)
		if (self.talk or self.fix) then
			textCellDiv:tag('span')
				:addClass('hide-when-compact')
				:wikitext(self.talk and (' ' .. self.talk) or nil)
				:wikitext(self.fix and (' ' .. self.fix) or nil)
		end
		textCellDiv:wikitext(self.date and (' ' .. self.date) or nil)
		if self.info and not self.isSmall then
			textCellDiv
				:tag('span')
				:addClass('hide-when-compact')
				:wikitext(self.info and (' ' .. self.info) or nil)
		end
		if self.removalNotice then
			textCellDiv:tag('span')
				:addClass('hide-when-compact')
				:tag('i')
					:wikitext(string.format(" (%s)", self.removalNotice))
		end
	else
		-- Default text formatting - anything goes.
		textCell
			:cssText(self.textstyle or nil)
			:wikitext(self.text or nil)
	end

	-- Add the right-hand image.
	if self.imageRight then
		local imageRightCell = row:tag('td'):addClass('mbox-imageright')
		if self.imageCellDiv then
			-- If we are using a div, redefine imageRightCell so that the image
			-- is inside it.
			imageRightCell = imageRightCell:tag('div'):addClass('mbox-image-div')
		end
		imageRightCell
			:addClass(self.imageRightClass)
			:wikitext(self.imageRight or nil)
	end

	-- Add the below row.
	if self.below then
		boxTable:tag('tr')
			:tag('td')
				:attr('colspan', self.imageRight and '3' or '2')
				:addClass('mbox-text')
				:cssText(self.textstyle or nil)
				:wikitext(self.below or nil)
	end

	-- Add error message for invalid type parameters.
	if self.invalidTypeError then
		root:tag('div')
			:addClass('mbox-invalid-type')
			:wikitext(string.format(
				'This message box is using an invalid "type=%s" parameter and needs fixing.',
				self.type or ''
			))
	end

	-- Add categories.
	root:wikitext(self:renderCategories() or nil)

	return tostring(root)
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p, mt = {}, {}

function p._exportClasses()
	-- For testing.
	return {
		MessageBox = MessageBox
	}
end

function p.main(boxType, args, cfgTables)
	local box = MessageBox.new(boxType, args, cfgTables or mw.loadData(CONFIG_MODULE))
	box:setParameters()
	box:setCategories()
	return box:export()
end

function mt.__index(t, k)
	return function (frame)
		if not getArgs then
			getArgs = require('Module:Arguments').getArgs
		end
		return t.main(k, getArgs(frame, {trim = false, removeBlanks = false}))
	end
end

return setmetatable(p, mt)</text>
      <sha1>qjedtq8k5rp7pkaeftelylik87u0bva</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Message box/configuration</title>
    <ns>828</ns>
    <id>20</id>
    <revision>
      <id>28</id>
      <parentid>27</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>27</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6546" sha1="8mlkapzjzi4hir1wgp29qb7kqksdzd4" xml:space="preserve">--------------------------------------------------------------------------------
--                          Message box configuration                         --
--                                                                            --
-- This module contains configuration data for [[Module:Message box]].        --
--------------------------------------------------------------------------------

return {
	ambox = {
		types = {
			speedy = {
				class = 'ambox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'ambox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'ambox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'ambox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'ambox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'ambox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			notice = {
				class = 'ambox-notice',
				image = 'Information icon4.svg'
			}
		},
		default                     = 'notice',
		allowBlankParams            = {'talk', 'sect', 'date', 'issue', 'fix', 'subst', 'hidden'},
		allowSmall                  = true,
		smallParam                  = 'left',
		smallClass                  = 'mbox-small-left',
		substCheck                  = true,
		classes                     = {'metadata', 'ambox'},
		imageEmptyCell              = true,
		imageCheckBlank             = true,
		imageSmallSize              = '20x20px',
		imageCellDiv                = true,
		useCollapsibleTextFields    = true,
		imageRightNone              = true,
		sectionDefault              = 'article',
		allowMainspaceCategories    = true,
		templateCategory            = 'Article message templates',
	        templateCategoryRequireName = true,
		templateErrorCategory       = 'Article message templates with missing parameters',
		templateErrorParamsToCheck  = {'issue', 'fix', 'subst'},
		removalNotice               = '&lt;small&gt;[[Help:Maintenance template removal|Learn how and when to remove this message]]&lt;/small&gt;',
		templatestyles              = 'Module:Message box/ambox.css'
	},
	
	cmbox = {
		types = {
			speedy = {
				class = 'cmbox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'cmbox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'cmbox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'cmbox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'cmbox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'cmbox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			notice = {
				class = 'cmbox-notice',
				image = 'Information icon4.svg'
			}
		},
		default              = 'notice',
		showInvalidTypeError = true,
		classes              = {'cmbox'},
		imageEmptyCell       = true,
		templatestyles       = 'Module:Message box/cmbox.css'
	},
	
	fmbox = {
		types = {
			warning = {
				class = 'fmbox-warning',
				image = 'Ambox warning pn.svg'
			},
			editnotice = {
				class = 'fmbox-editnotice',
				image = 'Information icon4.svg'
			},
			system = {
				class = 'fmbox-system',
				image = 'Information icon4.svg'
			}
		},
		default              = 'system',
		showInvalidTypeError = true,
		classes              = {'fmbox'},
		imageEmptyCell       = false,
		imageRightNone       = false,
		templatestyles       = 'Module:Message box/fmbox.css'
	},
	
	imbox = {
		types = {
			speedy = {
				class = 'imbox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'imbox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'imbox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'imbox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'imbox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'imbox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			license = {
				class = 'imbox-license licensetpl',
				image = 'Imbox-license.svg'
			},
			["license-related"] = {
				class = 'imbox-license',
				image = 'Imbox-license.svg'
			},
			featured = {
				class = 'imbox-featured',
				image = 'Cscr-featured.svg',
				imageNeedsLink = true
			},
			notice = {
				class = 'imbox-notice',
				image = 'Information icon4.svg'
			}
		},
		default              = 'notice',
		showInvalidTypeError = true,
		classes              = {'imbox'},
		imageEmptyCell       = true,
		below                = true,
		templateCategory     = 'File message boxes',
		templatestyles       = 'Module:Message box/imbox.css'
	},
	
	ombox = {
		types = {
			speedy = {
				class = 'ombox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'ombox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'ombox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'ombox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'ombox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'ombox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			notice = {
				class = 'ombox-notice',
				image = 'Information icon4.svg'
			}
		},
		default              = 'notice',
		showInvalidTypeError = true,
		classes              = {'ombox'},
		allowSmall           = true,
		imageEmptyCell       = true,
		imageRightNone       = true,
		templatestyles       = 'Module:Message box/ombox.css'
	},
	
	tmbox = {
		types = {
			speedy = {
				class = 'tmbox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'tmbox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'tmbox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'tmbox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'tmbox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'tmbox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			notice = {
				class = 'tmbox-notice',
				image = 'Information icon4.svg'
			}
		},
		default              = 'notice',
		showInvalidTypeError = true,
		classes              = {'tmbox'},
		allowSmall           = true,
		imageRightNone       = true,
		imageEmptyCell       = true,
		templateCategory     = 'Talk message boxes',
		templatestyles       = 'Module:Message box/tmbox.css'
	}
}</text>
      <sha1>8mlkapzjzi4hir1wgp29qb7kqksdzd4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Redirect</title>
    <ns>828</ns>
    <id>21</id>
    <revision>
      <id>30</id>
      <parentid>29</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>29</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3295" sha1="ixuh7hehfu8mxwx3ai7pksok45inaxs" xml:space="preserve">-- This module provides functions for getting the target of a redirect page.

local p = {}

-- Gets a mw.title object, using pcall to avoid generating script errors if we
-- are over the expensive function count limit (among other possible causes).
local function getTitle(...)
	local success, titleObj = pcall(mw.title.new, ...)
	if success then
		return titleObj
	else
		return nil
	end
end

-- Gets the name of a page that a redirect leads to, or nil if it isn't a
-- redirect.
function p.getTargetFromText(text)
	local target = string.match(
		text,
		"^%s*#[Rr][Ee][Dd][Ii][Rr][Ee][Cc][Tt]%s*:?%s*%[%[([^%[%]|]-)%]%]"
	) or string.match(
		text,
		"^%s*#[Rr][Ee][Dd][Ii][Rr][Ee][Cc][Tt]%s*:?%s*%[%[([^%[%]|]-)|[^%[%]]-%]%]"
	)
	return target and mw.uri.decode(target, 'PATH')
end

-- Gets the target of a redirect. If the page specified is not a redirect,
-- returns nil.
function p.getTarget(page, fulltext)
	-- Get the title object. Both page names and title objects are allowed
	-- as input.
	local titleObj
	if type(page) == 'string' or type(page) == 'number' then
		titleObj = getTitle(page)
	elseif type(page) == 'table' and type(page.getContent) == 'function' then
		titleObj = page
	else
		error(string.format(
			"bad argument #1 to 'getTarget'"
				.. " (string, number, or title object expected, got %s)",
			type(page)
		), 2)
	end
	if not titleObj then
		return nil
	end
	local targetTitle = titleObj.redirectTarget
	if targetTitle then
		if fulltext then
			return targetTitle.fullText
		else
			return targetTitle.prefixedText
		end
	else
		return nil
	end
end

--[[
-- Given a single page name determines what page it redirects to and returns the
-- target page name, or the passed page name when not a redirect. The passed
-- page name can be given as plain text or as a page link.
--
-- Returns page name as plain text, or when the bracket parameter is given, as a
-- page link. Returns an error message when page does not exist or the redirect
-- target cannot be determined for some reason.
--]]
function p.luaMain(rname, bracket, fulltext)
	if type(rname) ~= "string" or not rname:find("%S") then
		return nil
	end
	bracket = bracket and "[[%s]]" or "%s"
	rname = rname:match("%[%[(.+)%]%]") or rname
	local target = p.getTarget(rname, fulltext)
	local ret = target or rname
	ret = getTitle(ret)
	if ret then
		if fulltext then
			ret = ret.fullText
		else
			ret = ret.prefixedText
		end
		return bracket:format(ret)
	else
		return nil
	end
end

-- Provides access to the luaMain function from wikitext.
function p.main(frame)
	local args = require('Module:Arguments').getArgs(frame, {frameOnly = true})
	return p.luaMain(args[1], args.bracket, args.fulltext) or ''
end

-- Returns true if the specified page is a redirect, and false otherwise.
function p.luaIsRedirect(page)
	local titleObj = getTitle(page)
	if not titleObj then
		return false
	end
	if titleObj.isRedirect then
		return true
	else
		return false
	end
end

-- Provides access to the luaIsRedirect function from wikitext, returning 'yes'
-- if the specified page is a redirect, and the blank string otherwise.
function p.isRedirect(frame)
	local args = require('Module:Arguments').getArgs(frame, {frameOnly = true})
	if p.luaIsRedirect(args[1]) then
		return 'yes'
	else
		return ''
	end
end

return p</text>
      <sha1>ixuh7hehfu8mxwx3ai7pksok45inaxs</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ifsubst</title>
    <ns>10</ns>
    <id>22</id>
    <revision>
      <id>32</id>
      <parentid>31</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>31</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="302" sha1="6n9xrkgwrhqddknwc59l4tya8074m0o" xml:space="preserve">{{ safesubst:&lt;noinclude/&gt;#if:{{{demo|}}}
|{{ safesubst:&lt;noinclude/&gt;#ifeq:{{{demo}}} |no
 |{{{no|{{{2|}}}}}}
 |{{{yes|{{{1|}}}}}}
}}
|{{ safesubst:&lt;noinclude/&gt;#ifeq:{{ safesubst:&lt;noinclude/&gt;NAMESPACE}}|{{NAMESPACE}}
 |{{{no|{{{2|}}}}}}
 |{{{yes|{{{1|}}}}}}
}}}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>6n9xrkgwrhqddknwc59l4tya8074m0o</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1</title>
    <ns>828</ns>
    <id>23</id>
    <revision>
      <id>34</id>
      <parentid>33</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>33</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="232143" sha1="swdh50lofyqq0wmp3o2c259fg8s2nxi" xml:space="preserve">require ('strict');

--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------

each of these counts against the Lua upvalue limit

]]

local validation;																-- functions in Module:Citation/CS1/Date_validation

local utilities;																-- functions in Module:Citation/CS1/Utilities
local z = {};																	-- table of tables in Module:Citation/CS1/Utilities

local identifiers;																-- functions and tables in Module:Citation/CS1/Identifiers
local metadata;																	-- functions in Module:Citation/CS1/COinS
local cfg = {};																	-- table of configuration tables that are defined in Module:Citation/CS1/Configuration
local whitelist = {};															-- table of tables listing valid template parameter names; defined in Module:Citation/CS1/Whitelist


--[[------------------&lt; P A G E   S C O P E   V A R I A B L E S &gt;---------------

declare variables here that have page-wide scope that are not brought in from
other modules; that are created here and used here

]]

local added_deprecated_cat;														-- Boolean flag so that the category is added only once
local added_vanc_errs;															-- Boolean flag so we only emit one Vancouver error / category
local added_generic_name_errs;													-- Boolean flag so we only emit one generic name error / category and stop testing names once an error is encountered
local added_numeric_name_errs;													-- Boolean flag so we only emit one numeric name error / category and stop testing names once an error is encountered
local added_numeric_name_maint;													-- Boolean flag so we only emit one numeric name maint category and stop testing names once a category has been emitted
local is_preview_mode;															-- true when article is in preview mode; false when using 'Preview page with this template' (previewing the module)
local is_sandbox;																-- true when using sandbox modules to render citation


--[[--------------------------&lt; F I R S T _ S E T &gt;------------------------------------------------------------

Locates and returns the first set value in a table of values where the order established in the table,
left-to-right (or top-to-bottom), is the order in which the values are evaluated.  Returns nil if none are set.

This version replaces the original 'for _, val in pairs do' and a similar version that used ipairs.  With the pairs
version the order of evaluation could not be guaranteed.  With the ipairs version, a nil value would terminate
the for-loop before it reached the actual end of the list.

]]

local function first_set (list, count)
	local i = 1;
	while i &lt;= count do															-- loop through all items in list
		if utilities.is_set( list[i] ) then
			return list[i];														-- return the first set list member
		end
		i = i + 1;																-- point to next
	end
end


--[[--------------------------&lt; A D D _ V A N C _ E R R O R &gt;----------------------------------------------------

Adds a single Vancouver system error message to the template's output regardless of how many error actually exist.
To prevent duplication, added_vanc_errs is nil until an error message is emitted.

added_vanc_errs is a Boolean declared in page scope variables above

]]

local function add_vanc_error (source, position)
	if added_vanc_errs then return end
		
	added_vanc_errs = true;														-- note that we've added this category
	utilities.set_message ('err_vancouver', {source, position});
end


--[[--------------------------&lt; I S _ S C H E M E &gt;------------------------------------------------------------

does this thing that purports to be a URI scheme seem to be a valid scheme?  The scheme is checked to see if it
is in agreement with http://tools.ietf.org/html/std66#section-3.1 which says:
	Scheme names consist of a sequence of characters beginning with a
   letter and followed by any combination of letters, digits, plus
   ("+"), period ("."), or hyphen ("-").

returns true if it does, else false

]]

local function is_scheme (scheme)
	return scheme and scheme:match ('^%a[%a%d%+%.%-]*:');						-- true if scheme is set and matches the pattern
end


--[=[-------------------------&lt; I S _ D O M A I N _ N A M E &gt;--------------------------------------------------

Does this thing that purports to be a domain name seem to be a valid domain name?

Syntax defined here: http://tools.ietf.org/html/rfc1034#section-3.5
BNF defined here: https://tools.ietf.org/html/rfc4234
Single character names are generally reserved; see https://tools.ietf.org/html/draft-ietf-dnsind-iana-dns-01#page-15;
	see also [[Single-letter second-level domain]]
list of TLDs: https://www.iana.org/domains/root/db

RFC 952 (modified by RFC 1123) requires the first and last character of a hostname to be a letter or a digit.  Between
the first and last characters the name may use letters, digits, and the hyphen.

Also allowed are IPv4 addresses. IPv6 not supported

domain is expected to be stripped of any path so that the last character in the last character of the TLD.  tld
is two or more alpha characters.  Any preceding '//' (from splitting a URL with a scheme) will be stripped
here.  Perhaps not necessary but retained in case it is necessary for IPv4 dot decimal.

There are several tests:
	the first character of the whole domain name including subdomains must be a letter or a digit
	internationalized domain name (ASCII characters with .xn-- ASCII Compatible Encoding (ACE) prefix xn-- in the TLD) see https://tools.ietf.org/html/rfc3490
	single-letter/digit second-level domains in the .org, .cash, and .today TLDs
	q, x, and z SL domains in the .com TLD
	i and q SL domains in the .net TLD
	single-letter SL domains in the ccTLDs (where the ccTLD is two letters)
	two-character SL domains in gTLDs (where the gTLD is two or more letters)
	three-plus-character SL domains in gTLDs (where the gTLD is two or more letters)
	IPv4 dot-decimal address format; TLD not allowed

returns true if domain appears to be a proper name and TLD or IPv4 address, else false

]=]

local function is_domain_name (domain)
	if not domain then
		return false;															-- if not set, abandon
	end
	
	domain = domain:gsub ('^//', '');											-- strip '//' from domain name if present; done here so we only have to do it once
	
	if not domain:match ('^[%w]') then											-- first character must be letter or digit
		return false;
	end

	if domain:match ('^%a+:') then												-- hack to detect things that look like s:Page:Title where Page: is namespace at Wikisource
		return false;
	end

	local patterns = {															-- patterns that look like URLs
		'%f[%w][%w][%w%-]+[%w]%.%a%a+$',										-- three or more character hostname.hostname or hostname.tld
		'%f[%w][%w][%w%-]+[%w]%.xn%-%-[%w]+$',									-- internationalized domain name with ACE prefix
		'%f[%a][qxz]%.com$',													-- assigned one character .com hostname (x.com times out 2015-12-10)
		'%f[%a][iq]%.net$',														-- assigned one character .net hostname (q.net registered but not active 2015-12-10)
		'%f[%w][%w]%.%a%a$',													-- one character hostname and ccTLD (2 chars)
		'%f[%w][%w][%w]%.%a%a+$',												-- two character hostname and TLD
		'^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?',								-- IPv4 address
		'[%a%d]+%:?'                                                            -- IPv6 address
		}

	for _, pattern in ipairs (patterns) do										-- loop through the patterns list
		if domain:match (pattern) then
			return true;														-- if a match then we think that this thing that purports to be a URL is a URL
		end
	end

	for _, d in ipairs (cfg.single_letter_2nd_lvl_domains_t) do					-- look for single letter second level domain names for these top level domains
		if domain:match ('%f[%w][%w]%.' .. d) then
			return true
		end
	end
	return false;																-- no matches, we don't know what this thing is
end


--[[--------------------------&lt; I S _ U R L &gt;------------------------------------------------------------------

returns true if the scheme and domain parts of a URL appear to be a valid URL; else false.

This function is the last step in the validation process.  This function is separate because there are cases that
are not covered by split_url(), for example is_parameter_ext_wikilink() which is looking for bracketted external
wikilinks.

]]

local function is_url (scheme, domain)
	if utilities.is_set (scheme) then											-- if scheme is set check it and domain
		return is_scheme (scheme) and is_domain_name (domain);
	else
		return is_domain_name (domain);											-- scheme not set when URL is protocol-relative
	end
end


--[[--------------------------&lt; S P L I T _ U R L &gt;------------------------------------------------------------

Split a URL into a scheme, authority indicator, and domain.

First remove Fully Qualified Domain Name terminator (a dot following TLD) (if any) and any path(/), query(?) or fragment(#).

If protocol-relative URL, return nil scheme and domain else return nil for both scheme and domain.

When not protocol-relative, get scheme, authority indicator, and domain.  If there is an authority indicator (one
or more '/' characters immediately following the scheme's colon), make sure that there are only 2.

Any URL that does not have news: scheme must have authority indicator (//).  TODO: are there other common schemes
like news: that don't use authority indicator?

Strip off any port and path;

]]

local function split_url (url_str)
	local scheme, authority, domain;
	
	url_str = url_str:gsub ('([%a%d])%.?[/%?#].*$', '%1');						-- strip FQDN terminator and path(/), query(?), fragment (#) (the capture prevents false replacement of '//')

	if url_str:match ('^//%S*') then											-- if there is what appears to be a protocol-relative URL
		domain = url_str:match ('^//(%S*)')
	elseif url_str:match ('%S-:/*%S+') then										-- if there is what appears to be a scheme, optional authority indicator, and domain name
		scheme, authority, domain = url_str:match ('(%S-:)(/*)(%S+)');			-- extract the scheme, authority indicator, and domain portions
		if utilities.is_set (authority) then
			authority = authority:gsub ('//', '', 1);							-- replace place 1 pair of '/' with nothing;
			if utilities.is_set(authority) then									-- if anything left (1 or 3+ '/' where authority should be) then
				return scheme;													-- return scheme only making domain nil which will cause an error message
			end
		else
			if not scheme:match ('^news:') then									-- except for news:..., MediaWiki won't link URLs that do not have authority indicator; TODO: a better way to do this test?
				return scheme;													-- return scheme only making domain nil which will cause an error message
			end
		end
		domain = domain:gsub ('(%a):%d+', '%1');								-- strip port number if present
	end
	
	return scheme, domain;
end


--[[--------------------------&lt; L I N K _ P A R A M _ O K &gt;---------------------------------------------------

checks the content of |title-link=, |series-link=, |author-link=, etc. for properly formatted content: no wikilinks, no URLs

Link parameters are to hold the title of a Wikipedia article, so none of the WP:TITLESPECIALCHARACTERS are allowed:
	# &lt; &gt; [ ] | { } _
except the underscore which is used as a space in wiki URLs and # which is used for section links

returns false when the value contains any of these characters.

When there are no illegal characters, this function returns TRUE if value DOES NOT appear to be a valid URL (the
|&lt;param&gt;-link= parameter is ok); else false when value appears to be a valid URL (the |&lt;param&gt;-link= parameter is NOT ok).

]]

local function link_param_ok (value)
	local scheme, domain;
	if value:find ('[&lt;&gt;%[%]|{}]') then                                          -- if any prohibited characters
		return false;
	end

	scheme, domain = split_url (value);											-- get scheme or nil and domain or nil from URL; 
	return not is_url (scheme, domain);											-- return true if value DOES NOT appear to be a valid URL
end


--[[--------------------------&lt; L I N K _ T I T L E _ O K &gt;---------------------------------------------------

Use link_param_ok() to validate |&lt;param&gt;-link= value and its matching |&lt;title&gt;= value.

|&lt;title&gt;= may be wiki-linked but not when |&lt;param&gt;-link= has a value.  This function emits an error message when
that condition exists

check &lt;link&gt; for inter-language interwiki-link prefix.  prefix must be a MediaWiki-recognized language
code and must begin with a colon.

]]

local function link_title_ok (link, lorig, title, torig)
	local orig;
	if utilities.is_set (link) then 											-- don't bother if &lt;param&gt;-link doesn't have a value
		if not link_param_ok (link) then										-- check |&lt;param&gt;-link= markup
			orig = lorig;														-- identify the failing link parameter
		elseif title:find ('%[%[') then											-- check |title= for wikilink markup
			orig = torig;														-- identify the failing |title= parameter
		elseif link:match ('^%a+:') then										-- if the link is what looks like an interwiki
			local prefix = link:match ('^(%a+):'):lower();						-- get the interwiki prefix

			if cfg.inter_wiki_map[prefix] then									-- if prefix is in the map, must have preceding colon
				orig = lorig;													-- flag as error
			end
		end
	end

	if utilities.is_set (orig) then
		link = '';																-- unset
		utilities.set_message ('err_bad_paramlink', orig);						-- URL or wikilink in |title= with |title-link=;
	end
	
	return link;																-- link if ok, empty string else
end


--[[--------------------------&lt; C H E C K _ U R L &gt;------------------------------------------------------------

Determines whether a URL string appears to be valid.

First we test for space characters.  If any are found, return false.  Then split the URL into scheme and domain
portions, or for protocol-relative (//example.com) URLs, just the domain.  Use is_url() to validate the two
portions of the URL.  If both are valid, or for protocol-relative if domain is valid, return true, else false.

Because it is different from a standard URL, and because this module used external_link() to make external links
that work for standard and news: links, we validate newsgroup names here.  The specification for a newsgroup name
is at https://tools.ietf.org/html/rfc5536#section-3.1.4

]]

local function check_url( url_str )
	if nil == url_str:match ("^%S+$") then										-- if there are any spaces in |url=value it can't be a proper URL
		return false;
	end
	local scheme, domain;

	scheme, domain = split_url (url_str);										-- get scheme or nil and domain or nil from URL;
	
	if 'news:' == scheme then													-- special case for newsgroups
		return domain:match('^[%a%d%+%-_]+%.[%a%d%+%-_%.]*[%a%d%+%-_]$');
	end
	
	return is_url (scheme, domain);												-- return true if value appears to be a valid URL
end


--[=[-------------------------&lt; I S _ P A R A M E T E R _ E X T _ W I K I L I N K &gt;----------------------------

Return true if a parameter value has a string that begins and ends with square brackets [ and ] and the first
non-space characters following the opening bracket appear to be a URL.  The test will also find external wikilinks
that use protocol-relative URLs. Also finds bare URLs.

The frontier pattern prevents a match on interwiki-links which are similar to scheme:path URLs.  The tests that
find bracketed URLs are required because the parameters that call this test (currently |title=, |chapter=, |work=,
and |publisher=) may have wikilinks and there are articles or redirects like '//Hus' so, while uncommon, |title=[[//Hus]]
is possible as might be [[en://Hus]].

]=]

local function is_parameter_ext_wikilink (value)
local scheme, domain;

	if value:match ('%f[%[]%[%a%S*:%S+.*%]') then								-- if ext. wikilink with scheme and domain: [xxxx://yyyyy.zzz]
		scheme, domain = split_url (value:match ('%f[%[]%[(%a%S*:%S+).*%]'));
	elseif value:match ('%f[%[]%[//%S+.*%]') then								-- if protocol-relative ext. wikilink: [//yyyyy.zzz]
		scheme, domain = split_url (value:match ('%f[%[]%[(//%S+).*%]'));
	elseif value:match ('%a%S*:%S+') then										-- if bare URL with scheme; may have leading or trailing plain text
		scheme, domain = split_url (value:match ('(%a%S*:%S+)'));
	elseif value:match ('^//%S+') or value:match ('%s//%S+') then				-- if protocol-relative bare URL: //yyyyy.zzz; authority indicator (//) must be be preceded nothing or by whitespace
		scheme, domain = split_url (value:match ('(//%S+)'));					-- what is left should be the domain
	else
		return false;															-- didn't find anything that is obviously a URL
	end

	return is_url (scheme, domain);												-- return true if value appears to be a valid URL
end


--[[-------------------------&lt; C H E C K _ F O R _ U R L &gt;-----------------------------------------------------

loop through a list of parameters and their values.  Look at the value and if it has an external link, emit an error message.

]]

local function check_for_url (parameter_list, error_list)
	for k, v in pairs (parameter_list) do										-- for each parameter in the list
		if is_parameter_ext_wikilink (v) then									-- look at the value; if there is a URL add an error message
			table.insert (error_list, utilities.wrap_style ('parameter', k));
		end
	end
end


--[[--------------------------&lt; S A F E _ F O R _ U R L &gt;------------------------------------------------------

Escape sequences for content that will be used for URL descriptions

]]

local function safe_for_url( str )
	if str:match( "%[%[.-%]%]" ) ~= nil then 
		utilities.set_message ('err_wikilink_in_url', {});
	end
	
	return str:gsub( '[%[%]\n]', {	
		['['] = '&amp;#91;',
		[']'] = '&amp;#93;',
		['\n'] = ' ' } );
end


--[[--------------------------&lt; E X T E R N A L _ L I N K &gt;----------------------------------------------------

Format an external link with error checking

]]

local function external_link (URL, label, source, access)
	local err_msg = '';
	local domain;
	local path;
	local base_url;

	if not utilities.is_set (label) then
		label = URL;
		if utilities.is_set (source) then
			utilities.set_message ('err_bare_url_missing_title', {utilities.wrap_style ('parameter', source)});
		else
			error (cfg.messages["bare_url_no_origin"]);							-- programmer error; valid parameter name does not have matching meta-parameter
		end			
	end
	if not check_url (URL) then
		utilities.set_message ('err_bad_url', {utilities.wrap_style ('parameter', source)});
	end
	
	domain, path = URL:match ('^([/%.%-%+:%a%d]+)([/%?#].*)$');					-- split the URL into scheme plus domain and path
	if path then																-- if there is a path portion
		path = path:gsub ('[%[%]]', {['['] = '%5b', [']'] = '%5d'});			-- replace '[' and ']' with their percent-encoded values
		URL = table.concat ({domain, path});									-- and reassemble
	end

	base_url = table.concat ({ "[", URL, " ", safe_for_url (label), "]" });		-- assemble a wiki-markup URL

	if utilities.is_set (access) then											-- access level (subscription, registration, limited)
		base_url = utilities.substitute (cfg.presentation['ext-link-access-signal'], {cfg.presentation[access].class, cfg.presentation[access].title, base_url});	-- add the appropriate icon
	end

	return base_url;
end


--[[--------------------------&lt; D E P R E C A T E D _ P A R A M E T E R &gt;--------------------------------------

Categorize and emit an error message when the citation contains one or more deprecated parameters.  The function includes the
offending parameter name to the error message.  Only one error message is emitted regardless of the number of deprecated
parameters in the citation.

added_deprecated_cat is a Boolean declared in page scope variables above

]]

local function deprecated_parameter(name)
	if not added_deprecated_cat then
		added_deprecated_cat = true;											-- note that we've added this category
		utilities.set_message ('err_deprecated_params', {name});				-- add error message
	end
end


--[=[-------------------------&lt; K E R N _ Q U O T E S &gt;--------------------------------------------------------

Apply kerning to open the space between the quote mark provided by the module and a leading or trailing quote
mark contained in a |title= or |chapter= parameter's value.

This function will positive kern either single or double quotes:
	"'Unkerned title with leading and trailing single quote marks'"
	" 'Kerned title with leading and trailing single quote marks' " (in real life the kerning isn't as wide as this example)
Double single quotes (italic or bold wiki-markup) are not kerned.

Replaces Unicode quote marks in plain text or in the label portion of a [[L|D]] style wikilink with typewriter
quote marks regardless of the need for kerning.  Unicode quote marks are not replaced in simple [[D]] wikilinks.

Call this function for chapter titles, for website titles, etc.; not for book titles.

]=]

local function kern_quotes (str)
	local cap = '';
	local wl_type, label, link;

	wl_type, label, link = utilities.is_wikilink (str);							-- wl_type is: 0, no wl (text in label variable); 1, [[D]]; 2, [[L|D]]
	
	if 1 == wl_type then														-- [[D]] simple wikilink with or without quote marks
		if mw.ustring.match (str, '%[%[[\"“”\'‘’].+[\"“”\'‘’]%]%]') then		-- leading and trailing quote marks
			str = utilities.substitute (cfg.presentation['kern-left'], str);
			str = utilities.substitute (cfg.presentation['kern-right'], str);
		elseif mw.ustring.match (str, '%[%[[\"“”\'‘’].+%]%]')	then			-- leading quote marks
			str = utilities.substitute (cfg.presentation['kern-left'], str);
		elseif mw.ustring.match (str, '%[%[.+[\"“”\'‘’]%]%]') then				-- trailing quote marks
			str = utilities.substitute (cfg.presentation['kern-right'], str);
		end

	else																		-- plain text or [[L|D]]; text in label variable
		label = mw.ustring.gsub (label, '[“”]', '\"');							-- replace “” (U+201C &amp; U+201D) with " (typewriter double quote mark)
		label = mw.ustring.gsub (label, '[‘’]', '\'');							-- replace ‘’ (U+2018 &amp; U+2019) with ' (typewriter single quote mark)

		cap = mw.ustring.match (label, "^([\"\'][^\'].+)");						-- match leading double or single quote but not doubled single quotes (italic markup)
		if utilities.is_set (cap) then
			label = utilities.substitute (cfg.presentation['kern-left'], cap);
		end
	
		cap = mw.ustring.match (label, "^(.+[^\'][\"\'])$")						-- match trailing double or single quote but not doubled single quotes (italic markup)
		if utilities.is_set (cap) then
			label = utilities.substitute (cfg.presentation['kern-right'], cap);
		end
		
		if 2 == wl_type then
			str = utilities.make_wikilink (link, label);						-- reassemble the wikilink
		else
			str = label;
		end
	end
	return str;
end


--[[--------------------------&lt; F O R M A T _ S C R I P T _ V A L U E &gt;----------------------------------------

|script-title= holds title parameters that are not written in Latin-based scripts: Chinese, Japanese, Arabic, Hebrew, etc. These scripts should
not be italicized and may be written right-to-left.  The value supplied by |script-title= is concatenated onto Title after Title has been wrapped
in italic markup.

Regardless of language, all values provided by |script-title= are wrapped in &lt;bdi&gt;...&lt;/bdi&gt; tags to isolate RTL languages from the English left to right.

|script-title= provides a unique feature.  The value in |script-title= may be prefixed with a two-character ISO 639-1 language code and a colon:
	|script-title=ja:*** *** (where * represents a Japanese character)
Spaces between the two-character code and the colon and the colon and the first script character are allowed:
	|script-title=ja : *** ***
	|script-title=ja: *** ***
	|script-title=ja :*** ***
Spaces preceding the prefix are allowed: |script-title = ja:*** ***

The prefix is checked for validity.  If it is a valid ISO 639-1 language code, the lang attribute (lang="ja") is added to the &lt;bdi&gt; tag so that browsers can
know the language the tag contains.  This may help the browser render the script more correctly.  If the prefix is invalid, the lang attribute
is not added.  At this time there is no error message for this condition.

Supports |script-title=, |script-chapter=, |script-&lt;periodical&gt;=

]]

local function format_script_value (script_value, script_param)
	local lang='';																-- initialize to empty string
	local name;
	if script_value:match('^%l%l%l?%s*:') then									-- if first 3 or 4 non-space characters are script language prefix
		lang = script_value:match('^(%l%l%l?)%s*:%s*%S.*');						-- get the language prefix or nil if there is no script
		if not utilities.is_set (lang) then
			utilities.set_message ('err_script_parameter', {script_param, cfg.err_msg_supl['missing title part']});		-- prefix without 'title'; add error message
			return '';															-- script_value was just the prefix so return empty string
		end
																				-- if we get this far we have prefix and script
		name = cfg.lang_tag_remap[lang] or mw.language.fetchLanguageName( lang, cfg.this_wiki_code );	-- get language name so that we can use it to categorize
		if utilities.is_set (name) then											-- is prefix a proper ISO 639-1 language code?
			script_value = script_value:gsub ('^%l+%s*:%s*', '');				-- strip prefix from script
																				-- is prefix one of these language codes?
			if utilities.in_array (lang, cfg.script_lang_codes) then
				utilities.add_prop_cat ('script', {name, lang})
			else
				utilities.set_message ('err_script_parameter', {script_param, cfg.err_msg_supl['unknown language code']});	-- unknown script-language; add error message
			end
			lang = ' lang="' .. lang .. '" ';									-- convert prefix into a lang attribute
		else
			utilities.set_message ('err_script_parameter', {script_param, cfg.err_msg_supl['invalid language code']});		-- invalid language code; add error message
			lang = '';															-- invalid so set lang to empty string
		end
	else
		utilities.set_message ('err_script_parameter', {script_param, cfg.err_msg_supl['missing prefix']});				-- no language code prefix; add error message
	end
	script_value = utilities.substitute (cfg.presentation['bdi'], {lang, script_value});	-- isolate in case script is RTL

	return script_value;
end


--[[--------------------------&lt; S C R I P T _ C O N C A T E N A T E &gt;------------------------------------------

Initially for |title= and |script-title=, this function concatenates those two parameter values after the script
value has been wrapped in &lt;bdi&gt; tags.

]]

local function script_concatenate (title, script, script_param)
	if utilities.is_set (script) then
		script = format_script_value (script, script_param);					-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; returns empty string on error
		if utilities.is_set (script) then
			title = title .. ' ' .. script;										-- concatenate title and script title
		end
	end
	return title;
end


--[[--------------------------&lt; W R A P _ M S G &gt;--------------------------------------------------------------

Applies additional message text to various parameter values. Supplied string is wrapped using a message_list
configuration taking one argument.  Supports lower case text for {{citation}} templates.  Additional text taken
from citation_config.messages - the reason this function is similar to but separate from wrap_style().

]]

local function wrap_msg (key, str, lower)
	if not utilities.is_set ( str ) then
		return "";
	end
	if true == lower then
		local msg;
		msg = cfg.messages[key]:lower();										-- set the message to lower case before 
		return utilities.substitute ( msg, str );								-- including template text
	else
		return utilities.substitute ( cfg.messages[key], str );
	end		
end


--[[----------------&lt; W I K I S O U R C E _ U R L _ M A K E &gt;-------------------

Makes a Wikisource URL from Wikisource interwiki-link.  Returns the URL and appropriate
label; nil else.

str is the value assigned to |chapter= (or aliases) or |title= or |title-link=

]]

local function wikisource_url_make (str)
	local wl_type, D, L;
	local ws_url, ws_label;
	local wikisource_prefix = table.concat ({'https://', cfg.this_wiki_code, '.wikisource.org/wiki/'});

	wl_type, D, L = utilities.is_wikilink (str);								-- wl_type is 0 (not a wikilink), 1 (simple wikilink), 2 (complex wikilink)

	if 0 == wl_type then														-- not a wikilink; might be from |title-link=
		str = D:match ('^[Ww]ikisource:(.+)') or D:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if utilities.is_set (str) then
			ws_url = table.concat ({											-- build a Wikisource URL
				wikisource_prefix,												-- prefix
				str,															-- article title
				});
			ws_label = str;														-- label for the URL
		end
	elseif 1 == wl_type then													-- simple wikilink: [[Wikisource:ws article]]
		str = D:match ('^[Ww]ikisource:(.+)') or D:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if utilities.is_set (str) then
			ws_url = table.concat ({											-- build a Wikisource URL
				wikisource_prefix,												-- prefix
				str,															-- article title
				});
			ws_label = str;														-- label for the URL
		end
	elseif 2 == wl_type then													-- non-so-simple wikilink: [[Wikisource:ws article|displayed text]] ([[L|D]])
		str = L:match ('^[Ww]ikisource:(.+)') or L:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if utilities.is_set (str) then
			ws_label = D;														-- get ws article name from display portion of interwiki link
			ws_url = table.concat ({											-- build a Wikisource URL
				wikisource_prefix,												-- prefix
				str,															-- article title without namespace from link portion of wikilink
				});
		end
	end

	if ws_url then
		ws_url = mw.uri.encode (ws_url, 'WIKI');								-- make a usable URL
		ws_url = ws_url:gsub ('%%23', '#');										-- undo percent-encoding of fragment marker
	end

	return ws_url, ws_label, L or D;											-- return proper URL or nil and a label or nil
end


--[[----------------&lt; F O R M A T _ P E R I O D I C A L &gt;-----------------------

Format the three periodical parameters: |script-&lt;periodical&gt;=, |&lt;periodical&gt;=,
and |trans-&lt;periodical&gt;= into a single Periodical meta-parameter.

]]

local function format_periodical (script_periodical, script_periodical_source, periodical, trans_periodical)

	if not utilities.is_set (periodical) then
		periodical = '';														-- to be safe for concatenation
	else
		periodical = utilities.wrap_style ('italic-title', periodical);			-- style 
	end

	periodical = script_concatenate (periodical, script_periodical, script_periodical_source);	-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped

	if utilities.is_set (trans_periodical) then
		trans_periodical = utilities.wrap_style ('trans-italic-title', trans_periodical);
		if utilities.is_set (periodical) then
			periodical = periodical .. ' ' .. trans_periodical;
		else																	-- here when trans-periodical without periodical or script-periodical
			periodical = trans_periodical;
			utilities.set_message ('err_trans_missing_title', {'periodical'});
		end
	end

	return periodical;
end


--[[------------------&lt; F O R M A T _ C H A P T E R _ T I T L E &gt;---------------

Format the four chapter parameters: |script-chapter=, |chapter=, |trans-chapter=,
and |chapter-url= into a single chapter meta- parameter (chapter_url_source used
for error messages).

]]

local function format_chapter_title (script_chapter, script_chapter_source, chapter, chapter_source, trans_chapter, trans_chapter_source, chapter_url, chapter_url_source, no_quotes, access)
	local ws_url, ws_label, L = wikisource_url_make (chapter);					-- make a wikisource URL and label from a wikisource interwiki link
	if ws_url then
		ws_label = ws_label:gsub ('_', ' ');									-- replace underscore separators with space characters
		chapter = ws_label;
	end

	if not utilities.is_set (chapter) then
		chapter = '';															-- to be safe for concatenation
	else
		if false == no_quotes then
			chapter = kern_quotes (chapter);									-- if necessary, separate chapter title's leading and trailing quote marks from module provided quote marks
			chapter = utilities.wrap_style ('quoted-title', chapter);
		end
	end

	chapter = script_concatenate (chapter, script_chapter, script_chapter_source);	-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped

	if utilities.is_set (chapter_url) then
		chapter = external_link (chapter_url, chapter, chapter_url_source, access);	-- adds bare_url_missing_title error if appropriate
	elseif ws_url then
		chapter = external_link (ws_url, chapter .. '&amp;nbsp;', 'ws link in chapter');	-- adds bare_url_missing_title error if appropriate; space char to move icon away from chap text; TODO: better way to do this?
		chapter = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, chapter});				
	end

	if utilities.is_set (trans_chapter) then
		trans_chapter = utilities.wrap_style ('trans-quoted-title', trans_chapter);
		if utilities.is_set (chapter) then
			chapter = chapter .. ' ' .. trans_chapter;
		else																	-- here when trans_chapter without chapter or script-chapter
			chapter = trans_chapter;
			chapter_source = trans_chapter_source:match ('trans%-?(.+)');		-- when no chapter, get matching name from trans-&lt;param&gt;
			utilities.set_message ('err_trans_missing_title', {chapter_source});
		end
	end

	return chapter;
end


--[[----------------&lt; H A S _ I N V I S I B L E _ C H A R S &gt;-------------------

This function searches a parameter's value for non-printable or invisible characters.
The search stops at the first match.

This function will detect the visible replacement character when it is part of the Wikisource.

Detects but ignores nowiki and math stripmarkers.  Also detects other named stripmarkers
(gallery, math, pre, ref) and identifies them with a slightly different error message.
See also coins_cleanup().

Output of this function is an error message that identifies the character or the
Unicode group, or the stripmarker that was detected along with its position (or,
for multi-byte characters, the position of its first byte) in the parameter value.

]]

local function has_invisible_chars (param, v)
	local position = '';														-- position of invisible char or starting position of stripmarker
	local capture;																-- used by stripmarker detection to hold name of the stripmarker
	local stripmarker;															-- boolean set true when a stripmarker is found

	capture = string.match (v, '[%w%p ]*');										-- test for values that are simple ASCII text and bypass other tests if true
	if capture == v then														-- if same there are no Unicode characters
		return;
	end

	for _, invisible_char in ipairs (cfg.invisible_chars) do
		local char_name = invisible_char[1];									-- the character or group name
		local pattern = invisible_char[2];										-- the pattern used to find it
		position, _, capture = mw.ustring.find (v, pattern);					-- see if the parameter value contains characters that match the pattern
		
		if position and (cfg.invisible_defs.zwj == capture) then				-- if we found a zero-width joiner character
			if mw.ustring.find (v, cfg.indic_script) then						-- it's ok if one of the Indic scripts
				position = nil;													-- unset position
			elseif cfg.emoji_t[mw.ustring.codepoint (v, position+1)] then			-- is zwj followed by a character listed in emoji{}?
				position = nil;													-- unset position
			end
		end
		
		if position then
			if 'nowiki' == capture or 'math' == capture or						-- nowiki and math stripmarkers (not an error condition)
				('templatestyles' == capture and utilities.in_array (param, {'id', 'quote'})) then	-- templatestyles stripmarker allowed in these parameters
					stripmarker = true;											-- set a flag
			elseif true == stripmarker and cfg.invisible_defs.del == capture then	-- because stripmakers begin and end with the delete char, assume that we've found one end of a stripmarker
				position = nil;													-- unset
			else
				local err_msg;
				if capture and not (cfg.invisible_defs.del == capture or cfg.invisible_defs.zwj == capture) then
					err_msg = capture .. ' ' .. char_name;
				else
					err_msg = char_name .. ' ' .. 'character';
				end

				utilities.set_message ('err_invisible_char', {err_msg, utilities.wrap_style ('parameter', param), position});	-- add error message
				return;															-- and done with this parameter
			end
		end
	end
end


--[[-------------------&lt; A R G U M E N T _ W R A P P E R &gt;----------------------

Argument wrapper.  This function provides support for argument mapping defined
in the configuration file so that multiple names can be transparently aliased to
single internal variable.

]]

local function argument_wrapper ( args )
	local origin = {};
	
	return setmetatable({
		ORIGIN = function ( self, k )
			local dummy = self[k];												-- force the variable to be loaded.
			return origin[k];
		end
	},
	{
		__index = function ( tbl, k )
			if origin[k] ~= nil then
				return nil;
			end
			
			local args, list, v = args, cfg.aliases[k];
			
			if type( list ) == 'table' then
				v, origin[k] = utilities.select_one ( args, list, 'err_redundant_parameters' );
				if origin[k] == nil then
					origin[k] = '';												-- Empty string, not nil
				end
			elseif list ~= nil then
				v, origin[k] = args[list], list;
			else
				-- maybe let through instead of raising an error?
				-- v, origin[k] = args[k], k;
				error( cfg.messages['unknown_argument_map'] .. ': ' .. k);
			end
			
			-- Empty strings, not nil;
			if v == nil then
				v = '';
				origin[k] = '';
			end
			
			tbl = rawset( tbl, k, v );
			return v;
		end,
	});
end


--[[--------------------------&lt; N O W R A P _ D A T E &gt;-------------------------

When date is YYYY-MM-DD format wrap in nowrap span: &lt;span ...&gt;YYYY-MM-DD&lt;/span&gt;.
When date is DD MMMM YYYY or is MMMM DD, YYYY then wrap in nowrap span:
&lt;span ...&gt;DD MMMM&lt;/span&gt; YYYY or &lt;span ...&gt;MMMM DD,&lt;/span&gt; YYYY

DOES NOT yet support MMMM YYYY or any of the date ranges.

]]

local function nowrap_date (date)
	local cap = '';
	local cap2 = '';

	if date:match("^%d%d%d%d%-%d%d%-%d%d$") then
		date = utilities.substitute (cfg.presentation['nowrap1'], date);
	
	elseif date:match("^%a+%s*%d%d?,%s+%d%d%d%d$") or date:match ("^%d%d?%s*%a+%s+%d%d%d%d$") then
		cap, cap2 = string.match (date, "^(.*)%s+(%d%d%d%d)$");
		date = utilities.substitute (cfg.presentation['nowrap2'], {cap, cap2});
	end
	
	return date;
end


--[[--------------------------&lt; S E T _ T I T L E T Y P E &gt;---------------------

This function sets default title types (equivalent to the citation including
|type=&lt;default value&gt;) for those templates that have defaults. Also handles the
special case where it is desirable to omit the title type from the rendered citation
(|type=none).

]]

local function set_titletype (cite_class, title_type)
	if utilities.is_set (title_type) then
		if 'none' == cfg.keywords_xlate[title_type] then
			title_type = '';													-- if |type=none then type parameter not displayed
		end
		return title_type;														-- if |type= has been set to any other value use that value
	end

	return cfg.title_types [cite_class] or '';									-- set template's default title type; else empty string for concatenation
end


--[[--------------------------&lt; S A F E _ J O I N &gt;-----------------------------

Joins a sequence of strings together while checking for duplicate separation characters.

]]

local function safe_join( tbl, duplicate_char )
	local f = {};																-- create a function table appropriate to type of 'duplicate character'
		if 1 == #duplicate_char then											-- for single byte ASCII characters use the string library functions
			f.gsub = string.gsub
			f.match = string.match
			f.sub = string.sub
		else																	-- for multi-byte characters use the ustring library functions
			f.gsub = mw.ustring.gsub
			f.match = mw.ustring.match
			f.sub = mw.ustring.sub
		end

	local str = '';																-- the output string
	local comp = '';															-- what does 'comp' mean?
	local end_chr = '';
	local trim;
	for _, value in ipairs( tbl ) do
		if value == nil then value = ''; end
		
		if str == '' then														-- if output string is empty
			str = value;														-- assign value to it (first time through the loop)
		elseif value ~= '' then
			if value:sub(1, 1) == '&lt;' then										-- special case of values enclosed in spans and other markup.
				comp = value:gsub( "%b&lt;&gt;", "" );								-- remove HTML markup (&lt;span&gt;string&lt;/span&gt; -&gt; string)
			else
				comp = value;
			end
																				-- typically duplicate_char is sepc
			if f.sub(comp, 1, 1) == duplicate_char then							-- is first character same as duplicate_char? why test first character?
																				--   Because individual string segments often (always?) begin with terminal punct for the
																				--   preceding segment: 'First element' .. 'sepc next element' .. etc.?
				trim = false;
				end_chr = f.sub(str, -1, -1);									-- get the last character of the output string
				-- str = str .. "&lt;HERE(enchr=" .. end_chr .. ")"				-- debug stuff?
				if end_chr == duplicate_char then								-- if same as separator
					str = f.sub(str, 1, -2);									-- remove it
				elseif end_chr == "'" then										-- if it might be wiki-markup
					if f.sub(str, -3, -1) == duplicate_char .. "''" then		-- if last three chars of str are sepc'' 
						str = f.sub(str, 1, -4) .. "''";						-- remove them and add back ''
					elseif  f.sub(str, -5, -1) == duplicate_char .. "]]''" then	-- if last five chars of str are sepc]]'' 
						trim = true;											-- why? why do this and next differently from previous?
					elseif f.sub(str, -4, -1) == duplicate_char .. "]''" then	-- if last four chars of str are sepc]'' 
						trim = true;											-- same question
					end
				elseif end_chr == "]" then										-- if it might be wiki-markup
					if f.sub(str, -3, -1) == duplicate_char .. "]]" then		-- if last three chars of str are sepc]] wikilink 
						trim = true;
					elseif f.sub(str, -3, -1) == duplicate_char .. '"]' then	-- if last three chars of str are sepc"] quoted external link 
						trim = true;
					elseif  f.sub(str, -2, -1) == duplicate_char .. "]" then	-- if last two chars of str are sepc] external link
						trim = true;
					elseif f.sub(str, -4, -1) == duplicate_char .. "'']" then	-- normal case when |url=something &amp; |title=Title.
						trim = true;
					end
				elseif end_chr == " " then										-- if last char of output string is a space
					if f.sub(str, -2, -1) == duplicate_char .. " " then			-- if last two chars of str are &lt;sepc&gt;&lt;space&gt;
						str = f.sub(str, 1, -3);								-- remove them both
					end
				end

				if trim then
					if value ~= comp then 										-- value does not equal comp when value contains HTML markup
						local dup2 = duplicate_char;
						if f.match(dup2, "%A" ) then dup2 = "%" .. dup2; end	-- if duplicate_char not a letter then escape it
						
						value = f.gsub(value, "(%b&lt;&gt;)" .. dup2, "%1", 1 )		-- remove duplicate_char if it follows HTML markup
					else
						value = f.sub(value, 2, -1 );							-- remove duplicate_char when it is first character
					end
				end
			end
			str = str .. value; 												-- add it to the output string
		end
	end
	return str;
end


--[[--------------------------&lt; I S _ S U F F I X &gt;-----------------------------

returns true if suffix is properly formed Jr, Sr, or ordinal in the range 1–9.
Puncutation not allowed.

]]

local function is_suffix (suffix)
	if utilities.in_array (suffix, {'Jr', 'Sr', 'Jnr', 'Snr', '1st', '2nd', '3rd'}) or suffix:match ('^%dth$') then
		return true;
	end
	return false;
end


--[[--------------------&lt; I S _ G O O D _ V A N C _ N A M E &gt;-------------------

For Vancouver style, author/editor names are supposed to be rendered in Latin
(read ASCII) characters.  When a name uses characters that contain diacritical
marks, those characters are to be converted to the corresponding Latin
character. When a name is written using a non-Latin alphabet or logogram, that
name is to be transliterated into Latin characters. The module doesn't do this
so editors may/must.

This test allows |first= and |last= names to contain any of the letters defined
in the four Unicode Latin character sets
	[http://www.unicode.org/charts/PDF/U0000.pdf C0 Controls and Basic Latin] 0041–005A, 0061–007A
	[http://www.unicode.org/charts/PDF/U0080.pdf C1 Controls and Latin-1 Supplement] 00C0–00D6, 00D8–00F6, 00F8–00FF
	[http://www.unicode.org/charts/PDF/U0100.pdf Latin Extended-A] 0100–017F
	[http://www.unicode.org/charts/PDF/U0180.pdf Latin Extended-B] 0180–01BF, 01C4–024F

|lastn= also allowed to contain hyphens, spaces, and apostrophes.
	(http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)
|firstn= also allowed to contain hyphens, spaces, apostrophes, and periods

This original test:
	if nil == mw.ustring.find (last, "^[A-Za-zÀ-ÖØ-öø-ƿǄ-ɏ%-%s%']*$")
	or nil == mw.ustring.find (first, "^[A-Za-zÀ-ÖØ-öø-ƿǄ-ɏ%-%s%'%.]+[2-6%a]*$") then
was written outside of the code editor and pasted here because the code editor
gets confused between character insertion point and cursor position. The test has
been rewritten to use decimal character escape sequence for the individual bytes
of the Unicode characters so that it is not necessary to use an external editor
to maintain this code.

	\195\128-\195\150 – À-Ö (U+00C0–U+00D6 – C0 controls)
	\195\152-\195\182 – Ø-ö (U+00D8-U+00F6 – C0 controls)
	\195\184-\198\191 – ø-ƿ (U+00F8-U+01BF – C0 controls, Latin extended A &amp; B)
	\199\132-\201\143 – Ǆ-ɏ (U+01C4-U+024F – Latin extended B)

]]

local function is_good_vanc_name (last, first, suffix, position)
	if not suffix then
		if first:find ('[,%s]') then											-- when there is a space or comma, might be first name/initials + generational suffix
			first = first:match ('(.-)[,%s]+');									-- get name/initials
			suffix = first:match ('[,%s]+(.+)$');								-- get generational suffix
		end
	end
	if utilities.is_set (suffix) then
		if not is_suffix (suffix) then
			add_vanc_error (cfg.err_msg_supl.suffix, position);
			return false;														-- not a name with an appropriate suffix
		end
	end
	if nil == mw.ustring.find (last, "^[A-Za-z\195\128-\195\150\195\152-\195\182\195\184-\198\191\199\132-\201\143\225\184\128-\225\187\191%-%s%']*$") or
		nil == mw.ustring.find (first, "^[A-Za-z\195\128-\195\150\195\152-\195\182\195\184-\198\191\199\132-\201\143\225\184\128-\225\187\191%-%s%'%.]*$") then
			add_vanc_error (cfg.err_msg_supl['non-Latin char'], position);
			return false;														-- not a string of Latin characters; Vancouver requires Romanization
	end;
	return true;
end


--[[--------------------------&lt; R E D U C E _ T O _ I N I T I A L S &gt;------------------------------------------

Attempts to convert names to initials in support of |name-list-style=vanc.  

Names in |firstn= may be separated by spaces or hyphens, or for initials, a period.
See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35062/.

Vancouver style requires family rank designations (Jr, II, III, etc.) to be rendered
as Jr, 2nd, 3rd, etc.  See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35085/.
This code only accepts and understands generational suffix in the Vancouver format
because Roman numerals look like, and can be mistaken for, initials.

This function uses ustring functions because firstname initials may be any of the
Unicode Latin characters accepted by is_good_vanc_name ().

]]

local function reduce_to_initials (first, position)
	if first:find (',', 1, true) then
		return first;															-- commas not allowed; abandon
	end

	local name, suffix = mw.ustring.match (first, "^(%u+) ([%dJS][%drndth]+)$");

	if not name then															-- if not initials and a suffix
		name = mw.ustring.match (first, "^(%u+)$");								-- is it just initials?
	end

	if name then																-- if first is initials with or without suffix
		if 3 &gt; mw.ustring.len (name) then										-- if one or two initials
			if suffix then														-- if there is a suffix
				if is_suffix (suffix) then										-- is it legitimate?
					return first;												-- one or two initials and a valid suffix so nothing to do
				else
					add_vanc_error (cfg.err_msg_supl.suffix, position);			-- one or two initials with invalid suffix so error message
					return first;												-- and return first unmolested
				end
			else
				return first;													-- one or two initials without suffix; nothing to do
			end
		end
	end																			-- if here then name has 3 or more uppercase letters so treat them as a word

	local initials_t, names_t = {}, {};											-- tables to hold name parts and initials
	local i = 1;																-- counter for number of initials

	names_t = mw.text.split (first, '[%s%-]+');									-- split into a sequence of names and possible suffix

	while names_t[i] do															-- loop through the sequence
		if 1 &lt; i and names_t[i]:match ('[%dJS][%drndth]+%.?$') then				-- if not the first name, and looks like a suffix (may have trailing dot)
			names_t[i] = names_t[i]:gsub ('%.', '');							-- remove terminal dot if present
			if is_suffix (names_t[i]) then										-- if a legitimate suffix
				table.insert (initials_t, ' ' .. names_t[i]);					-- add a separator space, insert at end of initials sequence
				break;															-- and done because suffix must fall at the end of a name
			end																	-- no error message if not a suffix; possibly because of Romanization
		end
		if 3 &gt; i then
			table.insert (initials_t, mw.ustring.sub (names_t[i], 1, 1));		-- insert the initial at end of initials sequence
		end
		i = i + 1;																-- bump the counter
	end
			
	return table.concat (initials_t);											-- Vancouver format does not include spaces.
end


--[[--------------------------&lt; I N T E R W I K I _ P R E F I X E N _ G E T &gt;----------------------------------

extract interwiki prefixen from &lt;value&gt;.  Returns two one or two values:
	false – no prefixen
	nil – prefix exists but not recognized
	project prefix, language prefix – when value has either of:
		:&lt;project&gt;:&lt;language&gt;:&lt;article&gt;
		:&lt;language&gt;:&lt;project&gt;:&lt;article&gt;
	project prefix, nil – when &lt;value&gt; has only a known single-letter prefix
	nil, language prefix – when &lt;value&gt; has only a known language prefix

accepts single-letter project prefixen: 'd' (wikidata), 's' (wikisource), and 'w' (wikipedia) prefixes; at this
writing, the other single-letter prefixen (b (wikibook), c (commons), m (meta), n (wikinews), q (wikiquote), and
v (wikiversity)) are not supported.

]]

local function interwiki_prefixen_get (value, is_link)
	if not value:find (':%l+:') then											-- if no prefix
		return false;															-- abandon; boolean here to distinguish from nil fail returns later
	end

	local prefix_patterns_linked_t = {											-- sequence of valid interwiki and inter project prefixen
		'^%[%[:([dsw]):(%l%l+):',												-- wikilinked; project and language prefixes
		'^%[%[:(%l%l+):([dsw]):',												-- wikilinked; language and project prefixes
		'^%[%[:([dsw]):',														-- wikilinked; project prefix
		'^%[%[:(%l%l+):',														-- wikilinked; language prefix
		}
		
	local prefix_patterns_unlinked_t = {										-- sequence of valid interwiki and inter project prefixen
		'^:([dsw]):(%l%l+):',													-- project and language prefixes
		'^:(%l%l+):([dsw]):',													-- language and project prefixes
		'^:([dsw]):',															-- project prefix
		'^:(%l%l+):',															-- language prefix
		}
	
	local cap1, cap2;
	for _, pattern in ipairs ((is_link and prefix_patterns_linked_t) or prefix_patterns_unlinked_t) do
		cap1, cap2 = value:match (pattern);
		if cap1 then
			break;																-- found a match so stop looking
		end
	end
	
	if cap1 and cap2 then														-- when both then :project:language: or :language:project: (both forms allowed)
		if 1 == #cap1 then														-- length == 1 then :project:language:
			if cfg.inter_wiki_map[cap2] then									-- is language prefix in the interwiki map?
				return cap1, cap2;												-- return interwiki project and interwiki language
			end
		else																	-- here when :language:project:
			if cfg.inter_wiki_map[cap1] then									-- is language prefix in the interwiki map?
				return cap2, cap1;												-- return interwiki project and interwiki language
			end
		end
		return nil;																-- unknown interwiki language
	elseif not (cap1 or cap2) then												-- both are nil?
		return nil;																-- we got something that looks like a project prefix but isn't; return fail
	elseif 1 == #cap1 then														-- here when one capture
		return cap1, nil;														-- length is 1 so return project, nil language
	else																		-- here when one capture and its length it more than 1
		if cfg.inter_wiki_map[cap1] then										-- is language prefix in the interwiki map?
			return nil, cap1;													-- return nil project, language
		end
	end
end


--[[--------------------------&lt; L I S T _ P E O P L E &gt;--------------------------

Formats a list of people (authors, contributors, editors, interviewers, translators) 

names in the list will be linked when
	|&lt;name&gt;-link= has a value
	|&lt;name&gt;-mask- does NOT have a value; masked names are presumed to have been
		rendered previously so should have been linked there

when |&lt;name&gt;-mask=0, the associated name is not rendered

]]

local function list_people (control, people, etal)
	local sep;
	local namesep;
	local format = control.format;
	local maximum = control.maximum;
	local name_list = {};

	if 'vanc' == format then													-- Vancouver-like name styling?
		sep = cfg.presentation['sep_nl_vanc'];									-- name-list separator between names is a comma
		namesep = cfg.presentation['sep_name_vanc'];							-- last/first separator is a space
	else
		sep = cfg.presentation['sep_nl'];										-- name-list separator between names is a semicolon
		namesep = cfg.presentation['sep_name'];									-- last/first separator is &lt;comma&gt;&lt;space&gt;
	end
	
	if sep:sub (-1, -1) ~= " " then sep = sep .. " " end
	if utilities.is_set (maximum) and maximum &lt; 1 then return "", 0; end		-- returned 0 is for EditorCount; not used for other names
	
	for i, person in ipairs (people) do
		if utilities.is_set (person.last) then
			local mask = person.mask;
			local one;
			local sep_one = sep;

			if utilities.is_set (maximum) and i &gt; maximum then
				etal = true;
				break;
			end
			
			if mask then
				local n = tonumber (mask);										-- convert to a number if it can be converted; nil else
				if n then
					one = 0 ~= n and string.rep("&amp;mdash;", n) or nil;			-- make a string of (n &gt; 0) mdashes, nil else, to replace name
					person.link = nil;											-- don't create link to name if name is replaces with mdash string or has been set nil
				else
					one = mask;													-- replace name with mask text (must include name-list separator)
					sep_one = " ";												-- modify name-list separator
				end
			else
				one = person.last;												-- get surname
				local first = person.first										-- get given name
				if utilities.is_set (first) then
					if ("vanc" == format) then									-- if Vancouver format
						one = one:gsub ('%.', '');								-- remove periods from surnames (http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)
						if not person.corporate and is_good_vanc_name (one, first, nil, i) then		-- and name is all Latin characters; corporate authors not tested
							first = reduce_to_initials (first, i);				-- attempt to convert first name(s) to initials
						end
					end
					one = one .. namesep .. first;
				end
			end
			if utilities.is_set (person.link) then
				one = utilities.make_wikilink (person.link, one);				-- link author/editor
			end

			if one then															-- if &lt;one&gt; has a value (name, mdash replacement, or mask text replacement)
				local proj, tag = interwiki_prefixen_get (one, true);			-- get the interwiki prefixen if present
				if 'w' == proj and ('Wikipedia' == mw.site.namespaces.Project['name']) then
					proj = nil;													-- for stuff like :w:de:&lt;article&gt;, :w is unnecessary TODO: maint cat?
				end
				if proj then
					local proj_name = ({['d'] = 'Wikidata', ['s'] = 'Wikisource', ['w'] = 'Wikipedia'})[proj];	-- :w (wikipedia) for linking from a non-wikipedia project
					if proj_name then 
						one = one .. utilities.wrap_style ('interproj', proj_name);	-- add resized leading space, brackets, static text, language name
						utilities.add_prop_cat ('interproj-linked-name', proj);	-- categorize it; &lt;proj&gt; is sort key
						tag = nil;												-- unset; don't do both project and language
					end
				end
				if tag == cfg.this_wiki_code then
					tag = nil;													-- stuff like :en:&lt;article&gt; at en.wiki is pointless TODO: maint cat?
				end
				if tag then
					local lang = cfg.lang_tag_remap[tag] or cfg.mw_languages_by_tag_t[tag];
					if lang then												-- error messaging done in extract_names() where we know parameter names
						one = one .. utilities.wrap_style ('interwiki', lang);	-- add resized leading space, brackets, static text, language name
						utilities.add_prop_cat ('interwiki-linked-name', tag);	-- categorize it; &lt;tag&gt; is sort key
					end
				end

				table.insert (name_list, one);									-- add it to the list of names
				table.insert (name_list, sep_one);								-- add the proper name-list separator
			end
		end
	end

	local count = #name_list / 2;												-- (number of names + number of separators) divided by 2
	if 0 &lt; count then 
		if 1 &lt; count and not etal then
			if 'amp' == format then
				name_list[#name_list-2] = " &amp; ";								-- replace last separator with ampersand text
			elseif 'and' == format then
				if 2 == count then
					name_list[#name_list-2] = cfg.presentation.sep_nl_and;		-- replace last separator with 'and' text
				else
					name_list[#name_list-2] = cfg.presentation.sep_nl_end;		-- replace last separator with '(sep) and' text
				end
			end
		end
		name_list[#name_list] = nil;											-- erase the last separator
	end

	local result = table.concat (name_list);									-- construct list
	if etal and utilities.is_set (result) then									-- etal may be set by |display-authors=etal but we might not have a last-first list
		result = result .. sep .. cfg.messages['et al'];						-- we've got a last-first list and etal so add et al.
	end
	
	return result, count;														-- return name-list string and count of number of names (count used for editor names only)
end


--[[--------------------&lt; M A K E _ C I T E R E F _ I D &gt;-----------------------

Generates a CITEREF anchor ID if we have at least one name or a date.  Otherwise
returns an empty string.

namelist is one of the contributor-, author-, or editor-name lists chosen in that
order.  year is Year or anchor_year.

]]

local function make_citeref_id (namelist, year)
	local names={};							-- a table for the one to four names and year
	for i,v in ipairs (namelist) do			-- loop through the list and take up to the first four last names
		names[i] = v.last
		if i == 4 then break end			-- if four then done
	end
	table.insert (names, year);				-- add the year at the end
	local id = table.concat(names);			-- concatenate names and year for CITEREF id
	if utilities.is_set (id) then			-- if concatenation is not an empty string
		return "CITEREF" .. id;				-- add the CITEREF portion
	else
		return '';							-- return an empty string; no reason to include CITEREF id in this citation
	end
end


--[[--------------------------&lt; C I T E _ C L A S S _A T T R I B U T E _M A K E &gt;------------------------------

construct &lt;cite&gt; tag class attribute for this citation.

&lt;cite_class&gt; – config.CitationClass from calling template
&lt;mode&gt; – value from |mode= parameter

]]

local function cite_class_attribute_make (cite_class, mode)
	local class_t = {};
	table.insert (class_t, 'citation');											-- required for blue highlight
	if 'citation' ~= cite_class then
		table.insert (class_t, cite_class);										-- identify this template for user css
		table.insert (class_t, utilities.is_set (mode) and mode or 'cs1');		-- identify the citation style for user css or javascript
	else
		table.insert (class_t, utilities.is_set (mode) and mode or 'cs2');		-- identify the citation style for user css or javascript
	end
	for _, prop_key in ipairs (z.prop_keys_t) do
		table.insert (class_t, prop_key);										-- identify various properties for user css or javascript
	end

	return table.concat (class_t, ' ');											-- make a big string and done
end


--[[---------------------&lt; N A M E _ H A S _ E T A L &gt;--------------------------

Evaluates the content of name parameters (author, editor, etc.) for variations on
the theme of et al.  If found, the et al. is removed, a flag is set to true and
the function returns the modified name and the flag.

This function never sets the flag to false but returns its previous state because
it may have been set by previous passes through this function or by the associated
|display-&lt;names&gt;=etal parameter

]]

local function name_has_etal (name, etal, nocat, param)

	if utilities.is_set (name) then												-- name can be nil in which case just return
		local patterns = cfg.et_al_patterns; 									-- get patterns from configuration
		
		for _, pattern in ipairs (patterns) do									-- loop through all of the patterns
			if name:match (pattern) then										-- if this 'et al' pattern is found in name
				name = name:gsub (pattern, '');									-- remove the offending text
				etal = true;													-- set flag (may have been set previously here or by |display-&lt;names&gt;=etal)
				if not nocat then												-- no categorization for |vauthors=
					utilities.set_message ('err_etal', {param});				-- and set an error if not added
				end
			end
		end
	end

	return name, etal;
end


--[[---------------------&lt; N A M E _ I S _ N U M E R I C &gt;----------------------

Add an error message and category when &lt;name&gt; parameter value does not contain letters.  

Add a maintenance category when &lt;name&gt; parameter value has numeric characters mixed with characters that are 
not numeric characters; could be letters and/or punctuation characters.

This function will only emit one error and one maint message for the current template.  Does not emit both error
and maint messages/categories for the same parameter value.

returns nothing

]]

local function name_is_numeric (name, name_alias, list_name)
	local patterns = {
		'^%D+%d',																-- &lt;name&gt; must have digits preceded by other characters
		'^%D*%d+%D+',															-- &lt;name&gt; must have digits followed by other characters
		}

	if not added_numeric_name_errs and mw.ustring.match (name, '^[%A]+$') then	-- if we have not already set an error message and &lt;name&gt; does not have any alpha characters
		utilities.set_message ('err_numeric_names', name_alias);				-- add an error message
		added_numeric_name_errs = true;											-- set the flag so we emit only one error message
		return;																	-- when here no point in further testing; abandon
	end

	if not added_numeric_name_maint then										-- if we have already set a maint message
		for _, pattern in ipairs (patterns) do									-- spin through list of patterns
			if mw.ustring.match (name, pattern) then							-- digits preceded or followed by anything but digits; %D+ includes punctuation
				utilities.set_message ('maint_numeric_names', cfg.special_case_translation [list_name]);	-- add a maint cat for this template
				added_numeric_name_maint = true;								-- set the flag so we emit only one maint message
				return;															-- when here no point in further testing; abandon
			end
		end
	end
end


--[[-----------------&lt; N A M E _ H A S _ M U L T _ N A M E S &gt;------------------

Evaluates the content of last/surname (authors etc.) parameters for multiple names.
Multiple names are indicated if there is more than one comma or any "unescaped"
semicolons. Escaped semicolons are ones used as part of selected HTML entities.
If the condition is met, the function adds the multiple name maintenance category.

Same test for first except that commas should not appear in given names (MOS:JR says
that the generational suffix does not take a separator character).  Titles, degrees,
postnominals, affiliations, all normally comma separated don't belong in a citation.

&lt;name&gt; – name parameter value
&lt;list_name&gt; – AuthorList, EditorList, etc
&lt;limit&gt; – number of allowed commas; 1 (default) for surnames; 0 for given names

returns nothing

]]

local function name_has_mult_names (name, list_name, limit)
	local _, commas, semicolons, nbsps;
	limit = limit and limit or 1;
	if utilities.is_set (name) then
		_, commas = name:gsub (',', '');										-- count the number of commas
		_, semicolons = name:gsub (';', '');									-- count the number of semicolons
		-- nbsps probably should be its own separate count rather than merged in
		-- some way with semicolons because Lua patterns do not support the
		-- grouping operator that regex does, which means there is no way to add
		-- more entities to escape except by adding more counts with the new
		-- entities
		_, nbsps = name:gsub ('&amp;nbsp;','');										-- count nbsps
		
		-- There is exactly 1 semicolon per &amp;nbsp; entity, so subtract nbsps
		-- from semicolons to 'escape' them. If additional entities are added,
		-- they also can be subtracted.
		if limit &lt; commas or 0 &lt; (semicolons - nbsps) then
			utilities.set_message ('maint_mult_names', cfg.special_case_translation [list_name]);	-- add a maint message
		end
	end
end


--[=[-------------------------&lt; I S _ G E N E R I C &gt;----------------------------------------------------------

Compares values assigned to various parameters according to the string provided as &lt;item&gt; in the function call.
&lt;item&gt; can have on of two values:
	'generic_names' – for name-holding parameters: |last=, |first=, |editor-last=, etc
	'generic_titles' – for |title=

There are two types of generic tests.  The 'accept' tests look for a pattern that should not be rejected by the
'reject' test.  For example,
	|author=[[John Smith (author)|Smith, John]]
would be rejected by the 'author' reject test.  But piped wikilinks with 'author' disambiguation should not be
rejected so the 'accept' test prevents that from happening.  Accept tests are always performed before reject
tests.

Each of the 'accept' and 'reject' sequence tables hold tables for en.wiki (['en']) and local.wiki (['local'])
that each can hold a test sequence table  The sequence table holds, at index [1], a test pattern, and, at index
[2], a boolean control value.  The control value tells string.find() or mw.ustring.find() to do plain-text search (true)
or a pattern search (false).  The intent of all this complexity is to make these searches as fast as possible so
that we don't run out of processing time on very large articles.

Returns
	true when a reject test finds the pattern or string
	false when an accept test finds the pattern or string
	nil else

]=]

local function is_generic (item, value, wiki)
	local test_val;
	local str_lower = {															-- use string.lower() for en.wiki (['en']) and use mw.ustring.lower() or local.wiki (['local'])
		['en'] = string.lower,
		['local'] = mw.ustring.lower,
		}
	local str_find = {															-- use string.find() for en.wiki (['en']) and use mw.ustring.find() or local.wiki (['local'])
		['en'] = string.find,
		['local'] = mw.ustring.find,
		}

	local function test (val, test_t, wiki)										-- local function to do the testing; &lt;wiki&gt; selects lower() and find() functions
		val = test_t[2] and str_lower[wiki](value) or val;						-- when &lt;test_t[2]&gt; set to 'true', plaintext search using lowercase value
		return str_find[wiki] (val, test_t[1], 1, test_t[2]);					-- return nil when not found or matched
	end
		
	local test_types_t = {'accept', 'reject'};									-- test accept patterns first, then reject patterns
	local wikis_t = {'en', 'local'};											-- do tests for each of these keys; en.wiki first, local.wiki second

	for _, test_type in ipairs (test_types_t) do								-- for each test type
		for _, generic_value in pairs (cfg.special_case_translation[item][test_type]) do	-- spin through the list of generic value fragments to accept or reject
			for _, wiki in ipairs (wikis_t) do
				if generic_value[wiki] then
					if test (value, generic_value[wiki], wiki) then				-- go do the test
						return ('reject' == test_type);							-- param value rejected, return true; false else
					end
				end
			end
		end
	end
end


--[[--------------------------&lt; N A M E _ I S _ G E N E R I C &gt;------------------------------------------------

calls is_generic() to determine if &lt;name&gt; is a 'generic name' listed in cfg.generic_names; &lt;name_alias&gt; is the
parameter name used in error messaging

]]

local function name_is_generic (name, name_alias)
	if not added_generic_name_errs  and is_generic ('generic_names', name) then
		utilities.set_message ('err_generic_name', name_alias);					-- set an error message
		added_generic_name_errs = true;
	end
end


--[[--------------------------&lt; N A M E _ C H E C K S &gt;--------------------------------------------------------

This function calls various name checking functions used to validate the content of the various name-holding parameters.

]]

local function name_checks (last, first, list_name, last_alias, first_alias)
	local accept_name;

	if utilities.is_set (last) then
		last, accept_name = utilities.has_accept_as_written (last);				-- remove accept-this-as-written markup when it wraps all of &lt;last&gt;

		if not accept_name then													-- &lt;last&gt; not wrapped in accept-as-written markup
			name_has_mult_names (last, list_name);								-- check for multiple names in the parameter
			name_is_numeric (last, last_alias, list_name);						-- check for names that have no letters or are a mix of digits and other characters
			name_is_generic (last, last_alias);									-- check for names found in the generic names list
		end
	end

	if utilities.is_set (first) then
		first, accept_name = utilities.has_accept_as_written (first);			-- remove accept-this-as-written markup when it wraps all of &lt;first&gt;

		if not accept_name then													-- &lt;first&gt; not wrapped in accept-as-written markup
			name_has_mult_names (first, list_name, 0);							-- check for multiple names in the parameter; 0 is number of allowed commas in a given name
			name_is_numeric (first, first_alias, list_name);					-- check for names that have no letters or are a mix of digits and other characters
			name_is_generic (first, first_alias);								-- check for names found in the generic names list
		end
		local wl_type, D = utilities.is_wikilink (first);
		if 0 ~= wl_type then
			first = D;
			utilities.set_message ('err_bad_paramlink', first_alias);
		end
	end

	return last, first;															-- done
end


--[[----------------------&lt; E X T R A C T _ N A M E S &gt;-------------------------

Gets name list from the input arguments

Searches through args in sequential order to find |lastn= and |firstn= parameters
(or their aliases), and their matching link and mask parameters. Stops searching
when both |lastn= and |firstn= are not found in args after two sequential attempts:
found |last1=, |last2=, and |last3= but doesn't find |last4= and |last5= then the
search is done.

This function emits an error message when there is a |firstn= without a matching
|lastn=.  When there are 'holes' in the list of last names, |last1= and |last3=
are present but |last2= is missing, an error message is emitted. |lastn= is not
required to have a matching |firstn=.

When an author or editor parameter contains some form of 'et al.', the 'et al.'
is stripped from the parameter and a flag (etal) returned that will cause list_people()
to add the static 'et al.' text from Module:Citation/CS1/Configuration.  This keeps
'et al.' out of the template's metadata.  When this occurs, an error is emitted.

]]

local function extract_names(args, list_name)
	local names = {};															-- table of names
	local last;																	-- individual name components
	local first;
	local link;
	local mask;
	local i = 1;																-- loop counter/indexer
	local n = 1;																-- output table indexer
	local count = 0;															-- used to count the number of times we haven't found a |last= (or alias for authors, |editor-last or alias for editors)
	local etal = false;															-- return value set to true when we find some form of et al. in an author parameter

	local last_alias, first_alias, link_alias;									-- selected parameter aliases used in error messaging
	while true do
		last, last_alias = utilities.select_one ( args, cfg.aliases[list_name .. '-Last'], 'err_redundant_parameters', i );		-- search through args for name components beginning at 1
		first, first_alias = utilities.select_one ( args, cfg.aliases[list_name .. '-First'], 'err_redundant_parameters', i );
		link, link_alias = utilities.select_one ( args, cfg.aliases[list_name .. '-Link'], 'err_redundant_parameters', i );
		mask = utilities.select_one ( args, cfg.aliases[list_name .. '-Mask'], 'err_redundant_parameters', i );
	
		if last then															-- error check |lastn= alias for unknown interwiki link prefix; done here because this is where we have the parameter name
			local project, language = interwiki_prefixen_get (last, true);		-- true because we expect interwiki links in |lastn= to be wikilinked
			if nil == project and nil == language then							-- when both are nil
				utilities.set_message ('err_bad_paramlink', last_alias);		-- not known, emit an error message	-- TODO: err_bad_interwiki?
				last = utilities.remove_wiki_link (last);						-- remove wikilink markup; show display value only
			end
		end
		
		if link then															-- error check |linkn= alias for unknown interwiki link prefix
			local project, language = interwiki_prefixen_get (link, false);		-- false because wiki links in |author-linkn= is an error
			if nil == project and nil == language then							-- when both are nil
				utilities.set_message ('err_bad_paramlink', link_alias);		-- not known, emit an error message	-- TODO: err_bad_interwiki?
				link = nil;														-- unset so we don't link
				link_alias = nil;
			end
		end
		
		last, etal = name_has_etal (last, etal, false, last_alias);				-- find and remove variations on et al.
		first, etal = name_has_etal (first, etal, false, first_alias);			-- find and remove variations on et al.
		last, first = name_checks (last, first, list_name, last_alias, first_alias);						-- multiple names, extraneous annotation, etc. checks

		if first and not last then												-- if there is a firstn without a matching lastn
			local alias = first_alias:find ('given', 1, true) and 'given' or 'first';	-- get first or given form of the alias
			utilities.set_message ('err_first_missing_last', {
				first_alias,													-- param name of alias missing its mate
				first_alias:gsub (alias, {['first'] = 'last', ['given'] = 'surname'}),	-- make param name appropriate to the alias form
				});																-- add this error message
		elseif not first and not last then										-- if both firstn and lastn aren't found, are we done?
			count = count + 1;													-- number of times we haven't found last and first
			if 2 &lt;= count then													-- two missing names and we give up
				break;															-- normal exit or there is a two-name hole in the list; can't tell which
			end
		else																	-- we have last with or without a first
			local result;
			link = link_title_ok (link, link_alias, last, last_alias);			-- check for improper wiki-markup

			if first then
				link = link_title_ok (link, link_alias, first, first_alias);	-- check for improper wiki-markup
			end

			names[n] = {last = last, first = first, link = link, mask = mask, corporate = false};	-- add this name to our names list (corporate for |vauthors= only)
			n = n + 1;															-- point to next location in the names table
			if 1 == count then													-- if the previous name was missing
				utilities.set_message ('err_missing_name', {list_name:match ("(%w+)List"):lower(), i - 1});	-- add this error message
			end
			count = 0;															-- reset the counter, we're looking for two consecutive missing names
		end
		i = i + 1;																-- point to next args location
	end
	
	return names, etal;															-- all done, return our list of names and the etal flag
end


--[[--------------------------&lt; N A M E _ T A G _ G E T &gt;------------------------------------------------------

attempt to decode |language=&lt;lang_param&gt; and return language name and matching tag; nil else.

This function looks for:
	&lt;lang_param&gt; as a tag in cfg.lang_tag_remap{}
	&lt;lang_param&gt; as a name in cfg.lang_name_remap{}
	
	&lt;lang_param&gt; as a name in cfg.mw_languages_by_name_t
	&lt;lang_param&gt; as a tag in cfg.mw_languages_by_tag_t
when those fail, presume that &lt;lang_param&gt; is an IETF-like tag that MediaWiki does not recognize.  Strip all
script, region, variant, whatever subtags from &lt;lang_param&gt; to leave just a two or three character language tag
and look for the new &lt;lang_param&gt; in cfg.mw_languages_by_tag_t{}

on success, returns name (in properly capitalized form) and matching tag (in lowercase); on failure returns nil

]]

local function name_tag_get (lang_param)
	local lang_param_lc = mw.ustring.lower (lang_param);						-- use lowercase as an index into the various tables
	local name;
	local tag;

	name = cfg.lang_tag_remap[lang_param_lc];									-- assume &lt;lang_param_lc&gt; is a tag; attempt to get remapped language name 
	if name then																-- when &lt;name&gt;, &lt;lang_param&gt; is a tag for a remapped language name
		if cfg.lang_name_remap[name:lower()][2] ~= lang_param_lc then
			utilities.set_message ('maint_unknown_lang');						-- add maint category if not already added
			return name, cfg.lang_name_remap[name:lower()][2];					-- so return name and tag from lang_name_remap[name]; special case to xlate sr-ec and sr-el to sr-cyrl and sr-latn
		end
		return name, lang_param_lc;												-- so return &lt;name&gt; from remap and &lt;lang_param_lc&gt;
	end

	tag = lang_param_lc:match ('^(%a%a%a?)%-.*');								-- still assuming that &lt;lang_param_lc&gt; is a tag; strip script, region, variant subtags
	name = cfg.lang_tag_remap[tag];												-- attempt to get remapped language name with language subtag only
	if name then																-- when &lt;name&gt;, &lt;tag&gt; is a tag for a remapped language name
		return name, tag;														-- so return &lt;name&gt; from remap and &lt;tag&gt;
	end

	if cfg.lang_name_remap[lang_param_lc] then									-- not a remapped tag, assume &lt;lang_param_lc&gt; is a name; attempt to get remapped language tag 
		return cfg.lang_name_remap[lang_param_lc][1], cfg.lang_name_remap[lang_param_lc][2];	-- for this &lt;lang_param_lc&gt;, return a (possibly) new name and appropriate tag
	end

	name = cfg.mw_languages_by_tag_t[lang_param_lc];							-- assume that &lt;lang_param_lc&gt; is a tag; attempt to get its matching language name
	
	if name then
		return name, lang_param_lc;												-- &lt;lang_param_lc&gt; is a tag so return it and &lt;name&gt;
	end
	
	tag = cfg.mw_languages_by_name_t[lang_param_lc];							-- assume that &lt;lang_param_lc&gt; is a language name; attempt to get its matching tag
	
	if tag then
		return cfg.mw_languages_by_tag_t[tag], tag;								-- &lt;lang_param_lc&gt; is a name so return the name from the table and &lt;tag&gt;
	end

	tag = lang_param_lc:match ('^(%a%a%a?)%-.*');								-- is &lt;lang_param_lc&gt; an IETF-like tag that MediaWiki doesn't recognize? &lt;tag&gt; gets the language subtag; nil else

	if tag then
		name = cfg.mw_languages_by_tag_t[tag];									-- attempt to get a language name using the shortened &lt;tag&gt;
		if name then
			return name, tag;													-- &lt;lang_param_lc&gt; is an unrecognized IETF-like tag so return &lt;name&gt; and language subtag
		end
	end
end


--[[-------------------&lt; L A N G U A G E _ P A R A M E T E R &gt;------------------

Gets language name from a provided two- or three-character ISO 639 code.  If a code
is recognized by MediaWiki, use the returned name; if not, then use the value that
was provided with the language parameter.

When |language= contains a recognized language (either code or name), the page is
assigned to the category for that code: Category:Norwegian-language sources (no).
For valid three-character code languages, the page is assigned to the single category
for '639-2' codes: Category:CS1 ISO 639-2 language sources.

Languages that are the same as the local wiki are not categorized.  MediaWiki does
not recognize three-character equivalents of two-character codes: code 'ar' is
recognized but code 'ara' is not.

This function supports multiple languages in the form |language=nb, French, th
where the language names or codes are separated from each other by commas with
optional space characters.

]]

local function language_parameter (lang)
	local tag;																	-- some form of IETF-like language tag; language subtag with optional region, sript, vatiant, etc subtags
	local lang_subtag;															-- ve populates |language= with mostly unecessary region subtags the MediaWiki does not recognize; this is the base language subtag
	local name;																	-- the language name
	local language_list = {};													-- table of language names to be rendered
	local names_t = {};															-- table made from the value assigned to |language=

	local this_wiki_name = mw.language.fetchLanguageName (cfg.this_wiki_code, cfg.this_wiki_code);	-- get this wiki's language name

	names_t = mw.text.split (lang, '%s*,%s*');									-- names should be a comma separated list

	for _, lang in ipairs (names_t) do											-- reuse lang here because we don't yet know if lang is a language name or a language tag
		name, tag = name_tag_get (lang);										-- attempt to get name/tag pair for &lt;lang&gt;; &lt;name&gt; has proper capitalization; &lt;tag&gt; is lowercase

		if utilities.is_set (tag) then
			lang_subtag = tag:gsub ('^(%a%a%a?)%-.*', '%1');					-- for categorization, strip any IETF-like tags from language tag

			if cfg.this_wiki_code ~= lang_subtag then							-- when the language is not the same as this wiki's language
				if 2 == lang_subtag:len() then									-- and is a two-character tag
					utilities.add_prop_cat ('foreign-lang-source', {name, tag}, lang_subtag);		-- categorize it; tag appended to allow for multiple language categorization
				else															-- or is a recognized language (but has a three-character tag)
					utilities.add_prop_cat ('foreign-lang-source-2', {lang_subtag}, lang_subtag);			-- categorize it differently TODO: support multiple three-character tag categories per cs1|2 template?
				end
			elseif cfg.local_lang_cat_enable then								-- when the language and this wiki's language are the same and categorization is enabled
				utilities.add_prop_cat ('local-lang-source', {name, lang_subtag});		-- categorize it
			end
		else
			name = lang;														-- return whatever &lt;lang&gt; has so that we show something
			utilities.set_message ('maint_unknown_lang');						-- add maint category if not already added
		end
		
		table.insert (language_list, name);
		name = '';																-- so we can reuse it
	end
 
	name = utilities.make_sep_list (#language_list, language_list);
	if (1 == #language_list) and (lang_subtag == cfg.this_wiki_code) then		-- when only one language, find lang name in this wiki lang name; for |language=en-us, 'English' in 'American English'
		return '';																-- if one language and that language is this wiki's return an empty string (no annotation)
	end
	return (" " .. wrap_msg ('language', name));								-- otherwise wrap with '(in ...)'
	--[[ TODO: should only return blank or name rather than full list
	so we can clean up the bunched parenthetical elements Language, Type, Format
	]]
end


--[[-----------------------&lt; S E T _ C S _ S T Y L E &gt;--------------------------

Gets the default CS style configuration for the given mode.
Returns default separator and either postscript as passed in or the default.
In CS1, the default postscript and separator are '.'.
In CS2, the default postscript is the empty string and the default separator is ','.

]]

local function set_cs_style (postscript, mode)
	if utilities.is_set(postscript) then
		-- emit a maintenance message if user postscript is the default cs1 postscript
		-- we catch the opposite case for cs2 in set_style
		if mode == 'cs1' and postscript == cfg.presentation['ps_' .. mode] then
			utilities.set_message ('maint_postscript');
		end
	else
		postscript = cfg.presentation['ps_' .. mode];
	end
	return cfg.presentation['sep_' .. mode], postscript;
end


--[[--------------------------&lt; S E T _ S T Y L E &gt;-----------------------------

Sets the separator and postscript styles. Checks the |mode= first and the
#invoke CitationClass second. Removes the postscript if postscript == none.

]]

local function set_style (mode, postscript, cite_class)
	local sep;
	if 'cs2' == mode then
		sep, postscript = set_cs_style (postscript, 'cs2');
	elseif 'cs1' == mode then
		sep, postscript = set_cs_style (postscript, 'cs1');
	elseif 'citation' == cite_class	then
		sep, postscript = set_cs_style (postscript, 'cs2');
	else
		sep, postscript = set_cs_style (postscript, 'cs1');
	end

	if cfg.keywords_xlate[postscript:lower()] == 'none' then
		-- emit a maintenance message if user postscript is the default cs2 postscript
		-- we catch the opposite case for cs1 in set_cs_style
		if 'cs2' == mode or ('cs1' ~= mode and 'citation' == cite_class) then	-- {{citation |title=Title |mode=cs1 |postscript=none}} should not emit maint message
			utilities.set_message ('maint_postscript');
		end
		postscript = '';
	end
	
	return sep, postscript
end


--[=[-------------------------&lt; I S _ P D F &gt;-----------------------------------

Determines if a URL has the file extension that is one of the PDF file extensions
used by [[MediaWiki:Common.css]] when applying the PDF icon to external links.

returns true if file extension is one of the recognized extensions, else false

]=]

local function is_pdf (url)
	return url:match ('%.pdf$') or url:match ('%.PDF$') or
		url:match ('%.pdf[%?#]') or url:match ('%.PDF[%?#]') or
		url:match ('%.PDF&amp;#035') or url:match ('%.pdf&amp;#035');
end


--[[--------------------------&lt; S T Y L E _ F O R M A T &gt;-----------------------

Applies CSS style to |format=, |chapter-format=, etc.  Also emits an error message
if the format parameter does not have a matching URL parameter.  If the format parameter
is not set and the URL contains a file extension that is recognized as a PDF document
by MediaWiki's commons.css, this code will set the format parameter to (PDF) with
the appropriate styling.

]]

local function style_format (format, url, fmt_param, url_param)
	if utilities.is_set (format) then
		format = utilities.wrap_style ('format', format);						-- add leading space, parentheses, resize
		if not utilities.is_set (url) then
			utilities.set_message ('err_format_missing_url', {fmt_param, url_param});	-- add an error message
		end
	elseif is_pdf (url) then													-- format is not set so if URL is a PDF file then
		format = utilities.wrap_style ('format', 'PDF');						-- set format to PDF
	else
		format = '';															-- empty string for concatenation
	end
	return format;
end


--[[---------------------&lt; G E T _ D I S P L A Y _ N A M E S &gt;------------------

Returns a number that defines the number of names displayed for author and editor
name lists and a Boolean flag to indicate when et al. should be appended to the name list.

When the value assigned to |display-xxxxors= is a number greater than or equal to zero,
return the number and the previous state of the 'etal' flag (false by default
but may have been set to true if the name list contains some variant of the text 'et al.').

When the value assigned to |display-xxxxors= is the keyword 'etal', return a number
that is one greater than the number of authors in the list and set the 'etal' flag true.
This will cause the list_people() to display all of the names in the name list followed by 'et al.'

In all other cases, returns nil and the previous state of the 'etal' flag.

inputs:
	max: A['DisplayAuthors'] or A['DisplayEditors'], etc; a number or some flavor of etal
	count: #a or #e
	list_name: 'authors' or 'editors'
	etal: author_etal or editor_etal

This function sets an error message when |display-xxxxors= value greater than or equal to number of names but
not when &lt;max&gt; comes from {{cs1 config}} global settings.  When using global settings, &lt;param&gt; is set to the
keyword 'cs1 config' which is used to supress the normal error.  Error is suppressed because it is to be expected
that some citations in an article will have the same or fewer names that the limit specified in {{cs1 config}}.

]]

local function get_display_names (max, count, list_name, etal, param)
	if utilities.is_set (max) then
		if 'etal' == max:lower():gsub("[ '%.]", '') then						-- the :gsub() portion makes 'etal' from a variety of 'et al.' spellings and stylings
			max = count + 1;													-- number of authors + 1 so display all author name plus et al.
			etal = true;														-- overrides value set by extract_names()
		elseif max:match ('^%d+$') then											-- if is a string of numbers
			max = tonumber (max);												-- make it a number
			if (max &gt;= count) and ('cs1 config' ~= param) then					-- error when local |display-xxxxors= value greater than or equal to number of names; not an error when using global setting
				utilities.set_message ('err_disp_name', {param, max});			-- add error message
				max = nil;
			end
		else																	-- not a valid keyword or number
			utilities.set_message ('err_disp_name', {param, max});				-- add error message
			max = nil;															-- unset; as if |display-xxxxors= had not been set
		end
	end
	
	return max, etal;
end


--[[----------&lt; E X T R A _ T E X T _ I N _ P A G E _ C H E C K &gt;---------------

Adds error if |page=, |pages=, |quote-page=, |quote-pages= has what appears to be
some form of p. or pp. abbreviation in the first characters of the parameter content.

check page for extraneous p, p., pp, pp., pg, pg. at start of parameter value:
	good pattern: '^P[^%.P%l]' matches when page begins PX or P# but not Px
		      where x and X are letters and # is a digit
	bad pattern:  '^[Pp][PpGg]' matches when page begins pp, pP, Pp, PP, pg, pG, Pg, PG

]]

local function extra_text_in_page_check (val, name)
	if not val:match (cfg.vol_iss_pg_patterns.good_ppattern) then
		for _, pattern in ipairs (cfg.vol_iss_pg_patterns.bad_ppatterns) do		-- spin through the selected sequence table of patterns
			if val:match (pattern) then											-- when a match, error so
				utilities.set_message ('err_extra_text_pages', name);	 		-- add error message
				return;															-- and done
			end
		end
	end		
end


--[[--------------------------&lt; E X T R A _ T E X T _ I N _ V O L _ I S S _ C H E C K &gt;------------------------

Adds error if |volume= or |issue= has what appears to be some form of redundant 'type' indicator.  Applies to
both; this function looks for issue text in both |issue= and |volume= and looks for volume-like text in |voluem=
and |issue=.

For |volume=:
	'V.', or 'Vol.' (with or without the dot) abbreviations or 'Volume' in the first characters of the parameter
	content (all case insensitive). 'V' and 'v' (without the dot) are presumed to be roman numerals so
	are allowed.

For |issue=:
	'No.', 'I.', 'Iss.' (with or without the dot) abbreviations, or 'Issue' in the first characters of the
	parameter content (all case insensitive); numero styling: 'n°' with degree sign U+00B0, and № precomposed
	numero sign U+2116.
	
Single character values ('v', 'i', 'n') allowed when not followed by separator character ('.', ':', '=', or
whitespace character) – param values are trimmed of whitespace by MediaWiki before delivered to the module.
	
&lt;val&gt; is |volume= or |issue= parameter value
&lt;name&gt; is |volume= or |issue= parameter name for error message
&lt;selector&gt; is 'v' for |volume=, 'i' for |issue=

sets error message on failure; returns nothing

]]

local function extra_text_in_vol_iss_check (val, name, selector)
	if not utilities.is_set (val) then
		return;
	end
	
	local handler = 'v' == selector and 'err_extra_text_volume' or 'err_extra_text_issue';
	val = val:lower();															-- force parameter value to lower case

	for _, pattern in ipairs (cfg.vol_iss_pg_patterns.vi_patterns_t) do			-- spin through the sequence table of patterns
		if val:match (pattern) then												-- when a match, error so
			utilities.set_message (handler, name);								-- add error message
			return;																-- and done
		end
	end
end


--[=[-------------------------&lt; G E T _ V _ N A M E _ T A B L E &gt;----------------------------------------------

split apart a |vauthors= or |veditors= parameter.  This function allows for corporate names, wrapped in doubled
parentheses to also have commas; in the old version of the code, the doubled parentheses were included in the
rendered citation and in the metadata.  Individual author names may be wikilinked

	|vauthors=Jones AB, [[E. B. White|White EB]], ((Black, Brown, and Co.))

]=]

local function get_v_name_table (vparam, output_table, output_link_table)
	local _, accept = utilities.has_accept_as_written (vparam);
	if accept then
		utilities.add_prop_cat ('vanc-accept');									-- add properties category
	end
	local name_table = mw.text.split(vparam, "%s*,%s*");						-- names are separated by commas
	local wl_type, label, link;													-- wl_type not used here; just a placeholder
	
	local i = 1;
	
	while name_table[i] do
		if name_table[i]:match ('^%(%(.*[^%)][^%)]$') then						-- first segment of corporate with one or more commas; this segment has the opening doubled parentheses
			local name = name_table[i];
			i = i + 1;															-- bump indexer to next segment
			while name_table[i] do
				name = name .. ', ' .. name_table[i];							-- concatenate with previous segments
				if name_table[i]:match ('^.*%)%)$') then						-- if this table member has the closing doubled parentheses
					break;														-- and done reassembling so
				end
				i = i + 1;														-- bump indexer
			end
			table.insert (output_table, name);									-- and add corporate name to the output table
			table.insert (output_link_table, '');								-- no wikilink
		else
			wl_type, label, link = utilities.is_wikilink (name_table[i]);		-- wl_type is: 0, no wl (text in label variable); 1, [[D]]; 2, [[L|D]]
			table.insert (output_table, label);									-- add this name
			if 1 == wl_type then
				table.insert (output_link_table, label);						-- simple wikilink [[D]]
			else
				table.insert (output_link_table, link);							-- no wikilink or [[L|D]]; add this link if there is one, else empty string
			end
		end
		i = i + 1;
	end	
	return output_table;
end


--[[--------------------------&lt; P A R S E _ V A U T H O R S _ V E D I T O R S &gt;--------------------------------

This function extracts author / editor names from |vauthors= or |veditors= and finds matching |xxxxor-maskn= and
|xxxxor-linkn= in args.  It then returns a table of assembled names just as extract_names() does.

Author / editor names in |vauthors= or |veditors= must be in Vancouver system style. Corporate or institutional names
may sometimes be required and because such names will often fail the is_good_vanc_name() and other format compliance
tests, are wrapped in doubled parentheses ((corporate name)) to suppress the format tests.

Supports generational suffixes Jr, 2nd, 3rd, 4th–6th.

This function sets the Vancouver error when a required comma is missing and when there is a space between an author's initials.

]]

local function parse_vauthors_veditors (args, vparam, list_name)
	local names = {};															-- table of names assembled from |vauthors=, |author-maskn=, |author-linkn=
	local v_name_table = {};
	local v_link_table = {};													-- when name is wikilinked, targets go in this table
	local etal = false;															-- return value set to true when we find some form of et al. vauthors parameter
	local last, first, link, mask, suffix;
	local corporate = false;

	vparam, etal = name_has_etal (vparam, etal, true);							-- find and remove variations on et al. do not categorize (do it here because et al. might have a period)
	v_name_table = get_v_name_table (vparam, v_name_table, v_link_table);		-- names are separated by commas

	for i, v_name in ipairs(v_name_table) do
		first = '';																-- set to empty string for concatenation and because it may have been set for previous author/editor
		local accept_name;
		v_name, accept_name = utilities.has_accept_as_written (v_name);			-- remove accept-this-as-written markup when it wraps all of &lt;v_name&gt;

		if accept_name then
			last = v_name;
			corporate = true;													-- flag used in list_people()
		elseif string.find(v_name, "%s") then
			if v_name:find('[;%.]') then										-- look for commonly occurring punctuation characters; 
				add_vanc_error (cfg.err_msg_supl.punctuation, i);
			end
			local lastfirstTable = {}
			lastfirstTable = mw.text.split(v_name, "%s+")
			first = table.remove(lastfirstTable);								-- removes and returns value of last element in table which should be initials or generational suffix

			if not mw.ustring.match (first, '^%u+$') then						-- mw.ustring here so that later we will catch non-Latin characters
				suffix = first;													-- not initials so assume that whatever we got is a generational suffix
				first = table.remove(lastfirstTable);							-- get what should be the initials from the table
			end
			last = table.concat(lastfirstTable, ' ')							-- returns a string that is the concatenation of all other names that are not initials and generational suffix
			if not utilities.is_set (last) then
				first = '';														-- unset
				last = v_name;													-- last empty because something wrong with first
				add_vanc_error (cfg.err_msg_supl.name, i);
			end
			if mw.ustring.match (last, '%a+%s+%u+%s+%a+') then
				add_vanc_error (cfg.err_msg_supl['missing comma'], i);			-- matches last II last; the case when a comma is missing
			end
			if mw.ustring.match (v_name, ' %u %u$') then						-- this test is in the wrong place TODO: move or replace with a more appropriate test
				add_vanc_error (cfg.err_msg_supl.initials, i);					-- matches a space between two initials
			end
		else
			last = v_name;														-- last name or single corporate name?  Doesn't support multiword corporate names? do we need this?
		end
		
		if utilities.is_set (first) then
			if not mw.ustring.match (first, "^%u?%u$") then						-- first shall contain one or two upper-case letters, nothing else
				add_vanc_error (cfg.err_msg_supl.initials, i);					-- too many initials; mixed case initials (which may be ok Romanization); hyphenated initials
			end
			is_good_vanc_name (last, first, suffix, i);							-- check first and last before restoring the suffix which may have a non-Latin digit
			if utilities.is_set (suffix) then
				first = first .. ' ' .. suffix;									-- if there was a suffix concatenate with the initials
				suffix = '';													-- unset so we don't add this suffix to all subsequent names
			end
		else
			if not corporate then
				is_good_vanc_name (last, '', nil, i);
			end
		end

		link = utilities.select_one ( args, cfg.aliases[list_name .. '-Link'], 'err_redundant_parameters', i ) or v_link_table[i];
		mask = utilities.select_one ( args, cfg.aliases[list_name .. '-Mask'], 'err_redundant_parameters', i );
		names[i] = {last = last, first = first, link = link, mask = mask, corporate = corporate};		-- add this assembled name to our names list
	end
	return names, etal;															-- all done, return our list of names
end


--[[--------------------------&lt; S E L E C T _ A U T H O R _ E D I T O R _ S O U R C E &gt;------------------------

Select one of |authors=, |authorn= / |lastn / firstn=, or |vauthors= as the source of the author name list or
select one of |editorn= / editor-lastn= / |editor-firstn= or |veditors= as the source of the editor name list.

Only one of these appropriate three will be used.  The hierarchy is: |authorn= (and aliases) highest and |authors= lowest;
|editorn= (and aliases) highest and |veditors= lowest (support for |editors= withdrawn)

When looking for |authorn= / |editorn= parameters, test |xxxxor1= and |xxxxor2= (and all of their aliases); stops after the second
test which mimicks the test used in extract_names() when looking for a hole in the author name list.  There may be a better
way to do this, I just haven't discovered what that way is.

Emits an error message when more than one xxxxor name source is provided.

In this function, vxxxxors = vauthors or veditors; xxxxors = authors as appropriate.

]]

local function select_author_editor_source (vxxxxors, xxxxors, args, list_name)
	local lastfirst = false;
	if utilities.select_one ( args, cfg.aliases[list_name .. '-Last'], 'none', 1 ) or		-- do this twice in case we have a |first1= without a |last1=; this ...
		utilities.select_one ( args, cfg.aliases[list_name .. '-First'], 'none', 1 ) or		-- ... also catches the case where |first= is used with |vauthors=
		utilities.select_one ( args, cfg.aliases[list_name .. '-Last'], 'none', 2 ) or
		utilities.select_one ( args, cfg.aliases[list_name .. '-First'], 'none', 2 ) then
			lastfirst = true;
	end

	if (utilities.is_set (vxxxxors) and true == lastfirst) or					-- these are the three error conditions
		(utilities.is_set (vxxxxors) and utilities.is_set (xxxxors)) or
		(true == lastfirst and utilities.is_set (xxxxors)) then
			local err_name;
			if 'AuthorList' == list_name then									-- figure out which name should be used in error message
				err_name = 'author';
			else
				err_name = 'editor';
			end
			utilities.set_message ('err_redundant_parameters', err_name .. '-name-list parameters');	-- add error message
	end

	if true == lastfirst then return 1 end;										-- return a number indicating which author name source to use
	if utilities.is_set (vxxxxors) then return 2 end;
	if utilities.is_set (xxxxors) then return 3 end;
	return 1;																	-- no authors so return 1; this allows missing author name test to run in case there is a first without last 
end


--[[--------------------------&lt; I S _ V A L I D _ P A R A M E T E R _ V A L U E &gt;------------------------------

This function is used to validate a parameter's assigned value for those parameters that have only a limited number
of allowable values (yes, y, true, live, dead, etc.).  When the parameter value has not been assigned a value (missing
or empty in the source template) the function returns the value specified by ret_val.  If the parameter value is one
of the list of allowed values returns the translated value; else, emits an error message and returns the value
specified by ret_val.

TODO: explain &lt;invert&gt;

]]

local function is_valid_parameter_value (value, name, possible, ret_val, invert)
	if not utilities.is_set (value) then
		return ret_val;															-- an empty parameter is ok
	end

	if (not invert and utilities.in_array (value, possible)) then				-- normal; &lt;value&gt; is in &lt;possible&gt; table
		return cfg.keywords_xlate[value];										-- return translation of parameter keyword
	elseif invert and not utilities.in_array (value, possible) then				-- invert; &lt;value&gt; is not in &lt;possible&gt; table
		return value;															-- return &lt;value&gt; as it is
	else
		utilities.set_message ('err_invalid_param_val', {name, value});			-- not an allowed value so add error message
		return ret_val;
	end
end


--[[--------------------------&lt; T E R M I N A T E _ N A M E _ L I S T &gt;----------------------------------------

This function terminates a name list (author, contributor, editor) with a separator character (sepc) and a space
when the last character is not a sepc character or when the last three characters are not sepc followed by two
closing square brackets (close of a wikilink).  When either of these is true, the name_list is terminated with a
single space character.

]]

local function terminate_name_list (name_list, sepc)
	if (string.sub (name_list, -3, -1) == sepc .. '. ') then					-- if already properly terminated
		return name_list;														-- just return the name list
	elseif (string.sub (name_list, -1, -1) == sepc) or (string.sub (name_list, -3, -1) == sepc .. ']]') then	-- if last name in list ends with sepc char
		return name_list .. " ";												-- don't add another
	else
		return name_list .. sepc .. ' ';										-- otherwise terminate the name list
	end
end


--[[-------------------------&lt; F O R M A T _ V O L U M E _ I S S U E &gt;-----------------------------------------

returns the concatenation of the formatted volume and issue (or journal article number) parameters as a single
string; or formatted volume or formatted issue, or an empty string if neither are set.

]]
	
local function format_volume_issue (volume, issue, article, cite_class, origin, sepc, lower)
	if not utilities.is_set (volume) and not utilities.is_set (issue) and not utilities.is_set (article) then
		return '';
	end

	-- same condition as in format_pages_sheets()
	local is_journal = 'journal' == cite_class or (utilities.in_array (cite_class, {'citation', 'map', 'interview'}) and 'journal' == origin);

	local is_numeric_vol = volume and (volume:match ('^[MDCLXVI]+$') or volume:match ('^%d+$'));	-- is only uppercase roman numerals or only digits?
	local is_long_vol = volume and (4 &lt; mw.ustring.len(volume));				-- is |volume= value longer than 4 characters?
	
	if volume and (not is_numeric_vol and is_long_vol) then						-- when not all digits or Roman numerals, is |volume= longer than 4 characters?
		utilities.add_prop_cat ('long-vol');									-- yes, add properties cat
	end

	if is_journal then															-- journal-style formatting
		local vol = '';

		if utilities.is_set (volume) then
			if is_numeric_vol then												-- |volume= value all digits or all uppercase Roman numerals?
				vol = utilities.substitute (cfg.presentation['vol-bold'], {sepc, volume});	-- render in bold face
			elseif is_long_vol then												-- not all digits or Roman numerals; longer than 4 characters?
				vol = utilities.substitute (cfg.messages['j-vol'], {sepc, utilities.hyphen_to_dash (volume)});	-- not bold
			else																-- four or fewer characters
				vol = utilities.substitute (cfg.presentation['vol-bold'], {sepc, utilities.hyphen_to_dash (volume)});	-- bold
			end
		end
		vol = vol .. (utilities.is_set (issue) and utilities.substitute (cfg.messages['j-issue'], issue) or '')
		vol = vol .. (utilities.is_set (article) and utilities.substitute (cfg.messages['j-article-num'], article) or '')
		return vol;
	end
	
	if 'podcast' == cite_class and utilities.is_set (issue) then
		return wrap_msg ('issue', {sepc, issue}, lower);
	end
	
	if 'conference' == cite_class and utilities.is_set (article) then			-- |article-number= supported only in journal and conference cites
		if utilities.is_set (volume) and utilities.is_set (article) then		-- both volume and article number
			return wrap_msg ('vol-art', {sepc, utilities.hyphen_to_dash (volume), article}, lower);
		elseif utilities.is_set (article) then									-- article number alone; when volume alone, handled below
			return wrap_msg ('art', {sepc, article}, lower);
		end
	end

	-- all other types of citation
	if utilities.is_set (volume) and utilities.is_set (issue) then
		return wrap_msg ('vol-no', {sepc, utilities.hyphen_to_dash (volume), issue}, lower);
	elseif utilities.is_set (volume) then
		return wrap_msg ('vol', {sepc, utilities.hyphen_to_dash (volume)}, lower);
	else
		return wrap_msg ('issue', {sepc, issue}, lower);
	end
end


--[[-------------------------&lt; F O R M A T _ P A G E S _ S H E E T S &gt;-----------------------------------------

adds static text to one of |page(s)= or |sheet(s)= values and returns it with all of the others set to empty strings.
The return order is:
	page, pages, sheet, sheets

Singular has priority over plural when both are provided.

]]

local function format_pages_sheets (page, pages, sheet, sheets, cite_class, origin, sepc, nopp, lower)
	if 'map' == cite_class then													-- only cite map supports sheet(s) as in-source locators
		if utilities.is_set (sheet) then
			if 'journal' == origin then
				return '', '', wrap_msg ('j-sheet', sheet, lower), '';
			else
				return '', '', wrap_msg ('sheet', {sepc, sheet}, lower), '';
			end
		elseif utilities.is_set (sheets) then
			if 'journal' == origin then
				return '', '', '', wrap_msg ('j-sheets', sheets, lower);
			else
				return '', '', '', wrap_msg ('sheets', {sepc, sheets}, lower);
			end
		end
	end

	local is_journal = 'journal' == cite_class or (utilities.in_array (cite_class, {'citation', 'map', 'interview'}) and 'journal' == origin);
	
	if utilities.is_set (page) then
		if is_journal then
			return utilities.substitute (cfg.messages['j-page(s)'], page), '', '', '';
		elseif not nopp then
			return utilities.substitute (cfg.messages['p-prefix'], {sepc, page}), '', '', '';
		else
			return utilities.substitute (cfg.messages['nopp'], {sepc, page}), '', '', '';
		end
	elseif utilities.is_set (pages) then
		if is_journal then
			return utilities.substitute (cfg.messages['j-page(s)'], pages), '', '', '';
		elseif tonumber(pages) ~= nil and not nopp then							-- if pages is only digits, assume a single page number
			return '', utilities.substitute (cfg.messages['p-prefix'], {sepc, pages}), '', '';
		elseif not nopp then
			return '', utilities.substitute (cfg.messages['pp-prefix'], {sepc, pages}), '', '';
		else
			return '', utilities.substitute (cfg.messages['nopp'], {sepc, pages}), '', '';
		end
	end
	
	return '', '', '', '';														-- return empty strings
end


--[[--------------------------&lt; I N S O U R C E _ L O C _ G E T &gt;----------------------------------------------

returns one of the in-source locators: page, pages, or at. 

If any of these are interwiki links to Wikisource, returns the label portion of the interwiki-link as plain text
for use in COinS.  This COinS thing is done because here we convert an interwiki-link to an external link and
add an icon span around that; get_coins_pages() doesn't know about the span.  TODO: should it?  

TODO: add support for sheet and sheets?; streamline;

TODO: make it so that this function returns only one of the three as the single in-source (the return value assigned
to a new name)?

]]

local function insource_loc_get (page, page_orig, pages, pages_orig, at)
	local ws_url, ws_label, coins_pages, L;										-- for Wikisource interwiki-links; TODO: this corrupts page metadata (span remains in place after cleanup; fix there?)

	if utilities.is_set (page) then
		if utilities.is_set (pages) or utilities.is_set (at) then
			pages = '';															-- unset the others
			at = '';
		end
		extra_text_in_page_check (page, page_orig);								-- emit error message when |page= value begins with what looks like p., pp., etc.

		ws_url, ws_label, L = wikisource_url_make (page);						-- make ws URL from |page= interwiki link; link portion L becomes tooltip label
		if ws_url then
			page = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in page');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			page = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, page});
			coins_pages = ws_label;
		end
	elseif utilities.is_set (pages) then
		if utilities.is_set (at) then
			at = '';															-- unset
		end
		extra_text_in_page_check (pages, pages_orig);							-- emit error message when |page= value begins with what looks like p., pp., etc.

		ws_url, ws_label, L = wikisource_url_make (pages);						-- make ws URL from |pages= interwiki link; link portion L becomes tooltip label
		if ws_url then
			pages = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in pages');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			pages = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, pages});
			coins_pages = ws_label;
		end
	elseif utilities.is_set (at) then
		ws_url, ws_label, L = wikisource_url_make (at);							-- make ws URL from |at= interwiki link; link portion L becomes tooltip label
		if ws_url then
			at = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in at');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			at = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, at});
			coins_pages = ws_label;
		end
	end
	
	return page, pages, at, coins_pages;
end

--[[--------------------------&lt; I S _ U N I Q U E _ A R C H I V E _ U R L &gt;------------------------------------

add error message when |archive-url= value is same as |url= or chapter-url= (or alias...) value

]]

local function is_unique_archive_url (archive, url, c_url, source, date)
	if utilities.is_set (archive) then
		if archive == url or archive == c_url then
			utilities.set_message ('err_bad_url', {utilities.wrap_style ('parameter', source)});	-- add error message
			return '', '';														-- unset |archive-url= and |archive-date= because same as |url= or |chapter-url=
		end
	end

	return archive, date;
end


--[=[-------------------------&lt; A R C H I V E _ U R L _ C H E C K &gt;--------------------------------------------

Check archive.org URLs to make sure they at least look like they are pointing at valid archives and not to the 
save snapshot URL or to calendar pages.  When the archive URL is 'https://web.archive.org/save/' (or http://...)
archive.org saves a snapshot of the target page in the URL.  That is something that Wikipedia should not allow
unwitting readers to do.

When the archive.org URL does not have a complete timestamp, archive.org chooses a snapshot according to its own
algorithm or provides a calendar 'search' result.  [[WP:ELNO]] discourages links to search results.

This function looks at the value assigned to |archive-url= and returns empty strings for |archive-url= and
|archive-date= and an error message when:
	|archive-url= holds an archive.org save command URL
	|archive-url= is an archive.org URL that does not have a complete timestamp (YYYYMMDDhhmmss 14 digits) in the
		correct place
otherwise returns |archive-url= and |archive-date=

There are two mostly compatible archive.org URLs:
	//web.archive.org/&lt;timestamp&gt;...		-- the old form
	//web.archive.org/web/&lt;timestamp&gt;...	-- the new form

The old form does not support or map to the new form when it contains a display flag.  There are four identified flags
('id_', 'js_', 'cs_', 'im_') but since archive.org ignores others following the same form (two letters and an underscore)
we don't check for these specific flags but we do check the form.

This function supports a preview mode.  When the article is rendered in preview mode, this function may return a modified
archive URL:
	for save command errors, return undated wildcard (/*/)
	for timestamp errors when the timestamp has a wildcard, return the URL unmodified
	for timestamp errors when the timestamp does not have a wildcard, return with timestamp limited to six digits plus wildcard (/yyyymm*/)

A secondary function is to return an archive-url timestamp from those urls that have them (archive.org and
archive.today).  The timestamp is used by validation.archive_date_check() to see if the value in |archive-date=
matches the timestamp in the archive url.

]=]

local function archive_url_check (url, date)
	local err_msg = '';															-- start with the error message empty
	local path, timestamp, flag;												-- portions of the archive.org URL
	
	timestamp = url:match ('//archive.today/(%d%d%d%d%d%d%d%d%d%d%d%d%d%d)/') or	-- get timestamp from archive.today urls
		url:match ('//archive.today/(%d%d%d%d%.%d%d%.%d%d%-%d%d%d%d%d%d)/');		-- this timestamp needs cleanup
	if timestamp then															-- if this was an archive.today url ...
		return url, date, timestamp:gsub ('[%.%-]', '');						-- return ArchiveURL, ArchiveDate, and timestamp (dots and dashes removed) from |archive-url=, and done
	end
																				-- here for archive.org urls
	if (not url:match('//web%.archive%.org/')) and (not url:match('//liveweb%.archive%.org/')) then		-- also deprecated liveweb Wayback machine URL
		return url, date;														-- not an archive.org archive, return ArchiveURL and ArchiveDate
	end

	if url:match('//web%.archive%.org/save/') then								-- if a save command URL, we don't want to allow saving of the target page 
		err_msg = cfg.err_msg_supl.save;
		url = url:gsub ('(//web%.archive%.org)/save/', '%1/*/', 1);				-- for preview mode: modify ArchiveURL
	elseif url:match('//liveweb%.archive%.org/') then
		err_msg = cfg.err_msg_supl.liveweb;
	else
		path, timestamp, flag = url:match('//web%.archive%.org/([^%d]*)(%d+)([^/]*)/');	-- split out some of the URL parts for evaluation
		if not path then														-- malformed in some way; pattern did not match
			err_msg = cfg.err_msg_supl.timestamp;
		elseif 14 ~= timestamp:len() then										-- path and flag optional, must have 14-digit timestamp here
			err_msg = cfg.err_msg_supl.timestamp;
			if '*' ~= flag then
				local replacement = timestamp:match ('^%d%d%d%d%d%d') or timestamp:match ('^%d%d%d%d');	-- get the first 6 (YYYYMM) or first 4 digits (YYYY)
				if replacement then												-- nil if there aren't at least 4 digits (year)
					replacement = replacement .. string.rep ('0', 14 - replacement:len());	-- year or yearmo (4 or 6 digits) zero-fill to make 14-digit timestamp
					url=url:gsub ('(//web%.archive%.org/[^%d]*)%d[^/]*', '%1' .. replacement .. '*', 1)	-- for preview, modify ts to 14 digits plus splat for calendar display
				end
			end
		elseif utilities.is_set (path) and 'web/' ~= path then					-- older archive URLs do not have the extra 'web/' path element
			err_msg = cfg.err_msg_supl.path;
		elseif utilities.is_set (flag) and not utilities.is_set (path) then		-- flag not allowed with the old form URL (without the 'web/' path element)
			err_msg = cfg.err_msg_supl.flag;
		elseif utilities.is_set (flag) and not flag:match ('%a%a_') then		-- flag if present must be two alpha characters and underscore (requires 'web/' path element)
			err_msg = cfg.err_msg_supl.flag;
		else
			return url, date, timestamp;										-- return ArchiveURL, ArchiveDate, and timestamp from |archive-url=
		end
	end
																				-- if here, something not right so
	utilities.set_message ('err_archive_url', {err_msg});						-- add error message and

	if is_preview_mode then
		return url, date, timestamp;											-- preview mode so return ArchiveURL, ArchiveDate, and timestamp from |archive-url=
	else
		return '', '';															-- return empty strings for ArchiveURL and ArchiveDate
	end
end


--[[--------------------------&lt; P L A C E _ C H E C K &gt;--------------------------------------------------------

check |place=, |publication-place=, |location= to see if these params include digits.  This function added because
many editors misuse location to specify the in-source location (|page(s)= and |at= are supposed to do that)

returns the original parameter value without modification; added maint cat when parameter value contains digits

]]

local function place_check (param_val)
	if not utilities.is_set (param_val) then									-- parameter empty or omitted
		return param_val;														-- return that empty state
	end
	
	if mw.ustring.find (param_val, '%d') then									-- not empty, are there digits in the parameter value
		utilities.set_message ('maint_location');								-- yep, add maint cat
	end
	
	return param_val;															-- and done
end


--[[--------------------------&lt; I S _ A R C H I V E D _ C O P Y &gt;----------------------------------------------

compares |title= to 'Archived copy' (placeholder added by bots that can't find proper title); if matches, return true; nil else

]]

local function is_archived_copy (title)
	title = mw.ustring.lower(title);											-- switch title to lower case
	if title:find (cfg.special_case_translation.archived_copy.en) then			-- if title is 'Archived copy'
		return true;
	elseif cfg.special_case_translation.archived_copy['local'] then
		if mw.ustring.find (title, cfg.special_case_translation.archived_copy['local']) then	-- mw.ustring() because might not be Latin script
			return true;
		end
	end
end


--[[--------------------------&lt; D I S P L A Y _ N A M E S _ S E L E C T &gt;--------------------------------------

for any of the |display-authors=, |display-editors=, etc parameters, select either the local or global setting.
When both are present, look at &lt;local_display_names&gt; value.  When the value is some sort of 'et al.'string,
special handling is required.

When {{cs1 config}} has |display-&lt;namelist&gt;= AND this template has |display-&lt;namelist&gt;=etal AND:
	the number of names specified by &lt;number_of_names&gt; is:
		greater than the number specified in the global |display-&lt;namelist&gt;= parameter (&lt;global_display_names&gt;)
			use global |display-&lt;namelist&gt;= parameter value
			set overridden maint category
		less than or equal to the number specified in the global |display-&lt;namelist&gt;=  parameter
			use local |display-&lt;namelist&gt;= parameter value

The purpose of this function is to prevent categorizing a template that has fewer names than the global setting
to keep the etal annotation specified by &lt;local_display_names&gt;.

]]

local function display_names_select (global_display_names, local_display_names, param_name, number_of_names, test)
	if global_display_names and utilities.is_set (local_display_names) then		-- when both
		if 'etal' == local_display_names:lower():gsub("[ '%.]", '') then		-- the :gsub() portion makes 'etal' from a variety of 'et al.' spellings and stylings
			number_of_names = tonumber (number_of_names);						-- convert these to numbers for comparison
			local global_display_names_num = tonumber (global_display_names);	-- &lt;global_display_names&gt; not set when parameter value is not digits

			if number_of_names &gt; global_display_names_num then					-- template has more names than global config allows to be displayed?
				utilities.set_message ('maint_overridden_setting');				-- set a maint message because global is overriding local |display-&lt;namelist&gt;=etal
				return global_display_names, 'cs1 config';						-- return global with spoof parameter name (for get_display_names())
			else
				return local_display_names, param_name;							-- return local because fewer names so let &lt;local_display_names&gt; control
			end
		end
																				-- here when &lt;global_display_names&gt; and &lt;local_display_names&gt; both numbers; &lt;global_display_names&gt; controls
		utilities.set_message ('maint_overridden_setting');						-- set a maint message
		return global_display_names, 'cs1 config';								-- return global with spoof parameter name (for get_display_names())
	end
																				-- here when only one of &lt;global_display_names&gt; or &lt;local_display_names&gt; set
	if global_display_names then
		return global_display_names, 'cs1 config';								-- return global with spoof parameter name (for get_display_names())
	else
		return local_display_names, param_name;									-- return local
	end
end


--[[--------------------------&lt; M O D E _ S E T &gt;--------------------------------------------------------------

fetch global mode setting from {{cs1 config}} (if present) or from |mode= (if present); global setting overrides
local |mode= parameter value.  When both are present, emit maintenance message

]]

local function mode_set (Mode, Mode_origin)
	local mode;
	if cfg.global_cs1_config_t['Mode'] then										-- global setting in {{cs1 config}}; nil when empty or assigned value invalid
		mode = is_valid_parameter_value (cfg.global_cs1_config_t['Mode'], 'cs1 config: mode', cfg.keywords_lists['mode'], '');	-- error messaging 'param' here is a hoax
	else
		mode = is_valid_parameter_value (Mode, Mode_origin, cfg.keywords_lists['mode'], '');
	end

	if cfg.global_cs1_config_t['Mode'] and utilities.is_set (Mode) then			-- when template has |mode=&lt;something&gt; which global setting has overridden
		utilities.set_message ('maint_overridden_setting');						-- set a maint message
	end
	return mode;
end


--[[--------------------------&lt; Q U O T E _ M A K E &gt;----------------------------------------------------------

create quotation from |quote=, |trans-quote=, and/or script-quote= with or without |quote-page= or |quote-pages=

when any of those three quote parameters are set, this function unsets &lt;PostScript&gt;.  When none of those parameters
are set, |quote-page= and |quote-pages= are unset to nil so that they are not included in the template's metadata

]]

local function quote_make (quote, trans_quote, script_quote, quote_page, quote_pages, nopp, sepc, postscript)
	if utilities.is_set (quote) or utilities.is_set (trans_quote) or utilities.is_set (script_quote) then

		if utilities.is_set (quote) then
			if quote:sub(1, 1) == '"' and quote:sub(-1, -1) == '"' then			-- if first and last characters of quote are quote marks
				quote = quote:sub(2, -2);										-- strip them off
			end
		end
		
		quote = kern_quotes (quote);											-- kern if needed
		quote = utilities.wrap_style ('quoted-text', quote );					-- wrap in &lt;q&gt;...&lt;/q&gt; tags
	
		if utilities.is_set (script_quote) then
			quote = script_concatenate (quote, script_quote, 'script-quote');	-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after quote is wrapped
		end

		if utilities.is_set (trans_quote) then
			if trans_quote:sub(1, 1) == '"' and trans_quote:sub(-1, -1) == '"' then -- if first and last characters of |trans-quote are quote marks
				trans_quote = trans_quote:sub(2, -2); -- strip them off
			end
			quote = quote .. " " .. utilities.wrap_style ('trans-quoted-title', trans_quote );
		end

		if utilities.is_set (quote_page) or utilities.is_set (quote_pages) then	-- add page prefix
			local quote_prefix = '';
			if utilities.is_set (quote_page) then
				extra_text_in_page_check (quote_page, 'quote-page');			-- add to maint cat if |quote-page= value begins with what looks like p., pp., etc.
				if not nopp then
					quote_prefix = utilities.substitute (cfg.messages['p-prefix'], {sepc, quote_page}), '', '', '';
				else
					quote_prefix = utilities.substitute (cfg.messages['nopp'], {sepc, quote_page}), '', '', '';
				end
			elseif utilities.is_set (quote_pages) then
				extra_text_in_page_check (quote_pages, 'quote-pages');			-- add to maint cat if |quote-pages= value begins with what looks like p., pp., etc.
				if tonumber(quote_pages) ~= nil and not nopp then				-- if only digits, assume single page
					quote_prefix = utilities.substitute (cfg.messages['p-prefix'], {sepc, quote_pages}), '', '';
				elseif not nopp then
					quote_prefix = utilities.substitute (cfg.messages['pp-prefix'], {sepc, quote_pages}), '', '';
				else
					quote_prefix = utilities.substitute (cfg.messages['nopp'], {sepc, quote_pages}), '', '';
				end
			end
                        
			quote = quote_prefix .. ": " .. quote;
		else
			quote = sepc .. " " .. quote;
		end

		postscript = "";														-- cs1|2 does not supply terminal punctuation when |quote= is set
	
	elseif utilities.is_set (quote_page) or utilities.is_set (quote_pages) then
		quote_page = nil;														-- unset; these require |quote=; TODO: error message?
		quote_pages = nil;
	end

	return quote, quote_page, quote_pages, postscript;
end


--[[--------------------------&lt; C H E C K _ P U B L I S H E R _ N A M E &gt;--------------------------------------

look for variations of '&lt;text&gt;: &lt;text&gt;' that might be '&lt;location&gt;: &lt;publisher&gt;' in |publisher= parameter value.
when found, emit a maintenance message; return nil else

&lt;publisher&gt; is the value assigned to |publisher= or |institution=

]]

local function check_publisher_name (publisher)
	local patterns_t = {
		'^[%w%s]+%s*:%s*[%w%s]+$',												-- plain text &lt;location&gt;: &lt;publisher&gt;
		'^%[+[%w%s:|]+%]+%s*:%s*[%w%s]+$',										-- partially wikilinked [[&lt;location&gt;]]: &lt;publisher&gt;
		'^[%w%s]+%s*:%s*%[+[%w%s:|]+%]+$',										-- partially wikilinked &lt;location&gt;: [[&lt;publisher&gt;]]
		'^%[+[%w%s:|]+%]+%s*:%s*%[+[%w%s:|]+%]+$',								-- wikilinked [[&lt;location&gt;]]: [[&lt;publisher&gt;]]
		}
	
	for _, pattern in ipairs (patterns_t) do									-- spin through the patterns_t sequence
		if mw.ustring.match (publisher, pattern) then							-- does this pattern match?
			utilities.set_message ('maint_publisher_location');					-- set a maint message
			return;																-- and done
		end
	end
end


--[[--------------------------&lt; C I T A T I O N 0 &gt;------------------------------------------------------------

This is the main function doing the majority of the citation formatting.

]]

local function citation0( config, args )
	--[[ 
	Load Input Parameters
	The argument_wrapper facilitates the mapping of multiple aliases to single internal variable.
	]]
	local A = argument_wrapper ( args );
	local i 

	-- Pick out the relevant fields from the arguments.  Different citation templates
	-- define different field names for the same underlying things.	

	local author_etal;
	local a	= {};																-- authors list from |lastn= / |firstn= pairs or |vauthors=
	local Authors;
	local NameListStyle;
		if cfg.global_cs1_config_t['NameListStyle'] then						-- global setting in {{cs1 config}} overrides local |name-list-style= parameter value; nil when empty or assigned value invalid
			NameListStyle = is_valid_parameter_value (cfg.global_cs1_config_t['NameListStyle'], 'cs1 config: name-list-style', cfg.keywords_lists['name-list-style'], '');	-- error messaging 'param' here is a hoax
		else
			NameListStyle = is_valid_parameter_value (A['NameListStyle'], A:ORIGIN('NameListStyle'), cfg.keywords_lists['name-list-style'], '');
		end

		if cfg.global_cs1_config_t['NameListStyle'] and utilities.is_set (A['NameListStyle']) then	-- when template has |name-list-style=&lt;something&gt; which global setting has overridden
			utilities.set_message ('maint_overridden_setting');					-- set a maint message
		end

	local Collaboration = A['Collaboration'];

	do																			-- to limit scope of selected
		local selected = select_author_editor_source (A['Vauthors'], A['Authors'], args, 'AuthorList');
		if 1 == selected then
			a, author_etal = extract_names (args, 'AuthorList');				-- fetch author list from |authorn= / |lastn= / |firstn=, |author-linkn=, and |author-maskn=
		elseif 2 == selected then
			NameListStyle = 'vanc';												-- override whatever |name-list-style= might be
			a, author_etal = parse_vauthors_veditors (args, A['Vauthors'], 'AuthorList');	-- fetch author list from |vauthors=, |author-linkn=, and |author-maskn=
		elseif 3 == selected then
			Authors = A['Authors'];												-- use content of |people= or |credits=; |authors= is deprecated; TODO: constrain |people= and |credits= to cite av media, episode, serial?
		end
		if utilities.is_set (Collaboration) then
			author_etal = true;													-- so that |display-authors=etal not required
		end
	end

	local editor_etal;
	local e	= {};																-- editors list from |editor-lastn= / |editor-firstn= pairs or |veditors=

	do																			-- to limit scope of selected
		local selected = select_author_editor_source (A['Veditors'], nil, args, 'EditorList');	-- support for |editors= withdrawn
		if 1 == selected then
			e, editor_etal = extract_names (args, 'EditorList');				-- fetch editor list from |editorn= / |editor-lastn= / |editor-firstn=, |editor-linkn=, and |editor-maskn=
		elseif 2 == selected then
			NameListStyle = 'vanc';												-- override whatever |name-list-style= might be
			e, editor_etal = parse_vauthors_veditors (args, args.veditors, 'EditorList');	-- fetch editor list from |veditors=, |editor-linkn=, and |editor-maskn=
		end
	end
							
	local Chapter = A['Chapter'];												-- done here so that we have access to |contribution= from |chapter= aliases
	local Chapter_origin = A:ORIGIN ('Chapter');
	local Contribution;															-- because contribution is required for contributor(s)
		if 'contribution' == Chapter_origin then
			Contribution = Chapter;												-- get the name of the contribution
		end
	local c = {};																-- contributors list from |contributor-lastn= / contributor-firstn= pairs
	
	if utilities.in_array (config.CitationClass, {"book", "citation"}) and not utilities.is_set (A['Periodical']) then	-- |contributor= and |contribution= only supported in book cites
		c = extract_names (args, 'ContributorList');							-- fetch contributor list from |contributorn= / |contributor-lastn=, -firstn=, -linkn=, -maskn=
		
		if 0 &lt; #c then
			if not utilities.is_set (Contribution) then							-- |contributor= requires |contribution=
				utilities.set_message ('err_contributor_missing_required_param', 'contribution');	-- add missing contribution error message
				c = {};															-- blank the contributors' table; it is used as a flag later
			end
			if 0 == #a then														-- |contributor= requires |author=
				utilities.set_message ('err_contributor_missing_required_param', 'author');	-- add missing author error message
				c = {};															-- blank the contributors' table; it is used as a flag later
			end
		end
	else																		-- if not a book cite
		if utilities.select_one (args, cfg.aliases['ContributorList-Last'], 'err_redundant_parameters', 1 ) then	-- are there contributor name list parameters?
			utilities.set_message ('err_contributor_ignored');					-- add contributor ignored error message
		end
		Contribution = nil;														-- unset
	end

	local Title = A['Title'];
	local TitleLink = A['TitleLink'];

	local auto_select = '';														-- default is auto
	local accept_link;
	TitleLink, accept_link = utilities.has_accept_as_written (TitleLink, true);	-- test for accept-this-as-written markup
	if (not accept_link) and utilities.in_array (TitleLink, {'none', 'pmc', 'doi'}) then -- check for special keywords
		auto_select = TitleLink;												-- remember selection for later
		TitleLink = '';															-- treat as if |title-link= would have been empty
	end

	TitleLink = link_title_ok (TitleLink, A:ORIGIN ('TitleLink'), Title, 'title');	-- check for wiki-markup in |title-link= or wiki-markup in |title= when |title-link= is set

	local Section = '';															-- {{cite map}} only; preset to empty string for concatenation if not used
	if 'map' == config.CitationClass and 'section' == Chapter_origin then
		Section = A['Chapter'];													-- get |section= from |chapter= alias list; |chapter= and the other aliases not supported in {{cite map}}
		Chapter = '';															-- unset for now; will be reset later from |map= if present
	end

	local Periodical = A['Periodical'];
	local Periodical_origin = A:ORIGIN('Periodical');
	local ScriptPeriodical = A['ScriptPeriodical'];
	local ScriptPeriodical_origin = A:ORIGIN('ScriptPeriodical');
	local TransPeriodical =  A['TransPeriodical'];
	local TransPeriodical_origin =  A:ORIGIN ('TransPeriodical');
	
	if (utilities.in_array (config.CitationClass, {'book', 'encyclopaedia'}) and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical) or utilities.is_set (TransPeriodical))) then
		local param;
		if utilities.is_set (Periodical) then									-- get a parameter name from one of these periodical related meta-parameters
			Periodical = '';													-- unset because not valid {{cite book}} or {{cite encyclopedia}} parameters 
			param = Periodical_origin											-- get parameter name for error messaging
		elseif utilities.is_set (TransPeriodical) then
			TransPeriodical = '';												-- unset because not valid {{cite book}} or {{cite encyclopedia}} parameters 
			param = TransPeriodical_origin;										-- get parameter name for error messaging
		elseif utilities.is_set (ScriptPeriodical) then
			ScriptPeriodical = '';												-- unset because not valid {{cite book}} or {{cite encyclopedia}} parameters 
			param = ScriptPeriodical_origin;									-- get parameter name for error messaging
		end

		if utilities.is_set (param) then										-- if we found one
			utilities.set_message ('err_periodical_ignored', {param});			-- emit an error message
		end
	end

	if utilities.is_set (Periodical) then
		local i;
		Periodical, i = utilities.strip_apostrophe_markup (Periodical);			-- strip apostrophe markup so that metadata isn't contaminated 
		if i then																-- non-zero when markup was stripped so emit an error message
			utilities.set_message ('err_apostrophe_markup', {Periodical_origin});
		end
	end

	if 'mailinglist' == config.CitationClass then								-- special case for {{cite mailing list}}
		if utilities.is_set (Periodical) and utilities.is_set (A ['MailingList']) then	-- both set emit an error TODO: make a function for this and similar?
			utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', Periodical_origin) .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', 'mailinglist')});
		end

		Periodical = A ['MailingList'];											-- error or no, set Periodical to |mailinglist= value because this template is {{cite mailing list}}
		Periodical_origin = A:ORIGIN('MailingList');
	end

	-- web and news not tested for now because of 
	-- Wikipedia:Administrators%27_noticeboard#Is_there_a_semi-automated_tool_that_could_fix_these_annoying_"Cite_Web"_errors?
	if not (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) then	-- 'periodical' templates require periodical parameter
	--	local p = {['journal'] = 'journal', ['magazine'] = 'magazine', ['news'] = 'newspaper', ['web'] = 'website'};	-- for error message
		local p = {['journal'] = 'journal', ['magazine'] = 'magazine'};			-- for error message
		if p[config.CitationClass]  then
			utilities.set_message ('err_missing_periodical', {config.CitationClass, p[config.CitationClass]});
		end
	end
	
	local Volume;
	if 'citation' == config.CitationClass then
		if utilities.is_set (Periodical) then
			if not utilities.in_array (Periodical_origin, cfg.citation_no_volume_t) then	-- {{citation}} does not render |volume= when these parameters are used
				Volume = A['Volume'];											-- but does for all other 'periodicals'
			end
		elseif utilities.is_set (ScriptPeriodical) then
			if 'script-website' ~= ScriptPeriodical_origin then					-- {{citation}} does not render volume for |script-website=
				Volume = A['Volume'];											-- but does for all other 'periodicals'
			end
		else
			Volume = A['Volume'];												-- and does for non-'periodical' cites
		end
	elseif utilities.in_array (config.CitationClass, cfg.templates_using_volume) then	-- render |volume= for cs1 according to the configuration settings
		Volume = A['Volume'];
	end	
	extra_text_in_vol_iss_check (Volume, A:ORIGIN ('Volume'), 'v');	

	local Issue;
	if 'citation' == config.CitationClass then
		if utilities.is_set (Periodical) and utilities.in_array (Periodical_origin, cfg.citation_issue_t) then	-- {{citation}} may render |issue= when these parameters are used
			Issue = utilities.hyphen_to_dash (A['Issue']);
		end
	elseif utilities.in_array (config.CitationClass, cfg.templates_using_issue) then	-- conference &amp; map books do not support issue; {{citation}} listed here because included in settings table
		if not (utilities.in_array (config.CitationClass, {'conference', 'map', 'citation'}) and not (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical))) then
			Issue = utilities.hyphen_to_dash (A['Issue']);
		end
	end
	
	local ArticleNumber;

	if utilities.in_array (config.CitationClass, {'journal', 'conference'}) or ('citation' == config.CitationClass and utilities.is_set (Periodical) and 'journal' == Periodical_origin) then
		ArticleNumber = A['ArticleNumber'];
	end

	extra_text_in_vol_iss_check (Issue, A:ORIGIN ('Issue'), 'i');	

	local Page;
	local Pages;
	local At;
	local QuotePage;
	local QuotePages;
	if not utilities.in_array (config.CitationClass, cfg.templates_not_using_page) then		-- TODO: rewrite to emit ignored parameter error message?
		Page = A['Page'];
		Pages = utilities.hyphen_to_dash (A['Pages']);	
		At = A['At'];
		QuotePage = A['QuotePage'];
		QuotePages = utilities.hyphen_to_dash (A['QuotePages']);
	end

	local NoPP = is_valid_parameter_value (A['NoPP'], A:ORIGIN('NoPP'), cfg.keywords_lists['yes_true_y'], nil);

	local Mode = mode_set (A['Mode'], A:ORIGIN('Mode'));

	-- separator character and postscript
	local sepc, PostScript = set_style (Mode:lower(), A['PostScript'], config.CitationClass);
	local Quote;
	Quote, QuotePage, QuotePages, PostScript = quote_make (A['Quote'], A['TransQuote'], A['ScriptQuote'], QuotePage, QuotePages, NoPP, sepc, PostScript);

	local Edition = A['Edition'];
	local PublicationPlace = place_check (A['PublicationPlace'], A:ORIGIN('PublicationPlace'));
	local Place = place_check (A['Place'], A:ORIGIN('Place'));
	
	local PublisherName = A['PublisherName'];
	local PublisherName_origin = A:ORIGIN('PublisherName');
	if utilities.is_set (PublisherName) and (cfg.keywords_xlate['none'] ~= PublisherName) then
		local i = 0;
		PublisherName, i = utilities.strip_apostrophe_markup (PublisherName);	-- strip apostrophe markup so that metadata isn't contaminated; publisher is never italicized
		if i and (0 &lt; i) then													-- non-zero when markup was stripped so emit an error message
			utilities.set_message ('err_apostrophe_markup', {PublisherName_origin});
		end
	end
	
	if ('document' == config.CitationClass) and not utilities.is_set (PublisherName) then
		utilities.set_message ('err_missing_publisher', {config.CitationClass, 'publisher'});
	end

	local Newsgroup = A['Newsgroup'];											-- TODO: strip apostrophe markup?
	local Newsgroup_origin = A:ORIGIN('Newsgroup');	

	if 'newsgroup' == config.CitationClass then
		if utilities.is_set (PublisherName) and (cfg.keywords_xlate['none'] ~= PublisherName) then	-- general use parameter |publisher= not allowed in cite newsgroup
			utilities.set_message ('err_parameter_ignored', {PublisherName_origin});
		end

		PublisherName = nil;													-- ensure that this parameter is unset for the time being; will be used again after COinS
	end

	if 'book' == config.CitationClass or 'encyclopaedia' == config.CitationClass or ('citation' == config.CitationClass and not utilities.is_set (Periodical)) then
		local accept;
		PublisherName, accept = utilities.has_accept_as_written (PublisherName);	-- check for and remove accept-as-written markup from |publisher= wrapped
		if not accept then														-- when no accept-as-written markup
			check_publisher_name (PublisherName);								-- emit maint message when |publisher= might be prefixed with publisher's location
		end
	end

	local URL = A['URL'];														-- TODO: better way to do this for URL, ChapterURL, and MapURL?
	local UrlAccess = is_valid_parameter_value (A['UrlAccess'], A:ORIGIN('UrlAccess'), cfg.keywords_lists['url-access'], nil);
	
	if not utilities.is_set (URL) and utilities.is_set (UrlAccess) then
		UrlAccess = nil;
		utilities.set_message ('err_param_access_requires_param', 'url');
	end
	
	local ChapterURL = A['ChapterURL'];
	local ChapterUrlAccess = is_valid_parameter_value (A['ChapterUrlAccess'], A:ORIGIN('ChapterUrlAccess'), cfg.keywords_lists['url-access'], nil);
	if not utilities.is_set (ChapterURL) and utilities.is_set (ChapterUrlAccess) then
		ChapterUrlAccess = nil;
		utilities.set_message ('err_param_access_requires_param', {A:ORIGIN('ChapterUrlAccess'):gsub ('%-access', '')});
	end

	local MapUrlAccess = is_valid_parameter_value (A['MapUrlAccess'], A:ORIGIN('MapUrlAccess'), cfg.keywords_lists['url-access'], nil);
	if not utilities.is_set (A['MapURL']) and utilities.is_set (MapUrlAccess) then
		MapUrlAccess = nil;
		utilities.set_message ('err_param_access_requires_param', {'map-url'});
	end

	local this_page = mw.title.getCurrentTitle();								-- also used for COinS and for language
	local no_tracking_cats = is_valid_parameter_value (A['NoTracking'], A:ORIGIN('NoTracking'), cfg.keywords_lists['yes_true_y'], nil);

	-- check this page to see if it is in one of the namespaces that cs1 is not supposed to add to the error categories
	if not utilities.is_set (no_tracking_cats) then								-- ignore if we are already not going to categorize this page
		if cfg.uncategorized_namespaces[this_page.namespace] then				-- is this page's namespace id one of the uncategorized namespace ids?
			no_tracking_cats = "true";											-- set no_tracking_cats
		end
		for _, v in ipairs (cfg.uncategorized_subpages) do						-- cycle through page name patterns
			if this_page.text:match (v) then									-- test page name against each pattern
				no_tracking_cats = "true";										-- set no_tracking_cats
				break;															-- bail out if one is found
			end
		end
	end
																				-- check for extra |page=, |pages= or |at= parameters. (also sheet and sheets while we're at it)
	utilities.select_one (args, {'page', 'p', 'pp', 'pages', 'at', 'sheet', 'sheets'}, 'err_redundant_parameters');	-- this is a dummy call simply to get the error message and category

	local coins_pages;
	
	Page, Pages, At, coins_pages = insource_loc_get (Page, A:ORIGIN('Page'), Pages, A:ORIGIN('Pages'), At);

	if utilities.is_set (PublicationPlace) and utilities.is_set (Place) then	-- both |publication-place= and |place= (|location=) allowed if different
		utilities.add_prop_cat ('location-test');								-- add property cat to evaluate how often PublicationPlace and Place are used together
		if PublicationPlace == Place then
			Place = '';															-- unset; don't need both if they are the same
		end
	elseif not utilities.is_set (PublicationPlace) and utilities.is_set (Place) then	-- when only |place= (|location=) is set ...
		PublicationPlace = Place;												-- promote |place= (|location=) to |publication-place
	end

	if PublicationPlace == Place then Place = ''; end							-- don't need both if they are the same

	local URL_origin = A:ORIGIN('URL');											-- get name of parameter that holds URL
	local ChapterURL_origin = A:ORIGIN('ChapterURL');							-- get name of parameter that holds ChapterURL
	local ScriptChapter = A['ScriptChapter'];
	local ScriptChapter_origin = A:ORIGIN ('ScriptChapter');
	local Format = A['Format'];
	local ChapterFormat = A['ChapterFormat'];
	local TransChapter = A['TransChapter'];
	local TransChapter_origin = A:ORIGIN ('TransChapter');
	local TransTitle = A['TransTitle'];
	local ScriptTitle = A['ScriptTitle'];
	
	--[[
	Parameter remapping for cite encyclopedia:
	When the citation has these parameters:
		|encyclopedia= and |title= then map |title= to |article= and |encyclopedia= to |title= for rendering
		|encyclopedia= and |article= then map |encyclopedia= to |title= for rendering

		|trans-title= maps to |trans-chapter= when |title= is re-mapped
		|url= maps to |chapter-url= when |title= is remapped
	
	All other combinations of |encyclopedia=, |title=, and |article= are not modified
	
	]]

	local Encyclopedia = A['Encyclopedia'];										-- used as a flag by this module and by ~/COinS
	local ScriptEncyclopedia = A['ScriptEncyclopedia'];
	local TransEncyclopedia = A['TransEncyclopedia'];

	if utilities.is_set (Encyclopedia) or utilities.is_set (ScriptEncyclopedia) then	-- emit error message when Encyclopedia set but template is other than {{cite encyclopedia}} or {{citation}}
		if 'encyclopaedia' ~= config.CitationClass and 'citation' ~= config.CitationClass then
			if utilities.is_set (Encyclopedia) then
				utilities.set_message ('err_parameter_ignored', {A:ORIGIN ('Encyclopedia')});
			else
				utilities.set_message ('err_parameter_ignored', {A:ORIGIN ('ScriptEncyclopedia')});
			end
			Encyclopedia = nil;													-- unset these because not supported by this template
			ScriptEncyclopedia = nil;
			TransEncyclopedia = nil;
		end
	elseif utilities.is_set (TransEncyclopedia) then
		utilities.set_message ('err_trans_missing_title', {'encyclopedia'});
	end

	if ('encyclopaedia' == config.CitationClass) or ('citation' == config.CitationClass and utilities.is_set (Encyclopedia)) then
		if utilities.is_set (Periodical) and utilities.is_set (Encyclopedia) then	-- when both parameters set emit an error message; {{citation}} only; Periodical not allowed in {{cite encyclopedia}}
			utilities.set_message ('err_periodical_ignored', {Periodical_origin});
		end

		if utilities.is_set (Encyclopedia) or utilities.is_set (ScriptEncyclopedia) then
			Periodical = Encyclopedia;											-- error or no, set Periodical to Encyclopedia for rendering; {{citation}} could (not legitimately) have both; use Encyclopedia
			Periodical_origin = A:ORIGIN ('Encyclopedia');
			ScriptPeriodical = ScriptEncyclopedia;
			ScriptPeriodical_origin = A:ORIGIN ('ScriptEncyclopedia');

			if utilities.is_set (Title) or utilities.is_set (ScriptTitle) then
				if not utilities.is_set (Chapter) then
					Chapter = Title;											-- |encyclopedia= and |title= are set so map |title= params to |article= params for rendering
					ScriptChapter = ScriptTitle;
					ScriptChapter_origin = A:ORIGIN('ScriptTitle')
					TransChapter = TransTitle;
					ChapterURL = URL;
					ChapterURL_origin = URL_origin;
					ChapterUrlAccess = UrlAccess;
					ChapterFormat = Format;

					if not utilities.is_set (ChapterURL) and utilities.is_set (TitleLink) then
						Chapter = utilities.make_wikilink (TitleLink, Chapter);
					end
					Title = Periodical;											-- now map |encyclopedia= params to |title= params for rendering
					ScriptTitle = ScriptPeriodical or '';
					TransTitle = TransEncyclopedia or '';
					Periodical = '';											-- redundant so unset
					ScriptPeriodical = '';
					URL = '';
					Format = '';
					TitleLink = '';
				end
			elseif utilities.is_set (Chapter) or utilities.is_set (ScriptChapter) then	-- |title= not set
				Title = Periodical;												-- |encyclopedia= set and |article= set so map |encyclopedia= to |title= for rendering
				ScriptTitle = ScriptPeriodical or '';
				TransTitle = TransEncyclopedia or '';
				Periodical = '';												-- redundant so unset
				ScriptPeriodical = '';
			end
		end
	end

	-- special case for cite techreport.
	local ID = A['ID'];
	if (config.CitationClass == "techreport") then								-- special case for cite techreport
		if utilities.is_set (A['Number']) then									-- cite techreport uses 'number', which other citations alias to 'issue'
			if not utilities.is_set (ID) then									-- can we use ID for the "number"?
				ID = A['Number'];												-- yes, use it
			else																-- ID has a value so emit error message
				utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', 'id') .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', 'number')});
			end
		end	
	end

	-- Account for the oddity that is {{cite conference}}, before generation of COinS data.
	local ChapterLink -- = A['ChapterLink'];									-- deprecated as a parameter but still used internally by cite episode
	local Conference = A['Conference'];
	local BookTitle = A['BookTitle'];
	local TransTitle_origin = A:ORIGIN ('TransTitle');
	if 'conference' == config.CitationClass then
		if utilities.is_set (BookTitle) then
			Chapter = Title;
			Chapter_origin = 'title';
	--		ChapterLink = TitleLink;											-- |chapter-link= is deprecated
			ChapterURL = URL;
			ChapterUrlAccess = UrlAccess;
			ChapterURL_origin = URL_origin;
			URL_origin = '';
			ChapterFormat = Format;
			TransChapter = TransTitle;
			TransChapter_origin = TransTitle_origin;
			Title = BookTitle;
			Format = '';
	--		TitleLink = '';
			TransTitle = '';
			URL = '';
		end
	elseif 'speech' ~= config.CitationClass then
		Conference = '';														-- not cite conference or cite speech so make sure this is empty string
	end
	
	local use_lowercase = ( sepc == ',' );										-- controls capitalization of certain static text
	
	-- cite map oddities
	local Cartography = "";
	local Scale = "";
	local Sheet = A['Sheet'] or '';
	local Sheets = A['Sheets'] or '';
	if config.CitationClass == "map" then
		if utilities.is_set (Chapter) then										--TODO: make a function for this and similar?
			utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', 'map') .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', Chapter_origin)});	-- add error message
		end
		Chapter = A['Map'];
		Chapter_origin = A:ORIGIN('Map');
		ChapterURL = A['MapURL'];
		ChapterURL_origin = A:ORIGIN('MapURL');
		TransChapter = A['TransMap'];
		ScriptChapter = A['ScriptMap']
		ScriptChapter_origin = A:ORIGIN('ScriptMap')

		ChapterUrlAccess = MapUrlAccess;
		ChapterFormat = A['MapFormat'];

		Cartography = A['Cartography'];
		if utilities.is_set ( Cartography ) then
			Cartography = sepc .. " " .. wrap_msg ('cartography', Cartography, use_lowercase);
		end		
		Scale = A['Scale'];
		if utilities.is_set ( Scale ) then
			Scale = sepc .. " " .. Scale;
		end
	end

	-- Account for the oddities that are {{cite episode}} and {{cite serial}}, before generation of COinS data.
	local Series = A['Series'];
	if 'episode' == config.CitationClass or 'serial' == config.CitationClass then
		local SeriesLink = A['SeriesLink'];

		SeriesLink = link_title_ok (SeriesLink, A:ORIGIN ('SeriesLink'), Series, 'series');	-- check for wiki-markup in |series-link= or wiki-markup in |series= when |series-link= is set

		local Network = A['Network'];
		local Station = A['Station'];
		local s, n = {}, {};
																				-- do common parameters first
		if utilities.is_set (Network) then table.insert(n, Network); end
		if utilities.is_set (Station) then table.insert(n, Station); end
		ID = table.concat(n, sepc .. ' ');
		
		if 'episode' == config.CitationClass then								-- handle the oddities that are strictly {{cite episode}}
			local Season = A['Season'];
			local SeriesNumber = A['SeriesNumber'];

			if utilities.is_set (Season) and utilities.is_set (SeriesNumber) then	-- these are mutually exclusive so if both are set TODO: make a function for this and similar?
				utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', 'season') .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', 'seriesno')});		-- add error message
				SeriesNumber = '';												-- unset; prefer |season= over |seriesno=
			end
																				-- assemble a table of parts concatenated later into Series
			if utilities.is_set (Season) then table.insert(s, wrap_msg ('season', Season, use_lowercase)); end
			if utilities.is_set (SeriesNumber) then table.insert(s, wrap_msg ('seriesnum', SeriesNumber, use_lowercase)); end
			if utilities.is_set (Issue) then table.insert(s, wrap_msg ('episode', Issue, use_lowercase)); end
			Issue = '';															-- unset because this is not a unique parameter
	
			Chapter = Title;													-- promote title parameters to chapter
			ScriptChapter = ScriptTitle;
			ScriptChapter_origin = A:ORIGIN('ScriptTitle');
			ChapterLink = TitleLink;											-- alias |episode-link=
			TransChapter = TransTitle;
			ChapterURL = URL;
			ChapterUrlAccess = UrlAccess;
			ChapterURL_origin = URL_origin;
			ChapterFormat = Format;

			Title = Series;														-- promote series to title
			TitleLink = SeriesLink;
			Series = table.concat(s, sepc .. ' ');								-- this is concatenation of season, seriesno, episode number

			if utilities.is_set (ChapterLink) and not utilities.is_set (ChapterURL) then	-- link but not URL
				Chapter = utilities.make_wikilink (ChapterLink, Chapter);
			elseif utilities.is_set (ChapterLink) and utilities.is_set (ChapterURL) then	-- if both are set, URL links episode;
				Series = utilities.make_wikilink (ChapterLink, Series);
			end
			URL = '';															-- unset
			TransTitle = '';
			ScriptTitle = '';
			Format = '';
			
		else																	-- now oddities that are cite serial
			Issue = '';															-- unset because this parameter no longer supported by the citation/core version of cite serial
			Chapter = A['Episode'];												-- TODO: make |episode= available to cite episode someday?
			if utilities.is_set (Series) and utilities.is_set (SeriesLink) then
				Series = utilities.make_wikilink (SeriesLink, Series);
			end
			Series = utilities.wrap_style ('italic-title', Series);				-- series is italicized
		end	
	end
	-- end of {{cite episode}} stuff

	-- handle type parameter for those CS1 citations that have default values
	local TitleType = A['TitleType'];
	local Degree = A['Degree'];
	if utilities.in_array (config.CitationClass, {'AV-media-notes', 'document', 'interview', 'mailinglist', 'map', 'podcast', 'pressrelease', 'report', 'speech', 'techreport', 'thesis'}) then
		TitleType = set_titletype (config.CitationClass, TitleType);
		if utilities.is_set (Degree) and "Thesis" == TitleType then				-- special case for cite thesis
			TitleType = Degree .. ' ' .. cfg.title_types ['thesis']:lower();
		end
	end

	if utilities.is_set (TitleType) then										-- if type parameter is specified
		TitleType = utilities.substitute ( cfg.messages['type'], TitleType);	-- display it in parentheses
	-- TODO: Hack on TitleType to fix bunched parentheses problem
	end

	-- legacy: promote PublicationDate to Date if neither Date nor Year are set.
	local Date = A['Date'];
 	local Date_origin;															-- to hold the name of parameter promoted to Date; required for date error messaging
	local PublicationDate = A['PublicationDate'];
	local Year = A['Year'];

	if utilities.is_set (Year) then
		validation.year_check (Year);											-- returns nothing; emits maint message when |year= doesn't hold a 'year' value
	end
		
	if not utilities.is_set (Date) then
		Date = Year;															-- promote Year to Date
		Year = nil;																-- make nil so Year as empty string isn't used for CITEREF
		if not utilities.is_set (Date) and utilities.is_set (PublicationDate) then	-- use PublicationDate when |date= and |year= are not set
			Date = PublicationDate;												-- promote PublicationDate to Date
			PublicationDate = '';												-- unset, no longer needed
			Date_origin = A:ORIGIN('PublicationDate');							-- save the name of the promoted parameter
		else
			Date_origin = A:ORIGIN('Year');										-- save the name of the promoted parameter
		end
	else
		Date_origin = A:ORIGIN('Date');											-- not a promotion; name required for error messaging
	end

	if PublicationDate == Date then PublicationDate = ''; end					-- if PublicationDate is same as Date, don't display in rendered citation

	--[[
	Go test all of the date-holding parameters for valid MOS:DATE format and make sure that dates are real dates. This must be done before we do COinS because here is where
	we get the date used in the metadata.
	
	Date validation supporting code is in Module:Citation/CS1/Date_validation
	]]

	local DF = is_valid_parameter_value (A['DF'], A:ORIGIN('DF'), cfg.keywords_lists['df'], '');
	if not utilities.is_set (DF) then
		DF = cfg.global_df;														-- local |df= if present overrides global df set by {{use xxx date}} template
	end

	local ArchiveURL;
	local ArchiveDate;
	local ArchiveFormat = A['ArchiveFormat'];
	local archive_url_timestamp;												-- timestamp from wayback machine url
	
	ArchiveURL, ArchiveDate, archive_url_timestamp = archive_url_check (A['ArchiveURL'], A['ArchiveDate'])
	ArchiveFormat = style_format (ArchiveFormat, ArchiveURL, 'archive-format', 'archive-url');
	
	ArchiveURL, ArchiveDate = is_unique_archive_url (ArchiveURL, URL, ChapterURL, A:ORIGIN('ArchiveURL'), ArchiveDate);		-- add error message when URL or ChapterURL == ArchiveURL

	local AccessDate = A['AccessDate'];
	local COinS_date = {};														-- holds date info extracted from |date= for the COinS metadata by Module:Date verification
	local DoiBroken = A['DoiBroken'];
	local Embargo = A['Embargo'];
	local anchor_year;															-- used in the CITEREF identifier
	do	-- create defined block to contain local variables error_message, date_parameters_list, mismatch
		local error_message = '';
																				-- AirDate has been promoted to Date so not necessary to check it
		local date_parameters_list = {
			['access-date'] = {val = AccessDate, name = A:ORIGIN ('AccessDate')},
			['archive-date'] = {val = ArchiveDate, name = A:ORIGIN ('ArchiveDate')},
			['date'] = {val = Date, name = Date_origin},
			['doi-broken-date'] = {val = DoiBroken, name = A:ORIGIN ('DoiBroken')},
			['pmc-embargo-date'] = {val = Embargo, name = A:ORIGIN ('Embargo')},
			['publication-date'] = {val = PublicationDate, name = A:ORIGIN ('PublicationDate')},
			['year'] = {val = Year, name = A:ORIGIN ('Year')},
			};

		local error_list = {};
		anchor_year, Embargo = validation.dates(date_parameters_list, COinS_date, error_list);

		if utilities.is_set (Year) and utilities.is_set (Date) then				-- both |date= and |year= not normally needed; 
			validation.year_date_check (Year, A:ORIGIN ('Year'), Date, A:ORIGIN ('Date'), error_list);
		end

		if 0 == #error_list then												-- error free dates only; 0 when error_list is empty
			local modified = false;												-- flag
			
			if utilities.is_set (DF) then										-- if we need to reformat dates
				modified = validation.reformat_dates (date_parameters_list, DF);	-- reformat to DF format, use long month names if appropriate
			end

			if true == validation.date_hyphen_to_dash (date_parameters_list) then	-- convert hyphens to dashes where appropriate
				modified = true;
				utilities.set_message ('maint_date_format');					-- hyphens were converted so add maint category
			end
			
	-- for those wikis that can and want to have English date names translated to the local language; not supported at en.wiki
			if cfg.date_name_auto_xlate_enable and validation.date_name_xlate (date_parameters_list, cfg.date_digit_auto_xlate_enable ) then
				utilities.set_message ('maint_date_auto_xlated');				-- add maint cat
				modified = true;
			end

			if modified then													-- if the date_parameters_list values were modified
				AccessDate = date_parameters_list['access-date'].val;			-- overwrite date holding parameters with modified values
				ArchiveDate = date_parameters_list['archive-date'].val;
				Date = date_parameters_list['date'].val;
				DoiBroken = date_parameters_list['doi-broken-date'].val;
				PublicationDate = date_parameters_list['publication-date'].val;
			end

			if archive_url_timestamp and utilities.is_set (ArchiveDate) then
				validation.archive_date_check (ArchiveDate, archive_url_timestamp, DF);	-- does YYYYMMDD in archive_url_timestamp match date in ArchiveDate
			end
		else
			utilities.set_message ('err_bad_date', {utilities.make_sep_list (#error_list, error_list)});	-- add this error message
		end
	end	-- end of do

	if utilities.in_array (config.CitationClass, {'book', 'encyclopaedia'}) or	-- {{cite book}}, {{cite encyclopedia}}; TODO: {{cite conference}} and others?
		('citation' == config.CitationClass and utilities.is_set (Encyclopedia)) or			-- {{citation}} as an encylopedia citation
		('citation' == config.CitationClass and not utilities.is_set (Periodical)) then		-- {{citation}} as a book citation
			if utilities.is_set (PublicationPlace) then
				if not utilities.is_set (PublisherName) then
					local date = COinS_date.rftdate and tonumber (COinS_date.rftdate:match ('%d%d%d%d'));	-- get year portion of COinS date (because in Arabic numerals); convert string to number
					if date and (1850 &lt;= date) then								-- location has no publisher; if date is 1850 or later
						utilities.set_message ('maint_location_no_publisher');	-- add maint cat
					end
				else															-- PublisherName has a value
					if cfg.keywords_xlate['none'] == PublisherName then			-- if that value is 'none' (only for book and encyclopedia citations)
						PublisherName = '';										-- unset
					end
				end
			end
	end

	local ID_list = {};															-- sequence table of rendered identifiers
	local ID_list_coins = {};													-- table of identifiers and their values from args; key is same as cfg.id_handlers's key
	local Class = A['Class'];													-- arxiv class identifier
	
	local ID_support = {
		{A['ASINTLD'], 'ASIN', 'err_asintld_missing_asin', A:ORIGIN ('ASINTLD')},				
		{DoiBroken, 'DOI', 'err_doibroken_missing_doi', A:ORIGIN ('DoiBroken')},
		{Embargo, 'PMC', 'err_embargo_missing_pmc', A:ORIGIN ('Embargo')},
		}

	ID_list, ID_list_coins = identifiers.identifier_lists_get (args, {DoiBroken = DoiBroken, ASINTLD = A['ASINTLD'], Embargo = Embargo, Class = Class, Year=anchor_year}, ID_support);

	-- Account for the oddities that are {{cite arxiv}}, {{cite biorxiv}}, {{cite citeseerx}}, {{cite medrxiv}}, {{cite ssrn}}, before generation of COinS data.
	if utilities.in_array (config.CitationClass, whitelist.preprint_template_list_t) then	-- |arxiv= or |eprint= required for cite arxiv; |biorxiv=, |citeseerx=, |medrxiv=, |ssrn= required for their templates
		if not (args[cfg.id_handlers[config.CitationClass:upper()].parameters[1]] or 		-- can't use ID_list_coins k/v table here because invalid parameters omitted
			args[cfg.id_handlers[config.CitationClass:upper()].parameters[2]]) then			-- which causes unexpected parameter missing error message
				utilities.set_message ('err_' .. config.CitationClass .. '_missing');		-- add error message
		end

		Periodical = ({['arxiv'] = 'arXiv', ['biorxiv'] = 'bioRxiv', ['citeseerx'] = 'CiteSeerX', ['medrxiv'] = 'medRxiv', ['ssrn'] = 'Social Science Research Network'})[config.CitationClass];
	end

	-- Link the title of the work if no |url= was provided, but we have a |pmc= or a |doi= with |doi-access=free

	if config.CitationClass == "journal" and not utilities.is_set (URL) and not utilities.is_set (TitleLink) and not utilities.in_array (cfg.keywords_xlate[Title], {'off', 'none'}) then -- TODO: remove 'none' once existing citations have been switched to 'off', so 'none' can be used as token for "no title" instead
		if 'none' ~= cfg.keywords_xlate[auto_select] then						-- if auto-linking not disabled
 	 		if identifiers.auto_link_urls[auto_select] then						-- manual selection
		 		URL = identifiers.auto_link_urls[auto_select];					-- set URL to be the same as identifier's external link
 				URL_origin = cfg.id_handlers[auto_select:upper()].parameters[1];	-- set URL_origin to parameter name for use in error message if citation is missing a |title=
			elseif identifiers.auto_link_urls['pmc'] then						-- auto-select PMC
				URL = identifiers.auto_link_urls['pmc'];						-- set URL to be the same as the PMC external link if not embargoed
				URL_origin = cfg.id_handlers['PMC'].parameters[1];				-- set URL_origin to parameter name for use in error message if citation is missing a |title=
			elseif identifiers.auto_link_urls['doi'] then						-- auto-select DOI
				URL = identifiers.auto_link_urls['doi'];
				URL_origin = cfg.id_handlers['DOI'].parameters[1];
			end
 	 	end

		if utilities.is_set (URL) then											-- set when using an identifier-created URL
			if utilities.is_set (AccessDate) then								-- |access-date= requires |url=; identifier-created URL is not |url=
				utilities.set_message ('err_accessdate_missing_url');			-- add an error message
				AccessDate = '';												-- unset
			end

			if utilities.is_set (ArchiveURL) then								-- |archive-url= requires |url=; identifier-created URL is not |url=
				utilities.set_message ('err_archive_missing_url');				-- add an error message
				ArchiveURL = '';												-- unset
			end
		end
	end

	-- At this point fields may be nil if they weren't specified in the template use.  We can use that fact.
	-- Test if citation has no title
	if	not utilities.is_set (Title) and not utilities.is_set (TransTitle) and not utilities.is_set (ScriptTitle) then	-- has special case for cite episode
		utilities.set_message ('err_citation_missing_title', {'episode' == config.CitationClass and 'series' or 'title'});
	end

	if utilities.in_array (cfg.keywords_xlate[Title], {'off', 'none'}) and
			utilities.in_array (config.CitationClass, {'journal', 'citation'}) and
			(utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) and
			('journal' == Periodical_origin or 'script-journal' == ScriptPeriodical_origin) then	-- special case for journal cites
				Title = '';														-- set title to empty string
				utilities.set_message ('maint_untitled');						-- add maint cat
	end

	-- COinS metadata (see &lt;http://ocoins.info/&gt;) for automated parsing of citation information.
	-- handle the oddity that is cite encyclopedia and {{citation |encyclopedia=something}}. Here we presume that
	-- when Periodical, Title, and Chapter are all set, then Periodical is the book (encyclopedia) title, Title
	-- is the article title, and Chapter is a section within the article.  So, we remap 
	
	local coins_chapter = Chapter;												-- default assuming that remapping not required
	local coins_title = Title;													-- et tu
	if 'encyclopaedia' == config.CitationClass or ('citation' == config.CitationClass and utilities.is_set (Encyclopedia)) then
		if utilities.is_set (Chapter) and utilities.is_set (Title) and utilities.is_set (Periodical) then		-- if all are used then
			coins_chapter = Title;												-- remap
			coins_title = Periodical;
		end
	end
	local coins_author = a;														-- default for coins rft.au 
	if 0 &lt; #c then																-- but if contributor list
		coins_author = c;														-- use that instead
	end
	
	-- this is the function call to COinS()
	local OCinSoutput = metadata.COinS({
		['Periodical'] = utilities.strip_apostrophe_markup (Periodical),		-- no markup in the metadata
		['Encyclopedia'] = Encyclopedia,										-- just a flag; content ignored by ~/COinS
		['Chapter'] = metadata.make_coins_title (coins_chapter, ScriptChapter),	-- Chapter and ScriptChapter stripped of bold / italic / accept-as-written markup
		['Degree'] = Degree;													-- cite thesis only
		['Title'] = metadata.make_coins_title (coins_title, ScriptTitle),		-- Title and ScriptTitle stripped of bold / italic / accept-as-written markup
		['PublicationPlace'] = PublicationPlace,
		['Date'] = COinS_date.rftdate,											-- COinS_date.* has correctly formatted date values if Date is valid;
		['Season'] = COinS_date.rftssn,
		['Quarter'] = COinS_date.rftquarter,
		['Chron'] =  COinS_date.rftchron,
		['Series'] = Series,
		['Volume'] = Volume,
		['Issue'] = Issue,
		['ArticleNumber'] = ArticleNumber,
		['Pages'] = coins_pages or metadata.get_coins_pages (first_set ({Sheet, Sheets, Page, Pages, At, QuotePage, QuotePages}, 7)),	-- pages stripped of external links
		['Edition'] = Edition,
		['PublisherName'] = PublisherName or Newsgroup,							-- any apostrophe markup already removed from PublisherName
		['URL'] = first_set ({ChapterURL, URL}, 2),
		['Authors'] = coins_author,
		['ID_list'] = ID_list_coins,
		['RawPage'] = this_page.prefixedText,
	}, config.CitationClass);

	-- Account for the oddities that are {{cite arxiv}}, {{cite biorxiv}}, {{cite citeseerx}}, {{cite medrxiv}}, and {{cite ssrn}} AFTER generation of COinS data.
	if utilities.in_array (config.CitationClass, whitelist.preprint_template_list_t) then	-- we have set rft.jtitle in COinS to arXiv, bioRxiv, CiteSeerX, medRxiv, or ssrn now unset so it isn't displayed
		Periodical = '';														-- periodical not allowed in these templates; if article has been published, use cite journal
	end

	-- special case for cite newsgroup.  Do this after COinS because we are modifying Publishername to include some static text
	if 'newsgroup' == config.CitationClass and utilities.is_set (Newsgroup) then
		PublisherName = utilities.substitute (cfg.messages['newsgroup'], external_link( 'news:' .. Newsgroup, Newsgroup, Newsgroup_origin, nil ));
	end

	local Editors;
	local EditorCount;															-- used only for choosing {ed.) or (eds.) annotation at end of editor name-list
	local Contributors;															-- assembled contributors name list
	local contributor_etal;
	local Translators;															-- assembled translators name list
	local translator_etal;
	local t = {};																-- translators list from |translator-lastn= / translator-firstn= pairs
	t = extract_names (args, 'TranslatorList');									-- fetch translator list from |translatorn= / |translator-lastn=, -firstn=, -linkn=, -maskn=
	local Interviewers;															
	local interviewers_list = {};					
	interviewers_list = extract_names (args, 'InterviewerList');				-- process preferred interviewers parameters
	local interviewer_etal;
	
	-- Now perform various field substitutions.
	-- We also add leading spaces and surrounding markup and punctuation to the
	-- various parts of the citation, but only when they are non-nil.
	do
		local last_first_list;
		local control = { 
			format = NameListStyle,												-- empty string, '&amp;', 'amp', 'and', or 'vanc'
			maximum = nil,														-- as if display-authors or display-editors not set
			mode = Mode
		};

		do																		-- do editor name list first because the now unsupported coauthors used to modify control table
			local display_names, param = display_names_select (cfg.global_cs1_config_t['DisplayEditors'], A['DisplayEditors'], A:ORIGIN ('DisplayEditors'), #e);
			control.maximum, editor_etal = get_display_names (display_names, #e, 'editors', editor_etal, param);

			Editors, EditorCount = list_people (control, e, editor_etal);

			if 1 == EditorCount and (true == editor_etal or 1 &lt; #e) then		-- only one editor displayed but includes etal then 
				EditorCount = 2;												-- spoof to display (eds.) annotation
			end
		end
		do																		-- now do interviewers
			local display_names, param = display_names_select (cfg.global_cs1_config_t['DisplayInterviewers'], A['DisplayInterviewers'], A:ORIGIN ('DisplayInterviewers'), #interviewers_list);
			control.maximum, interviewer_etal = get_display_names (display_names, #interviewers_list, 'interviewers', interviewer_etal, param);

			Interviewers = list_people (control, interviewers_list, interviewer_etal);
		end
		do																		-- now do translators
			local display_names, param = display_names_select (cfg.global_cs1_config_t['DisplayTranslators'], A['DisplayTranslators'], A:ORIGIN ('DisplayTranslators'), #t);
			control.maximum, translator_etal = get_display_names (display_names, #t, 'translators', translator_etal, param);

			Translators = list_people (control, t, translator_etal);
		end
		do																		-- now do contributors
			local display_names, param = display_names_select (cfg.global_cs1_config_t['DisplayContributors'], A['DisplayContributors'], A:ORIGIN ('DisplayContributors'), #c);
			control.maximum, contributor_etal = get_display_names (display_names, #c, 'contributors', contributor_etal, param);

			Contributors = list_people (control, c, contributor_etal);
		end
		do																		-- now do authors
			local display_names, param = display_names_select (cfg.global_cs1_config_t['DisplayAuthors'], A['DisplayAuthors'], A:ORIGIN ('DisplayAuthors'), #a, author_etal);
			control.maximum, author_etal = get_display_names (display_names, #a, 'authors', author_etal, param);

			last_first_list = list_people (control, a, author_etal);

			if utilities.is_set (Authors) then
				Authors, author_etal = name_has_etal (Authors, author_etal, false, 'authors');	-- find and remove variations on et al.
				if author_etal then
					Authors = Authors .. ' ' .. cfg.messages['et al'];			-- add et al. to authors parameter
				end
			else
				Authors = last_first_list;										-- either an author name list or an empty string
			end
		end																		-- end of do
	
		if utilities.is_set (Authors) and utilities.is_set (Collaboration) then
			Authors = Authors .. ' (' .. Collaboration .. ')';					-- add collaboration after et al.
		end

	end

	local ConferenceFormat = A['ConferenceFormat'];
	local ConferenceURL = A['ConferenceURL'];
	ConferenceFormat = style_format (ConferenceFormat, ConferenceURL, 'conference-format', 'conference-url');
	Format = style_format (Format, URL, 'format', 'url');

	-- special case for chapter format so no error message or cat when chapter not supported
	if not (utilities.in_array (config.CitationClass, {'web', 'news', 'journal', 'magazine', 'pressrelease', 'podcast', 'newsgroup', 'arxiv', 'biorxiv', 'citeseerx', 'medrxiv', 'ssrn'}) or
		('citation' == config.CitationClass and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) and not utilities.is_set (Encyclopedia))) then
			ChapterFormat = style_format (ChapterFormat, ChapterURL, 'chapter-format', 'chapter-url');
	end

	if not utilities.is_set (URL) then
		if utilities.in_array (config.CitationClass, {"web", "podcast", "mailinglist"}) or		-- |url= required for cite web, cite podcast, and cite mailinglist
			('citation' == config.CitationClass and ('website' == Periodical_origin or 'script-website' == ScriptPeriodical_origin)) then	-- and required for {{citation}} with |website= or |script-website=
				utilities.set_message ('err_cite_web_url');
		end
		
		-- do we have |accessdate= without either |url= or |chapter-url=?
		if utilities.is_set (AccessDate) and not utilities.is_set (ChapterURL) then		-- ChapterURL may be set when URL is not set;
			utilities.set_message ('err_accessdate_missing_url');
			AccessDate = '';
		end
	end

	local UrlStatus = is_valid_parameter_value (A['UrlStatus'], A:ORIGIN('UrlStatus'), cfg.keywords_lists['url-status'], '');
	local OriginalURL
	local OriginalURL_origin
	local OriginalFormat
	local OriginalAccess;
	UrlStatus = UrlStatus:lower();												-- used later when assembling archived text
	if utilities.is_set ( ArchiveURL ) then
		if utilities.is_set (ChapterURL) then 									-- if chapter-url= is set apply archive url to it
			OriginalURL = ChapterURL;											-- save copy of source chapter's url for archive text
			OriginalURL_origin = ChapterURL_origin;								-- name of |chapter-url= parameter for error messages
			OriginalFormat = ChapterFormat;										-- and original |chapter-format=

			if 'live' ~= UrlStatus then
				ChapterURL = ArchiveURL											-- swap-in the archive's URL
				ChapterURL_origin = A:ORIGIN('ArchiveURL')						-- name of |archive-url= parameter for error messages
				ChapterFormat = ArchiveFormat or '';							-- swap in archive's format
				ChapterUrlAccess = nil;											-- restricted access levels do not make sense for archived URLs
			end
		elseif utilities.is_set (URL) then
			OriginalURL = URL;													-- save copy of original source URL
			OriginalURL_origin = URL_origin;									-- name of URL parameter for error messages
			OriginalFormat = Format; 											-- and original |format=
			OriginalAccess = UrlAccess;

			if 'live' ~= UrlStatus then											-- if URL set then |archive-url= applies to it
				URL = ArchiveURL												-- swap-in the archive's URL
				URL_origin = A:ORIGIN('ArchiveURL')								-- name of archive URL parameter for error messages
				Format = ArchiveFormat or '';									-- swap in archive's format
				UrlAccess = nil;												-- restricted access levels do not make sense for archived URLs
			end
		end
	elseif utilities.is_set (UrlStatus) then									-- if |url-status= is set when |archive-url= is not set
 		utilities.set_message ('maint_url_status');								-- add maint cat
	end

	if utilities.in_array (config.CitationClass, {'web', 'news', 'journal', 'magazine', 'pressrelease', 'podcast', 'newsgroup', 'arxiv', 'biorxiv', 'citeseerx', 'medrxiv', 'ssrn'}) or	-- if any of the 'periodical' cites except encyclopedia
		('citation' == config.CitationClass and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) and not utilities.is_set (Encyclopedia)) then
			local chap_param;
			if utilities.is_set (Chapter) then									-- get a parameter name from one of these chapter related meta-parameters
				chap_param = A:ORIGIN ('Chapter')
			elseif utilities.is_set (TransChapter) then
				chap_param = A:ORIGIN ('TransChapter')
			elseif utilities.is_set (ChapterURL) then
				chap_param = A:ORIGIN ('ChapterURL')
			elseif utilities.is_set (ScriptChapter) then
				chap_param = ScriptChapter_origin;
			else utilities.is_set (ChapterFormat)
				chap_param = A:ORIGIN ('ChapterFormat')
			end

			if utilities.is_set (chap_param) then								-- if we found one
				utilities.set_message ('err_chapter_ignored', {chap_param});	-- add error message
				Chapter = '';													-- and set them to empty string to be safe with concatenation
				TransChapter = '';
				ChapterURL = '';
				ScriptChapter = '';
				ChapterFormat = '';
			end
	else																		-- otherwise, format chapter / article title
		local no_quotes = false;												-- default assume that we will be quoting the chapter parameter value
		if utilities.is_set (Contribution) and 0 &lt; #c then						-- if this is a contribution with contributor(s)
			if utilities.in_array (Contribution:lower(), cfg.keywords_lists.contribution) then	-- and a generic contribution title
				no_quotes = true;												-- then render it unquoted
			end
		end

		Chapter = format_chapter_title (ScriptChapter, ScriptChapter_origin, Chapter, Chapter_origin, TransChapter, TransChapter_origin, ChapterURL, ChapterURL_origin, no_quotes, ChapterUrlAccess);		-- Contribution is also in Chapter
		if utilities.is_set (Chapter) then
			Chapter = Chapter .. ChapterFormat ;
			if 'map' == config.CitationClass and utilities.is_set (TitleType) then
				Chapter = Chapter .. ' ' .. TitleType;							-- map annotation here; not after title
			end
			Chapter = Chapter .. sepc .. ' ';
		elseif utilities.is_set (ChapterFormat) then							-- |chapter= not set but |chapter-format= is so ...
			Chapter = ChapterFormat .. sepc .. ' ';								-- ... ChapterFormat has error message, we want to see it
		end
	end

	-- Format main title
	local plain_title = false;
	local accept_title;
	Title, accept_title = utilities.has_accept_as_written (Title, true);		-- remove accept-this-as-written markup when it wraps all of &lt;Title&gt;
	if accept_title and ('' == Title) then										-- only support forced empty for now "(())"
		Title = cfg.messages['notitle'];										-- replace by predefined "No title" message
			-- TODO: utilities.set_message ( 'err_redundant_parameters', ...);	-- issue proper error message instead of muting	 
			ScriptTitle = '';													-- just mute for now	 
			TransTitle = '';													-- just mute for now
 		plain_title = true;														-- suppress text decoration for descriptive title
		utilities.set_message ('maint_untitled');								-- add maint cat
	end

	if not accept_title then													-- &lt;Title&gt; not wrapped in accept-as-written markup
		if '...' == Title:sub (-3) then											-- if ellipsis is the last three characters of |title=
			Title = Title:gsub ('(%.%.%.)%.+$', '%1');							-- limit the number of dots to three
		elseif not mw.ustring.find (Title, '%.%s*%a%.$') and					-- end of title is not a 'dot-(optional space-)letter-dot' initialism ...
			not mw.ustring.find (Title, '%s+%a%.$') then						-- ...and not a 'space-letter-dot' initial (''Allium canadense'' L.)
				Title = mw.ustring.gsub(Title, '%' .. sepc .. '$', '');			-- remove any trailing separator character; sepc and ms.ustring() here for languages that use multibyte separator characters
		end

		if utilities.is_set (ArchiveURL) and is_archived_copy (Title) then
			utilities.set_message ('maint_archived_copy');						-- add maintenance category before we modify the content of Title
		end

		if is_generic ('generic_titles', Title) then
			utilities.set_message ('err_generic_title');						-- set an error message
		end
	end

	if (not plain_title) and (utilities.in_array (config.CitationClass, {'web', 'news', 'journal', 'magazine', 'document', 'pressrelease', 'podcast', 'newsgroup', 'mailinglist', 'interview', 'arxiv', 'biorxiv', 'citeseerx', 'medrxiv', 'ssrn'}) or
		('citation' == config.CitationClass and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) and not utilities.is_set (Encyclopedia)) or
		('map' == config.CitationClass and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)))) then		-- special case for cite map when the map is in a periodical treat as an article
			Title = kern_quotes (Title);										-- if necessary, separate title's leading and trailing quote marks from module provided quote marks
			Title = utilities.wrap_style ('quoted-title', Title);
			Title = script_concatenate (Title, ScriptTitle, 'script-title');	-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped
			TransTitle = utilities.wrap_style ('trans-quoted-title', TransTitle );
	elseif plain_title or ('report' == config.CitationClass) then				-- no styling for cite report and descriptive titles (otherwise same as above)
		Title = script_concatenate (Title, ScriptTitle, 'script-title');		-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped
		TransTitle = utilities.wrap_style ('trans-quoted-title', TransTitle );	-- for cite report, use this form for trans-title
	else
		Title = utilities.wrap_style ('italic-title', Title);
		Title = script_concatenate (Title, ScriptTitle, 'script-title');		-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped
		TransTitle = utilities.wrap_style ('trans-italic-title', TransTitle);
	end

	if utilities.is_set (TransTitle) then
		if utilities.is_set (Title) then
			TransTitle = " " .. TransTitle;
		else
			utilities.set_message ('err_trans_missing_title', {'title'});
		end
	end

	if utilities.is_set (Title) then											-- TODO: is this the right place to be making Wikisource URLs?
		if utilities.is_set (TitleLink) and utilities.is_set (URL) then
			utilities.set_message ('err_wikilink_in_url');						-- set an error message because we can't have both
			TitleLink = '';														-- unset
		end
	
		if not utilities.is_set (TitleLink) and utilities.is_set (URL) then
			Title = external_link (URL, Title, URL_origin, UrlAccess) .. TransTitle .. Format;
			URL = '';															-- unset these because no longer needed
			Format = "";
		elseif utilities.is_set (TitleLink) and not utilities.is_set (URL) then
			local ws_url;
			ws_url = wikisource_url_make (TitleLink);							-- ignore ws_label return; not used here
			if ws_url then
				Title = external_link (ws_url, Title .. '&amp;nbsp;', 'ws link in title-link');	-- space char after Title to move icon away from italic text; TODO: a better way to do this?
				Title = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], TitleLink, Title});				
				Title = Title .. TransTitle;
			else
				Title = utilities.make_wikilink (TitleLink, Title) .. TransTitle;
			end
		else
			local ws_url, ws_label, L;											-- Title has italic or quote markup by the time we get here which causes is_wikilink() to return 0 (not a wikilink)
			ws_url, ws_label, L = wikisource_url_make (Title:gsub('^[\'"]*(.-)[\'"]*$', '%1'));	-- make ws URL from |title= interwiki link (strip italic or quote markup); link portion L becomes tooltip label
			if ws_url then
				Title = Title:gsub ('%b[]', ws_label);							-- replace interwiki link with ws_label to retain markup
				Title = external_link (ws_url, Title .. '&amp;nbsp;', 'ws link in title');	-- space char after Title to move icon away from italic text; TODO: a better way to do this?
				Title = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, Title});				
				Title = Title .. TransTitle;
			else
				Title = Title .. TransTitle;
			end
		end
	else
		Title = TransTitle;
	end

	if utilities.is_set (Place) then
		Place = " " .. wrap_msg ('written', Place, use_lowercase) .. sepc .. " ";
	end

	local ConferenceURL_origin = A:ORIGIN('ConferenceURL');						-- get name of parameter that holds ConferenceURL
	if utilities.is_set (Conference) then
		if utilities.is_set (ConferenceURL) then
			Conference = external_link( ConferenceURL, Conference, ConferenceURL_origin, nil );
		end
		Conference = sepc .. " " .. Conference .. ConferenceFormat;
	elseif utilities.is_set (ConferenceURL) then
		Conference = sepc .. " " .. external_link( ConferenceURL, nil, ConferenceURL_origin, nil );
	end

	local Position = '';
	if not utilities.is_set (Position) then
		local Minutes = A['Minutes'];
		local Time = A['Time'];

		if utilities.is_set (Minutes) then
			if utilities.is_set (Time) then		--TODO: make a function for this and similar?
				utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', 'minutes') .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', 'time')});
			end
			Position = " " .. Minutes .. " " .. cfg.messages['minutes'];
		else
			if utilities.is_set (Time) then
				local TimeCaption = A['TimeCaption']
				if not utilities.is_set (TimeCaption) then
					TimeCaption = cfg.messages['event'];
					if sepc ~= '.' then
						TimeCaption = TimeCaption:lower();
					end
				end
				Position = " " .. TimeCaption .. " " .. Time;
			end
		end
	else
		Position = " " .. Position;
		At = '';
	end

	Page, Pages, Sheet, Sheets = format_pages_sheets (Page, Pages, Sheet, Sheets, config.CitationClass, Periodical_origin, sepc, NoPP, use_lowercase);

	At = utilities.is_set (At) and (sepc .. " " .. At) or "";
	Position = utilities.is_set (Position) and (sepc .. " " .. Position) or "";
	if config.CitationClass == 'map' then
		local Sections = A['Sections'];											-- Section (singular) is an alias of Chapter so set earlier
		local Inset = A['Inset'];
		
		if utilities.is_set ( Inset ) then
			Inset = sepc .. " " .. wrap_msg ('inset', Inset, use_lowercase);
		end			

		if utilities.is_set ( Sections ) then
			Section = sepc .. " " .. wrap_msg ('sections', Sections, use_lowercase);
		elseif utilities.is_set ( Section ) then
			Section = sepc .. " " .. wrap_msg ('section', Section, use_lowercase);
		end
		At = At .. Inset .. Section;		
	end	

	local Others = A['Others'];
	if utilities.is_set (Others) and 0 == #a and 0 == #e then					-- add maint cat when |others= has value and used without |author=, |editor=
		if config.CitationClass == "AV-media-notes"
		or config.CitationClass == "audio-visual" then							-- special maint for AV/M which has a lot of 'false' positives right now
			utilities.set_message ('maint_others_avm')
		else
			utilities.set_message ('maint_others');
		end
	end
	Others = utilities.is_set (Others) and (sepc .. " " .. Others) or "";
	
	if utilities.is_set (Translators) then
		Others = safe_join ({sepc .. ' ', wrap_msg ('translated', Translators, use_lowercase), Others}, sepc);
	end
	if utilities.is_set (Interviewers) then
		Others = safe_join ({sepc .. ' ', wrap_msg ('interview', Interviewers, use_lowercase), Others}, sepc);
	end
	
	local TitleNote = A['TitleNote'];
	TitleNote = utilities.is_set (TitleNote) and (sepc .. " " .. TitleNote) or "";
	if utilities.is_set (Edition) then
		if Edition:match ('%f[%a][Ee]d%n?%.?$') or Edition:match ('%f[%a][Ee]dition$') then -- Ed, ed, Ed., ed., Edn, edn, Edn., edn.
			utilities.set_message ('err_extra_text_edition');					 -- add error message
		end
		Edition = " " .. wrap_msg ('edition', Edition);
	else
		Edition = '';
	end

	Series = utilities.is_set (Series) and wrap_msg ('series', {sepc, Series}) or "";	-- not the same as SeriesNum
	local Agency = A['Agency'] or '';											-- |agency= is supported by {{cite magazine}}, {{cite news}}, {{cite press release}}, {{cite web}}, and certain {{citation}} templates
	if utilities.is_set (Agency) then											-- this testing done here because {{citation}} supports 'news' citations
		if utilities.in_array (config.CitationClass, {'magazine', 'news', 'pressrelease', 'web'}) or ('citation' == config.CitationClass and utilities.in_array (Periodical_origin, {"magazine", "newspaper", "work"})) then
			Agency = wrap_msg ('agency', {sepc, Agency});						-- format for rendering
		else
			Agency = '';														-- unset; not supported
			utilities.set_message ('err_parameter_ignored', {'agency'});		-- add error message
		end
	end
	
	Volume = format_volume_issue (Volume, Issue, ArticleNumber, config.CitationClass, Periodical_origin, sepc, use_lowercase);

	if utilities.is_set (AccessDate) then
		local retrv_text = " " .. cfg.messages['retrieved']

		AccessDate = nowrap_date (AccessDate);									-- wrap in nowrap span if date in appropriate format
		if (sepc ~= ".") then retrv_text = retrv_text:lower() end				-- if mode is cs2, lower case
		AccessDate = utilities.substitute (retrv_text, AccessDate);				-- add retrieved text

		AccessDate = utilities.substitute (cfg.presentation['accessdate'], {sepc, AccessDate});	-- allow editors to hide accessdates
	end
	
	if utilities.is_set (ID) then ID = sepc .. " " .. ID; end
	
	local Docket = A['Docket'];
   	if "thesis" == config.CitationClass and utilities.is_set (Docket) then
		ID = sepc .. " Docket " .. Docket .. ID;
	end
   	if "report" == config.CitationClass and utilities.is_set (Docket) then		-- for cite report when |docket= is set
		ID = sepc .. ' ' .. Docket;												-- overwrite ID even if |id= is set
	end

	if utilities.is_set (URL) then
		URL = " " .. external_link( URL, nil, URL_origin, UrlAccess );
	end
	
	-- We check length of PostScript here because it will have been nuked by
	-- the quote parameters. We'd otherwise emit a message even if there wasn't
	-- a displayed postscript.
	-- TODO: Should the max size (1) be configurable?
	-- TODO: Should we check a specific pattern?
	if utilities.is_set(PostScript) and mw.ustring.len(PostScript) &gt; 1 then
		utilities.set_message ('maint_postscript')
	end
	
	local Archived;
	if utilities.is_set (ArchiveURL) then
		if not utilities.is_set (ArchiveDate) then								-- ArchiveURL set but ArchiveDate not set
			utilities.set_message ('err_archive_missing_date');					-- emit an error message
			ArchiveURL = '';													-- empty string for concatenation
			ArchiveDate = '';													-- empty string for concatenation
		end
	else														
		if utilities.is_set (ArchiveDate) then									-- ArchiveURL not set but ArchiveDate is set
			utilities.set_message ('err_archive_date_missing_url');				-- emit an error message
			ArchiveURL = '';													-- empty string for concatenation
			ArchiveDate = '';													-- empty string for concatenation
		end
	end

	if utilities.is_set (ArchiveURL) then
		local arch_text;
		if "live" == UrlStatus then
			arch_text = cfg.messages['archived'];
			if sepc ~= "." then arch_text = arch_text:lower() end
			if utilities.is_set (ArchiveDate) then
				Archived = sepc .. ' ' .. utilities.substitute ( cfg.messages['archived-live'],
					{external_link( ArchiveURL, arch_text, A:ORIGIN('ArchiveURL'), nil) .. ArchiveFormat, ArchiveDate } );
			else
				Archived = '';
			end
			if not utilities.is_set (OriginalURL) then
				utilities.set_message ('err_archive_missing_url');
				Archived = '';													-- empty string for concatenation
			end
		elseif utilities.is_set (OriginalURL) then								-- UrlStatus is empty, 'dead', 'unfit', 'usurped', 'bot: unknown'
			if utilities.in_array (UrlStatus, {'unfit', 'usurped', 'bot: unknown'}) then
				arch_text = cfg.messages['archived-unfit'];
				if sepc ~= "." then arch_text = arch_text:lower() end
				Archived = sepc .. ' ' .. arch_text .. ArchiveDate;				-- format already styled
				if 'bot: unknown' == UrlStatus then
					utilities.set_message ('maint_bot_unknown');				-- and add a category if not already added
				else
					utilities.add_prop_cat ('unfit');							-- and add a category if not already added
				end
			else																-- UrlStatus is empty, 'dead'
				arch_text = cfg.messages['archived-dead'];
				if sepc ~= "." then arch_text = arch_text:lower() end
				if utilities.is_set (ArchiveDate) then
					Archived = sepc .. " " .. utilities.substitute ( arch_text,
						{ external_link( OriginalURL, cfg.messages['original'], OriginalURL_origin, OriginalAccess ) .. OriginalFormat, ArchiveDate } );	-- format already styled
				else
					Archived = '';												-- unset for concatenation
				end
			end	
		else																	-- OriginalUrl not set
			utilities.set_message ('err_archive_missing_url');
			Archived = '';														-- empty string for concatenation
		end
	elseif utilities.is_set (ArchiveFormat) then
		Archived = ArchiveFormat;												-- if set and ArchiveURL not set ArchiveFormat has error message
	else
		Archived = '';
	end
	
	local TranscriptURL = A['TranscriptURL']
	local TranscriptFormat = A['TranscriptFormat'];
	TranscriptFormat = style_format (TranscriptFormat, TranscriptURL, 'transcript-format', 'transcripturl');
	local Transcript = A['Transcript'];
	local TranscriptURL_origin = A:ORIGIN('TranscriptURL');						-- get name of parameter that holds TranscriptURL
	if utilities.is_set (Transcript) then
		if utilities.is_set (TranscriptURL) then
			Transcript = external_link( TranscriptURL, Transcript, TranscriptURL_origin, nil );
		end
		Transcript = sepc .. ' ' .. Transcript .. TranscriptFormat;
	elseif utilities.is_set (TranscriptURL) then
		Transcript = external_link( TranscriptURL, nil, TranscriptURL_origin, nil );
	end

	local Publisher;
	if utilities.is_set (PublicationDate) then
		PublicationDate = wrap_msg ('published', PublicationDate);
	end
	if utilities.is_set (PublisherName) then
		if utilities.is_set (PublicationPlace) then
			Publisher = sepc .. " " .. PublicationPlace .. ": " .. PublisherName .. PublicationDate;
		else
			Publisher = sepc .. " " .. PublisherName .. PublicationDate;  
		end			
	elseif utilities.is_set (PublicationPlace) then 
		Publisher= sepc .. " " .. PublicationPlace .. PublicationDate;
	else 
		Publisher = PublicationDate;
	end
	
	-- Several of the above rely upon detecting this as nil, so do it last.
	if (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical) or utilities.is_set (TransPeriodical)) then
		if utilities.is_set (Title) or utilities.is_set (TitleNote) then 
			Periodical = sepc .. " " .. format_periodical (ScriptPeriodical, ScriptPeriodical_origin, Periodical, TransPeriodical, TransPeriodical_origin);
		else 
			Periodical = format_periodical (ScriptPeriodical, ScriptPeriodical_origin, Periodical, TransPeriodical, TransPeriodical_origin);
		end
	end
	
	local Language = A['Language'];
	if utilities.is_set (Language) then
		Language = language_parameter (Language);								-- format, categories, name from ISO639-1, etc.
	else
		Language='';															-- language not specified so make sure this is an empty string;
	--[[ TODO: need to extract the wrap_msg from language_parameter
	so that we can solve parentheses bunching problem with Format/Language/TitleType
	]]
	end

	--[[
	Handle the oddity that is cite speech.  This code overrides whatever may be the value assigned to TitleNote (through |department=) and forces it to be " (Speech)" so that
	the annotation directly follows the |title= parameter value in the citation rather than the |event= parameter value (if provided).
	]]
	if "speech" == config.CitationClass then									-- cite speech only
		TitleNote = TitleType;													-- move TitleType to TitleNote so that it renders ahead of |event=
		TitleType = '';															-- and unset

		if utilities.is_set (Periodical) then									-- if Periodical, perhaps because of an included |website= or |journal= parameter 
			if utilities.is_set (Conference) then								-- and if |event= is set
				Conference = Conference .. sepc .. " ";							-- then add appropriate punctuation to the end of the Conference variable before rendering
			end
		end
	end

	-- Piece all bits together at last.  Here, all should be non-nil.
	-- We build things this way because it is more efficient in LUA
	-- not to keep reassigning to the same string variable over and over.

	local tcommon;
	local tcommon2;																-- used for book cite when |contributor= is set
	
	if utilities.in_array (config.CitationClass, {"book", "citation"}) and not utilities.is_set (Periodical) then		-- special cases for book cites
		if utilities.is_set (Contributors) then									-- when we are citing foreword, preface, introduction, etc.
			tcommon = safe_join ({Title, TitleNote}, sepc);						-- author and other stuff will come after this and before tcommon2
			tcommon2 = safe_join ({TitleType, Series, Language, Volume, Others, Edition, Publisher}, sepc);
		else
			tcommon = safe_join ({Title, TitleNote, TitleType, Series, Language, Volume, Others, Edition, Publisher}, sepc);
		end

	elseif 'map' == config.CitationClass then									-- special cases for cite map
		if utilities.is_set (Chapter) then										-- map in a book; TitleType is part of Chapter
			tcommon = safe_join ({Title, Edition, Scale, Series, Language, Cartography, Others, Publisher, Volume}, sepc);
		elseif utilities.is_set (Periodical) then								-- map in a periodical
			tcommon = safe_join ({Title, TitleType, Periodical, Scale, Series, Language, Cartography, Others, Publisher, Volume}, sepc);
		else																	-- a sheet or stand-alone map
			tcommon = safe_join ({Title, TitleType, Edition, Scale, Series, Language, Cartography, Others, Publisher}, sepc);
		end
		
	elseif 'episode' == config.CitationClass then								-- special case for cite episode
		tcommon = safe_join ({Title, TitleNote, TitleType, Series, Language, Edition, Publisher}, sepc);

	else																		-- all other CS1 templates
		tcommon = safe_join ({Title, TitleNote, Conference, Periodical, TitleType, Series, Language, Volume, Others, Edition, Publisher, Agency}, sepc);
	end
	
	if #ID_list &gt; 0 then
		ID_list = safe_join( { sepc .. " ",  table.concat( ID_list, sepc .. " " ), ID }, sepc );
	else
		ID_list = ID;
	end
	
	local Via = A['Via'];
	Via = utilities.is_set (Via) and  wrap_msg ('via', Via) or '';
	local idcommon;
	if 'audio-visual' == config.CitationClass or 'episode' == config.CitationClass then	-- special case for cite AV media &amp; cite episode position transcript
		idcommon = safe_join( { ID_list, URL, Archived, Transcript, AccessDate, Via, Quote }, sepc );
	else
		idcommon = safe_join( { ID_list, URL, Archived, AccessDate, Via, Quote }, sepc );
	end
	
	local text;
	local pgtext = Position .. Sheet .. Sheets .. Page .. Pages .. At;

	local OrigDate = A['OrigDate'];
	OrigDate = utilities.is_set (OrigDate) and wrap_msg ('origdate', OrigDate) or '';
	if utilities.is_set (Date) then
		if utilities.is_set (Authors) or utilities.is_set (Editors) then		-- date follows authors or editors when authors not set
			Date = " (" .. Date .. ")" .. OrigDate .. sepc .. " ";				-- in parentheses
		else																	-- neither of authors and editors set
			if (string.sub(tcommon, -1, -1) == sepc) then						-- if the last character of tcommon is sepc
				Date = " " .. Date .. OrigDate;									-- Date does not begin with sepc
			else
				Date = sepc .. " " .. Date .. OrigDate;							-- Date begins with sepc
			end
		end
	end	
	if utilities.is_set (Authors) then
		if (not utilities.is_set (Date)) then									-- when date is set it's in parentheses; no Authors termination
			Authors = terminate_name_list (Authors, sepc);						-- when no date, terminate with 0 or 1 sepc and a space
		end
		if utilities.is_set (Editors) then
			local in_text = '';
			local post_text = '';
			if utilities.is_set (Chapter) and 0 == #c then
				in_text = cfg.messages['in'] .. ' ';
				if (sepc ~= '.') then
					in_text = in_text:lower();									-- lowercase for cs2
				end
			end
			if EditorCount &lt;= 1 then
				post_text = ' (' .. cfg.messages['editor'] .. ')';				-- be consistent with no-author, no-date case
			else
				post_text = ' (' .. cfg.messages['editors'] .. ')';
			end
			Editors = terminate_name_list (in_text .. Editors .. post_text, sepc);	-- terminate with 0 or 1 sepc and a space
		end
		if utilities.is_set (Contributors) then									-- book cite and we're citing the intro, preface, etc.
			local by_text = sepc .. ' ' .. cfg.messages['by'] .. ' ';
			if (sepc ~= '.') then by_text = by_text:lower() end					-- lowercase for cs2
			Authors = by_text .. Authors;										-- author follows title so tweak it here
			if utilities.is_set (Editors) and utilities.is_set (Date) then		-- when Editors make sure that Authors gets terminated
				Authors = terminate_name_list (Authors, sepc);					-- terminate with 0 or 1 sepc and a space
			end
			if (not utilities.is_set (Date)) then								-- when date is set it's in parentheses; no Contributors termination
				Contributors = terminate_name_list (Contributors, sepc);		-- terminate with 0 or 1 sepc and a space
			end
			text = safe_join( {Contributors, Date, Chapter, tcommon, Authors, Place, Editors, tcommon2, pgtext, idcommon }, sepc );
		else
			text = safe_join( {Authors, Date, Chapter, Place, Editors, tcommon, pgtext, idcommon }, sepc );
		end
	elseif utilities.is_set (Editors) then
		if utilities.is_set (Date) then
			if EditorCount &lt;= 1 then
				Editors = Editors .. cfg.presentation['sep_name'] .. cfg.messages['editor'];
			else
				Editors = Editors .. cfg.presentation['sep_name'] .. cfg.messages['editors'];
			end
		else
			if EditorCount &lt;= 1 then
				Editors = Editors .. " (" .. cfg.messages['editor'] .. ")" .. sepc .. " "
			else
				Editors = Editors .. " (" .. cfg.messages['editors'] .. ")" .. sepc .. " "
			end
		end
		text = safe_join( {Editors, Date, Chapter, Place, tcommon, pgtext, idcommon}, sepc );
	else
		if utilities.in_array (config.CitationClass, {"journal", "citation"}) and utilities.is_set (Periodical) then
			text = safe_join( {Chapter, Place, tcommon, pgtext, Date, idcommon}, sepc );
		else
			text = safe_join( {Chapter, Place, tcommon, Date, pgtext, idcommon}, sepc );
		end
	end

	if utilities.is_set (PostScript) and PostScript ~= sepc then
		text = safe_join( {text, sepc}, sepc ); 								-- Deals with italics, spaces, etc.
		if '.' == sepc then														-- remove final seperator if present
			text = text:gsub ('%' .. sepc .. '$', '');							-- dot must be escaped here
		else
			text = mw.ustring.gsub (text, sepc .. '$', '');						-- using ustring for non-dot sepc (likely a non-Latin character)
		end
	end	
	
	text = safe_join( {text, PostScript}, sepc );

	-- Now enclose the whole thing in a &lt;cite&gt; element
	local options_t = {};
	options_t.class = cite_class_attribute_make (config.CitationClass, Mode);

	local Ref = is_valid_parameter_value (A['Ref'], A:ORIGIN('Ref'), cfg.keywords_lists['ref'], nil, true);	-- nil when |ref=harv; A['Ref'] else

	if 'none' ~= cfg.keywords_xlate[(Ref and Ref:lower()) or ''] then
		local namelist_t = {};													-- holds selected contributor, author, editor name list
		local year = first_set ({Year, anchor_year}, 2);						-- Year first for legacy citations and for YMD dates that require disambiguation

		if #c &gt; 0 then															-- if there is a contributor list
			namelist_t = c;														-- select it
		elseif #a &gt; 0 then														-- or an author list
			namelist_t = a;
		elseif #e &gt; 0 then														-- or an editor list
			namelist_t = e;
		end
		local citeref_id;
		if #namelist_t &gt; 0 then													-- if there are names in namelist_t
			citeref_id = make_citeref_id (namelist_t, year);					-- go make the CITEREF anchor
			if mw.uri.anchorEncode (citeref_id) == ((Ref and mw.uri.anchorEncode (Ref)) or '') then	-- Ref may already be encoded (by {{sfnref}}) so citeref_id must be encoded before comparison
				utilities.set_message ('maint_ref_duplicates_default');
			end
		else
			citeref_id = '';													-- unset
		end
		options_t.id = Ref or citeref_id;
	end

	if string.len (text:gsub('%b&lt;&gt;', '')) &lt;= 2 then								-- remove html and html-like tags; then get length of what remains; 
		z.error_cats_t = {};													-- blank the categories list
		z.error_msgs_t = {};													-- blank the error messages list
		OCinSoutput = nil;														-- blank the metadata string
		text = '';																-- blank the the citation
		utilities.set_message ('err_empty_citation');							-- set empty citation message and category
	end
	
	local render_t = {};														-- here we collect the final bits for concatenation into the rendered citation

	if utilities.is_set (options_t.id) then										-- here we wrap the rendered citation in &lt;cite ...&gt;...&lt;/cite&gt; tags
		table.insert (render_t, utilities.substitute (cfg.presentation['cite-id'], {mw.uri.anchorEncode(options_t.id), mw.text.nowiki(options_t.class), text}));	-- when |ref= is set or when there is a namelist
	else
		table.insert (render_t, utilities.substitute (cfg.presentation['cite'], {mw.text.nowiki(options_t.class), text}));	-- when |ref=none or when namelist_t empty and |ref= is missing or is empty
	end		

	if OCinSoutput then															-- blanked when citation is 'empty' so don't bother to add boilerplate metadata span
		table.insert (render_t, utilities.substitute (cfg.presentation['ocins'], OCinSoutput));	-- format and append metadata to the citation
	end

	local template_name = ('citation' == config.CitationClass) and 'citation' or 'cite ' .. (cfg.citation_class_map_t[config.CitationClass] or config.CitationClass);
	local template_link = '[[Template:' .. template_name .. '|' .. template_name .. ']]';
	local msg_prefix = '&lt;code class="cs1-code"&gt;{{' .. template_link .. '}}&lt;/code&gt;: ';

	if 0 ~= #z.error_msgs_t then
		mw.addWarning (utilities.substitute (cfg.messages.warning_msg_e, template_link));

		table.insert (render_t, ' ');											-- insert a space between citation and its error messages
		table.sort (z.error_msgs_t);											-- sort the error messages list; sorting includes wrapping &lt;span&gt; and &lt;code&gt; tags; hidden-error sorts ahead of visible-error

		local hidden = true;													-- presume that the only error messages emited by this template are hidden
		for _, v in ipairs (z.error_msgs_t) do									-- spin through the list of error messages
			if v:find ('cs1-visible-error', 1, true) then						-- look for the visible error class name
				hidden = false;													-- found one; so don't hide the error message prefix
				break;															-- and done because no need to look further
			end
		end

		z.error_msgs_t[1] = table.concat ({utilities.error_comment (msg_prefix, hidden), z.error_msgs_t[1]});	-- add error message prefix to first error message to prevent extraneous punctuation
		table.insert (render_t, table.concat (z.error_msgs_t, '; '));			-- make a big string of error messages and add it to the rendering
	end

	if 0 ~= #z.maint_cats_t then
		mw.addWarning (utilities.substitute (cfg.messages.warning_msg_m, template_link));

		table.sort (z.maint_cats_t);											-- sort the maintenance messages list

		local maint_msgs_t = {};												-- here we collect all of the maint messages

		if 0 == #z.error_msgs_t then											-- if no error messages
			table.insert (maint_msgs_t, msg_prefix);							-- insert message prefix in maint message livery
		end
		
		for _, v in ipairs( z.maint_cats_t ) do									-- append maintenance categories
			table.insert (maint_msgs_t, 										-- assemble new maint message and add it to the maint_msgs_t table
				table.concat ({v, ' (', utilities.substitute (cfg.messages[':cat wikilink'], v), ')'})
				);
		end
		table.insert (render_t, utilities.substitute (cfg.presentation['hidden-maint'], table.concat (maint_msgs_t, ' ')));	-- wrap the group of maint messages with proper presentation and save
	end

	if not no_tracking_cats then
		local sort_key;
		local cat_wikilink = 'cat wikilink';
		if cfg.enable_sort_keys then											-- when namespace sort keys enabled
			local namespace_number = mw.title.getCurrentTitle().namespace;		-- get namespace number for this wikitext
			sort_key = (0 ~= namespace_number and (cfg.name_space_sort_keys[namespace_number] or cfg.name_space_sort_keys.other)) or nil;	-- get sort key character; nil for mainspace
			cat_wikilink = (not sort_key and 'cat wikilink') or 'cat wikilink sk';	-- make &lt;cfg.messages&gt; key
		end				

		for _, v in ipairs (z.error_cats_t) do									-- append error categories
			table.insert (render_t, utilities.substitute (cfg.messages[cat_wikilink], {v, sort_key}));
		end
		if cfg.id_limits_data_load_fail then									-- boolean true when load failed
			utilities.set_message ('maint_id_limit_load_fail');					-- done here because this maint cat emits no message
		end
		for _, v in ipairs (z.maint_cats_t) do									-- append maintenance categories
			table.insert (render_t, utilities.substitute (cfg.messages[cat_wikilink], {v, sort_key}));
		end
		for _, v in ipairs (z.prop_cats_t) do									-- append properties categories
			table.insert (render_t, utilities.substitute (cfg.messages['cat wikilink'], v));	-- no sort keys
		end
	end

	return table.concat (render_t);												-- make a big string and done
end


--[[--------------------------&lt; V A L I D A T E &gt;--------------------------------------------------------------

Looks for a parameter's name in one of several whitelists.

Parameters in the whitelist can have three values:
	true - active, supported parameters
	false - deprecated, supported parameters
	nil - unsupported parameters
	
]]

local function validate (name, cite_class, empty)
	local name = tostring (name);
	local enum_name;															-- parameter name with enumerator (if any) replaced with '#'
	local state;
	local function state_test (state, name)										-- local function to do testing of state values
		if true == state then return true; end									-- valid actively supported parameter
		if false == state then
			if empty then return nil; end										-- empty deprecated parameters are treated as unknowns
			deprecated_parameter (name);										-- parameter is deprecated but still supported
			return true;
		end
		if 'tracked' == state then
			local base_name = name:gsub ('%d', '');								-- strip enumerators from parameter names that have them to get the base name
			utilities.add_prop_cat ('tracked-param', {base_name}, base_name);	-- add a properties category; &lt;base_name&gt; modifies &lt;key&gt;
			return true;
		end
		return nil;
	end		

	if name:find ('#') then														-- # is a cs1|2 reserved character so parameters with # not permitted
		return nil;
	end
																				-- replace enumerator digit(s) with # (|last25= becomes |last#=) (mw.ustring because non-Western 'local' digits)
	enum_name = mw.ustring.gsub (name, '%d+$', '#');							-- where enumerator is last charaters in parameter name (these to protect |s2cid=)
	enum_name = mw.ustring.gsub (enum_name, '%d+([%-l])', '#%1');				-- where enumerator is in the middle of the parameter name; |author#link= is the oddity

	if 'document' == cite_class then											-- special case for {{cite document}}
		state = whitelist.document_parameters_t[enum_name];						-- this list holds enumerated and nonenumerated parameters
		if true == state_test (state, name) then return true; end
		
		return false;
	end

	if utilities.in_array (cite_class, whitelist.preprint_template_list_t) then	-- limited parameter sets allowed for these templates
		state = whitelist.limited_parameters_t[enum_name];						-- this list holds enumerated and nonenumerated parameters
		if true == state_test (state, name) then return true; end

		state = whitelist.preprint_arguments_t[cite_class][name];				-- look in the parameter-list for the template identified by cite_class
		if true == state_test (state, name) then return true; end

		return false;															-- not supported because not found or name is set to nil
	end																			-- end limited parameter-set templates

	if utilities.in_array (cite_class, whitelist.unique_param_template_list_t) then 	-- template-specific parameters for templates that accept parameters from the basic argument list
		state = whitelist.unique_arguments_t[cite_class][name];					-- look in the template-specific parameter-lists for the template identified by cite_class
		if true == state_test (state, name) then return true; end
	end																			-- if here, fall into general validation

	state = whitelist.common_parameters_t[enum_name];							-- all other templates; all normal parameters allowed; this list holds enumerated and nonenumerated parameters
	if true == state_test (state, name) then return true; end

	return false;																-- not supported because not found or name is set to nil
end


--[=[-------------------------&lt; I N T E R _ W I K I _ C H E C K &gt;----------------------------------------------

check &lt;value&gt; for inter-language interwiki-link markup.  &lt;prefix&gt; must be a MediaWiki-recognized language
code.  when these values have the form (without leading colon):
	[[&lt;prefix&gt;:link|label]] return label as plain-text
	[[&lt;prefix&gt;:link]] return &lt;prefix&gt;:link as plain-text

return value as is else

]=]

local function inter_wiki_check (parameter, value)
	local prefix = value:match ('%[%[(%a+):');									-- get an interwiki prefix if one exists
	local _;
	
	if prefix and cfg.inter_wiki_map[prefix:lower()] then						-- if prefix is in the map, needs preceding colon so
		utilities.set_message ('err_bad_paramlink', parameter);					-- emit an error message
		_, value, _ = utilities.is_wikilink (value);							-- extract label portion from wikilink
	end
	return value;
end


--[[--------------------------&lt; M I S S I N G _ P I P E _ C H E C K &gt;------------------------------------------

Look at the contents of a parameter. If the content has a string of characters and digits followed by an equal
sign, compare the alphanumeric string to the list of cs1|2 parameters.  If found, then the string is possibly a
parameter that is missing its pipe.  There are two tests made:
	{{cite ... |title=Title access-date=2016-03-17}}	-- the first parameter has a value and whitespace separates that value from the missing pipe parameter name
	{{cite ... |title=access-date=2016-03-17}}			-- the first parameter has no value (whitespace after the first = is trimmed by MediaWiki)
cs1|2 shares some parameter names with XML/HTML attributes: class=, title=, etc.  To prevent false positives XML/HTML
tags are removed before the search.

If a missing pipe is detected, this function adds the missing pipe maintenance category.

]]

local function missing_pipe_check (parameter, value)
	local capture;
	value = value:gsub ('%b&lt;&gt;', '');											-- remove XML/HTML tags because attributes: class=, title=, etc.

	capture = value:match ('%s+(%a[%w%-]+)%s*=') or value:match ('^(%a[%w%-]+)%s*=');	-- find and categorize parameters with possible missing pipes
	if capture and validate (capture) then										-- if the capture is a valid parameter name
		utilities.set_message ('err_missing_pipe', parameter);
	end
end


--[[--------------------------&lt; H A S _ E X T R A N E O U S _ P U N C T &gt;--------------------------------------

look for extraneous terminal punctuation in most parameter values; parameters listed in skip table are not checked

]]

local function has_extraneous_punc (param, value)
	if 'number' == type (param) then
		return;
	end
	
	param = param:gsub ('%d+', '#');											-- enumerated name-list mask params allow terminal punct; normalize 
	if cfg.punct_skip[param] then
		return;																	-- parameter name found in the skip table so done
	end
	
	if value:match ('[,;:]$') then
		utilities.set_message ('maint_extra_punct');							-- has extraneous punctuation; add maint cat
	end
	if value:match ('^=') then													-- sometimes an extraneous '=' character appears ...
		utilities.set_message ('maint_extra_punct');							-- has extraneous punctuation; add maint cat
	end
end


--[[--------------------------&lt; H A S _ T W L _ U R L &gt;--------------------------------------------------------

look for The Wikipedia Library urls in url-holding parameters.  TWL urls are accessible for readers who are not
active extended confirmed Wikipedia editors.  This function emits an error message when such urls are discovered.

looks for: '.wikipedialibrary.idm.oclc.org'

]]

local function has_twl_url (url_params_t)
	local url_error_t = {};														-- sequence of url-holding parameters that have a TWL url
	
	for param, value in pairs (url_params_t) do
		if value:find ('%.wikipedialibrary%.idm%.oclc%.org') then				-- has the TWL base url?
			table.insert (url_error_t, utilities.wrap_style ('parameter', param));	-- add parameter name to the list
		end
	end
	if 0 ~= #url_error_t then													-- non-zero when there are errors
		table.sort (url_error_t);
		utilities.set_message ('err_param_has_twl_url', {utilities.make_sep_list (#url_error_t, url_error_t)});	-- add this error message
		return true;
	end
end


--[[--------------------------&lt; H A S _ E X T R A N E O U S _ U R L &gt;------------------------------------------

look for extraneous url parameter values; parameters listed in skip table are not checked

]]

local function has_extraneous_url (non_url_param_t)
	local url_error_t = {};
	
	check_for_url (non_url_param_t, url_error_t);								-- extraneous url check
	if 0 ~= #url_error_t then													-- non-zero when there are errors
		table.sort (url_error_t);
		utilities.set_message ('err_param_has_ext_link', {utilities.make_sep_list (#url_error_t, url_error_t)});	-- add this error message
	end
end


--[[--------------------------&lt; _ C I T A T I O N &gt;------------------------------------------------------------

Module entry point

	frame – from template call (citation()); may be nil when called from another module
	args – table of all cs1|2 parameters in the template (the template frame)
	config – table of template-supplied parameter (the #invoke frame)

]]

local function _citation (frame, args, config)									-- save a copy in case we need to display an error message in preview mode
	if not frame then
		frame = mw.getCurrentFrame();											-- if called from another module, get a frame for frame-provided functions
	end
																				-- i18n: set the name that your wiki uses to identify sandbox subpages from sandbox template invoke (or can be set here)
	local sandbox = ((config.SandboxPath and '' ~= config.SandboxPath) and config.SandboxPath) or '/sandbox';	-- sandbox path from {{#invoke:Citation/CS1/sandbox|citation|SandboxPath=/...}}
	is_sandbox = nil ~= string.find (frame:getTitle(), sandbox, 1, true);		-- is this invoke the sandbox module?
	sandbox = is_sandbox and sandbox or '';										-- use i18n sandbox to load sandbox modules when this module is the sandox; live modules else

	cfg = mw.loadData ('Module:Citation/CS1/Configuration' .. sandbox);			-- load sandbox versions of support modules when {{#invoke:Citation/CS1/sandbox|...}}; live modules else
	whitelist = mw.loadData ('Module:Citation/CS1/Whitelist' .. sandbox);
	utilities = require ('Module:Citation/CS1/Utilities' .. sandbox);
	validation = require ('Module:Citation/CS1/Date_validation' .. sandbox);
	identifiers = require ('Module:Citation/CS1/Identifiers' .. sandbox);
	metadata = require ('Module:Citation/CS1/COinS' .. sandbox);

	utilities.set_selected_modules (cfg);										-- so that functions in Utilities can see the selected cfg tables
	identifiers.set_selected_modules (cfg, utilities);							-- so that functions in Identifiers can see the selected cfg tables and selected Utilities module
	validation.set_selected_modules (cfg, utilities);							-- so that functions in Date validataion can see selected cfg tables and the selected Utilities module
	metadata.set_selected_modules (cfg, utilities);								-- so that functions in COinS can see the selected cfg tables and selected Utilities module

	z = utilities.z;															-- table of error and category tables in Module:Citation/CS1/Utilities

	is_preview_mode = not utilities.is_set (frame:preprocess ('{{REVISIONID}}'));

	local suggestions = {};														-- table where we store suggestions if we need to loadData them
	local error_text;															-- used as a flag

	local capture;																-- the single supported capture when matching unknown parameters using patterns
	local empty_unknowns = {};													-- sequence table to hold empty unknown params for error message listing
	for k, v in pairs( args ) do												-- get parameters from the parent (template) frame
		v = mw.ustring.gsub (v, '^%s*(.-)%s*$', '%1');							-- trim leading/trailing whitespace; when v is only whitespace, becomes empty string
		if v ~= '' then
			if ('string' == type (k)) then
				k = mw.ustring.gsub (k, '%d', cfg.date_names.local_digits);		-- for enumerated parameters, translate 'local' digits to Western 0-9
			end
			if not validate( k, config.CitationClass ) then			
				if type (k) ~= 'string' then									-- exclude empty numbered parameters
					if v:match("%S+") ~= nil then
						error_text = utilities.set_message ('err_text_ignored', {v});
					end
				elseif validate (k:lower(), config.CitationClass) then 
					error_text = utilities.set_message ('err_parameter_ignored_suggest', {k, k:lower()});	-- suggest the lowercase version of the parameter
				else
					if nil == suggestions.suggestions then						-- if this table is nil then we need to load it
						suggestions = mw.loadData ('Module:Citation/CS1/Suggestions' .. sandbox);	--load sandbox version of suggestion module when {{#invoke:Citation/CS1/sandbox|...}}; live module else
					end
					for pattern, param in pairs (suggestions.patterns) do		-- loop through the patterns to see if we can suggest a proper parameter
						capture = k:match (pattern);							-- the whole match if no capture in pattern else the capture if a match
						if capture then											-- if the pattern matches 
							param = utilities.substitute (param, capture);		-- add the capture to the suggested parameter (typically the enumerator)
							if validate (param, config.CitationClass) then		-- validate the suggestion to make sure that the suggestion is supported by this template (necessary for limited parameter lists)
								error_text = utilities.set_message ('err_parameter_ignored_suggest', {k, param});	-- set the suggestion error message
							else
								error_text = utilities.set_message ('err_parameter_ignored', {k});	-- suggested param not supported by this template
								v = '';											-- unset
							end
						end
					end
					if not utilities.is_set (error_text) then					-- couldn't match with a pattern, is there an explicit suggestion?						
						if (suggestions.suggestions[ k:lower() ] ~= nil) and validate (suggestions.suggestions[ k:lower() ], config.CitationClass) then
							utilities.set_message ('err_parameter_ignored_suggest', {k, suggestions.suggestions[ k:lower() ]});
						else
							utilities.set_message ('err_parameter_ignored', {k});
							v = '';												-- unset value assigned to unrecognized parameters (this for the limited parameter lists)
						end
					end
				end				  
			end

			args[k] = v;														-- save this parameter and its value

		elseif not utilities.is_set (v) then									-- for empty parameters
			if not validate (k, config.CitationClass, true) then				-- is this empty parameter a valid parameter
				k = ('' == k) and '(empty string)' or k;						-- when k is empty string (or was space(s) trimmed to empty string), replace with descriptive text
				table.insert (empty_unknowns, utilities.wrap_style ('parameter', k));	-- format for error message and add to the list
			end
																				-- crude debug support that allows us to render a citation from module {{#invoke:}} TODO: keep?
	--	elseif args[k] ~= nil or (k == 'postscript') then						-- when args[k] has a value from {{#invoke}} frame (we don't normally do that)
	--		args[k] = v;														-- overwrite args[k] with empty string from pframe.args[k] (template frame); v is empty string here
		end																		-- not sure about the postscript bit; that gets handled in parameter validation; historical artifact?
	end	

	if 0 ~= #empty_unknowns then												-- create empty unknown error message
		utilities.set_message ('err_param_unknown_empty', {
			1 == #empty_unknowns and '' or 's',
			utilities.make_sep_list (#empty_unknowns, empty_unknowns)
			});
	end

	local non_url_param_t = {};													-- table of parameters and values that are not url-holding parameters
	local url_param_t = {};														-- table of url-holding paramters and their values

	for k, v in pairs( args ) do
		if 'string' == type (k) then											-- don't evaluate positional parameters
			has_invisible_chars (k, v);											-- look for invisible characters
		end
		has_extraneous_punc (k, v);												-- look for extraneous terminal punctuation in parameter values
		missing_pipe_check (k, v);												-- do we think that there is a parameter that is missing a pipe?
		args[k] = inter_wiki_check (k, v);										-- when language interwiki-linked parameter missing leading colon replace with wiki-link label

		if 'string' == type (k) then											-- when parameter k is not positional
			if not cfg.url_skip[k] then											-- and not in url skip table
				non_url_param_t[k] = v;											-- make a parameter/value list for extraneous url check
			else																-- and is in url skip table (a url-holding parameter)
				url_param_t[k] = v;												-- make a parameter/value list to check for values that are The Wikipedia Library url
			end
		end
	end

	has_extraneous_url (non_url_param_t);										-- look for url in parameter values where a url does not belong
	if has_twl_url (url_param_t) then												-- look for url-holding parameters that hold a The Wikipedia Library url
		args['url-access'] = 'subscription';
	end
	return table.concat ({
		frame:extensionTag ('templatestyles', '', {src='Module:Citation/CS1' .. sandbox .. '/styles.css'}),
		citation0( config, args)
	});
end


--[[--------------------------&lt; C I T A T I O N &gt;--------------------------------------------------------------

Template entry point

]]

local function citation (frame)
	local config_t = {};														-- table to store parameters from the module {{#invoke:}}
	local args_t = frame:getParent().args;										-- get template's preset parameters

	for k, v in pairs (frame.args) do											-- get parameters from the {{#invoke}} frame
		config_t[k] = v;
	--	args_t[k] = v;															-- crude debug support that allows us to render a citation from module {{#invoke:}}; skips parameter validation; TODO: keep?
	end	
	return _citation (frame, args_t, config_t)
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	citation = citation,														-- template entry point
	
	_citation = _citation,														-- module entry point
	}</text>
      <sha1>swdh50lofyqq0wmp3o2c259fg8s2nxi</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Configuration</title>
    <ns>828</ns>
    <id>24</id>
    <revision>
      <id>36</id>
      <parentid>35</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>35</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="116258" sha1="1qtnsk18jlmk0vxedax9rhtzltma8m9" xml:space="preserve">local lang_obj = mw.language.getContentLanguage();								-- make a language object for the local language; used here for languages and dates 


--[[--------------------------&lt; S E T T I N G S &gt;--------------------------------------------------------------

boolean settings used to control various things.  these setting located here to make them easy to find

]]
																				-- these settings local to this module only
local local_digits_from_mediawiki = false;										-- for i18n; when true, module fills date_names['local_digits'] from MediaWiki; manual fill required else; always false at en.wiki
local local_date_names_from_mediawiki = false;									-- for i18n; when true, module fills date_names['local']['long'] and date_names['local']['short'] from MediaWiki;
																				-- manual translation required else; ; always false at en.wiki

																				-- these settings exported to other modules
local use_identifier_redirects = true;											-- when true use redirect name for identifier label links; always true at en.wiki
local local_lang_cat_enable = false;											-- when true categorizes pages where |language=&lt;local wiki's language&gt;; always false at en.wiki
local date_name_auto_xlate_enable = false;										-- when true translates English month-names to the local-wiki's language month names; always false at en.wiki
local date_digit_auto_xlate_enable = false;										-- when true translates Western date digit to the local-wiki's language digits (date_names['local_digits']); always false at en.wiki
local enable_sort_keys = true;													-- when true module adds namespace sort keys to error and maintenance category links


--[[--------------------------&lt; U N C A T E G O R I Z E D _ N A M E S P A C E S &gt;------------------------------

List of namespaces identifiers for namespaces that will not be included in citation error categories.
Same as setting notracking = true by default.

For wikis that have a current version of Module:cs1 documentation support, this #invoke will return an unordered
list of namespace names and their associated identifiers:
	{{#invoke:cs1 documentation support|uncategorized_namespace_lister|all=&lt;anything&gt;}}

]]

local uncategorized_namespaces_t = {[2]=true};										-- init with user namespace id
for k, _ in pairs (mw.site.talkNamespaces) do									-- add all talk namespace ids
	uncategorized_namespaces_t[k] = true;
end

local uncategorized_subpages = {'/[Ss]andbox', '/[Tt]estcases', '/[^/]*[Ll]og', '/[Aa]rchive'};		-- list of Lua patterns found in page names of pages we should not categorize

--[[
at en.wiki Greek characters are used as sort keys for certain items in a category so that those items are
placed at the end of a category page.  See Wikipedia:Categorization#Sort_keys.  That works well for en.wiki
because English is written using the Latn script.  This may not work well for other languages.  At en.wiki it
is desireable to place content from certain namespaces at the end of a category listing so the module adds sort
keys to error and maintenance category links when rendering a cs1|2 template on a page in that namespace.

i18n: if this does not work well for your language, set &lt;enable_sort_keys&gt; to false.
]]

local name_space_sort_keys = {													-- sort keys to be used with these namespaces:
	[4] = 'ω',																	-- wikipedia; omega
	[10] = 'τ',																	-- template; tau
	[118] = 'Δ', 																-- draft; delta
	['other'] = 'ο',															-- all other non-talk namespaces except main (article); omicron
	}

--[[--------------------------&lt; M E S S A G E S &gt;--------------------------------------------------------------

Translation table

The following contains fixed text that may be output as part of a citation.
This is separated from the main body to aid in future translations of this
module.

]]

local messages = {
	['agency'] = '$1 $2',														-- $1 is sepc, $2 is agency
	['archived-dead'] = 'Archived from $1 on $2',
	['archived-live'] = '$1 from the original on $2',
	['archived-unfit'] = 'Archived from the original on ',
	['archived'] = 'Archived',
	['by'] = 'By',																-- contributions to authored works: introduction, foreword, afterword
	['cartography'] = 'Cartography by $1',
	['editor'] = 'ed.',
	['editors'] = 'eds.',
	['edition'] = '($1&amp;nbsp;ed.)',
	['episode'] = 'Episode $1',
	['et al'] = 'et&amp;nbsp;al.',
	['in'] = 'In',																-- edited works
	['inactive'] = 'inactive',
	['inset'] = '$1 inset',
	['interview'] = 'Interviewed by $1',										
	['mismatch'] = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; / &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt; mismatch',	-- $1 is year param name; $2 is date param name
	['newsgroup'] = '[[Usenet newsgroup|Newsgroup]]:&amp;nbsp;$1',
	['notitle'] = 'No title',													-- for |title=(()) and (in the future) |title=none
	['original'] = 'the original',
	['origdate'] = ' [$1]',
	['published'] = ' (published $1)',
	['retrieved'] = 'Retrieved $1',
	['season'] = 'Season $1',
	['section'] = '§&amp;nbsp;$1',
	['sections'] = '§§&amp;nbsp;$1',
	['series'] = '$1 $2',														-- $1 is sepc, $2 is series
	['seriesnum'] = 'Series $1',
	['translated'] = 'Translated by $1',
	['type'] = ' ($1)',															-- for titletype
	['written'] = 'Written at $1',

	['vol'] = '$1 Vol.&amp;nbsp;$2',												-- $1 is sepc; bold journal style volume is in presentation{}
	['vol-no'] = '$1 Vol.&amp;nbsp;$2, no.&amp;nbsp;$3',								-- sepc, volume, issue (alternatively insert $1 after $2, but then we'd also have to change capitalization)
	['issue'] = '$1 No.&amp;nbsp;$2',												-- $1 is sepc

	['art'] = '$1 Art.&amp;nbsp;$2',												-- $1 is sepc; for {{cite conference}} only
	['vol-art'] = '$1 Vol.&amp;nbsp;$2, art.&amp;nbsp;$3',								-- sepc, volume, article-number; for {{cite conference}} only

	['j-vol'] = '$1 $2',														-- sepc, volume; bold journal volume is in presentation{}
	['j-issue'] = ' ($1)',
	['j-article-num'] = ' $1',													-- TODO: any punctuation here? static text?

	['nopp'] = '$1 $2';															-- page(s) without prefix; $1 is sepc

	['p-prefix'] = "$1 p.&amp;nbsp;$2",												-- $1 is sepc
	['pp-prefix'] = "$1 pp.&amp;nbsp;$2",											-- $1 is sepc
	['j-page(s)'] = ': $1',														-- same for page and pages

	['sheet'] = '$1 Sheet&amp;nbsp;$2',												-- $1 is sepc
	['sheets'] = '$1 Sheets&amp;nbsp;$2',											-- $1 is sepc
	['j-sheet'] = ': Sheet&amp;nbsp;$1',
	['j-sheets'] = ': Sheets&amp;nbsp;$1',
	
	['language'] = '(in $1)',
	['via'] = " &amp;ndash; via $1",
	['event'] = 'Event occurs at',
	['minutes'] = 'minutes in',
	
	-- Determines the location of the help page
	['help page link'] = 'Help:CS1 errors',
	['help page label'] = 'help',
	
	-- categories
	['cat wikilink'] = '[[Category:$1]]',										-- $1 is the category name
	['cat wikilink sk'] = '[[Category:$1|$2]]',									-- $1 is the category name; $2 is namespace sort key
	[':cat wikilink'] = '[[:Category:$1|link]]',								-- category name as maintenance message wikilink; $1 is the category name

	-- Internal errors (should only occur if configuration is bad)
	['undefined_error'] = 'Called with an undefined error condition',
	['unknown_ID_key'] = 'Unrecognized ID key: ',								-- an ID key in id_handlers not found in ~/Identifiers func_map{}
	['unknown_ID_access'] = 'Unrecognized ID access keyword: ',					-- an ID access keyword in id_handlers not found in keywords_lists['id-access']{}
	['unknown_argument_map'] = 'Argument map not defined for this variable',
	['bare_url_no_origin'] = 'Bare URL found but origin indicator is nil or empty',
	
	['warning_msg_e'] = '&lt;span style="color:#d33"&gt;One or more &lt;code style="color: inherit; background: inherit; border: none; padding: inherit;"&gt;&amp;#123;{$1}}&lt;/code&gt; templates have errors&lt;/span&gt;; messages may be hidden ([[Help:CS1_errors#Controlling_error_message_display|help]]).';	-- $1 is template link
	['warning_msg_m'] = '&lt;span style="color:#3a3"&gt;One or more &lt;code style="color: inherit; background: inherit; border: none; padding: inherit;"&gt;&amp;#123;{$1}}&lt;/code&gt; templates have maintenance messages&lt;/span&gt;; messages may be hidden ([[Help:CS1_errors#Controlling_error_message_display|help]]).';	-- $1 is template link
	}


--[[--------------------------&lt; C I T A T I O N _ C L A S S _ M A P &gt;------------------------------------------

this table maps the value assigned to |CitationClass= in the cs1|2 templates to the canonical template name when
the value assigned to |CitationClass= is different from the canonical template name.  |CitationClass= values are
used as class attributes in the &lt;cite&gt; tag that encloses the citation so these names may not contain spaces while
the canonical template name may.  These names are used in warning_msg_e and warning_msg_m to create links to the
template's documentation when an article is displayed in preview mode.

Most cs1|2 template |CitationClass= values at en.wiki match their canonical template names so are not listed here.

]]

	local citation_class_map_t = {												-- TODO: if kept, these and all other config.CitationClass 'names' require some sort of i18n
		['arxiv'] = 'arXiv',
		['audio-visual'] = 'AV media',
		['AV-media-notes'] = 'AV media notes',
		['biorxiv'] = 'bioRxiv',
		['citeseerx'] = 'CiteSeerX',
		['encyclopaedia'] = 'encyclopedia',
		['mailinglist'] = 'mailing list',
		['medrxiv'] = 'medRxiv',
		['pressrelease'] = 'press release',
		['ssrn'] = 'SSRN',
		['techreport'] = 'tech report',
		}


--[=[-------------------------&lt; E T _ A L _ P A T T E R N S &gt;--------------------------------------------------

This table provides Lua patterns for the phrase "et al" and variants in name text
(author, editor, etc.). The main module uses these to identify and emit the 'etal' message.

]=]

local et_al_patterns = {
	"[;,]? *[\"']*%f[%a][Ee][Tt]%.? *[Aa][Ll][%.;,\"']*$",						-- variations on the 'et al' theme
	"[;,]? *[\"']*%f[%a][Ee][Tt]%.? *[Aa][Ll][Ii][AaIi][Ee]?[%.;,\"']*$",		-- variations on the 'et alia', 'et alii' and 'et aliae' themes (false positive 'et aliie' unlikely to match)
	"[;,]? *%f[%a]and [Oo]thers",												-- an alternative to et al.
	"%[%[ *[Ee][Tt]%.? *[Aa][Ll]%.? *%]%]",										-- a wikilinked form
	"%(%( *[Ee][Tt]%.? *[Aa][Ll]%.? *%)%)",										-- a double-bracketed form (to counter partial removal of ((...)) syntax)
	"[%(%[] *[Ee][Tt]%.? *[Aa][Ll]%.? *[%)%]]",									-- a bracketed form
	}


--[[--------------------------&lt; P R E S E N T A T I O N &gt;------------------------

Fixed presentation markup.  Originally part of citation_config.messages it has
been moved into its own, more semantically correct place.

]]

local presentation = 
	{
	-- .citation-comment class is specified at Help:CS1_errors#Controlling_error_message_display
	['hidden-error'] = '&lt;span class="cs1-hidden-error citation-comment"&gt;$1&lt;/span&gt;',
	['visible-error'] = '&lt;span class="cs1-visible-error citation-comment"&gt;$1&lt;/span&gt;',
	['hidden-maint'] = '&lt;span class="cs1-maint citation-comment"&gt;$1&lt;/span&gt;',
	
	['accessdate'] = '&lt;span class="reference-accessdate"&gt;$1$2&lt;/span&gt;',			-- to allow editors to hide accessdate using personal CSS

	['bdi'] = '&lt;bdi$1&gt;$2&lt;/bdi&gt;',												-- bidirectional isolation used with |script-title= and the like

	['cite'] = '&lt;cite class="$1"&gt;$2&lt;/cite&gt;';									-- for use when citation does not have a namelist and |ref= not set so no id="..." attribute
	['cite-id'] = '&lt;cite id="$1" class="$2"&gt;$3&lt;/cite&gt;';							-- for use when when |ref= is set or when citation has a namelist

	['format'] = ' &lt;span class="cs1-format"&gt;($1)&lt;/span&gt;',						-- for |format=, |chapter-format=, etc.
	['interwiki'] = ' &lt;span class="cs1-format"&gt;[in $1]&lt;/span&gt;',					-- for interwiki-language-linked author, editor, etc
	['interproj'] = ' &lt;span class="cs1-format"&gt;[at $1]&lt;/span&gt;',					-- for interwiki-project-linked author, editor, etc (:d: and :s: supported; :w: ignored)

	-- various access levels, for |access=, |doi-access=, |arxiv=, ...
	-- narrow no-break space &amp;#8239; may work better than nowrap CSS. Or not? Browser support?

	['ext-link-access-signal'] = '&lt;span class="$1" title="$2"&gt;$3&lt;/span&gt;',		-- external link with appropriate lock icon
		['free'] = {class='id-lock-free', title='Freely accessible'},			-- classes defined in Module:Citation/CS1/styles.css
		['registration'] = {class='id-lock-registration', title='Free registration required'},
		['limited'] = {class='id-lock-limited', title='Free access subject to limited trial, subscription normally required'},
		['subscription'] = {class='id-lock-subscription', title='Paid subscription required'},

	['interwiki-icon'] = '&lt;span class="$1" title="$2"&gt;$3&lt;/span&gt;',
		['class-wikisource'] = 'cs1-ws-icon',

	['italic-title'] = "''$1''",

	['kern-left'] = '&lt;span class="cs1-kern-left"&gt;&lt;/span&gt;$1',					-- spacing to use when title contains leading single or double quote mark
	['kern-right'] = '$1&lt;span class="cs1-kern-right"&gt;&lt;/span&gt;',					-- spacing to use when title contains trailing single or double quote mark

	['nowrap1'] = '&lt;span class="nowrap"&gt;$1&lt;/span&gt;',								-- for nowrapping an item: &lt;span ...&gt;yyyy-mm-dd&lt;/span&gt;
	['nowrap2'] = '&lt;span class="nowrap"&gt;$1&lt;/span&gt; $2',							-- for nowrapping portions of an item: &lt;span ...&gt;dd mmmm&lt;/span&gt; yyyy (note white space)

	['ocins'] = '&lt;span title="$1" class="Z3988"&gt;&lt;/span&gt;',
	
	['parameter'] = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',
	
	['ps_cs1'] = '.';															-- CS1 style postscript (terminal) character
	['ps_cs2'] = '';															-- CS2 style postscript (terminal) character (empty string)

	['quoted-text'] = '&lt;q&gt;$1&lt;/q&gt;',												-- for wrapping |quote= content
	['quoted-title'] = '"$1"',

	['sep_cs1'] = '.',															-- CS1 element separator
	['sep_cs2'] = ',',															-- CS2 separator
	['sep_nl'] = ';',															-- CS1|2 style name-list separator between names is a semicolon
	['sep_nl_and'] = ' and ',													-- used as last nl sep when |name-list-style=and and list has 2 items
	['sep_nl_end'] = '; and ',													-- used as last nl sep when |name-list-style=and and list has 3+ names
	['sep_name'] = ', ',														-- CS1|2 style last/first separator is &lt;comma&gt;&lt;space&gt;
	['sep_nl_vanc'] = ',',														-- Vancouver style name-list separator between authors is a comma
	['sep_name_vanc'] = ' ',													-- Vancouver style last/first separator is a space

	['sep_list'] = ', ',														-- used for |language= when list has 3+ items except for last sep which uses sep_list_end
	['sep_list_pair'] = ' and ',												-- used for |language= when list has 2 items
	['sep_list_end'] = ', and ',												-- used as last list sep for |language= when list has 3+ items
	
	['trans-italic-title'] = "&amp;#91;''$1''&amp;#93;",
	['trans-quoted-title'] = "&amp;#91;$1&amp;#93;",									-- for |trans-title= and |trans-quote=
	['vol-bold'] = '$1 &lt;b&gt;$2&lt;/b&gt;',												-- sepc, volume; for bold journal cites; for other cites ['vol'] in messages{}
	}

	
--[[--------------------------&lt; A L I A S E S &gt;---------------------------------

Aliases table for commonly passed parameters.

Parameter names on the right side in the assignments in this table must have been
defined in the Whitelist before they will be recognized as valid parameter names

]]

local aliases = {
	['AccessDate'] = {'access-date', 'accessdate'},								-- Used by InternetArchiveBot
	['Agency'] = 'agency',
	['ArchiveDate'] = {'archive-date', 'archivedate'},							-- Used by InternetArchiveBot
	['ArchiveFormat'] = 'archive-format',
	['ArchiveURL'] = {'archive-url', 'archiveurl'},								-- Used by InternetArchiveBot
	['ArticleNumber'] = 'article-number',
	['ASINTLD'] = 'asin-tld',
	['At'] = 'at',																-- Used by InternetArchiveBot
	['Authors'] = {'people', 'credits'},
	['BookTitle'] = {'book-title', 'booktitle'},
	['Cartography'] = 'cartography',
	['Chapter'] = {'chapter', 'contribution', 'entry', 'article', 'section'},
	['ChapterFormat'] = {'chapter-format', 'contribution-format', 'entry-format',
		'article-format', 'section-format'};
	['ChapterURL'] = {'chapter-url', 'contribution-url', 'entry-url', 'article-url', 'section-url'},	-- Used by InternetArchiveBot
	['ChapterUrlAccess'] = {'chapter-url-access', 'contribution-url-access',
		'entry-url-access', 'article-url-access', 'section-url-access'},		-- Used by InternetArchiveBot
	['Class'] = 'class',														-- cite arxiv and arxiv identifier
	['Collaboration'] = 'collaboration',
	['Conference'] = {'conference', 'event'},
	['ConferenceFormat'] = 'conference-format',
	['ConferenceURL'] = 'conference-url',										-- Used by InternetArchiveBot
	['Date'] = {'date', 'air-date', 'airdate'},									-- air-date and airdate for cite episode and cite serial only
	['Degree'] = 'degree',
	['DF'] = 'df',
	['DisplayAuthors'] = {'display-authors', 'display-subjects'},
	['DisplayContributors'] = 'display-contributors',
	['DisplayEditors'] = 'display-editors',
	['DisplayInterviewers'] = 'display-interviewers',
	['DisplayTranslators'] = 'display-translators',
	['Docket'] = 'docket',
	['DoiBroken'] = 'doi-broken-date',
	['Edition'] = 'edition',
	['Embargo'] = 'pmc-embargo-date',
	['Encyclopedia'] = {'encyclopedia', 'encyclopaedia', 'dictionary'},			-- cite encyclopedia only
	['Episode'] = 'episode',													-- cite serial only TODO: make available to cite episode?
	['Format'] = 'format',
	['ID'] = {'id', 'ID'},
	['Inset'] = 'inset',
	['Issue'] = {'issue', 'number'},
	['Language'] = {'language', 'lang'},
	['MailingList'] = {'mailing-list', 'mailinglist'},							-- cite mailing list only
	['Map'] = 'map',															-- cite map only
	['MapFormat'] = 'map-format',												-- cite map only
	['MapURL'] = {'map-url', 'mapurl'},											-- cite map only -- Used by InternetArchiveBot
	['MapUrlAccess'] = 'map-url-access',										-- cite map only -- Used by InternetArchiveBot
	['Minutes'] = 'minutes',
	['Mode'] = 'mode',
	['NameListStyle'] = 'name-list-style',
	['Network'] = 'network',
	['Newsgroup'] = 'newsgroup',												-- cite newsgroup only
	['NoPP'] = {'no-pp', 'nopp'},
	['NoTracking'] = {'no-tracking', 'template-doc-demo'},
	['Number'] = 'number',														-- this case only for cite techreport
	['OrigDate'] = {'orig-date', 'orig-year', 'origyear'},
	['Others'] = 'others',
	['Page'] = {'page', 'p'},													-- Used by InternetArchiveBot
	['Pages'] = {'pages', 'pp'},												-- Used by InternetArchiveBot
	['Periodical'] = {'journal', 'magazine', 'newspaper', 'periodical', 'website', 'work'},
	['Place'] = {'place', 'location'},
	['PostScript'] = 'postscript',
	['PublicationDate'] = {'publication-date', 'publicationdate'},
	['PublicationPlace'] = {'publication-place', 'publicationplace'},
	['PublisherName'] = {'publisher', 'institution'},
	['Quote'] = {'quote', 'quotation'},
	['QuotePage'] = 'quote-page',
	['QuotePages'] = 'quote-pages',
	['Ref'] = 'ref',
	['Scale'] = 'scale',
	['ScriptChapter'] = {'script-chapter', 'script-contribution', 'script-entry',
		'script-article', 'script-section'},
	['ScriptEncyclopedia'] = {'script-encyclopedia', 'script-encyclopaedia'},	-- cite encyclopedia only
	['ScriptMap'] = 'script-map',
	['ScriptPeriodical'] = {'script-journal', 'script-magazine', 'script-newspaper',
		'script-periodical', 'script-website', 'script-work'},
	['ScriptQuote'] = 'script-quote',
	['ScriptTitle'] = 'script-title',											-- Used by InternetArchiveBot
	['Season'] = 'season',
	['Sections'] = 'sections',													-- cite map only
	['Series'] = {'series', 'version'},
	['SeriesLink'] = {'series-link', 'serieslink'},
	['SeriesNumber'] = {'series-number', 'series-no'},
	['Sheet'] = 'sheet',														-- cite map only
	['Sheets'] = 'sheets',														-- cite map only
	['Station'] = 'station',
	['Time'] = 'time',
	['TimeCaption'] = 'time-caption',
	['Title'] = 'title',														-- Used by InternetArchiveBot
	['TitleLink'] = {'title-link', 'episode-link', 'episodelink'},				-- Used by InternetArchiveBot
	['TitleNote'] = {'title-note', 'department'},
	['TitleType'] = {'type', 'medium'},
	['TransChapter'] = {'trans-article', 'trans-chapter', 'trans-contribution',
		'trans-entry', 'trans-section'},
	['Transcript'] = 'transcript',
	['TranscriptFormat'] = 'transcript-format',	
	['TranscriptURL'] = 'transcript-url',										-- Used by InternetArchiveBot
	['TransEncyclopedia'] = {'trans-encyclopedia', 'trans-encyclopaedia'},		-- cite encyclopedia only
	['TransMap'] = 'trans-map',													-- cite map only
	['TransPeriodical'] = {'trans-journal', 'trans-magazine', 'trans-newspaper',
		'trans-periodical', 'trans-website', 'trans-work'},
	['TransQuote'] = 'trans-quote',
	['TransTitle'] = 'trans-title',												-- Used by InternetArchiveBot
	['URL'] = {'url', 'URL'},													-- Used by InternetArchiveBot
	['UrlAccess'] = 'url-access',												-- Used by InternetArchiveBot
	['UrlStatus'] = 'url-status',												-- Used by InternetArchiveBot
	['Vauthors'] = 'vauthors',
	['Veditors'] = 'veditors',
	['Via'] = 'via',
	['Volume'] = 'volume',
	['Year'] = 'year',

	['AuthorList-First'] = {"first#", "author-first#", "author#-first", "author-given#", "author#-given",
		"subject-first#", "subject#-first", "subject-given#", "subject#-given",
		"given#"},
	['AuthorList-Last'] = {"last#", "author-last#", "author#-last", "author-surname#", "author#-surname",
		"subject-last#", "subject#-last", "subject-surname#", "subject#-surname",
		"author#", 'host#', "subject#", "surname#"},
	['AuthorList-Link'] = {"author-link#", "author#-link", "subject-link#",
		"subject#-link", "authorlink#", "author#link"},
	['AuthorList-Mask'] = {"author-mask#", "author#-mask", "subject-mask#", "subject#-mask"},

	['ContributorList-First'] = {'contributor-first#', 'contributor#-first',
		'contributor-given#', 'contributor#-given'},
	['ContributorList-Last'] = {'contributor-last#', 'contributor#-last',
		'contributor-surname#', 'contributor#-surname', 'contributor#'},
	['ContributorList-Link'] = {'contributor-link#', 'contributor#-link'},
	['ContributorList-Mask'] = {'contributor-mask#', 'contributor#-mask'},

	['EditorList-First'] = {"editor-first#", "editor#-first", "editor-given#", "editor#-given"},
	['EditorList-Last'] = {"editor-last#", "editor#-last", "editor-surname#",
		"editor#-surname", "editor#"},
	['EditorList-Link'] = {"editor-link#", "editor#-link"},
	['EditorList-Mask'] = {"editor-mask#", "editor#-mask"},
	
	['InterviewerList-First'] = {'interviewer-first#', 'interviewer#-first',
		'interviewer-given#', 'interviewer#-given'},
	['InterviewerList-Last'] = {'interviewer-last#', 'interviewer#-last',
		'interviewer-surname#', 'interviewer#-surname', 'interviewer#'},
	['InterviewerList-Link'] = {'interviewer-link#', 'interviewer#-link'},
	['InterviewerList-Mask'] = {'interviewer-mask#', 'interviewer#-mask'},

	['TranslatorList-First'] = {'translator-first#', 'translator#-first',
		'translator-given#', 'translator#-given'},
	['TranslatorList-Last'] = {'translator-last#', 'translator#-last',
		'translator-surname#', 'translator#-surname', 'translator#'},
	['TranslatorList-Link'] = {'translator-link#', 'translator#-link'},
	['TranslatorList-Mask'] = {'translator-mask#', 'translator#-mask'},
	}


--[[--------------------------&lt; P U N C T _ S K I P &gt;---------------------------

builds a table of parameter names that the extraneous terminal punctuation check should not check.

]]

local punct_meta_params = {														-- table of aliases[] keys (meta parameters); each key has a table of parameter names for a value
	'BookTitle', 'Chapter', 'ScriptChapter', 'ScriptTitle', 'Title', 'TransChapter', 'Transcript', 'TransMap',	'TransTitle',	-- title-holding parameters
	'AuthorList-Mask', 'ContributorList-Mask', 'EditorList-Mask', 'InterviewerList-Mask', 'TranslatorList-Mask',	-- name-list mask may have name separators
	'PostScript', 'Quote', 'ScriptQuote', 'TransQuote', 'Ref',											-- miscellaneous
	'ArchiveURL', 'ChapterURL', 'ConferenceURL', 'MapURL', 'TranscriptURL', 'URL',						-- URL-holding parameters
	}

local url_meta_params = {														-- table of aliases[] keys (meta parameters); each key has a table of parameter names for a value
	'ArchiveURL', 'ChapterURL', 'ConferenceURL', 'ID', 'MapURL', 'TranscriptURL', 'URL',		-- parameters allowed to hold urls
	'Page', 'Pages', 'At', 'QuotePage', 'QuotePages',							-- insource locators allowed to hold urls
	}

local function build_skip_table (skip_t, meta_params)
	for _, meta_param in ipairs (meta_params) do								-- for each meta parameter key
		local params = aliases[meta_param];										-- get the parameter or the table of parameters associated with the meta parameter name
		if 'string' == type (params) then
			skip_t[params] = 1;													-- just a single parameter
		else
			for _, param in ipairs (params) do									-- get the parameter name
				skip_t[param] = 1;												-- add the parameter name to the skip table
				local count;
				param, count = param:gsub ('#', '');							-- remove enumerator marker from enumerated parameters
				if 0 ~= count then												-- if removed
					skip_t[param] = 1;											-- add param name without enumerator marker
				end
			end
		end
	end
	return skip_t;
end

local punct_skip = {};
local url_skip = {};


--[[--------------------------&lt; S I N G L E - L E T T E R   S E C O N D - L E V E L   D O M A I N S &gt;----------

this is a list of tlds that are known to have single-letter second-level domain names.  This list does not include
ccTLDs which are accepted in is_domain_name().

]]

local single_letter_2nd_lvl_domains_t = {'cash', 'company', 'foundation', 'media', 'org', 'today'};


--[[-----------&lt; S P E C I A L   C A S E   T R A N S L A T I O N S &gt;------------

This table is primarily here to support internationalization.  Translations in
this table are used, for example, when an error message, category name, etc.,
is extracted from the English alias key.  There may be other cases where
this translation table may be useful.

]]
local is_Latn = 'A-Za-z\195\128-\195\150\195\152-\195\182\195\184-\198\191\199\132-\201\143\225\184\128-\225\187\191';
local special_case_translation = {
	['AuthorList'] = 'authors list',											-- used to assemble maintenance category names
	['ContributorList'] = 'contributors list',									-- translation of these names plus translation of the base maintenance category names in maint_cats{} table below
	['EditorList'] = 'editors list',											-- must match the names of the actual categories
	['InterviewerList'] = 'interviewers list',									-- this group or translations used by name_has_ed_markup() and name_has_mult_names()
	['TranslatorList'] = 'translators list',
	
																				-- Lua patterns to match pseudo-titles used by InternetArchiveBot and others as placeholder for unknown |title= value
	['archived_copy'] = {														-- used with CS1 maint: Archive[d] copy as title
		['en'] = '^archived?%s+copy$',											-- for English; translators: keep this because templates imported from en.wiki
		['local'] = nil,														-- translators: replace ['local'] = nil with lowercase translation only when bots or tools create generic titles in your language
		},

																				-- Lua patterns to match generic titles; usually created by bots or reference filling tools
																				-- translators: replace ['local'] = nil with lowercase translation only when bots or tools create generic titles in your language
		-- generic titles and patterns in this table should be lowercase only
		-- leave ['local'] nil except when there is a matching generic title in your language
		-- boolean 'true' for plain-text searches; 'false' for pattern searches

	['generic_titles'] = {
		['accept'] = {
			},
		['reject'] = {
			{['en'] = {'^wayback%s+machine$', false},				['local'] = nil},
			{['en'] = {'are you a robot', true},					['local'] = nil},
			{['en'] = {'hugedomains', true},						['local'] = nil},
			{['en'] = {'^[%(%[{&lt;]?no +title[&gt;}%]%)]?$', false},		['local'] = nil},
			{['en'] = {'page not found', true},						['local'] = nil},
			{['en'] = {'subscribe to read', true},					['local'] = nil},
			{['en'] = {'^[%(%[{&lt;]?unknown[&gt;}%]%)]?$', false},		['local'] = nil},
			{['en'] = {'website is for sale', true},				['local'] = nil},
			{['en'] = {'^404', false},								['local'] = nil},
			{['en'] = {'error[ %-]404', false},						['local'] = nil},
			{['en'] = {'internet archive wayback machine', true},	['local'] = nil},
			{['en'] = {'log into facebook', true},					['local'] = nil},
			{['en'] = {'login • instagram', true},					['local'] = nil},
			{['en'] = {'redirecting...', true},						['local'] = nil},
			{['en'] = {'usurped title', true},						['local'] = nil},	-- added by a GreenC bot
			{['en'] = {'webcite query result', true},				['local'] = nil},
			{['en'] = {'wikiwix\'s cache', true},					['local'] = nil},
			}
		},

		-- boolean 'true' for plain-text searches, search string must be lowercase only
		-- boolean 'false' for pattern searches
		-- leave ['local'] nil except when there is a matching generic name in your language

	['generic_names'] = {
		['accept'] = {
			{['en'] = {'%[%[[^|]*%(author%) *|[^%]]*%]%]', false},				['local'] = nil},
			},
		['reject'] = {
			{['en'] = {'about us', true},										['local'] = nil},
			{['en'] = {'%f[%a][Aa]dvisor%f[%A]', false},						['local'] = nil},
			{['en'] = {'allmusic', true},										['local'] = nil},
			{['en'] = {'%f[%a][Aa]uthor%f[%A]', false},							['local'] = nil},
			{['en'] = {'^[Bb]ureau$', false},									['local'] = nil},
			{['en'] = {'business', true},										['local'] = nil},
			{['en'] = {'cnn', true},											['local'] = nil},
			{['en'] = {'collaborator', true},									['local'] = nil},
			{['en'] = {'^[Cc]ompany$', false},									['local'] = nil},
			{['en'] = {'contributor', true},									['local'] = nil},
			{['en'] = {'contact us', true},										['local'] = nil},
			{['en'] = {'correspondent', true},									['local'] = nil},
			{['en'] = {'^[Dd]esk$', false},										['local'] = nil},
			{['en'] = {'directory', true},										['local'] = nil},
			{['en'] = {'%f[%(%[][%(%[]%s*eds?%.?%s*[%)%]]?$', false},			['local'] = nil},
			{['en'] = {'[,%.%s]%f[e]eds?%.?$', false},							['local'] = nil},
			{['en'] = {'^eds?[%.,;]', false},									['local'] = nil},
			{['en'] = {'^[%(%[]%s*[Ee][Dd][Ss]?%.?%s*[%)%]]', false},			['local'] = nil},
			{['en'] = {'%f[%a][Ee]dited%f[%A]', false},							['local'] = nil},
			{['en'] = {'%f[%a][Ee]ditors?%f[%A]', false},						['local'] = nil},
			{['en'] = {'%f[%a][Ee]mail%f[%A]', false},							['local'] = nil},
			{['en'] = {'facebook', true},										['local'] = nil},
			{['en'] = {'google', true},											['local'] = nil},
			{['en'] = {'^[Gg]roup$', false},									['local'] = nil},
			{['en'] = {'home page', true},										['local'] = nil},
			{['en'] = {'^[Ii]nc%.?$', false},									['local'] = nil},
			{['en'] = {'instagram', true},										['local'] = nil},
			{['en'] = {'interviewer', true},									['local'] = nil},
			{['en'] = {'^[Ll]imited$', false},									['local'] = nil},
			{['en'] = {'linkedIn', true},										['local'] = nil},
			{['en'] = {'^[Nn]ews$', false},										['local'] = nil},
			{['en'] = {'[Nn]ews[ %-]?[Rr]oom', false},							['local'] = nil},
			{['en'] = {'pinterest', true},										['local'] = nil},
			{['en'] = {'policy', true},											['local'] = nil},
			{['en'] = {'privacy', true},										['local'] = nil},
			{['en'] = {'reuters', true},										['local'] = nil},
			{['en'] = {'translator', true},										['local'] = nil},
			{['en'] = {'tumblr', true},											['local'] = nil},
			{['en'] = {'twitter', true},										['local'] = nil},
			{['en'] = {'site name', true},										['local'] = nil},
			{['en'] = {'statement', true},										['local'] = nil},
			{['en'] = {'submitted', true},										['local'] = nil},
			{['en'] = {'super.?user', false},									['local'] = nil},
			{['en'] = {'%f['..is_Latn..'][Uu]ser%f[^'..is_Latn..']', false},	['local'] = nil},
			{['en'] = {'verfasser', true},										['local'] = nil},
			}
	}
	}


--[[--------------------------&lt; D A T E _ N A M E S &gt;----------------------------------------------------------

This table of tables lists local language date names and fallback English date names.
The code in Date_validation will look first in the local table for valid date names.
If date names are not found in the local table, the code will look in the English table.

Because citations can be copied to the local wiki from en.wiki, the English is
required when the date-name translation function date_name_xlate() is used.

In these tables, season numbering is defined by
Extended Date/Time Format (EDTF) Specification (https://www.loc.gov/standards/datetime/)
which became part of ISO 8601 in 2019.  See '§Sub-year groupings'. The standard
defines various divisions using numbers 21-41. CS1|2 only supports generic seasons.
EDTF does support the distinction between north and south hemisphere seasons
but CS1|2 has no way to make that distinction.

33-36 = Quarter 1, Quarter 2, Quarter 3, Quarter 4 (3 months each)

The standard does not address 'named' dates so, for the purposes of CS1|2,
Easter and Christmas are defined here as 98 and 99, which should be out of the
ISO 8601 (EDTF) range of uses for a while.

local_date_names_from_mediawiki is a boolean.  When set to:
	true – module will fetch local month names from MediaWiki for both date_names['local']['long'] and date_names['local']['short']; this will unconditionally overwrite manual translations
	false – module will *not* fetch local month names from MediaWiki

Caveat lector:  There is no guarantee that MediaWiki will provide short month names.  At your wiki you can test
the results of the MediaWiki fetch in the debug console with this command (the result is alpha sorted):
	=mw.dumpObject (p.date_names['local'])

While the module can fetch month names from MediaWiki, it cannot fetch the quarter, season, and named date names
from MediaWiki.  Those must be translated manually.

]]

local local_date_names_from_mediawiki = true;									-- when false, manual translation required for date_names['local']['long'] and date_names['local']['short']; overwrites manual translations
																				-- when true, module fetches long and short month names from MediaWiki
local date_names = {
	['en'] = {																	-- English
		['long']	= {['January'] = 1, ['February'] = 2, ['March'] = 3, ['April'] = 4, ['May'] = 5, ['June'] = 6, ['July'] = 7, ['August'] = 8, ['September'] = 9, ['October'] = 10, ['November'] = 11, ['December'] = 12},
		['short']	= {['Jan'] = 1, ['Feb'] = 2, ['Mar'] = 3, ['Apr'] = 4, ['May'] = 5, ['Jun'] = 6, ['Jul'] = 7, ['Aug'] = 8, ['Sep'] = 9, ['Oct'] = 10, ['Nov'] = 11, ['Dec'] = 12},
		['quarter'] = {['First Quarter'] = 33, ['Second Quarter'] = 34, ['Third Quarter'] = 35, ['Fourth Quarter'] = 36},
		['season']	= {['Winter'] = 24, ['Spring'] = 21, ['Summer'] = 22, ['Fall'] = 23, ['Autumn'] = 23},
		['named']	= {['Easter'] = 98, ['Christmas'] = 99},
		},
																				-- when local_date_names_from_mediawiki = false
	['local'] = {																-- replace these English date names with the local language equivalents
		['long']	= {['January'] = 1, ['February'] = 2, ['March'] = 3, ['April'] = 4, ['May'] = 5, ['June'] = 6, ['July'] = 7, ['August'] = 8, ['September'] = 9, ['October'] = 10, ['November'] = 11, ['December'] = 12},
		['short']	= {['Jan'] = 1, ['Feb'] = 2, ['Mar'] = 3, ['Apr'] = 4, ['May'] = 5, ['Jun'] = 6, ['Jul'] = 7, ['Aug'] = 8, ['Sep'] = 9, ['Oct'] = 10, ['Nov'] = 11, ['Dec'] = 12},
		['quarter'] = {['First Quarter'] = 33, ['Second Quarter'] = 34, ['Third Quarter'] = 35, ['Fourth Quarter'] = 36},
		['season']	= {['Winter'] = 24, ['Spring'] = 21, ['Summer'] = 22, ['Fall'] = 23, ['Autumn'] = 23},
		['named']	= {['Easter'] = 98, ['Christmas'] = 99},
		},
	['inv_local_long'] = {},													-- used in date reformatting &amp; translation; copy of date_names['local'].long where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['inv_local_short'] = {},													-- used in date reformatting &amp; translation; copy of date_names['local'].short where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['inv_local_quarter'] = {},													-- used in date translation; copy of date_names['local'].quarter where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['inv_local_season'] = {},													-- used in date translation; copy of date_names['local'].season where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['inv_local_named'] = {},													-- used in date translation; copy of date_names['local'].named where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['local_digits'] = {['0'] = '0', ['1'] = '1', ['2'] = '2', ['3'] = '3', ['4'] = '4', ['5'] = '5', ['6'] = '6', ['7'] = '7', ['8'] = '8', ['9'] = '9'},	-- used to convert local language digits to Western 0-9
	['xlate_digits'] = {},
	}

if local_date_names_from_mediawiki then											-- if fetching local month names from MediaWiki is enabled
	local long_t = {};
	local short_t = {};
	for i=1, 12 do																-- loop 12x and 
		local name = lang_obj:formatDate('F', '2022-' .. i .. '-1');			-- get long month name for each i
		long_t[name] = i;														-- save it
		name = lang_obj:formatDate('M', '2022-' .. i .. '-1');					-- get short month name for each i
		short_t[name] = i;														-- save it
	end
	date_names['local']['long'] = long_t;										-- write the long table – overwrites manual translation
	date_names['local']['short'] = short_t;										-- write the short table – overwrites manual translation
end
																				-- create inverted date-name tables for reformatting and/or translation
for _, invert_t in pairs {{'long', 'inv_local_long'}, {'short', 'inv_local_short'}, {'quarter', 'inv_local_quarter'}, {'season', 'inv_local_season'}, {'named', 'inv_local_named'}} do
	for name, i in pairs (date_names['local'][invert_t[1]]) do					-- this table is ['name'] = i
		date_names[invert_t[2]][i] = name;										-- invert to get [i] = 'name' for conversions from ymd
	end
end

if local_digits_from_mediawiki then												-- if fetching local digits from MediaWiki is enabled
	local digits_t = {};
	for i=0, 9 do																-- loop 10x and 
		digits_t [lang_obj:formatNum (i)] = tostring (i);						-- format the loop indexer as local lang table index and assign loop indexer (a string) as the value
	end
	date_names['local_digits'] = digits_t;
end

for ld, ed in pairs (date_names.local_digits) do								-- make a digit translation table for simple date translation from en to local language using local_digits table
	date_names.xlate_digits [ed] = ld;											-- en digit becomes index with local digit as the value
end

local df_template_patterns = {													-- table of redirects to {{Use dmy dates}} and {{Use mdy dates}}
	'{{ *[Uu]se +(dmy) +dates *[|}]',	-- 1159k								-- sorted by approximate transclusion count
	'{{ *[Uu]se +(mdy) +dates *[|}]',	-- 212k
	'{{ *[Uu]se +(MDY) +dates *[|}]',	-- 788
	'{{ *[Uu]se +(DMY) +dates *[|}]',	-- 343
	'{{ *([Mm]dy) *[|}]',				-- 176
	'{{ *[Uu]se *(dmy) *[|}]',			-- 156 + 18
	'{{ *[Uu]se *(mdy) *[|}]',			-- 149 + 11
	'{{ *([Dd]my) *[|}]',				-- 56
	'{{ *[Uu]se +(MDY) *[|}]',			-- 5
	'{{ *([Dd]MY) *[|}]',				-- 3
	'{{ *[Uu]se(mdy)dates *[|}]',		-- 1
	'{{ *[Uu]se +(DMY) *[|}]',			-- 0
	'{{ *([Mm]DY) *[|}]',				-- 0
	}

local title_object = mw.title.getCurrentTitle();
local content;																	-- done this way  so that unused templates appear in unused-template-reports; self-transcluded makes them look like they are used
if 10 ~= title_object.namespace then											-- all namespaces except Template
	content = title_object:getContent() or '';									-- get the content of the article or ''; new pages edited w/ve do not have 'content' until saved; ve does not preview; phab:T221625
end

local function get_date_format ()
	if not content then															-- nil content when we're in template
		return nil;																-- auto-formatting does not work in Template space so don't set global_df
	end
	for _, pattern in ipairs (df_template_patterns) do							-- loop through the patterns looking for {{Use dmy dates}} or {{Use mdy dates}} or any of their redirects
		local start, _, match = content:find(pattern);							-- match is the three letters indicating desired date format
		if match then
			local use_dates_template = content:match ('%b{}', start);			-- get the whole template
			if use_dates_template:match ('| *cs1%-dates *= *[lsy][sy]?') then	-- look for |cs1-dates=publication date length access-/archive-date length
				return match:lower() .. '-' .. use_dates_template:match ('| *cs1%-dates *= *([lsy][sy]?)');
			else
				return match:lower() .. '-all';									-- no |cs1-dates= k/v pair; return value appropriate for use in |df=
			end
		end
	end
end

local global_df;																-- TODO: add this to &lt;global_cs1_config_t&gt;?


--[[-----------------&lt; V O L U M E ,  I S S U E ,  P A G E S &gt;------------------

These tables hold cite class values (from the template invocation) and identify those templates that support
|volume=, |issue=, and |page(s)= parameters.  Cite conference and cite map require further qualification which
is handled in the main module.

]]

local templates_using_volume = {'citation', 'audio-visual', 'book', 'conference', 'encyclopaedia', 'interview', 'journal', 'magazine', 'map', 'news', 'report', 'techreport', 'thesis'}
local templates_using_issue = {'citation', 'conference', 'episode', 'interview', 'journal', 'magazine', 'map', 'news', 'podcast'}
local templates_not_using_page = {'audio-visual', 'episode', 'mailinglist', 'newsgroup', 'podcast', 'serial', 'sign', 'speech'}

--[[

These tables control when it is appropriate for {{citation}} to render |volume= and/or |issue=.  The parameter
names in the tables constrain {{citation}} so that its renderings match the renderings of the equivalent cs1
templates.  For example, {{cite web}} does not support |volume= so the equivalent {{citation |website=...}} must
not support |volume=.

]]

local citation_no_volume_t = {													-- {{citation}} does not render |volume= when these parameters are used
	'website', 'mailinglist', 'script-website',
	}
local citation_issue_t = {														-- {{citation}} may render |issue= when these parameters are used
	'journal', 'magazine', 'newspaper', 'periodical', 'work',
	'script-journal', 'script-magazine', 'script-newspaper', 'script-periodical', 'script-work',
	}

--[[

Patterns for finding extra text in |volume=, |issue=, |page=, |pages=

]]

local vol_iss_pg_patterns = {
	good_ppattern = '^P[^%.PpGg]',												-- OK to begin with uppercase P: P7 (page 7 of section P), but not p123 (page 123); TODO: this allows 'Pages' which it should not
	bad_ppatterns = {															-- patterns for |page= and |pages=
		'^[Pp][PpGg]?%.?[ %d]',
		'^[Pp][Pp]?%.&amp;nbsp;',													-- from {{p.}} and {{pp.}} templates
		'^[Pp]ages?',
		'^[Pp]gs.?',
		},
	vi_patterns_t = {															-- combined to catch volume-like text in |issue= and issue-like text in |volume=
		'^volumes?',															-- volume-like text
		'^vols?[%.:=]?',

		'^issues?',																--issue-like text
		'^iss[%.:=]?',
		'^numbers?',
		'^nos?%A',																-- don't match 'november' or 'nostradamus'
		'^nr[%.:=]?',
		'^n[%.:= ]',															-- might be a valid issue without separator (space char is sep char here)
		'^n°',																	-- 'n' with degree sign (U+00B0)
		'^№',																	-- precomposed unicode numero character (U+2116)
		},
	}

--[[--------------------------&lt; K E Y W O R D S &gt;-------------------------------

These tables hold keywords for those parameters that have defined sets of acceptable keywords.

]]

--[[-------------------&lt; K E Y W O R D S   T A B L E &gt;--------------------------

this is a list of keywords; each key in the list is associated with a table of
synonymous keywords possibly from different languages.

for I18N: add local-language keywords to value table; do not change the key.
For example, adding the German keyword 'ja':
	['affirmative'] = {'yes', 'true', 'y', 'ja'},

Because CS1|2 templates from en.wiki articles are often copied to other local wikis,
it is recommended that the English keywords remain in these tables.

]]

local keywords = {
	['amp'] = {'&amp;', 'amp', 'ampersand'}, 										-- |name-list-style=
	['and'] = {'and', 'serial'},												-- |name-list-style=
	['affirmative'] = {'yes', 'true', 'y'},										-- |no-tracking=, |no-pp= -- Used by InternetArchiveBot
	['afterword'] = {'afterword'},												-- |contribution=
	['bot: unknown'] = {'bot: unknown'},										-- |url-status= -- Used by InternetArchiveBot
	['cs1'] = {'cs1'},															-- |mode=
	['cs2'] = {'cs2'},															-- |mode=
	['dead'] = {'dead', 'deviated'},											-- |url-status= -- Used by InternetArchiveBot
	['dmy'] = {'dmy'},															-- |df=
	['dmy-all'] = {'dmy-all'},													-- |df=
	['foreword'] = {'foreword'},												-- |contribution=
	['free'] = {'free'},														-- |&lt;id&gt;-access= -- Used by InternetArchiveBot
	['harv'] = {'harv'},														-- |ref=; this no longer supported; is_valid_parameter_value() called with &lt;invert&gt; = true
	['introduction'] = {'introduction'},										-- |contribution=
	['limited'] = {'limited'},													-- |url-access= -- Used by InternetArchiveBot
	['live'] = {'live'},														-- |url-status= -- Used by InternetArchiveBot
	['mdy'] = {'mdy'},															-- |df=
	['mdy-all'] = {'mdy-all'},													-- |df=
	['none'] = {'none'},														-- |postscript=, |ref=, |title=, |type= -- Used by InternetArchiveBot
	['off'] = {'off'},															-- |title= (potentially also: |title-link=, |postscript=, |ref=, |type=)
	['preface'] = {'preface'},													-- |contribution=
	['registration'] = {'registration'},										-- |url-access= -- Used by InternetArchiveBot
	['subscription'] = {'subscription'},										-- |url-access= -- Used by InternetArchiveBot
	['unfit'] = {'unfit'},														-- |url-status= -- Used by InternetArchiveBot
	['usurped'] = {'usurped'},													-- |url-status= -- Used by InternetArchiveBot
	['vanc'] = {'vanc'},														-- |name-list-style=
	['ymd'] = {'ymd'},															-- |df=
	['ymd-all'] = {'ymd-all'},													-- |df=
	--	['yMd'] = {'yMd'},														-- |df=; not supported at en.wiki
	--	['yMd-all'] = {'yMd-all'},												-- |df=; not supported at en.wiki
	}


--[[------------------------&lt; X L A T E _ K E Y W O R D S &gt;---------------------

this function builds a list, keywords_xlate{}, of the keywords found in keywords{} where the values from keywords{}
become the keys in keywords_xlate{} and the keys from keywords{} become the values in keywords_xlate{}:
	['affirmative'] = {'yes', 'true', 'y'},		-- in keywords{}
becomes
	['yes'] = 'affirmative',					-- in keywords_xlate{}
	['true'] = 'affirmative',
	['y'] = 'affirmative',

the purpose of this function is to act as a translator between a non-English keyword and its English equivalent
that may be used in other modules of this suite

]]

local function xlate_keywords ()
	local out_table = {};														-- output goes here
	for k, keywords_t in pairs (keywords) do									-- spin through the keywords table
		for _, keyword in ipairs (keywords_t) do								-- for each keyword
			out_table[keyword] = k;												-- create an entry in the output table where keyword is the key
		end
	end
	
	return out_table;
end

local keywords_xlate = xlate_keywords ();										-- the list of translated keywords


--[[----------------&lt; M A K E _ K E Y W O R D S _ L I S T &gt;---------------------

this function assembles, for parameter-value validation, the list of keywords appropriate to that parameter.

keywords_lists{}, is a table of tables from keywords{}

]]

local function make_keywords_list (keywords_lists)
	local out_table = {};														-- output goes here
	
	for _, keyword_list in ipairs (keywords_lists) do							-- spin through keywords_lists{} and get a table of keywords
		for _, keyword in ipairs (keyword_list) do								-- spin through keyword_list{} and add each keyword, ...
			table.insert (out_table, keyword);									-- ... as plain text, to the output list
		end
	end
	return out_table;
end


--[[----------------&lt; K E Y W O R D S _ L I S T S &gt;-----------------------------

this is a list of lists of valid keywords for the various parameters in [key].
Generally the keys in this table are the canonical en.wiki parameter names though
some are contrived because of use in multiple differently named parameters:
['yes_true_y'], ['id-access'].

The function make_keywords_list() extracts the individual keywords from the
appropriate list in keywords{}.

The lists in this table are used to validate the keyword assignment for the
parameters named in this table's keys.

]]

local keywords_lists = {
	['yes_true_y'] = make_keywords_list ({keywords.affirmative}),
	['contribution'] = make_keywords_list ({keywords.afterword, keywords.foreword, keywords.introduction, keywords.preface}),
	['df'] = make_keywords_list ({keywords.dmy, keywords['dmy-all'], keywords.mdy, keywords['mdy-all'], keywords.ymd, keywords['ymd-all']}),
	--	['df'] = make_keywords_list ({keywords.dmy, keywords['dmy-all'], keywords.mdy, keywords['mdy-all'], keywords.ymd, keywords['ymd-all'], keywords.yMd, keywords['yMd-all']}),	-- not supported at en.wiki
	['mode'] = make_keywords_list ({keywords.cs1, keywords.cs2}),
	['name-list-style'] = make_keywords_list ({keywords.amp, keywords['and'], keywords.vanc}),
	['ref'] = make_keywords_list ({keywords.harv}),								-- inverted check; |ref=harv no longer supported
	['url-access'] = make_keywords_list ({keywords.subscription, keywords.limited, keywords.registration}),
	['url-status'] = make_keywords_list ({keywords.dead, keywords.live, keywords.unfit, keywords.usurped, keywords['bot: unknown']}),
	['id-access'] = make_keywords_list ({keywords.free}),
	}


--[[--------------------------&lt; C S 1 _ C O N F I G _ G E T &gt;--------------------------------------------------

fetch and validate values from {{cs1 config}} template to fill &lt;global_cs1_config_t&gt;

no error messages; when errors are detected, the parameter value from {{cs1 config}} is blanked.

Supports all parameters and aliases associated with the metaparameters: DisplayAuthors, DisplayContributors,
DisplayEditors, DisplayInterviewers, DisplayTranslators, NameListStyle, and Mode.  The DisplayWhatever metaparameters
accept numeric values only (|display-authors=etal and the like is not supported).

]]

local global_cs1_config_t = {};													-- TODO: add value returned from get_date_format() to this table?

local function get_cs1_config ()
	if not content then															-- nil content when we're in template
		return nil;																-- auto-formatting does not work in Template space so don't set global_df
	end

	local start = content:find('{{ *[Cc][Ss]1 config *[|}]');					-- &lt;start&gt; is offset into &lt;content&gt; when {{cs1 config}} found; nil else
	if start then
		local cs1_config_template = content:match ('%b{}', start);				-- get the whole template

		if not cs1_config_template then
			return nil;
		end

		local params_t = mw.text.split (cs1_config_template:gsub ('^{{%s*', ''):gsub ('%s*}}$', ''), '%s*|%s*');	-- remove '{{' and '}}'; make a sequence of parameter/value pairs (split on the pipe)
		table.remove (params_t, 1);												-- remove the template name because it isn't a parameter/value pair

		local config_meta_params_t = {'DisplayAuthors', 'DisplayContributors', 'DisplayEditors', 'DisplayInterviewers', 'DisplayTranslators', 'NameListStyle', 'Mode'};
		local meta_param_map_t = {};											-- list of accepted parameter names usable in {{cs1 config}} goes here
		
		for _, meta_param in ipairs (config_meta_params_t) do					-- for i18n using &lt;config_meta_params_t&gt;, map template parameter names to their metaparameter equivalents
			if 'table' == type (aliases[meta_param]) then						-- if &lt;meta_param&gt; is a sequence, 
				for _, param in ipairs (aliases[meta_param]) do					-- extract its contents
					meta_param_map_t[param] = meta_param;						-- and add to &lt;meta_param_map_t&gt;
				end
			else
				meta_param_map_t[aliases[meta_param]] = meta_param;				-- not a sequence so just add the parameter to &lt;meta_param_map_t&gt;
			end
		end

		local keywords_t = {};													-- map valid keywords to their associate metaparameter; reverse form of &lt;keyword_lists[key] for these metaparameters
		for _, metaparam_t in ipairs ({{'NameListStyle', 'name-list-style'}, {'Mode', 'mode'}}) do	-- only these metaparameter / keywords_lists key pairs
			for _, keyword in ipairs (keywords_lists[metaparam_t[2]]) do		-- spin through the list of keywords
				keywords_t[keyword] = metaparam_t[1];							-- add [keyword] = metaparameter to the map
			end
		end

		for _, param in ipairs (params_t) do									-- spin through the {{cs1 config}} parameters and fill &lt;global_cs1_config_t&gt;
			local k, v = param:match ('([^=]-)%s*=%s*(.+)');					-- &lt;k&gt; is the parameter name; &lt;v&gt; is parameter's assigned value
			if k then
				if k:find ('^display') then										-- if &lt;k&gt; is one of the |display-&lt;namelist&gt;= parameters
					if v:match ('%d+') then										-- the assigned value must be digits; doesn't accept 'etal'
						global_cs1_config_t[meta_param_map_t[k]]=v;				-- add the display param and its value to globals table
					end
				else
					if keywords_t[v] == meta_param_map_t[k] then				-- keywords_t[v] returns nil or the metaparam name; these must be the same
						global_cs1_config_t[meta_param_map_t[k]]=v;				-- add the parameter and its value to globals table
					end
				end
			end
		end
	end
end

get_cs1_config ();																-- fill &lt;global_cs1_config_t&gt;


--[[---------------------&lt; S T R I P M A R K E R S &gt;----------------------------

Common pattern definition location for stripmarkers so that we don't have to go
hunting for them if (when) MediaWiki changes their form.

]]

local stripmarkers = {
	['any'] = '\127[^\127]*UNIQ%-%-(%a+)%-[%a%d]+%-QINU[^\127]*\127',			-- capture returns name of stripmarker
	['math'] = '\127[^\127]*UNIQ%-%-math%-[%a%d]+%-QINU[^\127]*\127'			-- math stripmarkers used in coins_cleanup() and coins_replace_math_stripmarker()
	}


--[[------------&lt; I N V I S I B L E _ C H A R A C T E R S &gt;---------------------

This table holds non-printing or invisible characters indexed either by name or
by Unicode group. Values are decimal representations of UTF-8 codes.  The table
is organized as a table of tables because the Lua pairs keyword returns table
data in an arbitrary order.  Here, we want to process the table from top to bottom
because the entries at the top of the table are also found in the ranges specified
by the entries at the bottom of the table.

Also here is a pattern that recognizes stripmarkers that begin and end with the
delete characters.  The nowiki stripmarker is not an error but some others are
because the parameter values that include them become part of the template's
metadata before stripmarker replacement.

]]

local invisible_defs = {
	del = '\127',																-- used to distinguish between stripmarker and del char
	zwj = '\226\128\141',														-- used with capture because zwj may be allowed
	}

local invisible_chars = {
	{'replacement', '\239\191\189'},											-- U+FFFD, EF BF BD
	{'zero width joiner', '('.. invisible_defs.zwj .. ')'},						-- U+200D, E2 80 8D; capture because zwj may be allowed
	{'zero width space', '\226\128\139'},										-- U+200B, E2 80 8B
	{'hair space', '\226\128\138'},												-- U+200A, E2 80 8A
	{'soft hyphen', '\194\173'},												-- U+00AD, C2 AD
	{'horizontal tab', '\009'},													-- U+0009 (HT), 09
	{'line feed', '\010'},														-- U+000A (LF), 0A
	{'no-break space', '\194\160'},												-- U+00A0 (NBSP), C2 A0
	{'carriage return', '\013'},												-- U+000D (CR), 0D
	{'stripmarker', stripmarkers.any},											-- stripmarker; may or may not be an error; capture returns the stripmaker type
	{'delete', '('.. invisible_defs.del .. ')'},								-- U+007F (DEL), 7F; must be done after stripmarker test; capture to distinguish isolated del chars not part of stripmarker
	{'C0 control', '[\000-\008\011\012\014-\031]'},								-- U+0000–U+001F (NULL–US), 00–1F (except HT, LF, CR (09, 0A, 0D))
	{'C1 control', '[\194\128-\194\159]'},										-- U+0080–U+009F (XXX–APC), C2 80 – C2 9F
	--	{'Specials', '[\239\191\185-\239\191\191]'},								-- U+FFF9-U+FFFF, EF BF B9 – EF BF BF
	--	{'Private use area', '[\238\128\128-\239\163\191]'},						-- U+E000–U+F8FF, EE 80 80 – EF A3 BF
	--	{'Supplementary Private Use Area-A', '[\243\176\128\128-\243\191\191\189]'},	-- U+F0000–U+FFFFD, F3 B0 80 80 – F3 BF BF BD
	--	{'Supplementary Private Use Area-B', '[\244\128\128\128-\244\143\191\189]'},	-- U+100000–U+10FFFD, F4 80 80 80 – F4 8F BF BD
	}

--[[

Indic script makes use of zero width joiner as a character modifier so zwj
characters must be left in.  This pattern covers all of the unicode characters
for these languages:
	Devanagari					0900–097F – https://unicode.org/charts/PDF/U0900.pdf
		Devanagari extended		A8E0–A8FF – https://unicode.org/charts/PDF/UA8E0.pdf
	Bengali						0980–09FF – https://unicode.org/charts/PDF/U0980.pdf
	Gurmukhi					0A00–0A7F – https://unicode.org/charts/PDF/U0A00.pdf
	Gujarati					0A80–0AFF – https://unicode.org/charts/PDF/U0A80.pdf
	Oriya						0B00–0B7F – https://unicode.org/charts/PDF/U0B00.pdf
	Tamil						0B80–0BFF – https://unicode.org/charts/PDF/U0B80.pdf
	Telugu						0C00–0C7F – https://unicode.org/charts/PDF/U0C00.pdf
	Kannada						0C80–0CFF – https://unicode.org/charts/PDF/U0C80.pdf
	Malayalam					0D00–0D7F – https://unicode.org/charts/PDF/U0D00.pdf
plus the not-necessarily Indic scripts for Sinhala and Burmese:
	Sinhala						0D80-0DFF - https://unicode.org/charts/PDF/U0D80.pdf
	Myanmar						1000-109F - https://unicode.org/charts/PDF/U1000.pdf
		Myanmar extended A		AA60-AA7F - https://unicode.org/charts/PDF/UAA60.pdf
		Myanmar extended B		A9E0-A9FF - https://unicode.org/charts/PDF/UA9E0.pdf
the pattern is used by has_invisible_chars() and coins_cleanup()

]]

local indic_script = '[\224\164\128-\224\181\191\224\163\160-\224\183\191\225\128\128-\225\130\159\234\167\160-\234\167\191\234\169\160-\234\169\191]';

-- list of emoji that use a zwj character (U+200D) to combine with another emoji
-- from: https://unicode.org/Public/emoji/16.0/emoji-zwj-sequences.txt; version: 16.0; 2024-08-14
-- table created by: [[:en:Module:Make emoji zwj table]]
local emoji_t = {																-- indexes are decimal forms of the hex values in U+xxxx
	[8596] = true,																-- U+2194 ↔ left right arrow
	[8597] = true,																-- U+2195 ↕ up down arrow
	[9760] = true,																-- U+2620 ☠ skull and crossbones
	[9792] = true,																-- U+2640 ♀ female sign
	[9794] = true,																-- U+2642 ♂ male sign
	[9877] = true,																-- U+2695 ⚕ staff of aesculapius
	[9878] = true,																-- U+2696 ⚖ scales
	[9895] = true,																-- U+26A7 ⚧ male with stroke and male and female sign
	[9992] = true,																-- U+2708 ✈ airplane
	[10052] = true,																-- U+2744 ❄ snowflake
	[10084] = true,																-- U+2764 ❤ heavy black heart
	[10145] = true,																-- U+27A1 ➡ black rightwards arrow
	[11035] = true,																-- U+2B1B ⬛ black large square
	[127752] = true,															-- U+1F308 🌈 rainbow
	[127787] = true,															-- U+1F32B 🌫 fog
	[127806] = true,															-- U+1F33E 🌾 ear of rice
	[127859] = true,															-- U+1F373 🍳 cooking
	[127868] = true,															-- U+1F37C 🍼 baby bottle
	[127876] = true,															-- U+1F384 🎄 christmas tree
	[127891] = true,															-- U+1F393 🎓 graduation cap
	[127908] = true,															-- U+1F3A4 🎤 microphone
	[127912] = true,															-- U+1F3A8 🎨 artist palette
	[127979] = true,															-- U+1F3EB 🏫 school
	[127981] = true,															-- U+1F3ED 🏭 factory
	[128102] = true,															-- U+1F466 👦 boy
	[128103] = true,															-- U+1F467 👧 girl
	[128104] = true,															-- U+1F468 👨 man
	[128105] = true,															-- U+1F469 👩 woman
	[128139] = true,															-- U+1F48B 💋 kiss mark
	[128165] = true,															-- U+1F4A5 💥 collision symbol
	[128168] = true,															-- U+1F4A8 💨 dash symbol
	[128171] = true,															-- U+1F4AB 💫 dizzy symbol
	[128187] = true,															-- U+1F4BB 💻 personal computer
	[128188] = true,															-- U+1F4BC 💼 brief case
	[128293] = true,															-- U+1F525 🔥 fire
	[128295] = true,															-- U+1F527 🔧 wrench
	[128300] = true,															-- U+1F52C 🔬 microscope
	[128488] = true,															-- U+1F5E8 🗨 left speech bubble
	[128640] = true,															-- U+1F680 🚀 rocket
	[128658] = true,															-- U+1F692 🚒 fire engine
	[129001] = true,															-- U+1F7E9 🟩 large green square
	[129003] = true,															-- U+1F7EB 🟫 large brown square
	[129309] = true,															-- U+1F91D 🤝 handshake
	[129455] = true,															-- U+1F9AF 🦯 probing cane
	[129456] = true,															-- U+1F9B0 🦰 emoji component red hair
	[129457] = true,															-- U+1F9B1 🦱 emoji component curly hair
	[129458] = true,															-- U+1F9B2 🦲 emoji component bald
	[129459] = true,															-- U+1F9B3 🦳 emoji component white hair
	[129466] = true,															-- U+1F9BA 🦺 safety vest
	[129468] = true,															-- U+1F9BC 🦼 motorized wheelchair
	[129469] = true,															-- U+1F9BD 🦽 manual wheelchair
	[129489] = true,															-- U+1F9D1 🧑 adult
	[129490] = true,															-- U+1F9D2 🧒 child
	[129657] = true,															-- U+1FA79 🩹 adhesive bandage
	[129778] = true,															-- U+1FAF2 🫲 leftwards hand
	}


--[[----------------------&lt; L A N G U A G E   S U P P O R T &gt;-------------------

These tables and constants support various language-specific functionality.

]]

--local this_wiki_code = mw.getContentLanguage():getCode();						-- get this wiki's language code
local this_wiki_code = lang_obj:getCode();										-- get this wiki's language code
if string.match (mw.site.server, 'wikidata') then
		this_wiki_code = mw.getCurrentFrame():callParserFunction('int', {'lang'}); -- on Wikidata so use interface language setting instead
	end

local mw_languages_by_tag_t = mw.language.fetchLanguageNames (this_wiki_code, 'all');	-- get a table of language tag/name pairs known to Wikimedia; used for interwiki tests
local mw_languages_by_name_t = {};
	for k, v in pairs (mw_languages_by_tag_t) do								-- build a 'reversed' table name/tag language pairs know to MediaWiki; used for |language=
		v = mw.ustring.lower (v);												-- lowercase for tag fetch; get name's proper case from mw_languages_by_tag_t[&lt;tag&gt;]
		if mw_languages_by_name_t[v] then										-- when name already in the table
			if 2 == #k or 3 == #k then											-- if tag does not have subtags
				mw_languages_by_name_t[v] = k;									-- prefer the shortest tag for this name
			end
		else																	-- here when name not in the table
			mw_languages_by_name_t[v] = k;										-- so add name and matching tag
		end
	end

local inter_wiki_map = {};														-- map of interwiki prefixes that are language-code prefixes
	for k, v in pairs (mw.site.interwikiMap ('local')) do						-- spin through the base interwiki map (limited to local)
		if mw_languages_by_tag_t[v["prefix"]] then								-- if the prefix matches a known language tag
			inter_wiki_map[v["prefix"]] = true;									-- add it to our local map
		end
	end


--[[--------------------&lt; S C R I P T _ L A N G _ C O D E S &gt;-------------------

This table is used to hold ISO 639-1 two-character and ISO 639-3 three-character
language codes that apply only to |script-title= and |script-chapter=

]]

local script_lang_codes = {
	'ab', 'am', 'ar', 'az', 'be', 'bg', 'bn', 'bo', 'bs', 'ce', 'chr', 'dv', 'dz',
	'el', 'fa', 'grc', 'gu', 'he', 'hi', 'hy', 'ja', 'ka', 'kk', 'km', 'kn', 'ko',
	'ku', 'ky', 'lo', 'mk', 'ml', 'mn', 'mni', 'mr', 'my', 'ne', 'or', 'ota',
	'pa', 'ps', 'ru', 'sd', 'si', 'sr', 'syc', 'ta', 'te', 'tg', 'th', 'ti', 'tt',
	'ug', 'uk', 'ur', 'uz', 'yi', 'yue', 'zh', 'zgh'
	};


--[[---------------&lt; L A N G U A G E   R E M A P P I N G &gt;----------------------

These tables hold language information that is different (correct) from MediaWiki's definitions

For each ['&lt;tag&gt;'] = 'language name' in lang_code_remap{} there must be a matching ['language name'] = {'language name', '&lt;tag&gt;'} in lang_name_remap{}

lang_tag_remap{}:
	key is always lowercase ISO 639-1, -2, -3 language tag or a valid lowercase IETF language tag
	value is properly spelled and capitalized language name associated with &lt;tag&gt;
	only one language name per &lt;tag&gt;;
	key/value pair must have matching entry in lang_name_remap{}

lang_name_remap{}:
	key is always lowercase language name
	value is a table the holds correctly spelled and capitalized language name [1] and associated tag [2] (tag must match a tag key in lang_tag_remap{})
	may have multiple keys referring to a common preferred name and tag; For example:
		['kolsch'] and ['kölsch'] both refer to 'Kölsch' and 'ksh'

]]

local lang_tag_remap = {														-- used for |language= and |script-title= / |script-chapter=
	['als'] = 'Tosk Albanian',													-- MediaWiki returns Alemannisch 
	['bh'] = 'Bihari',															-- MediaWiki uses 'bh' as a subdomain name for Bhojpuri Wikipedia: bh.wikipedia.org
	['bla'] = 'Blackfoot',														-- MediaWiki/IANA/ISO 639: Siksika; use en.wiki preferred name
	['bn'] = 'Bengali',															-- MediaWiki returns Bangla
	['ca-valencia'] = 'Valencian',												-- IETF variant of Catalan
	['fkv'] = 'Kven',															-- MediaWiki returns Kvensk
	['gsw'] = 'Swiss German',
	['ilo'] = 'Ilocano',														-- MediaWiki/IANA/ISO 639: Iloko; use en.wiki preferred name
	['ksh'] = 'Kölsch',															-- MediaWiki: Colognian; use IANA/ISO 639 preferred name
	['ksh-x-colog'] = 'Colognian',												-- override MediaWiki ksh; no IANA/ISO 639 code for Colognian; IETF private code created at Module:Lang/data
	['mis-x-ripuar'] = 'Ripuarian',												-- override MediaWiki ksh; no IANA/ISO 639 code for Ripuarian; IETF private code created at Module:Lang/data
	['nan-tw'] = 'Taiwanese Hokkien',											-- make room for MediaWiki/IANA/ISO 639 nan: Min Nan Chinese and support en.wiki preferred name
	['sr-ec'] = 'Serbian (Cyrillic script)',									-- MediaWiki returns српски (ћирилица)
	['sr-el'] = 'Serbian (Latin script)',										-- MediaWiki returns srpski (latinica)
	}

local lang_name_remap = {														-- used for |language=; names require proper capitalization; tags must be lowercase
	['alemannic'] = {'Swiss German', 'gsw'},									-- ISO 639-2, -3 alternate for Swiss German; MediaWiki mediawiki returns Alemannic for gsw; en.wiki preferred name
	['alemannisch'] = {'Swiss German', 'gsw'},									-- not an ISO or IANA language name; MediaWiki uses 'als' as a subdomain name for Alemannic Wikipedia: als.wikipedia.org
	['bangla'] = {'Bengali', 'bn'},												-- MediaWiki returns Bangla (the endonym) but we want Bengali (the exonym); here we remap
	['bengali'] = {'Bengali', 'bn'},											-- MediaWiki doesn't use exonym so here we provide correct language name and 639-1 code
	['bhojpuri'] = {'Bhojpuri', 'bho'},											-- MediaWiki uses 'bh' as a subdomain name for Bhojpuri Wikipedia: bh.wikipedia.org
	['bihari'] = {'Bihari', 'bh'},												-- MediaWiki replaces 'Bihari' with 'Bhojpuri' so 'Bihari' cannot be found
	['blackfoot'] = {'Blackfoot', 'bla'},										-- MediaWiki/IANA/ISO 639: Siksika; use en.wiki preferred name
	['colognian'] = {'Colognian', 'ksh-x-colog'},								-- MediaWiki preferred name for ksh
	['ilocano'] = {'Ilocano', 'ilo'},											-- MediaWiki/IANA/ISO 639: Iloko; use en.wiki preferred name
	['kolsch'] = {'Kölsch', 'ksh'},												-- use IANA/ISO 639 preferred name (use non-diacritical o instead of umlaut ö)
	['kölsch'] = {'Kölsch', 'ksh'},												-- use IANA/ISO 639 preferred name
	['kven'] = {'Kven', 'fkv'},													-- Unicode CLDR have decided not to support English language name for these two...
	['kvensk'] = {'Kven', 'fkv'},												-- ...they say to refer to IANA registry for English names
	['ripuarian'] = {'Ripuarian', 'mis-x-ripuar'},								-- group of dialects; no code in MediaWiki or in IANA/ISO 639
	['serbian (cyrillic script)'] = {'Serbian (Cyrillic script)', 'sr-cyrl'},	-- special case to get correct tag when |language=sr-ec
	['serbian (latin script)'] = {'Serbian (Latin script)', 'sr-latn'},			-- special case to get correct tag when |language=sr-el
	['swiss german'] = {'Swiss German', 'gsw'},
	['taiwanese hokkien'] = {'Taiwanese Hokkien', 'nan-tw'},					-- make room for MediaWiki/IANA/ISO 639 nan: Min Nan Chinese 
	['tosk albanian'] = {'Tosk Albanian', 'als'},								-- MediaWiki replaces 'Tosk Albanian' with 'Alemannisch' so 'Tosk Albanian' cannot be found
	['valencian'] = {'Valencian', 'ca-valencia'},								-- variant of Catalan; categorizes as Valencian
	}


--[[---------------&lt; P R O P E R T I E S _ C A T E G O R I E S &gt;----------------

Properties categories. These are used for investigating qualities of citations.

]]

local prop_cats = {
	['foreign-lang-source'] = 'CS1 $1-language sources ($2)',					-- |language= categories; $1 is foreign-language name, $2 is ISO639-1 code
	['foreign-lang-source-2'] = 'CS1 foreign language sources (ISO 639-2)|$1',	-- |language= category; a cat for ISO639-2 languages; $1 is the ISO 639-2 code used as a sort key
	['interproj-linked-name'] = 'CS1 interproject-linked names|$1',				-- any author, editor, etc that has an interproject link; $1 is interproject tag used as a sort key
	['interwiki-linked-name'] = 'CS1 interwiki-linked names|$1',				-- any author, editor, etc that has an interwiki link; $1 is interwiki tag used as a sort key; yeilds to interproject
	['local-lang-source'] = 'CS1 $1-language sources ($2)',						-- |language= categories; $1 is local-language name, $2 is ISO639-1 code; not emitted when local_lang_cat_enable is false
	['location-test'] = 'CS1 location test',
	['long-vol'] = 'CS1: long volume value',									-- probably temporary cat to identify scope of |volume= values longer than 4 characters
	['script'] = 'CS1 uses $1-language script ($2)',							-- |script-title=xx: has matching category; $1 is language name, $2 is language tag
	['tracked-param'] = 'CS1 tracked parameter: $1',							-- $1 is base (enumerators removed) parameter name
	['unfit'] = 'CS1: unfit URL',												-- |url-status=unfit or |url-status=usurped; used to be a maint cat
	['vanc-accept'] = 'CS1:Vancouver names with accept markup',					-- for |vauthors=/|veditors= with accept-as-written markup
	['year-range-abbreviated'] = 'CS1: abbreviated year range',					-- probably temporary cat to identify scope of |date=, |year= values using YYYY–YY form
	}


--[[-------------------&lt; T I T L E _ T Y P E S &gt;--------------------------------

Here we map a template's CitationClass to TitleType (default values for |type= parameter)

]]

local title_types = {
	['AV-media-notes'] = 'Media notes',
	['document'] = 'Document',
	['interview'] = 'Interview',
	['mailinglist'] = 'Mailing list',
	['map'] = 'Map',
	['podcast'] = 'Podcast',
	['pressrelease'] = 'Press release',
	['report'] = 'Report',
	['speech'] = 'Speech',
	['techreport'] = 'Technical report',
	['thesis'] = 'Thesis',
	}


--[[--------------------------&lt; B U I L D _ K N O W N _ F R E E _ D O I _ R E G I S T R A N T S _ T A B L E &gt;--

build a table of doi registrants known to be free-to-read  In a doi, the registrant ID is the series of digits
between the '10.' and the first '/': in doi 10.1100/sommat, 1100 is the registrant ID

see §3.2.2 DOI prefix of the Doi Handbook p. 43
https://www.doi.org/doi-handbook/DOI_Handbook_Final.pdf#page=43

]]

local function build_free_doi_registrants_table()
	local registrants_t = {};
	for _, v in ipairs ({
		'1045', '1074', '1096', '1100', '1155', '1186', '1194', '1371', '1629', '1989', '1999', '2147', '2196', '3285', '3389', '3390',
		'3748', '3814', '3847', '3897', '4061', '4089', '4103', '4172', '4175', '4230', '4236', '4239', '4240', '4249', '4251',
		'4252', '4253', '4254', '4291', '4292', '4329', '4330', '4331', '5194', '5210', '5306', '5312', '5313', '5314',
		'5315', '5316', '5317', '5318', '5319', '5320', '5321', '5334', '5402', '5409', '5410', '5411', '5412',
		'5492', '5493', '5494', '5495', '5496', '5497', '5498', '5499', '5500', '5501', '5527', '5528', '5662',
		'6064', '6219', '7167', '7217', '7287', '7482', '7490', '7554', '7717', '7759', '7766', '11131', '11569', '11647',
		'11648', '12688', '12703', '12715', '12942', '12998', '13105', '14256', '14293', '14303', '15215', '15347', '15412', '15560', '16995',
		'17645', '18637', '19080', '19173', '20944', '21037', '21468', '21767', '22261', '22323', '22459', '24105', '24196', '24966',
		'26775', '30845', '32545', '35711', '35712', '35713', '35995', '36648', '37126', '37532', '37871', '47128',
		'47622', '47959', '52437', '52975', '53288', '54081', '54947', '55667', '55914', '57009', '58647', '59081',
		}) do
			registrants_t[v] = true;											-- build a k/v table of known free-to-read doi registrants
	end

	return registrants_t;
end

local extended_registrants_t = {												-- known free registrants identifiable by the doi suffix incipit
	['1002'] = {'aelm', 'leap'},												-- Advanced Electronic Materials, Learned Publishing
	['1016'] = {'j.heliyon', 'j.nlp', 'j.proche'},								-- Heliyon, Natural Language Processing, Procedia Chemistry
	['1017'] = {'nlp'},															-- Natural Language Processing Journal
	['1046'] = {'j.1365-8711', 'j.1365-246x'},									-- MNRAS, GJI
	['1093'] = {'mnras', 'mnrasl', 'gji', 'rasti'},								-- MNRAS, MNRAS Letters, GJI, RASTI
	['1099'] = {'acmi', 'mic', '00221287', 'mgen'},                             -- Access Microbiology, Microbiology, Journal of General Microbiology, Microbial Genomics
	['1111'] = {'j.1365-2966', 'j.1745-3933', 'j.1365-246X'},					-- MNRAS, MNRAS Letters, GJI
	['1210'] = {'jendso','jcemcr'},												-- Journal of the Endocrine Society, JCEM Case Reports
	['4171'] = {'dm','mag'},												    -- Documenta Mathematica, EMS Magazine
	['14231'] = {'ag'},															-- Algebraic Geometry
	}


--[[===================&lt;&lt; E R R O R   M E S S A G I N G &gt;&gt;======================
]]

--[[----------&lt; E R R O R   M E S S A G E   S U P P L I M E N T S &gt;-------------

I18N for those messages that are supplemented with additional specific text that
describes the reason for the error

TODO: merge this with special_case_translations{}?
]]

local err_msg_supl = {
	['char'] = 'invalid character',												-- |isbn=, |sbn=
	['check'] = 'checksum',														-- |isbn=, |sbn=
	['flag'] = 'flag',															-- |archive-url=
	['form'] = 'invalid form',													-- |isbn=, |sbn=
	['group'] = 'invalid group id',												-- |isbn=
	['initials'] = 'initials',													-- Vancouver
	['invalid language code'] = 'invalid language code',						-- |script-&lt;param&gt;=
	['journal'] = 'journal',													-- |bibcode=
	['length'] = 'length',														-- |isbn=, |bibcode=, |sbn=
	['liveweb'] = 'liveweb',													-- |archive-url=
	['missing comma'] = 'missing comma',										-- Vancouver
	['missing prefix'] = 'missing prefix',										-- |script-&lt;param&gt;=
	['missing title part'] = 'missing title part',								-- |script-&lt;param&gt;=
	['name'] = 'name',															-- Vancouver
	['non-Latin char'] = 'non-Latin character',									-- Vancouver
	['path'] = 'path',															-- |archive-url=
	['prefix'] = 'invalid prefix',												-- |isbn=
	['punctuation'] = 'punctuation',											-- Vancouver
	['save'] = 'save command',													-- |archive-url=
	['suffix'] = 'suffix',														-- Vancouver
	['timestamp'] = 'timestamp',												-- |archive-url=
	['unknown language code'] = 'unknown language code',						-- |script-&lt;param&gt;=
	['value'] = 'value',														-- |bibcode=
	['year'] = 'year',															-- |bibcode=
	}


--[[--------------&lt; E R R O R _ C O N D I T I O N S &gt;---------------------------

Error condition table.  This table has two sections: errors at the top, maintenance
at the bottom.  Maint 'messaging' does not have a 'message' (message=nil)

The following contains a list of IDs for various error conditions defined in the
code.  For each ID, we specify a text message to display, an error category to
include, and whether the error message should be wrapped as a hidden comment.

Anchor changes require identical changes to matching anchor in Help:CS1 errors

TODO: rename error_conditions{} to something more generic; create separate error
and maint tables inside that?

]]

local error_conditions = {
	err_accessdate_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;access-date=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'accessdate_missing_url',
		category = 'CS1 errors: access-date without URL',
		hidden = false
 		},
	err_apostrophe_markup = {
		message = 'Italic or bold markup not allowed in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'apostrophe_markup',
		category = 'CS1 errors: markup',
		hidden = false
 		},
	err_archive_date_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-date=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt;',
		anchor = 'archive_date_missing_url',
		category = 'CS1 errors: archive-url',
		hidden = false
		},
	err_archive_date_url_ts_mismatch = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-date=&lt;/code&gt; / &lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; timestamp mismatch; $1 suggested',
		anchor = 'archive_date_url_ts_mismatch',
		category = 'CS1 errors: archive-url',
		hidden = false
		},
	err_archive_missing_date = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;archive-date=&lt;/code&gt;',
		anchor = 'archive_missing_date',
		category = 'CS1 errors: archive-url',
		hidden = false
		},
	err_archive_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'archive_missing_url',
		category = 'CS1 errors: archive-url',
		hidden = false
		},
	err_archive_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; is malformed: $1',	-- $1 is error message detail
		anchor = 'archive_url',
		category = 'CS1 errors: archive-url',
		hidden = false
		},
	err_arxiv_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;arxiv=&lt;/code&gt; required',
		anchor = 'arxiv_missing',
		category = 'CS1 errors: arXiv',											-- same as bad arxiv
		hidden = false
		},
	err_asintld_missing_asin = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;asin=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'asintld_missing_asin',
		category = 'CS1 errors: ASIN TLD',
		hidden = false
		},
	err_bad_arxiv = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;arxiv=&lt;/code&gt; value',
		anchor = 'bad_arxiv',
		category = 'CS1 errors: arXiv',
		hidden = false
		},
	err_bad_asin = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;asin=&lt;/code&gt; value',
		anchor = 'bad_asin',
		category ='CS1 errors: ASIN',
		hidden = false
		},
	err_bad_asin_tld = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;asin-tld=&lt;/code&gt; value',
		anchor = 'bad_asin_tld',
		category ='CS1 errors: ASIN TLD',
		hidden = false
		},
	err_bad_bibcode = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;bibcode=&lt;/code&gt; $1',		-- $1 is error message detail
		anchor = 'bad_bibcode',
		category = 'CS1 errors: bibcode',
		hidden = false
		},
	err_bad_biorxiv = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;biorxiv=&lt;/code&gt; value',
		anchor = 'bad_biorxiv',
		category = 'CS1 errors: bioRxiv',
		hidden = false
		},
	err_bad_citeseerx = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;citeseerx=&lt;/code&gt; value',
		anchor = 'bad_citeseerx',
		category = 'CS1 errors: citeseerx',
		hidden = false
		},
	err_bad_date = {
		message = 'Check date values in: $1',									-- $1 is a parameter name list
		anchor = 'bad_date',
		category = 'CS1 errors: dates',
		hidden = false
		},
	err_bad_doi = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;doi=&lt;/code&gt; value',
		anchor = 'bad_doi',
		category = 'CS1 errors: DOI',
		hidden = false
		},
	err_bad_hdl = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;hdl=&lt;/code&gt; value',
		anchor = 'bad_hdl',
		category = 'CS1 errors: HDL',
		hidden = false
		},
	err_bad_isbn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;isbn=&lt;/code&gt; value: $1',	-- $1 is error message detail
		anchor = 'bad_isbn',
		category = 'CS1 errors: ISBN',
		hidden = false
		},
	err_bad_ismn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ismn=&lt;/code&gt; value',
		anchor = 'bad_ismn',
		category = 'CS1 errors: ISMN',
		hidden = false
		},
	err_bad_issn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;$1issn=&lt;/code&gt; value',	-- $1 is 'e' or '' for eissn or issn
		anchor = 'bad_issn',
		category = 'CS1 errors: ISSN',
		hidden = false
		},
	err_bad_jfm = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;jfm=&lt;/code&gt; value',
		anchor = 'bad_jfm',
		category = 'CS1 errors: JFM',
		hidden = false
		},
	err_bad_jstor = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;jstor=&lt;/code&gt; value',
		anchor = 'bad_jstor',
		category = 'CS1 errors: JSTOR',
		hidden = false
		},
	err_bad_lccn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;lccn=&lt;/code&gt; value',
		anchor = 'bad_lccn',
		category = 'CS1 errors: LCCN',
		hidden = false
		},
	err_bad_medrxiv = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;medrxiv=&lt;/code&gt; value',
		anchor = 'bad_medrxiv',
		category = 'CS1 errors: medRxiv',
		hidden = false
		},
	err_bad_mr = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;mr=&lt;/code&gt; value',
		anchor = 'bad_mr',
		category = 'CS1 errors: MR',
		hidden = false
		},
	err_bad_oclc = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;oclc=&lt;/code&gt; value',
		anchor = 'bad_oclc',
		category = 'CS1 errors: OCLC',
		hidden = false
		},
	err_bad_ol = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ol=&lt;/code&gt; value',
		anchor = 'bad_ol',
		category = 'CS1 errors: OL',
		hidden = false
		},
	err_bad_osti = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;osti=&lt;/code&gt; value',
		anchor = 'bad_osti',
		category = 'CS1 errors: OSTI',
		hidden = false
		},
	err_bad_paramlink = {														-- for |title-link=, |author/editor/translator-link=, |series-link=, |episode-link=
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; value',		-- $1 is parameter name
		anchor = 'bad_paramlink',
		category = 'CS1 errors: parameter link',
		hidden = false
		},
	err_bad_pmc = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;pmc=&lt;/code&gt; value',
		anchor = 'bad_pmc',
		category = 'CS1 errors: PMC',
		hidden = false
		},
	err_bad_pmid = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;pmid=&lt;/code&gt; value',
		anchor = 'bad_pmid',
		category = 'CS1 errors: PMID',
		hidden = false
		},
	err_bad_rfc = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;rfc=&lt;/code&gt; value',
		anchor = 'bad_rfc',
		category = 'CS1 errors: RFC',
		hidden = false
		},
	err_bad_s2cid = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;s2cid=&lt;/code&gt; value',
		anchor = 'bad_s2cid',
		category = 'CS1 errors: S2CID',
		hidden = false
		},
	err_bad_sbn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;sbn=&lt;/code&gt; value: $1',	-- $1 is error message detail
		anchor = 'bad_sbn',
		category = 'CS1 errors: SBN',
		hidden = false
		},
	err_bad_ssrn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ssrn=&lt;/code&gt; value',
		anchor = 'bad_ssrn',
		category = 'CS1 errors: SSRN',
		hidden = false
		},
	err_bad_url = {
		message = 'Check $1 value',												-- $1 is parameter name
		anchor = 'bad_url',
		category = 'CS1 errors: URL',
		hidden = false
		},
	err_bad_usenet_id = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;message-id=&lt;/code&gt; value',
		anchor = 'bad_message_id',
		category = 'CS1 errors: message-id',
		hidden = false
		},
	err_bad_zbl = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;zbl=&lt;/code&gt; value',
		anchor = 'bad_zbl',
		category = 'CS1 errors: Zbl',
		hidden = false
		},
	err_bare_url_missing_title = {
		message = '$1 missing title',											-- $1 is parameter name
		anchor = 'bare_url_missing_title',
		category = 'CS1 errors: bare URL',
		hidden = false
		},
	err_biorxiv_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;biorxiv=&lt;/code&gt; required',
		anchor = 'biorxiv_missing',
		category = 'CS1 errors: bioRxiv',										-- same as bad bioRxiv
		hidden = false
		},
	err_chapter_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored',			-- $1 is parameter name
		anchor = 'chapter_ignored',
		category = 'CS1 errors: chapter ignored',
		hidden = false
		},
	err_citation_missing_title = {
		message = 'Missing or empty &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'citation_missing_title',
		category = 'CS1 errors: missing title',
		hidden = false
		},
	err_citeseerx_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;citeseerx=&lt;/code&gt; required',
		anchor = 'citeseerx_missing',
		category = 'CS1 errors: citeseerx',										-- same as bad citeseerx
		hidden = false
		},
	err_cite_web_url = {														-- this error applies to cite web and to cite podcast
		message = 'Missing or empty &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'cite_web_url',
		category = 'CS1 errors: requires URL',
		hidden = false
		},
	err_class_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;class=&lt;/code&gt; ignored',
		anchor = 'class_ignored',
		category = 'CS1 errors: class',
		hidden = false
		},
	err_contributor_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;contributor=&lt;/code&gt; ignored',
		anchor = 'contributor_ignored',
		category = 'CS1 errors: contributor',
		hidden = false
		},
	err_contributor_missing_required_param = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;contributor=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'contributor_missing_required_param',
		category = 'CS1 errors: contributor',
		hidden = false
		},
	err_deprecated_params = {
		message = 'Cite uses deprecated parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'deprecated_params',
		category = 'CS1 errors: deprecated parameters',
		hidden = false
		},
	err_disp_name = {
		message = 'Invalid &lt;code class="cs1-code"&gt;&amp;#124;$1=$2&lt;/code&gt;',			-- $1 is parameter name; $2 is the assigned value
		anchor = 'disp_name',
		category = 'CS1 errors: display-names',
		hidden = false,
		},
	err_doibroken_missing_doi = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;doi=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'doibroken_missing_doi',
		category = 'CS1 errors: DOI',
		hidden = false
		},
	err_embargo_missing_pmc = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;pmc=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'embargo_missing_pmc',
		category = 'CS1 errors: PMC embargo',
		hidden = false
		},
	err_empty_citation = {
		message = 'Empty citation',
		anchor = 'empty_citation',
		category = 'CS1 errors: empty citation',
		hidden = false
		},
	err_etal = {
		message = 'Explicit use of et al. in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'explicit_et_al',
		category = 'CS1 errors: explicit use of et al.',
		hidden = false
		},
	err_extra_text_edition = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;edition=&lt;/code&gt; has extra text',
		anchor = 'extra_text_edition',
		category = 'CS1 errors: extra text: edition',
		hidden = false,
		},
	err_extra_text_issue = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has extra text',		-- $1 is parameter name
		anchor = 'extra_text_issue',
		category = 'CS1 errors: extra text: issue',
		hidden = false,
		},
	err_extra_text_pages = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has extra text',		-- $1 is parameter name
		anchor = 'extra_text_pages',
		category = 'CS1 errors: extra text: pages',
		hidden = false,
		},
	err_extra_text_volume = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has extra text',		-- $1 is parameter name
		anchor = 'extra_text_volume',
		category = 'CS1 errors: extra text: volume',
		hidden = false,
		},
	err_first_missing_last = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; missing &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is first alias, $2 is matching last alias
		anchor = 'first_missing_last',
		category = 'CS1 errors: missing name',									-- author, contributor, editor, interviewer, translator
		hidden = false
		},
	err_format_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is format parameter $2 is url parameter
		anchor = 'format_missing_url',
		category = 'CS1 errors: format without URL',
		hidden = false
		},
	err_generic_name = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has generic name',	-- $1 is parameter name
		anchor = 'generic_name',
		category = 'CS1 errors: generic name',
		hidden = false,
		},
	err_generic_title = {
		message = 'Cite uses generic title',
		anchor = 'generic_title',
		category = 'CS1 errors: generic title',
		hidden = false,
		},
	err_invalid_isbn_date = {
		message = 'ISBN / Date incompatibility',
		anchor = 'invalid_isbn_date',
		category = 'CS1 errors: ISBN date',
		hidden = true
		},
	err_invalid_param_val = {
		message = 'Invalid &lt;code class="cs1-code"&gt;&amp;#124;$1=$2&lt;/code&gt;',			-- $1 is parameter name $2 is parameter value
		anchor = 'invalid_param_val',
		category = 'CS1 errors: invalid parameter value',
		hidden = false
		},
	err_invisible_char = {
		message = '$1 in $2 at position $3',									-- $1 is invisible char $2 is parameter name $3 is position number
		anchor = 'invisible_char',
		category = 'CS1 errors: invisible characters',
		hidden = false
		},
	err_medrxiv_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;medrxiv=&lt;/code&gt; required',
		anchor = 'medrxiv_missing',
		category = 'CS1 errors: medRxiv',										-- same as bad medRxiv
		hidden = false
		},
	err_missing_name = {
		message = 'Missing &lt;code class="cs1-code"&gt;&amp;#124;$1$2=&lt;/code&gt;',			-- $1 is modified NameList; $2 is enumerator
		anchor = 'missing_name',
		category = 'CS1 errors: missing name',									-- author, contributor, editor, interviewer, translator
		hidden = false
		},
	err_missing_periodical = {
		message = 'Cite $1 requires &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is cs1 template name; $2 is canonical periodical parameter name for cite $1
		anchor = 'missing_periodical',
		category = 'CS1 errors: missing periodical',
		hidden = false
		},
	err_missing_pipe = {
		message = 'Missing pipe in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'missing_pipe',
		category = 'CS1 errors: missing pipe',
		hidden = false
		},
	err_missing_publisher = {
		message = 'Cite $1 requires &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is cs1 template name; $2 is canonical publisher parameter name for cite $1
		anchor = 'missing_publisher',
		category = 'CS1 errors: missing publisher',
		hidden = false
		},
	err_numeric_names = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has numeric name',	-- $1 is parameter name',
		anchor = 'numeric_names',
		category = 'CS1 errors: numeric name',
		hidden = false,
		},
	err_param_access_requires_param = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1-access=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'param_access_requires_param',
		category = 'CS1 errors: param-access',
		hidden = false
		},
	err_param_has_ext_link = {
		message = 'External link in &lt;code class="cs1-code"&gt;$1&lt;/code&gt;',			-- $1 is parameter name
		anchor = 'param_has_ext_link',
		category = 'CS1 errors: external links',
		hidden = false
		},
	err_param_has_twl_url = {
		message = 'Wikipedia Library link in &lt;code class="cs1-code"&gt;$1&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'param_has_twl_url',
		category = 'CS1 errors: URL',
		hidden = false
		},
	err_parameter_ignored = {
		message = 'Unknown parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored',	-- $1 is parameter name
		anchor = 'parameter_ignored',
		category = 'CS1 errors: unsupported parameter',
		hidden = false
		},
	err_parameter_ignored_suggest = {
		message = 'Unknown parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored (&lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt; suggested)',	-- $1 is unknown parameter $2 is suggested parameter name
		anchor = 'parameter_ignored_suggest',
		category = 'CS1 errors: unsupported parameter',
		hidden = false
		},
	err_periodical_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored',			-- $1 is parameter name
		anchor = 'periodical_ignored',
		category = 'CS1 errors: periodical ignored',
		hidden = false
		},
	err_redundant_parameters = {
		message = 'More than one of $1 specified',								-- $1 is error message detail
		anchor = 'redundant_parameters',
		category = 'CS1 errors: redundant parameter',
		hidden = false
		},
	err_script_parameter = {
		message = 'Invalid &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;: $2',		-- $1 is parameter name $2 is script language code or error detail
		anchor = 'script_parameter',
		category = 'CS1 errors: script parameters',
		hidden = false
		},
	err_ssrn_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;ssrn=&lt;/code&gt; required',
		anchor = 'ssrn_missing',
		category = 'CS1 errors: SSRN',
		hidden = false
		},
	err_text_ignored = {
		message = 'Text "$1" ignored',											-- $1 is ignored text
		anchor = 'text_ignored',
		category = 'CS1 errors: unrecognized parameter',
		hidden = false
		},
	err_trans_missing_title = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;trans-$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; or &lt;code class="cs1-code"&gt;&amp;#124;script-$1=&lt;/code&gt;',	-- $1 is base parameter name
		anchor = 'trans_missing_title',
		category = 'CS1 errors: translated title',
		hidden = false
		},
	err_param_unknown_empty = {
		message = 'Cite has empty unknown parameter$1: $2',						-- $1 is 's' or empty space; $2 is emty unknown param list
		anchor = 'param_unknown_empty',
		category = 'CS1 errors: empty unknown parameters',
		hidden = false
		},
	err_vancouver = {
		message = 'Vancouver style error: $1 in name $2',						-- $1 is error detail, $2 is the nth name
		anchor = 'vancouver',
		category = 'CS1 errors: Vancouver style',
		hidden = false
		},
	err_wikilink_in_url = {
		message = 'URL–wikilink conflict',										-- uses ndash
		anchor = 'wikilink_in_url',
		category = 'CS1 errors: URL–wikilink conflict',							-- uses ndash
		hidden = false
		},


--[[--------------------------&lt; M A I N T &gt;-------------------------------------

maint messages do not have a message (message = nil); otherwise the structure
is the same as error messages

]]

	maint_archived_copy = {
		message = nil,
		anchor = 'archived_copy',
		category = 'CS1 maint: archived copy as title',
		hidden = true,
		},
	maint_bibcode = {
		message = nil,
		anchor = 'bibcode',
		category = 'CS1 maint: bibcode',
		hidden = true,
		},
	maint_location_no_publisher = {												-- cite book, conference, encyclopedia; citation as book cite or encyclopedia cite
		message = nil,
		anchor = 'location_no_publisher',
		category = 'CS1 maint: location missing publisher',
		hidden = true,
		},
	maint_bot_unknown = {
		message = nil,
		anchor = 'bot:_unknown',
		category = 'CS1 maint: bot: original URL status unknown',
		hidden = true,
		},
	maint_date_auto_xlated = {													-- date auto-translation not supported by en.wiki
		message = nil,
		anchor = 'date_auto_xlated',
		category = 'CS1 maint: date auto-translated',
		hidden = true,
		},
	maint_date_format = {
		message = nil,
		anchor = 'date_format',
		category = 'CS1 maint: date format',
		hidden = true,
		},
	maint_date_year = {
		message = nil,
		anchor = 'date_year',
		category = 'CS1 maint: date and year',
		hidden = true,
		},
	maint_doi_ignore = {
		message = nil,
		anchor = 'doi_ignore',
		category = 'CS1 maint: ignored DOI errors',
		hidden = true,
		},
	maint_doi_inactive = {
		message = nil,
		anchor = 'doi_inactive',
		category = 'CS1 maint: DOI inactive',
		hidden = true,
		},
	maint_doi_inactive_dated = {
		message = nil,
		anchor = 'doi_inactive_dated',
		category = 'CS1 maint: DOI inactive as of $2$3$1',						-- $1 is year, $2 is month-name or empty string, $3 is space or empty string
		hidden = true,
		},
	maint_doi_unflagged_free = {
		message = nil,
		anchor = 'doi_unflagged_free',
		category = 'CS1 maint: unflagged free DOI',
		hidden = true,
		},
	maint_extra_punct = {
		message = nil,
		anchor = 'extra_punct',
		category = 'CS1 maint: extra punctuation',
		hidden = true,
		},
	maint_id_limit_load_fail = {												-- applies to all cs1|2 templates on a page; 
		message = nil,															-- maint message (category link) never emitted
		anchor = 'id_limit_load_fail',
		category = 'CS1 maint: ID limit load fail',
		hidden = true,
		},
	maint_isbn_ignore = {
		message = nil,
		anchor = 'ignore_isbn_err',
		category = 'CS1 maint: ignored ISBN errors',
		hidden = true,
		},
	maint_issn_ignore = {
		message = nil,
		anchor = 'ignore_issn',
		category = 'CS1 maint: ignored ISSN errors',
		hidden = true,
		},
	maint_jfm_format = {
		message = nil,
		anchor = 'jfm_format',
		category = 'CS1 maint: JFM format',
		hidden = true,
		},
	maint_location = {
		message = nil,
		anchor = 'location',
		category = 'CS1 maint: location',
		hidden = true,
		},
	maint_mr_format = {
		message = nil,
		anchor = 'mr_format',
		category = 'CS1 maint: MR format',
		hidden = true,
		},
	maint_mult_names = {
		message = nil,
		anchor = 'mult_names',
		category = 'CS1 maint: multiple names: $1',								-- $1 is '&lt;name&gt;s list'; gets value from special_case_translation table
		hidden = true,
		},
	maint_numeric_names = {
		message = nil,
		anchor = 'numeric_names',
		category = 'CS1 maint: numeric names: $1',								-- $1 is '&lt;name&gt;s list'; gets value from special_case_translation table
		hidden = true,
		},
	maint_others = {
		message = nil,
		anchor = 'others',
		category = 'CS1 maint: others',
		hidden = true,
		},
	maint_others_avm = {
		message = nil,
		anchor = 'others_avm',
		category = 'CS1 maint: others in cite AV media (notes)',
		hidden = true,
		},
	maint_overridden_setting = {
		message = nil,
		anchor = 'overridden',
		category = 'CS1 maint: overridden setting',
		hidden = true,
		},
	maint_pmc_embargo = {
		message = nil,
		anchor = 'embargo',
		category = 'CS1 maint: PMC embargo expired',
		hidden = true,
		},
	maint_pmc_format = {
		message = nil,
		anchor = 'pmc_format',
		category = 'CS1 maint: PMC format',
		hidden = true,
		},
	maint_postscript = {
		message = nil,
		anchor = 'postscript',
		category = 'CS1 maint: postscript',
		hidden = true,
	},
	maint_publisher_location = {
		message = nil,
		anchor = 'publisher_location',
		category = 'CS1 maint: publisher location',
		hidden = true,
	},
	maint_ref_duplicates_default = {
		message = nil,
		anchor = 'ref_default',
		category = 'CS1 maint: ref duplicates default',
		hidden = true,
	},
	maint_unknown_lang = {
		message = nil,
		anchor = 'unknown_lang',
		category = 'CS1 maint: unrecognized language',
		hidden = true,
		},
	maint_untitled = {
		message = nil,
		anchor = 'untitled',
		category = 'CS1 maint: untitled periodical',
		hidden = true,
		},
	maint_url_status = {
		message = nil,
		anchor = 'url_status',
		category = 'CS1 maint: url-status',
		hidden = true,
		},
	maint_year= {
		message = nil,
		anchor = 'year',
		category = 'CS1 maint: year',
		hidden = true,
		},
	maint_zbl = {
		message = nil,
		anchor = 'zbl',
		category = 'CS1 maint: Zbl',
		hidden = true,
		},
	}


--[[--------------------------&lt; I D _ L I M I T S _ D A T A _ T &gt;----------------------------------------------

fetch id limits for certain identifiers from c:Data:CS1/Identifier limits.tab.  This source is a json tabular 
data file maintained at wikipedia commons.  Convert the json format to a table of k/v pairs.

The values from &lt;id_limits_data_t&gt; are used to set handle.id_limit.

From 2025-02-21, MediaWiki is broken.  Use this link to edit the tablular data file:
	https://commons.wikimedia.org/w/index.php?title=Data:CS1/Identifier_limits.tab&amp;action=edit
See Phab:T389105

]]

local id_limits_data_t = {};

local use_commons_data = true;													-- set to false if your wiki does not have access to mediawiki commons; then,
if false == use_commons_data then												-- update this table from https://commons.wikimedia.org/wiki/Data:CS1/Identifier_limits.tab; last update: 2025-02-21
	id_limits_data_t = {['OCLC'] = 10450000000, ['OSTI'] = 23010000, ['PMC'] = 11900000, ['PMID'] = 40400000, ['RFC'] = 9300, ['SSRN'] = 5200000, ['S2CID'] = 276000000};	-- this table must be maintained locally

else																			-- here for wikis that do have access to mediawiki commons
	local load_fail_limit = 99999999999;										-- very high number to avoid error messages on load failure
	id_limits_data_t = {['OCLC'] = load_fail_limit, ['OSTI'] = load_fail_limit, ['PMC'] = load_fail_limit, ['PMID'] = load_fail_limit, ['RFC'] = load_fail_limit, ['SSRN'] = load_fail_limit, ['S2CID'] = load_fail_limit};

	local id_limits_data_load_fail = false;										-- flag; assume that we will be successful when loading json id limit tabular data
	
	local tab_data_t = mw.ext.data.get ('CS1/Identifier limits.tab').data;		-- attempt to load the json limit data from commons into &lt;tab_data_t&gt;
	if false == tab_data_t then													-- undocumented 'feature': mw.ext.data.get() sometimes returns false
		id_limits_data_load_fail = true;										-- set the flag so that Module:Citation/CS1 can create an unannotated maint category
	else
		for _, limit_t in ipairs (tab_data_t) do								-- overwrite default &lt;load_fail_limit&gt; values
			id_limits_data_t[limit_t[1]] = limit_t[2];							-- &lt;limit[1]&gt; is identifier; &lt;limit[2]&gt; is upper limit for that identifier
		end
	end
end


--[[--------------------------&lt; I D _ H A N D L E R S &gt;--------------------------------------------------------

The following contains a list of values for various defined identifiers.  For each
identifier we specify a variety of information necessary to properly render the
identifier in the citation.

	parameters: a list of parameter aliases for this identifier; first in the list is the canonical form
	link: Wikipedia article name
	redirect: a local redirect to a local Wikipedia article name;  at en.wiki, 'ISBN (identifier)' is a redirect to 'International Standard Book Number'
	q: Wikidata q number for the identifier
	label: the label preceding the identifier; label is linked to a Wikipedia article (in this order):
		redirect from id_handlers['&lt;id&gt;'].redirect when use_identifier_redirects is true
		Wikidata-supplied article name for the local wiki from id_handlers['&lt;id&gt;'].q
		local article name from id_handlers['&lt;id&gt;'].link
	prefix: the first part of a URL that will be concatenated with a second part which usually contains the identifier
	suffix: optional third part to be added after the identifier
	encode: true if URI should be percent-encoded; otherwise false
	COinS: identifier link or keyword for use in COinS:
		for identifiers registered at info-uri.info use: info:.... where '...' is the appropriate identifier label 
		for identifiers that have COinS keywords, use the keyword: rft.isbn, rft.issn, rft.eissn
		for |asin= and |ol=, which require assembly, use the keyword: url
		for others make a URL using the value in prefix/suffix and #label, use the keyword: pre (not checked; any text other than 'info', 'rft', or 'url' works here)
		set to nil to leave the identifier out of the COinS
	separator: character or text between label and the identifier in the rendered citation
	id_limit: for those identifiers with established limits, this property holds the upper limit
	access: use this parameter to set the access level for all instances of this identifier.
		the value must be a valid access level for an identifier (see ['id-access'] in this file).
	custom_access: to enable custom access level for an identifier, set this parameter
		to the parameter that should control it (normally 'id-access')
		
]]

local id_handlers = {
	['ARXIV'] = {
		parameters = {'arxiv', 'eprint'},
		link = 'arXiv',
		redirect = 'arXiv (identifier)',
		q = 'Q118398',
		label = 'arXiv',
		prefix = 'https://arxiv.org/abs/',
		encode = false,
		COinS = 'info:arxiv',
		separator = ':',
		access = 'free',														-- free to read
		},
	['ASIN'] = {
		parameters = { 'asin', 'ASIN' },
		link = 'Amazon Standard Identification Number',
		redirect = 'ASIN (identifier)',
		q = 'Q1753278',
		label = 'ASIN',
		prefix = 'https://www.amazon.',
		COinS = 'url',
		separator = '&amp;nbsp;',
		encode = false;
		},
	['BIBCODE'] = {
		parameters = {'bibcode'},
		link = 'Bibcode',
		redirect = 'Bibcode (identifier)',
		q = 'Q25754',
		label = 'Bibcode',
		prefix = 'https://ui.adsabs.harvard.edu/abs/',
		encode = false,
		COinS = 'info:bibcode',
		separator = ':',
		custom_access = 'bibcode-access',
		},
	['BIORXIV'] = {
		parameters = {'biorxiv'},
		link = 'bioRxiv',
		redirect = 'bioRxiv (identifier)',
		q = 'Q19835482',
		label = 'bioRxiv',
		prefix = 'https://doi.org/',
		COinS = 'pre',															-- use prefix value
		access = 'free',														-- free to read
		encode = true,
		separator = '&amp;nbsp;',
		},
	['CITESEERX'] = {
		parameters = {'citeseerx'},
		link = 'CiteSeerX',
		redirect = 'CiteSeerX (identifier)',
		q = 'Q2715061',
		label = 'CiteSeerX',
		prefix = 'https://citeseerx.ist.psu.edu/viewdoc/summary?doi=',
		COinS =  'pre',															-- use prefix value
		access = 'free',														-- free to read
		encode = true,
		separator = '&amp;nbsp;',
		},
	['DOI'] = {																	-- Used by InternetArchiveBot
		parameters = { 'doi', 'DOI'},
		link = 'Digital object identifier',
		redirect = 'doi (identifier)',
		q = 'Q25670',
		label = 'doi',
		prefix = 'https://doi.org/',
		COinS = 'info:doi',
		separator = ':',
		encode = true,
		custom_access = 'doi-access',
		},
	['EISSN'] = {
		parameters = {'eissn', 'EISSN'},
		link = 'International Standard Serial Number#Electronic ISSN',
		redirect = 'eISSN (identifier)',
		q = 'Q46339674',
		label = 'eISSN',
		prefix = 'https://search.worldcat.org/issn/',
		COinS = 'rft.eissn',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['HDL'] = {
		parameters = { 'hdl', 'HDL' },
		link = 'Handle System',
		redirect = 'hdl (identifier)',
		q = 'Q3126718',
		label = 'hdl',
		prefix = 'https://hdl.handle.net/',
		COinS = 'info:hdl',
		separator = ':',
		encode = true,
		custom_access = 'hdl-access',
		},
	['ISBN'] = {																-- Used by InternetArchiveBot
		parameters = {'isbn', 'ISBN'},
		link = 'International Standard Book Number',
		redirect = 'ISBN (identifier)',
		q = 'Q33057',
		label = 'ISBN',
		prefix = 'Special:BookSources/',
		COinS = 'rft.isbn',
		separator = '&amp;nbsp;',
		},
	['ISMN'] = {
		parameters = {'ismn', 'ISMN'},
		link = 'International Standard Music Number',
		redirect = 'ISMN (identifier)',
		q = 'Q1666938',
		label = 'ISMN',
		prefix = '',															-- not currently used;
		COinS = nil,															-- nil because we can't use pre or rft or info:
		separator = '&amp;nbsp;',
		},
	['ISSN'] = {
		parameters = {'issn', 'ISSN'},
		link = 'International Standard Serial Number',
		redirect = 'ISSN (identifier)',
		q = 'Q131276',
		label = 'ISSN',
		prefix = 'https://search.worldcat.org/issn/',
		COinS = 'rft.issn',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['JFM'] = {
		parameters = {'jfm', 'JFM'},
		link = 'Jahrbuch über die Fortschritte der Mathematik',
		redirect = 'JFM (identifier)',
		q = '',
		label = 'JFM',
		prefix = 'https://zbmath.org/?format=complete&amp;q=an:',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	['JSTOR'] = {
		parameters = {'jstor', 'JSTOR'},
		link = 'JSTOR',
		redirect = 'JSTOR (identifier)',
		q = 'Q1420342',
		label = 'JSTOR',
		prefix = 'https://www.jstor.org/stable/',
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		custom_access = 'jstor-access',
		},
	['LCCN'] = {
		parameters = {'lccn', 'LCCN'},
		link = 'Library of Congress Control Number',
		redirect = 'LCCN (identifier)',
		q = 'Q620946',
		label = 'LCCN',
		prefix = 'https://lccn.loc.gov/',
		COinS = 'info:lccn',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['MEDRXIV'] = {
		parameters = {'medrxiv'},
		link = 'medRxiv',
		redirect = 'medRxiv (identifier)',
		q = 'Q58465838',
		label = 'medRxiv',
		prefix = 'https://www.medrxiv.org/content/',
		COinS = 'pre',															-- use prefix value
		access = 'free',														-- free to read
		encode = false,
		separator = '&amp;nbsp;',
		},
	['MR'] = {
		parameters = {'mr', 'MR'},
		link = 'Mathematical Reviews',
		redirect = 'MR (identifier)',
		q = 'Q211172',
		label = 'MR',
		prefix = 'https://mathscinet.ams.org/mathscinet-getitem?mr=',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	['OCLC'] = {
		parameters = {'oclc', 'OCLC'},
		link = 'OCLC',
		redirect = 'OCLC (identifier)',
		q = 'Q190593',
		label = 'OCLC',
		prefix = 'https://search.worldcat.org/oclc/',
		COinS = 'info:oclcnum',
		encode = true,
		separator = '&amp;nbsp;',
		id_limit = id_limits_data_t.OCLC or 0,
		},
	['OL'] = {
		parameters = { 'ol', 'OL' },
		link = 'Open Library',
		redirect = 'OL (identifier)',
		q = 'Q1201876',
		label = 'OL',
		prefix = 'https://openlibrary.org/',
		COinS = 'url',
		separator = '&amp;nbsp;',
		encode = true,
		custom_access = 'ol-access',
		},
	['OSTI'] = {
		parameters = {'osti', 'OSTI'},
		link = 'Office of Scientific and Technical Information',
		redirect = 'OSTI (identifier)',
		q = 'Q2015776',
		label = 'OSTI',
		prefix = 'https://www.osti.gov/biblio/',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		id_limit = id_limits_data_t.OSTI or 0,
		custom_access = 'osti-access',
		},
	['PMC'] = {
		parameters = {'pmc', 'PMC'},
		link = 'PubMed Central',
		redirect = 'PMC (identifier)',
		q = 'Q229883',
		label = 'PMC',
		prefix = 'https://www.ncbi.nlm.nih.gov/pmc/articles/PMC',
		suffix = '',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		id_limit = id_limits_data_t.PMC or 0,
		access = 'free',														-- free to read
		},
	['PMID'] = {
		parameters = {'pmid', 'PMID'},
		link = 'PubMed Identifier',
		redirect = 'PMID (identifier)',
		q = 'Q2082879',
		label = 'PMID',
		prefix = 'https://pubmed.ncbi.nlm.nih.gov/',
		COinS = 'info:pmid',
		encode = false,
		separator = '&amp;nbsp;',
		id_limit = id_limits_data_t.PMID or 0,
		},
	['RFC'] = {
		parameters = {'rfc', 'RFC'},
		link = 'Request for Comments',
		redirect = 'RFC (identifier)',
		q = 'Q212971',
		label = 'RFC',
		prefix = 'https://tools.ietf.org/html/rfc',
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		id_limit = id_limits_data_t.RFC or 0,
		access = 'free',														-- free to read
		},
	['SBN'] = {
		parameters = {'sbn', 'SBN'},
		link = 'Standard Book Number',											-- redirect to International_Standard_Book_Number#History
		redirect = 'SBN (identifier)',
		label = 'SBN',
		prefix = 'Special:BookSources/0-',										-- prefix has leading zero necessary to make 9-digit sbn a 10-digit isbn
		COinS = nil,															-- nil because we can't use pre or rft or info:
		separator = '&amp;nbsp;',
		},
	['SSRN'] = {
		parameters = {'ssrn', 'SSRN'},
		link = 'Social Science Research Network',
		redirect = 'SSRN (identifier)',
		q = 'Q7550801',
		label = 'SSRN',
		prefix = 'https://papers.ssrn.com/sol3/papers.cfm?abstract_id=',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		id_limit = id_limits_data_t.SSRN or 0,
		custom_access = 'ssrn-access',
		},
	['S2CID'] = {
		parameters = {'s2cid', 'S2CID'},
		link = 'Semantic Scholar',
		redirect = 'S2CID (identifier)',
		q = 'Q22908627',
		label = 'S2CID',
		prefix = 'https://api.semanticscholar.org/CorpusID:',
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		id_limit = id_limits_data_t.S2CID or 0,
		custom_access = 's2cid-access',
		},
	['USENETID'] = {
		parameters = {'message-id'},
		link = 'Usenet',
		redirect = 'Usenet (identifier)',
		q = 'Q193162',
		label = 'Usenet:',
		prefix = 'news:',
		encode = false,
		COinS = 'pre',															-- use prefix value
		separator = '&amp;nbsp;',
		},
	['ZBL'] = {
		parameters = {'zbl', 'ZBL' },
		link = 'Zentralblatt MATH',
		redirect = 'Zbl (identifier)',
		q = 'Q190269',
		label = 'Zbl',
		prefix = 'https://zbmath.org/?format=complete&amp;q=an:',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	}


--[[--------------------------&lt; E X P O R T S &gt;---------------------------------
]]

return 	{
	use_identifier_redirects = use_identifier_redirects,						-- booleans defined in the settings at the top of this module
	local_lang_cat_enable = local_lang_cat_enable,
	date_name_auto_xlate_enable = date_name_auto_xlate_enable,
	date_digit_auto_xlate_enable = date_digit_auto_xlate_enable,
	enable_sort_keys = enable_sort_keys,
	
																				-- tables and variables created when this module is loaded
	global_df = get_date_format (),												-- this line can be replaced with "global_df = 'dmy-all'," to have all dates auto translated to dmy format.
	global_cs1_config_t = global_cs1_config_t,									-- global settings from {{cs1 config}}
	punct_skip = build_skip_table (punct_skip, punct_meta_params),
	url_skip = build_skip_table (url_skip, url_meta_params),
	known_free_doi_registrants_t = build_free_doi_registrants_table(),
	id_limits_data_load_fail = id_limits_data_load_fail,						-- true when commons tabular identifier-limit data fails to load

	name_space_sort_keys = name_space_sort_keys,
	aliases = aliases,
	special_case_translation = special_case_translation,
	date_names = date_names,
	err_msg_supl = err_msg_supl,
	error_conditions = error_conditions,
	editor_markup_patterns = editor_markup_patterns,
	et_al_patterns = et_al_patterns,
	extended_registrants_t = extended_registrants_t,
	id_handlers = id_handlers,
	keywords_lists = keywords_lists,
	keywords_xlate = keywords_xlate,
	stripmarkers = stripmarkers,
	invisible_chars = invisible_chars,
	invisible_defs = invisible_defs,
	indic_script = indic_script,
	emoji_t = emoji_t,
	maint_cats = maint_cats,
	messages = messages,
	presentation = presentation,
	prop_cats = prop_cats,
	script_lang_codes = script_lang_codes,
	lang_tag_remap = lang_tag_remap,
	lang_name_remap = lang_name_remap,
	this_wiki_code = this_wiki_code,
	title_types = title_types,
	uncategorized_namespaces = uncategorized_namespaces_t,
	uncategorized_subpages = uncategorized_subpages,
	templates_using_volume = templates_using_volume,
	templates_using_issue = templates_using_issue,
	templates_not_using_page = templates_not_using_page,
	vol_iss_pg_patterns = vol_iss_pg_patterns,
	single_letter_2nd_lvl_domains_t = single_letter_2nd_lvl_domains_t,
	
	inter_wiki_map = inter_wiki_map,
	mw_languages_by_tag_t = mw_languages_by_tag_t,
	mw_languages_by_name_t = mw_languages_by_name_t,
	citation_class_map_t = citation_class_map_t,

	citation_issue_t = citation_issue_t,
	citation_no_volume_t = citation_no_volume_t,
	}</text>
      <sha1>1qtnsk18jlmk0vxedax9rhtzltma8m9</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Whitelist</title>
    <ns>828</ns>
    <id>25</id>
    <revision>
      <id>38</id>
      <parentid>37</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>37</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="17975" sha1="baub5v4d976tff8ebf3konhoua4ojgu" xml:space="preserve">--[[--------------------------&lt; S U P P O R T E D   P A R A M E T E R S &gt;--------------------------------------

Because a steady-state signal conveys no useful information, whitelist.basic_arguments[] list items can have three values:
	true - these parameters are valid and supported parameters
	false - these parameters are deprecated but still supported
	tracked - these parameters are valid and supported parameters tracked in an eponymous properties category
	nil - these parameters are no longer supported. remove entirely
	
]]

local basic_arguments_t = {
	['accessdate'] = true,
	['access-date'] = true,
	['agency'] = true,
	['archivedate'] = true,
	['archive-date'] = true,
	['archive-format'] = true,
	['archiveurl'] = true,
	['archive-url'] = true,
	['article'] = true,
	['article-format'] = true,
	['article-number'] = true,													-- {{cite journal}}, {{cite conference}}; {{citation}} when |journal= has a value
	['article-url'] = true,
	['article-url-access'] = true,
	['arxiv'] = true,															-- cite arxiv; here because allowed in cite ... as identifier
	['asin'] = true,
	['ASIN'] = true,
	['asin-tld'] = true,
	['at'] = true,
	['author'] = true,
	['author-first'] = true,
	['author-given'] = true,
	['author-last'] = true,
	['author-surname'] = true,
	['authorlink'] = true,
	['author-link'] = true,
	['author-mask'] = true,
	['bibcode'] = true,
	['bibcode-access'] = true,
	['biorxiv'] = true,															-- cite biorxiv; here because allowed in cite ... as identifier
	['chapter'] = true,
	['chapter-format'] = true,
	['chapter-url'] = true,
	['chapter-url-access'] = true,
	['citeseerx'] = true,														-- cite citeseerx; here because allowed in cite ... as identifier
	['collaboration'] = true,
	['contribution'] = true,
	['contribution-format'] = true,
	['contribution-url'] = true,
	['contribution-url-access'] = true,
	['contributor'] = true,
	['contributor-first'] = true,
	['contributor-given'] = true,
	['contributor-last'] = true,
	['contributor-surname'] = true,
	['contributor-link'] = true,
	['contributor-mask'] = true,
	['date'] = true,
	['department'] = true,
	['df'] = true,
	['dictionary'] = true,
	['display-authors'] = true,
	['display-contributors'] = true,
	['display-editors'] = true,
	['display-interviewers'] = true,
	['display-subjects'] = true,
	['display-translators'] = true,
	['doi'] = true,
	['DOI'] = true,
	['doi-access'] = true,
	['doi-broken-date'] = true,
	['edition'] = true,
	['editor'] = true,
	['editor-first'] = true,
	['editor-given'] = true,
	['editor-last'] = true,
	['editor-surname'] = true,
	['editor-link'] = true,
	['editor-mask'] = true,
	['eissn'] = true,
	['EISSN'] = true,
	['encyclopaedia'] = true,
	['encyclopedia'] = true,
	['entry'] = true,
	['entry-format'] = true,
	['entry-url'] = true,
	['entry-url-access'] = true,
	['eprint'] = true,															-- cite arxiv; here because allowed in cite ... as identifier
	['first'] = true,
	['format'] = true,
	['given'] = true,
	['hdl'] = true,
	['HDL'] = true,
	['hdl-access'] = true,
	['host'] = true,															-- unique to certain templates?
	['id'] = true,
	['ID'] = true,
	['institution'] = true,														-- constrain to cite thesis?
	['interviewer'] = true,
	['interviewer-first'] = true,
	['interviewer-given'] = true,
	['interviewer-last'] = true,
	['interviewer-surname'] = true,
	['interviewer-link'] = true,
	['interviewer-mask'] = true,
	['isbn'] = true,
	['ISBN'] = true,
	['ismn'] = true,
	['ISMN'] = true,
	['issn'] = true,
	['ISSN'] = true,
	['issue'] = true,
	['jfm'] = true,
	['JFM'] = true,
	['journal'] = true,
	['jstor'] = true,
	['JSTOR'] = true,
	['jstor-access'] = true,
	['lang'] = true,
	['language'] = true,
	['last'] = true,
	['lccn'] = true,
	['LCCN'] = true,
	['location'] = true,
	['magazine'] = true,
	['medium'] = true,
	['medrxiv'] = true,															-- cite medrxiv; here because allowed in cite ... as identifier
	['minutes'] = true,															-- constrain to cite AV media and podcast?
	['mode'] = true,
	['mr'] = true,
	['MR'] = true,
	['name-list-style'] = true,
	['newspaper'] = true,
	['no-pp'] = true,
	['no-tracking'] = true,
	['number'] = true,
	['oclc'] = true,
	['OCLC'] = true,
	['ol'] = true,
	['OL'] = true,
	['ol-access'] = true,
	['orig-date'] = true,
	['origyear'] = true,
	['orig-year'] = true,
	['osti'] = true,
	['OSTI'] = true,
	['osti-access'] = true,
	['others'] = true,
	['p'] = true,
	['page'] = true,
	['pages'] = true,
	['periodical'] = true,
	['place'] = true,
	['pmc'] = true,
	['PMC'] = true,
	['pmc-embargo-date'] = true,
	['pmid'] = true,
	['PMID'] = true,
	['postscript'] = true,
	['pp'] = true,
	['publication-date'] = true,
	['publication-place'] = true,
	['publisher'] = true,
	['quotation'] = true,
	['quote'] = true,
	['quote-page'] = true,
	['quote-pages'] = true,
	['ref'] = true,
	['rfc'] = true,
	['RFC'] = true,
	['sbn'] = true,
	['SBN'] = true,
	['scale'] = true,
	['script-article'] = true,
	['script-chapter'] = true,
	['script-contribution'] = true,
	['script-encyclopaedia'] = true,
	['script-encyclopedia'] = true,
	['script-entry'] = true,
	['script-journal'] = true,
	['script-magazine'] = true,
	['script-newspaper'] = true,
	['script-periodical'] = true,
	['script-quote'] = true,
	['script-section'] = true,
	['script-title'] = true,
	['script-website'] = true,
	['script-work'] = true,
	['section'] = true,
	['section-format'] = true,
	['section-url'] = true,
	['section-url-access'] = true,
	['series'] = true,
	['ssrn'] = true,															-- cite ssrn; these three here because allowed in cite ... as identifier
	['SSRN'] = true,
	['ssrn-access'] = true,
	['subject'] = true,
	['subject-first'] = true,
	['subject-given'] = true,
	['subject-last'] = true,
	['subject-link'] = true,
	['subject-mask'] = true,
	['subject-surname'] = true,
	['surname'] = true,
	['s2cid'] = true,
	['S2CID'] = true,
	['s2cid-access'] = true,
	['template-doc-demo'] = true,
	['time'] = true,															-- constrain to cite av media and podcast?
	['time-caption'] = true,													-- constrain to cite av media and podcast?
	['title'] = true,
	['title-link'] = true,
	['title-note'] = true,
	['translator'] = true,
	['translator-first'] = true,
	['translator-given'] = true,
	['translator-last'] = true,	
	['translator-surname'] = true,
	['translator-link'] = true,
	['translator-mask'] = true,
	['trans-article'] = true,
	['trans-chapter'] = true,
	['trans-contribution'] = true,
	['trans-encyclopaedia'] = true,
	['trans-encyclopedia'] = true,
	['trans-entry'] = true,
	['trans-journal'] = true,
	['trans-magazine'] = true,
	['trans-newspaper'] = true,
	['trans-periodical'] = true,
	['trans-quote'] = true,
	['trans-section'] = true,
	['trans-title'] = true,
	['trans-website'] = true,
	['trans-work'] = true,
	['type'] = true,
	['url'] = true,
	['URL'] = true,
	['url-access'] = true,
	['url-status'] = true,
	['vauthors'] = true,
	['veditors'] = true,
	['version'] = true,
	['via'] = true,
	['volume'] = true,
	['website'] = true,
	['work'] = true,
	['year'] = true,
	['zbl'] = true,
	['ZBL'] = true,
	}

local numbered_arguments_t = {
	['author#'] = true,
	['author-first#'] = true,
	['author#-first'] = true,
	['author-given#'] = true,
	['author#-given'] = true,
	['author-last#'] = true,
	['author#-last'] = true,
	['author-surname#'] = true,
	['author#-surname'] = true,
	['author-link#'] = true,
	['author#-link'] = true,
	['authorlink#'] = true,
	['author#link'] = true,
	['author-mask#'] = true,
	['author#-mask'] = true,
	['contributor#'] = true,
	['contributor-first#'] = true,
	['contributor#-first'] = true,
	['contributor-given#'] = true,
	['contributor#-given'] = true,
	['contributor-last#'] = true,
	['contributor#-last'] = true,
	['contributor-surname#'] = true,
	['contributor#-surname'] = true,
	['contributor-link#'] = true,
	['contributor#-link'] = true,
	['contributor-mask#'] = true,
	['contributor#-mask'] = true,
	['editor#'] = true,
	['editor-first#'] = true,
	['editor#-first'] = true,
	['editor-given#'] = true,
	['editor#-given'] = true,
	['editor-last#'] = true,
	['editor#-last'] = true,
	['editor-surname#'] = true,
	['editor#-surname'] = true,
	['editor-link#'] = true,
	['editor#-link'] = true,
	['editor-mask#'] = true,
	['editor#-mask'] = true,
	['first#'] = true,
	['given#'] = true,
	['host#'] = true,
	['interviewer#'] = true,
	['interviewer-first#'] = true,
	['interviewer#-first'] = true,
	['interviewer-given#'] = true,
	['interviewer#-given'] = true,
	['interviewer-last#'] = true,
	['interviewer#-last'] = true,
	['interviewer-surname#'] = true,
	['interviewer#-surname'] = true,
	['interviewer-link#'] = true,
	['interviewer#-link'] = true,
	['interviewer-mask#'] = true,
	['interviewer#-mask'] = true,
	['last#'] = true,
	['subject#'] = true,
	['subject-first#'] = true,
	['subject#-first'] = true,
	['subject-given#'] = true,
	['subject#-given'] = true,
	['subject-last#'] = true,
	['subject#-last'] = true,
	['subject-link#'] = true,
	['subject#-link'] = true,
	['subject-mask#'] = true,
	['subject#-mask'] = true,
	['subject-surname#'] = true,
	['subject#-surname'] = true,
	['surname#'] = true,
	['translator#'] = true,
	['translator-first#'] = true,
	['translator#-first'] = true,
	['translator-given#'] = true,
	['translator#-given'] = true,
	['translator-last#'] = true,
	['translator#-last'] = true,
	['translator-surname#'] = true,
	['translator#-surname'] = true,
	['translator-link#'] = true,
	['translator#-link'] = true,
	['translator-mask#'] = true,
	['translator#-mask'] = true,
	}


--[[--------------------------&lt; P R E P R I N T   S U P P O R T E D   P A R A M E T E R S &gt;--------------------

Cite arXiv, cite biorxiv, cite citeseerx, cite medrxiv, and cite ssrn are preprint templates that use the limited
set of parameters defined in the limited_basic_arguments and limited_numbered_arguments tables.  Those lists are
supplemented with a template-specific list of parameters that are required by the particular template and may be
exclusive to one of the preprint templates.  Some of these parameters may also be available to the general cs1|2
templates.

Same conventions for true/false/tracked/nil as above.

]]

local preprint_arguments_t = {
	arxiv = {
		['arxiv'] = true,														-- cite arxiv and arxiv identifiers
		['class'] = true,
		['eprint'] = true,														-- cite arxiv and arxiv identifiers
		},
	biorxiv = {
		['biorxiv'] = true,
		},
	citeseerx = {
		['citeseerx'] = true,
		},
	medrxiv = {
		['medrxiv'] = true,
		},
	ssrn = {
		['ssrn'] = true,
		['SSRN'] = true,
		['ssrn-access'] = true,
		},
	}


--[[--------------------------&lt; L I M I T E D   S U P P O R T E D   P A R A M E T E R S &gt;----------------------

cite arxiv, cite biorxiv, cite citeseerx, cite medrxiv, and cite ssrn templates are preprint templates so are
allowed only a limited subset of parameters allowed to all other cs1|2 templates.  The limited subset is defined
here.

This list of parameters also used by {{cite document}}

Same conventions for true/false/tracked/nil as above.
	
]]

local limited_basic_arguments_t = {
	['at'] = true,
	['author'] = true,
	['author-first'] = true,
	['author-given'] = true,
	['author-last'] = true,
	['author-surname'] = true,
	['author-link'] = true,
	['authorlink'] = true,
	['author-mask'] = true,
	['collaboration'] = true,
	['date'] = true,
	['df'] = true,
	['display-authors'] = true,
	['first'] = true,
	['given'] = true,
	['language'] = true,
	['last'] = true,
	['mode'] = true,
	['name-list-style'] = true,
	['no-tracking'] = true,
	['p'] = true,
	['page'] = true,
	['pages'] = true,
	['postscript'] = true,
	['pp'] = true,
	['quotation'] = true,
	['quote'] = true,
	['ref'] = true,
	['surname'] = true,
	['template-doc-demo'] = true,
	['title'] = true,
	['trans-title'] = true,
	['vauthors'] = true,
	['year'] = true,
	}

local limited_numbered_arguments_t = {
	['author#'] = true,
	['author-first#'] = true,
	['author#-first'] = true,
	['author-given#'] = true,
	['author#-given'] = true,
	['author-last#'] = true,
	['author#-last'] = true,
	['author-surname#'] = true,
	['author#-surname'] = true,
	['author-link#'] = true,
	['author#-link'] = true,
	['authorlink#'] = true,
	['author#link'] = true,
	['author-mask#'] = true,
	['author#-mask'] = true,
	['first#'] = true,
	['given#'] = true,
	['last#'] = true,
	['surname#'] = true,
	}


--[[--------------------------&lt; U N I Q U E _ A R G U M E N T S &gt;----------------------------------------------

Some templates have unique parameters.  Those templates and their unique parameters are listed here. Keys in this
table are the template's CitationClass parameter value

Same conventions for true/false/tracked/nil as above.

]]

local unique_arguments_t = {
	['audio-visual'] = {
		['people'] = true,
		['transcript'] = true,
		['transcript-format'] = true,
		['transcript-url'] = true,
		},
	conference = {
		['book-title'] = true,
		['conference'] = true,
		['conference-format'] = true,
		['conference-url'] = true,
		['event'] = true,
		},
	episode = {
		['airdate'] = true,
		['air-date'] = true,
		['credits'] = true,
		['episode-link'] = true,												-- alias of |title-link=
		['network'] = true,
		['people'] = true,
		['season'] = true,
		['series-link'] = true,
		['series-no'] = true,
		['series-number'] = true,
		['station'] = true,
		['transcript'] = true,
		['transcript-format'] = true,
		['transcript-url'] = true,
		},
	mailinglist = {
		['mailing-list'] = true,
		},
	map = {
		['cartography'] = true,
		['inset'] = true,
		['map'] = true,
		['map-format'] = true,
		['map-url'] = true,
		['map-url-access'] = true,
		['script-map'] = true,
		['sections'] = true,
		['sheet'] = true,
		['sheets'] = true,
		['trans-map'] = true,
		},
	newsgroup = {
		['message-id'] = true,
		['newsgroup'] = true,
		},
	report = {
		['docket'] = true,
		},
	serial = {
		['airdate'] = true,
		['air-date'] = true,
		['credits'] = true,
		['episode'] = true,														-- cite serial only TODO: make available to cite episode?
		['episode-link'] = true,												-- alias of |title-link=
		['network'] = true,
		['people'] = true,
		['series-link'] = true,
		['station'] = true,
		},
	speech = {
		['conference'] = true,
		['conference-format'] = true,
		['conference-url'] = true,
		['event'] = true,
		},
	thesis = {
		['degree'] = true,
		['docket'] = true,
		},
	}


--[[--------------------------&lt; C I T E _ D O C U M E N T &gt;----------------------------------------------------

Special case for cite document.  This template takes the limited basic and limited enumerated parameters plus
others that are apply only to standalone published sources that cannot be cited any other way; no url, book,
periodical, etc parameters; limited support for name lists and named identifiers.

when validating parameters in {{cite document}} templates, the basic and 

]]

local document_arguments_t = {
	['bibcode'] = true,
	['bibcode-access'] = true,
	['doi'] = true,
	['DOI'] = true,
	['doi-access'] = true,
	['doi-broken-date'] = true,
	['hdl'] = true,
	['HDL'] = true,
	['hdl-access'] = true,
	['id'] = true,
	['ID'] = true,
	['jfm'] = true,
	['JFM'] = true,
	['lang'] = true,
	['location'] = true,
	['mr'] = true,
	['MR'] = true,
	['no-pp'] = true,
	['orig-date'] = true,
	['origyear'] = true,
	['orig-year'] = true,
	['osti'] = true,
	['OSTI'] = true,
	['osti-access'] = true,
	['place'] = true,
	['publisher'] = true,
	['quote-page'] = true,
	['quote-pages'] = true,
	['script-quote'] = true,
	['script-title'] = true,
	['title-link'] = true,
	['translator'] = true,
	['translator-first'] = true,
	['translator-given'] = true,
	['translator-last'] = true,
	['translator-surname'] = true,
	['translator-link'] = true,
	['translator-mask'] = true,
	['trans-quote'] = true,
	['type'] = true,
	['zbl'] = true,
	['ZBL'] = true,
	}

local document_numbered_arguments_t = {
	['translator#'] = true,
	['translator-first#'] = true,
	['translator#-first'] = true,
	['translator-given#'] = true,
	['translator#-given'] = true,
	['translator-last#'] = true,
	['translator#-last'] = true,
	['translator-surname#'] = true,
	['translator#-surname'] = true,
	['translator-link#'] = true,
	['translator#-link'] = true,
	['translator-mask#'] = true,
	['translator#-mask'] = true,
	}


--[[--------------------------&lt; L I S T _ C O M B I N E &gt;------------------------------------------------------

makes one table from a list of tables.  &lt;lists_t&gt; is a sequence of tables to be combined

]]

local function list_combine (lists_t)
	local out_t = {};

	for _, list_t in ipairs (lists_t) do										-- for each list in &lt;lists_t&gt;
		for k, v in pairs (list_t) do											-- extract each k/v pair
			out_t[k] = v;														-- add to &lt;out_t&gt;
		end
	end
	return out_t;																-- and done
end


--[[--------------------------&lt; T E M P L A T E _ L I S T _ G E T &gt;--------------------------------------------

gets a list of the templates from table t

]]

local function template_list_get (t)
	local out_t = {};															-- a table for output
	for k, _ in pairs (t) do													-- spin through the table and collect the keys
		table.insert (out_t, k)													-- add each key to the output table
	end
	return out_t;																-- and done
end


--[[--------------------------&lt; E X P O R T E D   T A B L E S &gt;------------------------------------------------
]]

return {
	preprint_arguments_t = preprint_arguments_t,
	preprint_template_list_t = template_list_get (preprint_arguments_t),		-- make a template list from preprint_arguments{} table
	unique_arguments_t = unique_arguments_t,
	unique_param_template_list_t = template_list_get (unique_arguments_t),		-- make a template list from unique_arguments{} table
	
	document_parameters_t = list_combine ({limited_basic_arguments_t, limited_numbered_arguments_t, document_arguments_t, document_numbered_arguments_t});
	common_parameters_t = list_combine ({basic_arguments_t, numbered_arguments_t});
	limited_parameters_t = list_combine ({limited_basic_arguments_t, limited_numbered_arguments_t});
	};</text>
      <sha1>baub5v4d976tff8ebf3konhoua4ojgu</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Utilities</title>
    <ns>828</ns>
    <id>26</id>
    <revision>
      <id>40</id>
      <parentid>39</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>39</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="24954" sha1="1rgyhapxi1dzuxmh3cqix2zrvvro8l2" xml:space="preserve">local z = {
	error_cats_t = {};															-- for categorizing citations that contain errors
	error_ids_t = {};															-- list of error identifiers; used to prevent duplication of certain errors; local to this module
	error_msgs_t = {};															-- sequence table of error messages
	maint_cats_t = {};															-- for categorizing citations that aren't erroneous per se, but could use a little work
	prop_cats_t = {};															-- for categorizing citations based on certain properties, language of source for instance
	prop_keys_t = {};															-- for adding classes to the citation's &lt;cite&gt; tag
};


--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local cfg;																		-- table of tables imported from selected Module:Citation/CS1/Configuration


--[[--------------------------&lt; I S _ S E T &gt;------------------------------------------------------------------

Returns true if argument is set; false otherwise. Argument is 'set' when it exists (not nil) or when it is not an empty string.

]]

local function is_set (var)
	return not (var == nil or var == '');
end


--[[--------------------------&lt; I N _ A R R A Y &gt;--------------------------------------------------------------

Whether needle is in haystack

]]

local function in_array (needle, haystack)
	if needle == nil then
		return false;
	end
	for n, v in ipairs (haystack) do
		if v == needle then
			return n;
		end
	end
	return false;
end


--[[--------------------------&lt; H A S _ A C C E P T _ A S _ W R I T T E N &gt;------------------------------------

When &lt;str&gt; is wholly wrapped in accept-as-written markup, return &lt;str&gt; without markup and true; return &lt;str&gt; and false else

with allow_empty = false, &lt;str&gt; must have at least one character inside the markup
with allow_empty = true, &lt;str&gt; the markup frame can be empty like (()) to distinguish an empty template parameter from the specific condition "has no applicable value" in citation-context.

After further evaluation the two cases might be merged at a later stage, but should be kept separated for now.

]]

local function has_accept_as_written (str, allow_empty)
	if not is_set (str) then
		return str, false;
	end

	local count;

	if true == allow_empty then
		str, count = str:gsub ('^%(%((.*)%)%)$', '%1'); 						-- allows (()) to be an empty set
	else
		str, count = str:gsub ('^%(%((.+)%)%)$', '%1');
	end
	return str, 0 ~= count;
end


--[[--------------------------&lt; S U B S T I T U T E &gt;----------------------------------------------------------

Populates numbered arguments in a message string using an argument table. &lt;args&gt; may be a single string or a
sequence table of multiple strings.

]]

local function substitute (msg, args)
	return args and mw.message.newRawMessage (msg, args):plain() or msg;
end


--[[--------------------------&lt; E R R O R _ C O M M E N T &gt;----------------------------------------------------

Wraps error messages with CSS markup according to the state of hidden. &lt;content&gt; may be a single string or a
sequence table of multiple strings.

]]

local function error_comment (content, hidden)
	return substitute (hidden and cfg.presentation['hidden-error'] or cfg.presentation['visible-error'], content);
end


--[[--------------------------&lt; H Y P H E N _ T O _ D A S H &gt;--------------------------------------------------

Converts a hyphen, endash, emdash to endash under certain conditions.  The hyphen/en/em must separate
like items; unlike items are returned unmodified.  These forms are modified:
	letter - letter (A-B)
	digit - digit (4-5)
	digit separator digit - digit separator digit (4.1-4.5 or 4-1-4-5)
	letterdigit - letterdigit (A1-A5) (an optional separator between letter and
		digit is supported – a.1-a.5 or a-1-a-5)
	digitletter - digitletter (5a-5d) (an optional separator between letter and
		digit is supported – 5.a-5.d or 5-a-5-d)

any other forms are returned unmodified.

str may be a comma- or semicolon-separated list of page ranges with/without single pages

]]

local function hyphen_to_dash (str)
	if not is_set (str) then
		return str;
	end

	str = str:gsub ("(%(%(.-%)%))", function(m) return m:gsub(",", "，"):gsub(";", "；") end) -- replace commas and semicolons in accept-as-written markup with similar unicode characters so they'll be ignored during the split	
	str = str:gsub ('&amp;[nm]dash;', {['&amp;ndash;'] = '–', ['&amp;mdash;'] = '—'});		-- replace &amp;mdash; and &amp;ndash; entities with their characters; semicolon mucks up the text.split
	str = str:gsub ('&amp;#45;', '-');												-- replace HTML numeric entity with hyphen character
	str = str:gsub ('&amp;nbsp;', ' ');												-- replace &amp;nbsp; entity with generic keyboard space character
	
	local out = {};
	local list = mw.text.split (str, '%s*[,;]%s*');								-- split str at comma or semicolon separators if there are any

	local accept;																-- boolean

	for _, item in ipairs (list) do												-- for each item in the list
		item, accept = has_accept_as_written (item);							-- remove accept-this-as-written markup when it wraps all of item
		if not accept and mw.ustring.match (item, '^%w*[%.%-]?%w+%s*[—–-]%s*%w*[%.%-]?%w+$') then	-- if a hyphenated range or has endash or emdash separators
			if mw.ustring.match (item, '^%a+[%.%-]?%d+%s*[—–-]%s*%a+[%.%-]?%d+$') or		-- letterdigit hyphen letterdigit (optional separator between letter and digit)
				mw.ustring.match (item, '^%d+[%.%-]?%a+%s*[—–-]%s*%d+[%.%-]?%a+$') or		-- digitletter hyphen digitletter (optional separator between digit and letter)
				mw.ustring.match (item, '^%d+[%.%-]%d+%s*[—–-]%s*%d+[%.%-]%d+$') then		-- digit separator digit hyphen digit separator digit
					item = mw.ustring.gsub (item, '(%w*[%.%-]?%w+)%s*[—–-]%s*(%w*[%.%-]?%w+)', '&lt;span class="nowrap"&gt;%1 –&lt;/span&gt; &lt;span class="nowrap"&gt;%2&lt;/span&gt;');	-- replace hyphen/dash, with spaced endash

			elseif mw.ustring.match (item, '^%d+%s*[—–-]%s*%d+$') or			-- digit hyphen digit
				mw.ustring.match (item, '^%a+%s*[—–-]%s*%a+$') then				-- letter hyphen letter
					item = mw.ustring.gsub (item, '(%w+)%s*[—–-]%s*(%w+)', '&lt;span class="nowrap"&gt;%1–&lt;/span&gt;%2');	-- replace hyphen/emdash with endash, remove extraneous space characters

			else
--				item = mw.ustring.gsub (item, '%s*[—–-]%s*', '–');				-- disabled; here when 'unlike' items so return &lt;item&gt; as is
			end
		end
		table.insert (out, item);												-- add the (possibly modified) item to the output table
	end

	local temp_str = '';														-- concatenate the output table into a comma separated string
	temp_str, accept = has_accept_as_written (table.concat (out, ', '));		-- remove accept-this-as-written markup when it wraps all of concatenated out
	if accept then
		temp_str = has_accept_as_written (str);									-- when global markup removed, return original str; do it this way to suppress boolean second return value
		return temp_str:gsub("，", ","):gsub("；", ";");
	else
		return temp_str:gsub("，", ","):gsub("；", ";");						-- else, return assembled temp_str
	end
end


--[=[-------------------------&lt; M A K E _ W I K I L I N K &gt;----------------------------------------------------

Makes a wikilink; when both link and display text is provided, returns a wikilink in the form [[L|D]]; if only
link is provided (or link and display are the same), returns a wikilink in the form [[L]]; if neither are
provided or link is omitted, returns an empty string.

]=]

local function make_wikilink (link, display)
	if not is_set (link) then return '' end

	if is_set (display) and link ~= display then			
		return table.concat ({'[[', link, '|', display, ']]'});			
	else
		return table.concat ({'[[', link, ']]'});
	end
end


--[[--------------------------&lt; S E T _ M E S S A G E &gt;----------------------------------------------------------

Sets an error message using the ~/Configuration error_conditions{} table along with arguments supplied in the function
call, inserts the resulting message in z.error_msgs_t{} sequence table, and returns the error message.

&lt;error_id&gt; – key value for appropriate error handler in ~/Configuration error_conditions{} table 
&lt;arguments&gt; – may be a single string or a sequence table of multiple strings to be subsititued into error_conditions[error_id].message
&lt;raw&gt; – boolean
	true –	causes this function to return the error message not wrapped in visible-error, hidden-error span tag;
			returns error_conditions[error_id].hidden as a second return value
			does not add message to z.error_msgs_t sequence table
	false, nil – adds message wrapped in visible-error, hidden-error span tag to z.error_msgs_t
			returns the error message wrapped in visible-error, hidden-error span tag; there is no second return value
&lt;prefix&gt; – string to be prepended to &lt;message&gt;									-- TODO: remove support for these unused(?) arguments?
&lt;suffix&gt; – string to be appended to &lt;message&gt;

TODO: change z.error_cats_t and z.maint_cats_t to have the form cat_name = true?  this to avoid dups without having to have an extra table

]]

local added_maint_cats = {}														-- list of maintenance categories that have been added to z.maint_cats_t; TODO: figure out how to delete this table

local function set_message (error_id, arguments, raw, prefix, suffix)
	local error_state = cfg.error_conditions[error_id];
	
	prefix = prefix or '';
	suffix = suffix or '';
	
	if error_state == nil then
		error (cfg.messages['undefined_error'] .. ': ' .. error_id);			-- because missing error handler in Module:Citation/CS1/Configuration

	elseif is_set (error_state.category) then
		if error_state.message then												-- when error_state.message defined, this is an error message
			table.insert (z.error_cats_t, error_state.category);
		else
			if not added_maint_cats[error_id] then
				added_maint_cats[error_id] = true;								-- note that we've added this category
				table.insert (z.maint_cats_t, substitute (error_state.category, arguments));	-- make cat name then add to table
			end
			return;																-- because no message, nothing more to do
		end
	end

	local message = substitute (error_state.message, arguments);

	message = table.concat (
		{
		message,
		' (',
		make_wikilink (
			table.concat (
				{
				cfg.messages['help page link'],
				'#',
				error_state.anchor
				}),
			cfg.messages['help page label']),
		')'
		});

	z.error_ids_t[error_id] = true;
	if z.error_ids_t['err_citation_missing_title'] and							-- if missing-title error already noted
		in_array (error_id, {'err_bare_url_missing_title', 'err_trans_missing_title'}) then		-- and this error is one of these
			return '', false;													-- don't bother because one flavor of missing title is sufficient
	end
	
	message = table.concat ({prefix, message, suffix});

	if true == raw then
		return message, error_state.hidden;										-- return message not wrapped in visible-error, hidden-error span tag
	end		

	message = error_comment (message, error_state.hidden);						-- wrap message in visible-error, hidden-error span tag
	table.insert (z.error_msgs_t, message);										-- add it to the messages sequence table
	return message;																-- and done; return value generally not used but is used as a flag in various functions of ~/Identifiers
end


--[[-------------------------&lt; I S _ A L I A S _ U S E D &gt;-----------------------------------------------------

This function is used by select_one() to determine if one of a list of alias parameters is in the argument list
provided by the template.

Input:
	args – pointer to the arguments table from calling template
	alias – one of the list of possible aliases in the aliases lists from Module:Citation/CS1/Configuration
	index – for enumerated parameters, identifies which one
	enumerated – true/false flag used to choose how enumerated aliases are examined
	value – value associated with an alias that has previously been selected; nil if not yet selected
	selected – the alias that has previously been selected; nil if not yet selected
	error_list – list of aliases that are duplicates of the alias already selected

Returns:
	value – value associated with alias we selected or that was previously selected or nil if an alias not yet selected
	selected – the alias we selected or the alias that was previously selected or nil if an alias not yet selected

]]

local function is_alias_used (args, alias, index, enumerated, value, selected, error_list)
	if enumerated then															-- is this a test for an enumerated parameters?
		alias = alias:gsub ('#', index);										-- replace '#' with the value in index
	else
		alias = alias:gsub ('#', '');											-- remove '#' if it exists
	end

	if is_set (args[alias]) then												-- alias is in the template's argument list
		if value ~= nil and selected ~= alias then								-- if we have already selected one of the aliases
			local skip;
			for _, v in ipairs (error_list) do									-- spin through the error list to see if we've added this alias
				if v == alias then
					skip = true;
					break;														-- has been added so stop looking 
				end
			end
			if not skip then													-- has not been added so
				table.insert (error_list, alias);								-- add error alias to the error list
			end
		else
			value = args[alias];												-- not yet selected an alias, so select this one
			selected = alias;
		end
	end
	return value, selected;														-- return newly selected alias, or previously selected alias
end


--[[--------------------------&lt; A D D _ M A I N T _ C A T &gt;------------------------------------------------------

Adds a category to z.maint_cats_t using names from the configuration file with additional text if any.
To prevent duplication, the added_maint_cats table lists the categories by key that have been added to z.maint_cats_t.

]]

local function add_maint_cat (key, arguments)
	if not added_maint_cats [key] then
		added_maint_cats [key] = true;											-- note that we've added this category
		table.insert (z.maint_cats_t, substitute (cfg.maint_cats [key], arguments));	-- make name then add to table
	end
end


--[[--------------------------&lt; A D D _ P R O P _ C A T &gt;--------------------------------------------------------

Adds a category to z.prop_cats_t using names from the configuration file with additional text if any.

foreign_lang_source and foreign_lang_source_2 keys have a language code appended to them so that multiple languages
may be categorized but multiples of the same language are not categorized.

added_prop_cats is a table declared in page scope variables above

]]

local added_prop_cats = {};														-- list of property categories that have been added to z.prop_cats_t

local function add_prop_cat (key, arguments, key_modifier)
	local key_modified = key .. ((key_modifier and key_modifier) or '');		-- modify &lt;key&gt; with &lt;key_modifier&gt; if present and not nil
	
	if not added_prop_cats [key_modified] then
		added_prop_cats [key_modified] = true;									-- note that we've added this category
		table.insert (z.prop_cats_t, substitute (cfg.prop_cats [key], arguments));	-- make name then add to table
		table.insert (z.prop_keys_t, 'cs1-prop-' .. key);						-- convert key to class for use in the citation's &lt;cite&gt; tag
	end
end


--[[--------------------------&lt; S A F E _ F O R _ I T A L I C S &gt;----------------------------------------------

Protects a string that will be wrapped in wiki italic markup '' ... ''

Note: We cannot use &lt;i&gt; for italics, as the expected behavior for italics specified by ''...'' in the title is that
they will be inverted (i.e. unitalicized) in the resulting references.  In addition, &lt;i&gt; and '' tend to interact
poorly under Mediawiki's HTML tidy.

]]

local function safe_for_italics (str)
	if not is_set (str) then return str end

	if str:sub (1, 1) == "'" then str = "&lt;span&gt;&lt;/span&gt;" .. str; end
	if str:sub (-1, -1) == "'" then str = str .. "&lt;span&gt;&lt;/span&gt;"; end
	
	return str:gsub ('\n', ' ');												-- Remove newlines as they break italics.
end


--[[--------------------------&lt; W R A P _ S T Y L E &gt;----------------------------------------------------------

Applies styling to various parameters.  Supplied string is wrapped using a message_list configuration taking one
argument; protects italic styled parameters.  Additional text taken from citation_config.presentation - the reason
this function is similar to but separate from wrap_msg().

]]

local function wrap_style (key, str)
	if not is_set (str) then
		return "";
	elseif in_array (key, {'italic-title', 'trans-italic-title'}) then
		str = safe_for_italics (str);
	end

	return substitute (cfg.presentation[key], {str});
end


--[[--------------------------&lt; M A K E _ S E P _ L I S T &gt;------------------------------------------------------------

make a separated list of items using provided separators.
	&lt;sep_list&gt; - typically '&lt;comma&gt;&lt;space&gt;'
	&lt;sep_list_pair&gt; - typically '&lt;space&gt;and&lt;space&gt;'
	&lt;sep_list_end&gt; - typically '&lt;comma&gt;&lt;space&gt;and&lt;space&gt;' or '&lt;comma&gt;&lt;space&gt;&amp;&lt;space&gt;'

defaults to cfg.presentation['sep_list'], cfg.presentation['sep_list_pair'], and cfg.presentation['sep_list_end']
if &lt;sep_list_end&gt; is specified, &lt;sep_list&gt; and &lt;sep_list_pair&gt; must also be supplied

]]

local function make_sep_list (count, list_seq, sep_list, sep_list_pair, sep_list_end)
	local list = '';

	if not sep_list then														-- set the defaults
		sep_list = cfg.presentation['sep_list'];
		sep_list_pair = cfg.presentation['sep_list_pair'];
		sep_list_end = cfg.presentation['sep_list_end'];
	end
	
	if 2 &gt;= count then
		list = table.concat (list_seq, sep_list_pair);							-- insert separator between two items; returns list_seq[1] then only one item
	elseif 2 &lt; count then
		list = table.concat (list_seq, sep_list, 1, count - 1);					-- concatenate all but last item with plain list separator
		list = table.concat ({list, list_seq[count]}, sep_list_end);			-- concatenate last item onto end of &lt;list&gt; with final separator
	end
	
	return list;
end


--[[--------------------------&lt; S E L E C T _ O N E &gt;----------------------------------------------------------

Chooses one matching parameter from a list of parameters to consider.  The list of parameters to consider is just
names.  For parameters that may be enumerated, the position of the numerator in the parameter name is identified
by the '#' so |author-last1= and |author1-last= are represented as 'author-last#' and 'author#-last'.

Because enumerated parameter |&lt;param&gt;1= is an alias of |&lt;param&gt;= we must test for both possibilities.


Generates an error if more than one match is present.

]]

local function select_one (args, aliases_list, error_condition, index)
	local value = nil;															-- the value assigned to the selected parameter
	local selected = '';														-- the name of the parameter we have chosen
	local error_list = {};

	if index ~= nil then index = tostring(index); end

	for _, alias in ipairs (aliases_list) do									-- for each alias in the aliases list
		if alias:match ('#') then												-- if this alias can be enumerated
			if '1' == index then												-- when index is 1 test for enumerated and non-enumerated aliases
				value, selected = is_alias_used (args, alias, index, false, value, selected, error_list);	-- first test for non-enumerated alias
			end
			value, selected = is_alias_used (args, alias, index, true, value, selected, error_list);	-- test for enumerated alias
		else
			value, selected = is_alias_used (args, alias, index, false, value, selected, error_list);	-- test for non-enumerated alias
		end
	end

	if #error_list &gt; 0 and 'none' ~= error_condition then						-- for cases where this code is used outside of extract_names()
		for i, v in ipairs (error_list) do
			error_list[i] = wrap_style ('parameter', v);
		end
		table.insert (error_list, wrap_style ('parameter', selected));
		set_message (error_condition, {make_sep_list (#error_list, error_list)});
	end
	
	return value, selected;
end


--[=[-------------------------&lt; R E M O V E _ W I K I _ L I N K &gt;----------------------------------------------

Gets the display text from a wikilink like [[A|B]] or [[B]] gives B

The str:gsub() returns either A|B froma [[A|B]] or B from [[B]] or B from B (no wikilink markup).

In l(), l:gsub() removes the link and pipe (if they exist); the second :gsub() trims whitespace from the label
if str was wrapped in wikilink markup.  Presumably, this is because without wikimarkup in str, there is no match
in the initial gsub, the replacement function l() doesn't get called.

]=]

local function remove_wiki_link (str)
	return (str:gsub ("%[%[([^%[%]]*)%]%]", function(l)
		return l:gsub ("^[^|]*|(.*)$", "%1" ):gsub ("^%s*(.-)%s*$", "%1");
	end));
end


--[=[-------------------------&lt; I S _ W I K I L I N K &gt;--------------------------------------------------------

Determines if str is a wikilink, extracts, and returns the wikilink type, link text, and display text parts.
If str is a complex wikilink ([[L|D]]):
	returns wl_type 2 and D and L from [[L|D]];
if str is a simple wikilink ([[D]])
	returns wl_type 1 and D from [[D]] and L as empty string;
if not a wikilink:
	returns wl_type 0, str as D, and L as empty string.

trims leading and trailing whitespace and pipes from L and D ([[L|]] and [[|D]] are accepted by MediaWiki and
treated like [[D]]; while [[|D|]] is not accepted by MediaWiki, here, we accept it and return D without the pipes).

]=]

local function is_wikilink (str)
	local D, L
	local wl_type = 2;															-- assume that str is a complex wikilink [[L|D]]

	if not str:match ('^%[%[[^%]]+%]%]$') then									-- is str some sort of a wikilink (must have some sort of content)
		return 0, str, '';														-- not a wikilink; return wl_type as 0, str as D, and empty string as L
	end
	
	L, D = str:match ('^%[%[([^|]+)|([^%]]+)%]%]$');							-- get L and D from [[L|D]] 

	if not is_set (D) then														-- if no separate display
		D = str:match ('^%[%[([^%]]*)|*%]%]$');									-- get D from [[D]] or [[D|]]
		wl_type = 1; 
	end
	
	D = mw.text.trim (D, '%s|');												-- trim white space and pipe characters 
	return wl_type, D, L or '';
end


--[[--------------------------&lt; S T R I P _ A P O S T R O P H E _ M A R K U P &gt;--------------------------------

Strip wiki italic and bold markup from argument so that it doesn't contaminate COinS metadata.
This function strips common patterns of apostrophe markup.  We presume that editors who have taken the time to
markup a title have, as a result, provided valid markup. When they don't, some single apostrophes are left behind.

Returns the argument without wiki markup and a number; the number is more-or-less meaningless except as a flag
to indicate that markup was replaced; do not rely on it as an indicator of how many of any kind of markup was
removed; returns the argument and nil when no markup removed

]]

local function strip_apostrophe_markup (argument)
	if not is_set (argument) then
		return argument, nil;													-- no argument, nothing to do
	end

	if nil == argument:find ( "''", 1, true ) then								-- Is there at least one double apostrophe?  If not, exit.
		return argument, nil;
	end

	local flag;
	while true do
		if argument:find ("'''''", 1, true) then								-- bold italic (5)
			argument, flag = argument:gsub ("%'%'%'%'%'", "");					-- remove all instances of it
		elseif argument:find ("''''", 1, true) then								-- italic start and end without content (4)
			argument, flag=argument:gsub ("%'%'%'%'", "");
		elseif argument:find ("'''", 1, true) then								-- bold (3)
			argument, flag=argument:gsub ("%'%'%'", "");
		elseif argument:find ("''", 1, true) then								-- italic (2)
			argument, flag = argument:gsub ("%'%'", "");
		else
			break;
		end
	end

	return argument, flag;														-- done
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr)
	cfg = cfg_table_ptr;
	
end


--[[--------------------------&lt; E X P O R T S &gt;----------------------------------------------------------------
]]

return {
	add_maint_cat = add_maint_cat,												-- exported functions
	add_prop_cat = add_prop_cat,
	error_comment = error_comment,
	has_accept_as_written = has_accept_as_written,
	hyphen_to_dash = hyphen_to_dash,
	in_array = in_array,
	is_set = is_set,
	is_wikilink = is_wikilink,
	make_sep_list = make_sep_list,
	make_wikilink = make_wikilink,
	remove_wiki_link = remove_wiki_link,
	safe_for_italics = safe_for_italics,
	select_one = select_one,
	set_message = set_message,
	set_selected_modules = set_selected_modules,
	strip_apostrophe_markup = strip_apostrophe_markup,
	substitute = substitute,
	wrap_style = wrap_style,

	z = z,																		-- exported table
	}</text>
      <sha1>1rgyhapxi1dzuxmh3cqix2zrvvro8l2</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Date validation</title>
    <ns>828</ns>
    <id>27</id>
    <revision>
      <id>42</id>
      <parentid>41</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>41</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="67787" sha1="h37xf2hxsrjgq13ms7lozl3uiigkklr" xml:space="preserve">--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local add_prop_cat, is_set, in_array, set_message, substitute, wrap_style;		-- imported functions from selected Module:Citation/CS1/Utilities
local cfg;																		-- table of tables imported from selected Module:Citation/CS1/Configuration


--[[--------------------------&lt; F I L E - S C O P E   D E C L A R A T I O N S &gt;--------------------------------

File-scope variables are declared here

]]

local lang_object = mw.getContentLanguage();									-- used by is_valid_accessdate(), is_valid_year(), date_name_xlate(); TODO: move to ~/Configuration?
local year_limit;																-- used by is_valid_year()


--[=[-------------------------&lt; I S _ V A L I D _ A C C E S S D A T E &gt;----------------------------------------

returns true if:
	Wikipedia start date &lt;= accessdate &lt; today + 2 days

Wikipedia start date is 2001-01-15T00:00:00 UTC which is 979516800 seconds after 1970-01-01T00:00:00 UTC (the start of Unix time)
accessdate is the date provided in |access-date= at time 00:00:00 UTC
today is the current date at time 00:00:00 UTC plus 48 hours
	if today is 2015-01-01T00:00:00 then
		adding 24 hours gives 2015-01-02T00:00:00 – one second more than today
		adding 24 hours gives 2015-01-03T00:00:00 – one second more than tomorrow

This function does not work if it is fed month names for languages other than English.  Wikimedia #time: parser
apparently doesn't understand non-English date month names. This function will always return false when the date
contains a non-English month name because good1 is false after the call to lang.formatDate().  To get around that
call this function with YYYY-MM-DD format dates.

]=]

local function is_valid_accessdate (accessdate)
	local good1, good2;
	local access_ts, tomorrow_ts;												-- to hold Unix time stamps representing the dates

	good1, access_ts = pcall (lang_object.formatDate, lang_object, 'U', accessdate );			-- convert accessdate value to Unix timestamp 
	good2, tomorrow_ts = pcall (lang_object.formatDate, lang_object, 'U', 'today + 2 days' );	-- today midnight + 2 days is one second more than all day tomorrow
	
	if good1 and good2 then														-- lang.formatDate() returns a timestamp in the local script which which tonumber() may not understand
		access_ts = tonumber (access_ts) or lang_object:parseFormattedNumber (access_ts);		-- convert to numbers for the comparison;
		tomorrow_ts = tonumber (tomorrow_ts) or lang_object:parseFormattedNumber (tomorrow_ts);
	else
		return false;															-- one or both failed to convert to Unix time stamp
	end

	if 979516800 &lt;= access_ts and access_ts &lt; tomorrow_ts then					-- Wikipedia start date &lt;= accessdate &lt; tomorrow's date
		return true;
	else
		return false;															-- accessdate out of range
	end
end


--[[--------------------------&lt; G E T _ M O N T H _ N U M B E R &gt;----------------------------------------------

returns a number according to the month in a date: 1 for January, etc.  Capitalization and spelling must be correct.
If not a valid month, returns 0

]]

local function get_month_number (month)
	return cfg.date_names['local'].long[month] or cfg.date_names['local'].short[month] or	-- look for local names first
			cfg.date_names['en'].long[month] or	cfg.date_names['en'].short[month] or		-- failing that, look for English names
			0;																				-- not a recognized month name
end


--[[--------------------------&lt; G E T _ S E A S O N _ N U M B E R &gt;--------------------------------------------

returns a number according to the sequence of seasons in a year: 21 for Spring, etc.  Capitalization and spelling
must be correct. If not a valid season, returns 0.
	21-24 = Spring, Summer, Autumn, Winter, independent of “Hemisphere”

returns 0 when &lt;param&gt; is not |date=

Season numbering is defined by Extended Date/Time Format (EDTF) specification (https://www.loc.gov/standards/datetime/)
which became part of ISO 8601 in 2019.  See '§Sub-year groupings'.  The standard defines various divisions using
numbers 21-41.  cs1|2 only supports generic seasons.  EDTF does support the distinction between north and south
hemisphere seasons but cs1|2 has no way to make that distinction.

These additional divisions not currently supported:
	25-28 = Spring - Northern Hemisphere, Summer- Northern Hemisphere, Autumn - Northern Hemisphere, Winter - Northern Hemisphere
	29-32 = Spring – Southern Hemisphere, Summer– Southern Hemisphere, Autumn – Southern Hemisphere, Winter - Southern Hemisphere
	33-36 = Quarter 1, Quarter 2, Quarter 3, Quarter 4 (3 months each)
	37-39 = Quadrimester 1, Quadrimester 2, Quadrimester 3 (4 months each)
	40-41 = Semestral 1, Semestral-2 (6 months each)

]]

local function get_season_number (season, param)
	if 'date' ~= param then
		return 0;																-- season dates only supported by |date=
	end
	return cfg.date_names['local'].season[season] or							-- look for local names first
			cfg.date_names['en'].season[season] or								-- failing that, look for English names
			0;																	-- not a recognized season name
end


--[[--------------------------&lt; G E T _ Q U A R T E R _ N U M B E R &gt;------------------------------------------

returns a number according to the sequence of quarters in a year: 33 for first quarter, etc.  Capitalization and spelling
must be correct. If not a valid quarter, returns 0.
	33-36 = Quarter 1, Quarter 2, Quarter 3, Quarter 4 (3 months each)

returns 0 when &lt;param&gt; is not |date=

Quarter numbering is defined by Extended Date/Time Format (EDTF) specification (https://www.loc.gov/standards/datetime/)
which became part of ISO 8601 in 2019.  See '§Sub-year groupings'.  The standard defines various divisions using
numbers 21-41.  cs1|2 only supports generic seasons and quarters.

These additional divisions not currently supported:
	37-39 = Quadrimester 1, Quadrimester 2, Quadrimester 3 (4 months each)
	40-41 = Semestral 1, Semestral-2 (6 months each)

]]

local function get_quarter_number (quarter, param)
	if 'date' ~= param then
		return 0;																-- quarter dates only supported by |date=
	end
	quarter = mw.ustring.gsub (quarter, ' +', ' ');								-- special case replace multiple space chars with a single space char
	return cfg.date_names['local'].quarter[quarter] or							-- look for local names first
			cfg.date_names['en'].quarter[quarter] or							-- failing that, look for English names
			0;																	-- not a recognized quarter name
end


--[[--------------------------&lt; G E T _ P R O P E R _ N A M E _ N U M B E R &gt;----------------------------------

returns a non-zero number if date contains a recognized proper-name.  Capitalization and spelling must be correct.

returns 0 when &lt;param&gt; is not |date=

]]

local function get_proper_name_number (name, param)
	if 'date' ~= param then
		return 0;																-- proper-name dates only supported by |date=
	end
	return cfg.date_names['local'].named[name] or								-- look for local names dates first
			cfg.date_names['en'].named[name] or									-- failing that, look for English names
			0;																	-- not a recognized named date
end


--[[--------------------------&lt; G E T _ E L E M E N T _ N U M B E R &lt;------------------------------------------

returns true if month or season or quarter or proper name is valid (properly spelled, capitalized, abbreviated)

]]

local function get_element_number (element, param)
	local num;
	
	local funcs = {get_month_number, get_season_number, get_quarter_number, get_proper_name_number};	-- list of functions to execute in order
	
	for _, func in ipairs (funcs) do											-- spin through the function list
		num = func (element, param);											-- call the function and get the returned number
		if 0 ~= num then														-- non-zero when valid month season quarter 
			return num;															-- return that number
		end
	end
	return nil;																	-- not valid
end


--[[--------------------------&lt; I S _ V A L I D _ Y E A R &gt;----------------------------------------------------

Function gets current year from the server and compares it to year from a citation parameter.  Years more than one
year in the future are not acceptable.

Special case for |pmc-embargo-date=: years more than two years in the future are not acceptable

]]

local function is_valid_year (year, param)
	if not is_set (year_limit) then
		year_limit = tonumber(os.date("%Y"))+1;									-- global variable so we only have to fetch it once
	end

	year = tonumber (year) or lang_object:parseFormattedNumber (year);			-- convert to number for the comparison
	if year and (100 &gt; year) then												-- years less than 100 not supported
		return false;
	end
	
	if 'pmc-embargo-date' == param then											-- special case for |pmc-embargo-date=
		return year and (year &lt;= tonumber(os.date("%Y"))+2) or false;			-- years more than two years in the future are not accepted
	end	
	return year and (year &lt;= year_limit) or false;
end


--[[--------------------------&lt; I S _ V A L I D _ D A T E &gt;----------------------------------------------------

Returns true if day is less than or equal to the number of days in month and year is no farther into the future
than next year; else returns false.

Assumes Julian calendar prior to year 1582 and Gregorian calendar thereafter. Accounts for Julian calendar leap
years before 1582 and Gregorian leap years after 1582. Where the two calendars overlap (1582 to approximately
1923) dates are assumed to be Gregorian.

]]

local function is_valid_date (year, month, day, param)
local days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
local month_length;
	if not is_valid_year (year, param) then										-- no farther into the future than next year except |pmc-embargo-date= no more than two years in the future
		return false;
	end
	
	month = tonumber (month);													-- required for YYYY-MM-DD dates
	
	if (2 == month) then														-- if February
		month_length = 28;														-- then 28 days unless
		if 1582 &gt; tonumber(year) then											-- Julian calendar
			if 0 == (year%4) then												-- is a leap year?
				month_length = 29;												-- if leap year then 29 days in February
			end
		else																	-- Gregorian calendar
			if (0 == (year%4) and (0 ~= (year%100) or 0 == (year%400))) then	-- is a leap year?
				month_length = 29;												-- if leap year then 29 days in February
			end
		end
	else
		month_length = days_in_month[month];
	end

	if tonumber (day) &gt; month_length then
		return false;
	end
	return true;
end


--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ R A N G E _ S T Y L E &gt;--------------------------

Months in a range are expected to have the same style: Jan–Mar or October–December but not February–Mar or Jul–August. 
This function looks in cfg.date_names{} to see if both month names are listed in the long subtable or both are
listed in the short subtable.  When both have the same style (both are listed in the same table), returns true; false else

]]

local function is_valid_month_range_style (month1, month2)
	if (cfg.date_names.en.long[month1] and cfg.date_names.en.long[month2]) or					-- are both English names listed in the long subtable?
		(cfg.date_names.en.short[month1] and cfg.date_names.en.short[month2]) or				-- are both English names listed in the short subtable?
		(cfg.date_names['local'].long[month1] and cfg.date_names['local'].long[month2]) or		-- are both local names listed in the long subtable?
		(cfg.date_names['local'].short[month1] and cfg.date_names['local'].short[month2]) then	-- are both local names listed in the short subtable?
			return true;
	end
	return false;																-- names are mixed
end


--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ S E A S O N _ R A N G E &gt;------------------------

Check a pair of months or seasons to see if both are valid members of a month or season pair.

Month pairs are expected to be left to right, earliest to latest in time.

All season ranges are accepted as valid because there are publishers out there who have published a Summer–Spring YYYY issue, hence treat as ok

]]

local function is_valid_month_season_range(range_start, range_end, param)
	local range_start_number = get_month_number (range_start);
	local range_end_number;

	if 0 == range_start_number then												-- is this a month range?
		range_start_number = get_season_number (range_start, param);			-- not a month; is it a season? get start season number
		range_end_number = get_season_number (range_end, param);				-- get end season number

		if (0 ~= range_start_number) and (0 ~= range_end_number) and (range_start_number ~= range_end_number) then
			return true;														-- any season pairing is accepted except when both are the same
		end
		return false;															-- range_start and/or range_end is not a season
	end
																				-- here when range_start is a month
	range_end_number = get_month_number (range_end);							-- get end month number
	if range_start_number &lt; range_end_number and								-- range_start is a month; does range_start precede range_end?
		is_valid_month_range_style (range_start, range_end) then				-- do months have the same style?
			return true;														-- proper order and same style
	end
	return false;																-- range_start month number is greater than or equal to range end number; or range end isn't a month
end


--[[--------------------------&lt; M A K E _ C O I N S _ D A T E &gt;------------------------------------------------

This function receives a table of date parts for one or two dates and an empty table reference declared in
Module:Citation/CS1.  The function is called only for |date= parameters and only if the |date=&lt;value&gt; is 
determined to be a valid date format.  The question of what to do with invalid date formats is not answered here.

The date parts in the input table are converted to an ISO 8601 conforming date string:
	single whole dates:		yyyy-mm-dd
	month and year dates:	yyyy-mm
	year dates:				yyyy
	ranges:					yyyy-mm-dd/yyyy-mm-dd
							yyyy-mm/yyyy-mm
							yyyy/yyyy

Dates in the Julian calendar are reduced to year or year/year so that we don't have to do calendar conversion from
Julian to Proleptic Gregorian.

The input table has:
	year, year2 – always present; if before 1582, ignore months and days if present
	month, month2 – 0 if not provided, 1-12 for months, 21-24 for seasons; 99 Christmas
	day, day2 –  0 if not provided, 1-31 for days
	
the output table receives:
	rftdate:	an ISO 8601 formatted date
	rftchron:	a free-form version of the date, usually without year which is in rftdate (season ranges and proper-name dates)
	rftssn:		one of four season keywords: winter, spring, summer, fall (lowercase)
	rftquarter:	one of four values: 1, 2, 3, 4

]]

local function make_COinS_date (input, tCOinS_date)
	local date;																	-- one date or first date in a range
	local date2 = '';															-- end of range date
	input.year = tonumber (input.year) or lang_object:parseFormattedNumber (input.year);	-- language-aware tonumber()
	input.year2 = tonumber (input.year2) or lang_object:parseFormattedNumber (input.year2);	-- COinS dates are pseudo-ISO 8601 so convert to Arabic numerals

	if ((1582 == input.year) and (10 &gt; tonumber(input.month))) or (1582 &gt; input.year) then	-- if a Julian calendar date
		tCOinS_date.rftdate = tostring (input.year);							-- &amp;rft.date gets year only
		return;																	-- done
	end
																				-- here for all forms of Gregorian dates
	if 20 &lt; tonumber (input.month) then											-- if season, quarter, or proper-name date
		date = input.year;														-- &amp;rft.date gets year only
		if 0 ~= input.year2 and input.year ~= input.year2 then					-- if a range, only the second year portion when not the same as range start year
			date = string.format ('%.4d/%.4d', input.year, input.year2)			-- assemble the date range
		end

		local season = {[24] = 'winter', [21] = 'spring', [22] = 'summer', [23] = 'fall', [33] = '1', [34] = '2', [35] = '3', [36] = '4', [98] = 'Easter', [99] = 'Christmas'};	-- seasons lowercase, no autumn; proper-names use title case
		if 0 == input.month2 then												-- single season, quarter, or proper-name date
			if 40 &lt; tonumber(input.month) then
				tCOinS_date.rftchron = season[input.month];						-- proper-name date; used in journal metadata only
			elseif 30 &lt; tonumber(input.month) then
				tCOinS_date.rftquarter = season[input.month];					-- quarter date; used in journal metadata only
			else
				tCOinS_date.rftssn = season[input.month];						-- season date; used in journal metadata only
			end
		else																	-- season ranges are lumped into &amp;rft.chron; &amp;rft.ssn and &amp;rft.quarter are left blank
			if input.year ~= input.year2 then									-- season year – season year range or season year–year
				if 0 ~= input.month2 then
					tCOinS_date.rftchron = string.format ('%s %s – %s %s', season[input.month], input.year, season[input.month2], input.year2);	-- used in journal metadata only
				end
			else																-- season–season year range
				tCOinS_date.rftchron = season[input.month] .. '–' .. season[input.month2];	-- season–season year range; used in journal metadata only
			end
		end

		tCOinS_date.rftdate = tostring (date);
		return;																	-- done
	end
																				-- here for gregorian calendar dates
	if 0 ~= input.day then
		date = string.format ('%s-%.2d-%.2d', input.year, tonumber(input.month), tonumber(input.day));	-- whole date
	elseif 0 ~= input.month then
		date = string.format ('%s-%.2d', input.year, tonumber(input.month));	-- year and month
	else
		date = string.format ('%s', input.year);								-- just year
	end

	if 0 ~= input.year2 then
		if 0 ~= input.day2 then
			date2 = string.format ('/%s-%.2d-%.2d', input.year2, tonumber(input.month2), tonumber(input.day2));		-- whole date
		elseif 0 ~= input.month2 then
			date2 = string.format ('/%s-%.2d', input.year2, tonumber(input.month2));	-- year and month
		else
			date2 = string.format ('/%s', input.year2);							-- just year
		end
	end
	
	tCOinS_date.rftdate = date .. date2;										-- date2 has the '/' separator
	return;
end


--[[--------------------------&lt; P A T T E R N S _ T &gt;----------------------------------------------------------

this is the list of patterns for date formats that this module recognizes.  Approximately the first half of these
patterns represent formats that might be reformatted into another format.  Those that might be reformatted have
'indicator' letters that identify the content of the matching capture: 'd' (day), 'm' (month), 'a' (anchor year),
'y' (year); second day, month, year have a '2' suffix.

These patterns are used for both date validation and for reformatting.  This table should not be moved to ~/Configuration
because changes to this table require changes to check_date() and to reformatter() and reformat_date()

]]

local patterns_t = {
	 																			-- year-initial numerical year-month-day
	['ymd'] = {'^(%d%d%d%d)%-(%d%d)%-(%d%d)$', 'y', 'm', 'd'},					
																				-- month-initial: month day, year
	['Mdy'] = {'^(%D-) +([1-9]%d?), +((%d%d%d%d?)%a?)$', 'm', 'd', 'a', 'y'},
																				-- month-initial day range: month day–day, year; days are separated by endash
	['Md-dy'] = {'^(%D-) +([1-9]%d?)[%-–]([1-9]%d?), +((%d%d%d%d)%a?)$', 'm', 'd', 'd2', 'a', 'y'},
																				-- day-initial: day month year
	['dMy'] = {'^([1-9]%d?) +(%D-) +((%d%d%d%d?)%a?)$', 'd', 'm', 'a', 'y'},
																				-- year-initial: year month day; day: 1 or 2 two digits, leading zero allowed; not supported at en.wiki
	--	['yMd'] = {'^((%d%d%d%d?)%a?) +(%D-) +(%d%d?)$', 'a', 'y', 'm', 'd'},
																				-- day-range-initial: day–day month year; days are separated by endash
	['d-dMy'] = {'^([1-9]%d?)[%-–]([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'd2', 'm', 'a', 'y'},
																				-- day initial month-day-range: day month - day month year; uses spaced endash
	['dM-dMy'] = {'^([1-9]%d?) +(%D-) +[%-–] +([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'm', 'd2', 'm2', 'a', 'y'},
																				-- month initial month-day-range: month day – month day, year;  uses spaced endash
	['Md-Mdy'] = {'^(%D-) +([1-9]%d?) +[%-–] +(%D-) +([1-9]%d?), +((%d%d%d%d)%a?)$','m', 'd', 'm2', 'd2', 'a', 'y'},
																				-- day initial month-day-year-range: day month year - day month year; uses spaced endash
	['dMy-dMy'] = {'^([1-9]%d?) +(%D-) +(%d%d%d%d) +[%-–] +([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'm', 'y', 'd2', 'm2', 'a', 'y2'},
																				-- month initial month-day-year-range: month day, year – month day, year;  uses spaced endash
	['Mdy-Mdy'] = {'^(%D-) +([1-9]%d?), +(%d%d%d%d) +[%-–] +(%D-) +([1-9]%d?), +((%d%d%d%d)%a?)$', 'm', 'd', 'y', 'm2', 'd2', 'a', 'y2'},

																				-- these date formats cannot be converted, per se, but month name can be rendered short or long
																				-- month/season year - month/season year; separated by spaced endash
	['My-My'] = {'^(%D-) +(%d%d%d%d) +[%-–] +(%D-) +((%d%d%d%d)%a?)$', 'm', 'y', 'm2', 'a', 'y2'},
																				-- month/season range year; months separated by endash
	['M-My'] = {'^(%D-)[%-–](%D-) +((%d%d%d%d)%a?)$', 'm', 'm2', 'a', 'y'},
																				-- month/season year or proper-name year; quarter year when First Quarter YYYY etc.
	['My'] = {'^([^%d–]-) +((%d%d%d%d)%a?)$', 'm', 'a', 'y'},					-- this way because endash is a member of %D; %D- will match January–March 2019 when it shouldn't

																				-- these date formats cannot be converted
	['Sy4-y2'] = {'^(%D-) +((%d%d)%d%d)[%-–]((%d%d)%a?)$'},						-- special case Winter/Summer year-year (YYYY-YY); year separated with unspaced endash
	['Sy-y'] = {'^(%D-) +(%d%d%d%d)[%-–]((%d%d%d%d)%a?)$'},						-- special case Winter/Summer year-year; year separated with unspaced endash
	['y-y'] = {'^(%d%d%d%d?)[%-–]((%d%d%d%d?)%a?)$'},							-- year range: YYY-YYY or YYY-YYYY or YYYY–YYYY; separated by unspaced endash; 100-9999
	['y4-y2'] = {'^((%d%d)%d%d)[%-–]((%d%d)%a?)$'},								-- year range: YYYY–YY; separated by unspaced endash
	['y'] = {'^((%d%d%d%d?)%a?)$'},												-- year; here accept either YYY or YYYY
	}


--[[--------------------------&lt; I S _ V A L I D _ E M B A R G O _ D A T E &gt;------------------------------------

returns true and date value if that value has proper dmy, mdy, ymd format.

returns false and 9999 (embargoed forever) when date value is not proper format; assumes that when |pmc-embargo-date= is
set, the editor intended to embargo a PMC but |pmc-embargo-date= does not hold a single date.

]]

local function is_valid_embargo_date (v)
	if v:match (patterns_t['ymd'][1]) or										-- ymd
		v:match (patterns_t['Mdy'][1]) or										-- dmy
		v:match (patterns_t['dMy'][1]) then										-- mdy
			return true, v;
	end
	return false, '9999';														-- if here not good date so return false and set embargo date to long time in future
end


--[[--------------------------&lt; C H E C K _ D A T E &gt;----------------------------------------------------------

Check date format to see that it is one of the formats approved by WP:DATESNO or WP:DATERANGE. Exception: only
allowed range separator is endash.  Additionally, check the date to see that it is a real date: no 31 in 30-day
months; no 29 February when not a leap year.  Months, both long-form and three character abbreviations, and seasons
must be spelled correctly.  Future years beyond next year are not allowed.

If the date fails the format tests, this function returns false and does not return values for anchor_year and
COinS_date.  When this happens, the date parameter is (DEBUG: not?) used in the COinS metadata and the CITEREF identifier gets
its year from the year parameter if present otherwise CITEREF does not get a date value.

Inputs:
	date_string - date string from date-holding parameters (date, year, publication-date, access-date, pmc-embargo-date, archive-date, lay-date)

Returns:
	false if date string is not a real date; else
	true, anchor_year, COinS_date
		anchor_year can be used in CITEREF anchors
		COinS_date is ISO 8601 format date; see make_COInS_date()

]]

local function check_date (date_string, param, tCOinS_date)
	local year;																	-- assume that year2, months, and days are not used;
	local year2 = 0;															-- second year in a year range
	local month = 0;
	local month2 = 0;															-- second month in a month range
	local day = 0;
	local day2 = 0;																-- second day in a day range
	local anchor_year;
	local coins_date;

	if date_string:match (patterns_t['ymd'][1]) then							-- year-initial numerical year month day format
		year, month, day = date_string:match (patterns_t['ymd'][1]);
		if 12 &lt; tonumber(month) or 1 &gt; tonumber(month) or 1582 &gt; tonumber(year) or 0 == tonumber(day) then return false; end	-- month or day number not valid or not Gregorian calendar
		anchor_year = year;
	
	elseif mw.ustring.match(date_string, patterns_t['Mdy'][1]) then				-- month-initial: month day, year
		month, day, anchor_year, year = mw.ustring.match(date_string, patterns_t['Mdy'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
				
	elseif mw.ustring.match(date_string, patterns_t['Md-dy'][1]) then			-- month-initial day range: month day–day, year; days are separated by endash
		month, day, day2, anchor_year, year = mw.ustring.match(date_string, patterns_t['Md-dy'][1]);
		if tonumber(day) &gt;= tonumber(day2) then return false; end				-- date range order is left to right: earlier to later; dates may not be the same;
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
		month2=month;															-- for metadata
		year2 = year;

	elseif mw.ustring.match(date_string, patterns_t['dMy'][1]) then				-- day-initial: day month year
		day, month, anchor_year, year = mw.ustring.match(date_string, patterns_t['dMy'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months

--[[ NOT supported at en.wiki
	elseif mw.ustring.match(date_string, patterns_t['yMd'][1]) then				-- year-initial: year month day; day: 1 or 2 two digits, leading zero allowed
		anchor_year, year, month, day = mw.ustring.match(date_string, patterns_t['yMd'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
-- end NOT supported at en.wiki ]]

	elseif mw.ustring.match(date_string, patterns_t['d-dMy'][1]) then			-- day-range-initial: day–day month year; days are separated by endash
		day, day2, month, anchor_year, year = mw.ustring.match(date_string, patterns_t['d-dMy'][1]);
		if tonumber(day) &gt;= tonumber(day2) then return false; end				-- date range order is left to right: earlier to later; dates may not be the same;
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
		month2 = month;															-- for metadata
		year2 = year;

	elseif mw.ustring.match(date_string, patterns_t['dM-dMy'][1]) then			-- day initial month-day-range: day month - day month year; uses spaced endash
		day, month, day2, month2, anchor_year, year = mw.ustring.match(date_string, patterns_t['dM-dMy'][1]);
		if (not is_valid_month_season_range(month, month2)) or not is_valid_year(year) then return false; end	-- date range order is left to right: earlier to later;
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);
		year2 = year;

	elseif mw.ustring.match(date_string, patterns_t['Md-Mdy'][1]) then			-- month initial month-day-range: month day – month day, year; uses spaced endash
		month, day, month2, day2, anchor_year, year = mw.ustring.match(date_string, patterns_t['Md-Mdy'][1]);
		if (not is_valid_month_season_range(month, month2, param)) or not is_valid_year(year) then return false; end
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);
		year2 = year;

	elseif mw.ustring.match(date_string, patterns_t['dMy-dMy'][1]) then			-- day initial month-day-year-range: day month year - day month year; uses spaced endash
		day, month, year, day2, month2, anchor_year, year2 = mw.ustring.match(date_string, patterns_t['dMy-dMy'][1]);
		if tonumber(year2) &lt;= tonumber(year) then return false; end				-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end		-- year2 no more than one year in the future; months same style
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);
		if 0 == month or 0 == month2 then return false; end						-- both must be valid

	elseif mw.ustring.match(date_string, patterns_t['Mdy-Mdy'][1]) then			-- month initial month-day-year-range: month day, year – month day, year; uses spaced endash
		month, day, year, month2, day2, anchor_year, year2 = mw.ustring.match(date_string, patterns_t['Mdy-Mdy'][1]);
		if tonumber(year2) &lt;= tonumber(year) then return false; end				-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end		-- year2 no more than one year in the future; months same style
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number(month2);
		if 0 == month or 0 == month2 then return false; end						-- both must be valid

	elseif mw.ustring.match(date_string, patterns_t['Sy4-y2'][1]) then			-- special case Winter/Summer year-year (YYYY-YY); year separated with unspaced endash
		local century;
		month, year, century, anchor_year, year2 = mw.ustring.match(date_string, patterns_t['Sy4-y2'][1]);
		if 'Winter' ~= month and 'Summer' ~= month then return false end;		-- 'month' can only be Winter or Summer
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor_year from both years
		year2 = century..year2;													-- add the century to year2 for comparisons
		if 1 ~= tonumber(year2) - tonumber(year) then return false; end			-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year
		month = get_season_number(month, param);

	elseif mw.ustring.match(date_string, patterns_t['Sy-y'][1]) then			-- special case Winter/Summer year-year; year separated with unspaced endash
		month, year, anchor_year, year2 = mw.ustring.match(date_string, patterns_t['Sy-y'][1]);
		month = get_season_number (month, param);								-- &lt;month&gt; can only be winter or summer; also for metadata
		if (month ~= cfg.date_names['en'].season['Winter']) and (month ~= cfg.date_names['en'].season['Summer']) then
			return false;														-- not Summer or Winter; abandon
		end
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor_year from both years
		if 1 ~= tonumber(year2) - tonumber(year) then return false; end			-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif mw.ustring.match(date_string, patterns_t['My-My'][1]) then			-- month/season year - month/season year; separated by spaced endash
		month, year, month2, anchor_year, year2 = mw.ustring.match(date_string, patterns_t['My-My'][1]);
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor_year from both years
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year
		if 0 ~= get_month_number(month) and 0 ~= get_month_number(month2) and is_valid_month_range_style(month, month2) then 	-- both must be month year, same month style
			month = get_month_number(month);
			month2 = get_month_number(month2);
		elseif 0 ~= get_season_number(month, param) and 0 ~= get_season_number(month2, param) then	-- both must be season year, not mixed
			month = get_season_number(month, param);
			month2 = get_season_number(month2, param);
		else
			 return false;
		end

	elseif mw.ustring.match(date_string, patterns_t['M-My'][1]) then			-- month/season range year; months separated by endash 
		month, month2, anchor_year, year = mw.ustring.match(date_string, patterns_t['M-My'][1]);
		if (not is_valid_month_season_range(month, month2, param)) or (not is_valid_year(year)) then return false; end
		if 0 ~= get_month_number(month) then									-- determined to be a valid range so just check this one to know if month or season
			month = get_month_number(month);
			month2 = get_month_number(month2);
			if 0 == month or 0 == month2 then return false; end
		else
			month = get_season_number(month, param);
			month2 = get_season_number(month2, param);
		end
		year2 = year;
		
	elseif mw.ustring.match(date_string, patterns_t['My'][1]) then				-- month/season/quarter/proper-name year
		month, anchor_year, year = mw.ustring.match(date_string, patterns_t['My'][1]);
		if not is_valid_year(year) then return false; end
		month = get_element_number(month, param);								-- get month season quarter proper-name number or nil
		if not month then return false; end										-- not valid whatever it is

	elseif mw.ustring.match(date_string, patterns_t['y-y'][1]) then				-- Year range: YYY-YYY or YYY-YYYY or YYYY–YYYY; separated by unspaced endash; 100-9999
		year, anchor_year, year2 = mw.ustring.match(date_string, patterns_t['y-y'][1]);
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor year from both years
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif mw.ustring.match(date_string, patterns_t['y4-y2'][1]) then			-- Year range: YYYY–YY; separated by unspaced endash
		local century;
		year, century, anchor_year, year2 = mw.ustring.match(date_string, patterns_t['y4-y2'][1]);
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor year from both years

		if 13 &gt; tonumber(year2) then return false; end							-- don't allow 2003-05 which might be May 2003
		year2 = century .. year2;												-- add the century to year2 for comparisons
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

		if in_array (param, {'date', 'publication-date', 'year'}) then			-- here when 'valid' abbreviated year range; if one of these parameters
			add_prop_cat ('year-range-abbreviated');							-- add properties cat
		end

	elseif mw.ustring.match(date_string, patterns_t['y'][1]) then				-- year; here accept either YYY or YYYY
		anchor_year, year = mw.ustring.match(date_string, patterns_t['y'][1]);
		if false == is_valid_year(year) then
			return false;
		end

	else
		return false;															-- date format not one of the MOS:DATE approved formats
	end

	if param ~= 'date' then														-- CITEREF disambiguation only allowed in |date=; |year= &amp; |publication-date= promote to date
		if anchor_year:match ('%l$') then
			return false;
		end
	end

	if 'access-date' == param then												-- test access-date here because we have numerical date parts
		if 0 ~= year and 0 ~= month and 0 ~= day and 							-- all parts of a single date required
			0 == year2 and 0 == month2 and 0 == day2 then						-- none of these; access-date must not be a range
				if not is_valid_accessdate(year .. '-' .. month .. '-' .. day) then	
					return false;												-- return false when access-date out of bounds
				end
		else
			return false;														-- return false when access-date is a range of two dates
		end
	end

	if 'archive-date' == param then												-- test archive-date here because we have numerical date parts
		if not (0 ~= year and 0 ~= month and 0 ~= day and						-- all parts of a single date required
			0 == year2 and 0 == month2 and 0 == day2) then						-- none of these; archive-date must not be a range
				return false;													-- return false when archive-date is a range of two dates
		end
	end

	local result=true;															-- check whole dates for validity; assume true because not all dates will go through this test
	if 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 == day2 then		-- YMD (simple whole date)
		result = is_valid_date (year, month, day, param);						-- &lt;param&gt; for |pmc-embargo-date=

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 ~= day2 then	-- YMD-d (day range)
		result = is_valid_date (year, month, day);
		result = result and is_valid_date (year, month, day2);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 ~= month2 and 0 ~= day2 then	-- YMD-md (day month range)
		result = is_valid_date (year, month, day);
		result = result and is_valid_date (year, month2, day2);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 ~= year2 and 0 ~= month2 and 0 ~= day2 then	-- YMD-ymd (day month year range)
		result = is_valid_date(year, month, day);
		result = result and is_valid_date(year2, month2, day2);
	end
	
	if false == result then return false; end

	if nil ~= tCOinS_date then													-- this table only passed into this function when testing |date= parameter values
		make_COinS_date ({year = year, month = month, day = day, year2 = year2, month2 = month2, day2 = day2}, tCOinS_date);	-- make an ISO 8601 date string for COinS
	end
	
	return true, anchor_year;													-- format is good and date string represents a real date
end	


--[[--------------------------&lt; D A T E S &gt;--------------------------------------------------------------------

Cycle the date-holding parameters in passed table date_parameters_list through check_date() to check compliance with MOS:DATE. For all valid dates, check_date() returns
true. The |date= parameter test is unique, it is the only date holding parameter from which values for anchor_year (used in CITEREF identifiers) and COinS_date (used in
the COinS metadata) are derived.  The |date= parameter is the only date-holding parameter that is allowed to contain the no-date keywords "n.d." or "nd" (without quotes).

Unlike most error messages created in this module, only one error message is created by this function. Because all of the date holding parameters are processed serially,
parameters with errors are added to the &lt;error_list&gt; sequence table as the dates are tested.

]]

local function dates(date_parameters_list, tCOinS_date, error_list)
	local anchor_year;															-- will return as nil if the date being tested is not |date=
	local COinS_date;															-- will return as nil if the date being tested is not |date=
	local embargo_date;															-- if embargo date is a good dmy, mdy, ymd date then holds original value else reset to 9999
	local good_date = false;

	for k, v in pairs(date_parameters_list) do									-- for each date-holding parameter in the list
		if is_set(v.val) then													-- if the parameter has a value
			v.val = mw.ustring.gsub(v.val, '%d', cfg.date_names.local_digits);	-- translate 'local' digits to Western 0-9
			if v.val:match("^c%. [1-9]%d%d%d?%a?$") then						-- special case for c. year or with or without CITEREF disambiguator - only |date= and |year=
				local year = v.val:match("c%. ([1-9]%d%d%d?)%a?");				-- get the year portion so it can be tested
				if 'date' == k then
					anchor_year, COinS_date = v.val:match("((c%. [1-9]%d%d%d?)%a?)");	-- anchor year and COinS_date only from |date= parameter
					good_date = is_valid_year(year);
				elseif 'year' == k then
					good_date = is_valid_year(year);
				end
			elseif 'date' == k then												-- if the parameter is |date=
				if v.val:match("^n%.d%.%a?$") then -- ToDo: I18N								-- if |date=n.d. with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((n%.d%.)%a?)"); -- ToDo: I18N	-- "n.d."; no error when date parameter is set to no date
				elseif v.val:match("^nd%a?$") then -- ToDo: I18N								-- if |date=nd with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((nd)%a?)"); -- ToDo: I18N	-- "nd";	no error when date parameter is set to no date
				else
					good_date, anchor_year, COinS_date = check_date (v.val, k, tCOinS_date);	-- go test the date
				end
			elseif 'year' == k then												-- if the parameter is |year= it should hold only a year value
				if v.val:match("^[1-9]%d%d%d?%a?$") then						-- if |year = 3 or 4 digits only with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((%d+)%a?)");
				end
			elseif 'pmc-embargo-date' == k then									-- if the parameter is |pmc-embargo-date=
				good_date = check_date (v.val, k);								-- go test the date
				if true == good_date then										-- if the date is a valid date
					good_date, embargo_date = is_valid_embargo_date (v.val);	-- is |pmc-embargo-date= date a single dmy, mdy, or ymd formatted date? yes: returns embargo date; no: returns 9999
				end
			else																-- any other date-holding parameter
				good_date = check_date (v.val, k);								-- go test the date
			end
			if false == good_date then											-- assemble one error message so we don't add the tracking category multiple times
				table.insert (error_list, wrap_style ('parameter', v.name));	-- make parameter name suitable for error message list
			end
		end
	end
	return anchor_year, embargo_date;											-- and done
end


--[[--------------------------&lt; Y E A R _ C H E C K &gt;----------------------------------------------------------

Temporary function to test |year= for acceptable values:
	YYY, YYYY, year-only ranges, their circa forms, with or without CITEREF disambiguators.

When |year= holds some form of date that is not one of these year-only dates, emit a maintenance message.

This function necessary because many non-cs1|2 templates have a |year= parameter so cirrus searches are more-or-
less useless

]]

local function year_check (year)
	year = year:gsub ('c%. *', '');												-- remove circa annotation (if present) before testing &lt;year&gt;
	
	for _, index in ipairs ({'y-y', 'y4-y2', 'y'}) do							-- spin through these indexes into patterns_t
		if mw.ustring.match (year, patterns_t[index][1]) then
			return;																-- if a match then |year= holds a valid 'year'
		end
	end

	set_message ('maint_year');													-- if here, |year= value is not an accepted value; add a maint cat
end


--[[--------------------------&lt; Y E A R _ D A T E _ C H E C K &gt;------------------------------------------------

Compare the value provided in |year= with the year value(s) provided in |date=.  This function sets a local numeric value:
	0 - year value does not match the year value in date
	1 - (default) year value matches the year value in date or one of the year values when date contains two years
	2 - year value matches the year value in date when date is in the form YYYY-MM-DD and year is disambiguated (|year=YYYYx)

the numeric value in &lt;result&gt; determines the 'output' if any from this function:
	0 – adds error message to error_list sequence table
	1 – adds maint cat
	2 – does nothing

]]

local function year_date_check (year_string, year_origin, date_string, date_origin, error_list)
	local year;
	local date1;
	local date2;
	local result = 1;															-- result of the test; assume that the test passes

	year = year_string:match ('(%d%d%d%d?)');

	if date_string:match ('%d%d%d%d%-%d%d%-%d%d') and year_string:match ('%d%d%d%d%a') then	--special case where both date and year are required YYYY-MM-DD and YYYYx
		date1 = date_string:match ('(%d%d%d%d)');
		year = year_string:match ('(%d%d%d%d)');
		if year ~= date1 then
			result = 0;															-- years don't match
		else
			result = 2;															-- years match; but because disambiguated, don't add to maint cat
		end
		
	elseif date_string:match ("%d%d%d%d?.-%d%d%d%d?") then						-- any of the standard range formats of date with two three- or four-digit years
		date1, date2 = date_string:match ("(%d%d%d%d?).-(%d%d%d%d?)");
		if year ~= date1 and year ~= date2 then
			result = 0;
		end

	elseif mw.ustring.match(date_string, "%d%d%d%d[%-–]%d%d") then				-- YYYY-YY date ranges
		local century;
		date1, century, date2 = mw.ustring.match(date_string, "((%d%d)%d%d)[%-–]+(%d%d)");
		date2 = century..date2;													-- convert YY to YYYY
		if year ~= date1 and year ~= date2 then
			result = 0;
		end

	elseif date_string:match ("%d%d%d%d?") then									-- any of the standard formats of date with one year
		date1 = date_string:match ("(%d%d%d%d?)");
		if year ~= date1 then
			result = 0;
		end
	else																		-- should never get here; this function called only when no other date errors
		result = 0;																-- no recognizable year in date
	end

	if 0 == result then															-- year / date mismatch
		table.insert (error_list, substitute (cfg.messages['mismatch'], {year_origin, date_origin}));	-- add error message to error_list sequence table
	elseif 1 == result then														-- redundant year / date
		set_message ('maint_date_year');										-- add a maint cat
	end
end


--[[--------------------------&lt; R E F O R M A T T E R &gt;--------------------------------------------------------

reformat 'date' into new format specified by format_param if pattern_idx (the current format of 'date') can be
reformatted.  Does the grunt work for reformat_dates().

The table re_formats maps pattern_idx (current format) and format_param (desired format) to a table that holds:
	format string used by string.format()
	identifier letters ('d', 'm', 'y', 'd2', 'm2', 'y2') that serve as indexes into a table t{} that holds captures
		from mw.ustring.match() for the various date parts specified by  patterns_t[pattern_idx][1]

Items in patterns_t{} have the general form:
	['ymd'] = {'^(%d%d%d%d)%-(%d%d)%-(%d%d)$', 'y', 'm', 'd'}, where:
		['ymd'] is pattern_idx
		patterns_t['ymd'][1] is the match pattern with captures for mw.ustring.match()
		patterns_t['ymd'][2] is an indicator letter identifying the content of the first capture
		patterns_t['ymd'][3] ... the second capture etc.

when a pattern matches a date, the captures are loaded into table t{} in capture order using the idemtifier
characters as indexes into t{}  For the above, a ymd date is in t{} as:
	t.y = first capture (year), t.m = second capture (month), t.d = third capture (day)

To reformat, this function is called with the pattern_idx that matches the current format of the date and with
format_param set to the desired format.  This function loads table t{} as described and then calls string.format()
with the format string specified by re_format[pattern_idx][format_param][1] using values taken from t{} according
to the capture identifier letters specified by patterns_t[pattern_idx][format_param][n] where n is 2..

]]

local re_formats = {
	['ymd'] = {																	-- date format is ymd; reformat to:
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- |df=mdy
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- |df=dmy
	--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},								-- |df=yMd; not supported at en.wiki
		},
	['Mdy'] = {																	-- date format is Mdy; reformat to:
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- for long/short reformatting
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- |df=dmy
		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},									-- |df=ymd
	--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},								-- |df=yMd; not supported at en.wiki
		},
	['dMy'] = {																	-- date format is dMy; reformat to:
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- for long/short reformatting
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- |df=mdy
		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},									-- |df=ymd
	--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},								-- |df=yMd; not supported at en.wiki
		},
	['Md-dy'] = {																-- date format is Md-dy; reformat to:
		['mdy'] = {'%s %s–%s, %s', 'm', 'd', 'd2', 'y'},						-- for long/short reformatting
		['dmy'] = {'%s–%s %s %s', 'd', 'd2', 'm', 'y'},							-- |df=dmy -&gt; d-dMy 
		},
	['d-dMy'] = {																-- date format is d-d&gt;y; reformat to:
		['dmy'] = {'%s–%s %s %s', 'd', 'd2', 'm', 'y'},							-- for long/short reformatting
		['mdy'] = {'%s %s–%s, %s', 'm', 'd', 'd2', 'y'},						-- |df=mdy -&gt; Md-dy 
		},
	['dM-dMy'] = {																-- date format is dM-dMy; reformat to:
		['dmy'] = {'%s %s – %s %s %s', 'd', 'm', 'd2', 'm2', 'y'},				-- for long/short reformatting
		['mdy'] = {'%s %s – %s %s, %s', 'm', 'd', 'm2', 'd2', 'y'},				-- |df=mdy -&gt; Md-Mdy 
		},
	['Md-Mdy'] = {																-- date format is Md-Mdy; reformat to:
		['mdy'] = {'%s %s – %s %s, %s', 'm', 'd',  'm2', 'd2', 'y'},			-- for long/short reformatting
		['dmy'] = {'%s %s – %s %s %s', 'd', 'm', 'd2', 'm2', 'y'},				-- |df=dmy -&gt; dM-dMy 
		},
	['dMy-dMy'] = {																-- date format is dMy-dMy; reformat to:
		['dmy'] = {'%s %s %s – %s %s %s', 'd', 'm', 'y', 'd2', 'm2', 'y2'},		-- for long/short reformatting
		['mdy'] = {'%s %s, %s – %s %s, %s', 'm', 'd', 'y', 'm2', 'd2', 'y2'},	-- |df=mdy -&gt; Mdy-Mdy 
		},
	['Mdy-Mdy'] = {																-- date format is Mdy-Mdy; reformat to:
		['mdy'] = {'%s %s, %s – %s %s, %s', 'm', 'd', 'y', 'm2', 'd2', 'y2'},	-- for long/short reformatting
		['dmy'] = {'%s %s %s – %s %s %s', 'd', 'm', 'y', 'd2', 'm2', 'y2'},		-- |df=dmy -&gt; dMy-dMy 
		},
	['My-My'] = {																-- these for long/short reformatting
		['any'] = {'%s %s – %s %s', 'm', 'y', 'm2', 'y2'},						-- dmy/mdy agnostic
		},
	['M-My'] = {																-- these for long/short reformatting
		['any'] = {'%s–%s %s', 'm', 'm2', 'y'},									-- dmy/mdy agnostic
		},
	['My'] = {																	-- these for long/short reformatting
		['any'] = {'%s %s', 'm', 'y'},											-- dmy/mdy agnostic
		},
	--	['yMd'] = {																-- not supported at en.wiki
	--		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},								-- |df=mdy
	--		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},								-- |df=dmy
	--		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},								-- |df=ymd
	--		},
	}


local function reformatter (date, pattern_idx, format_param, mon_len)
	if not in_array (pattern_idx, {'ymd', 'Mdy', 'Md-dy', 'dMy', 'yMd', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy', 'My-My', 'M-My', 'My'}) then
		return;																	-- not in this set of date format patterns_t then not a reformattable date
	end
	
	if 'ymd' == format_param and in_array (pattern_idx, {'ymd', 'Md-dy', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy', 'My-My', 'M-My', 'My'}) then
		return;																	-- ymd date ranges not supported at en.wiki; no point in reformatting ymd to ymd
	end

	if in_array (pattern_idx, {'My', 'M-My', 'My-My'}) then						-- these are not dmy/mdy so can't be 'reformatted' into either
		format_param = 'any';													-- so format-agnostic 
	end

																				-- yMd is not supported at en.wiki; when yMd is supported at your wiki, uncomment the next line
	--	if 'yMd' == format_param and in_array (pattern_idx, {'yMd', 'Md-dy', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy'}) then	-- these formats not convertable; yMd not supported at en.wiki
	if 'yMd' == format_param then												-- yMd not supported at en.wiki; when yMd is supported at your wiki, remove or comment-out this line
		return;																	-- not a reformattable date
	end
	
	local c1, c2, c3, c4, c5, c6, c7;											-- these hold the captures specified in patterns_t[pattern_idx][1]
	c1, c2, c3, c4, c5, c6, c7 = mw.ustring.match (date, patterns_t[pattern_idx][1]);	-- get the captures

	local t = {																	-- table that holds k/v pairs of date parts from the captures and patterns_t[pattern_idx][2..]
		[patterns_t[pattern_idx][2]] = c1;										-- at minimum there is always one capture with a matching indicator letter
		[patterns_t[pattern_idx][3] or 'x'] = c2;								-- patterns_t can have a variable number of captures; each capture requires an indicator letter;
		[patterns_t[pattern_idx][4] or 'x'] = c3;								-- where there is no capture, there is no indicator letter so n in patterns_t[pattern_idx][n] will be nil;
		[patterns_t[pattern_idx][5] or 'x'] = c4;								-- the 'x' here spoofs an indicator letter to prevent 'table index is nil' error
		[patterns_t[pattern_idx][6] or 'x'] = c5;
		[patterns_t[pattern_idx][7] or 'x'] = c6;
		[patterns_t[pattern_idx][8] or 'x'] = c7;
		};

	if t.a then																	-- if this date has an anchor year capture (all convertable date formats except ymd)
		if t.y2 then															-- for year range date formats														
			t.y2 = t.a;															-- use the anchor year capture when reassembling the date
		else																	-- here for single date formats (except ymd)
			t.y = t.a;															-- use the anchor year capture when reassembling the date
		end
	end

	if tonumber(t.m) then														-- if raw month is a number (converting from ymd)
		if 's' == mon_len then													-- if we are to use abbreviated month names
			t.m = cfg.date_names['inv_local_short'][tonumber(t.m)];					-- convert it to a month name
		else
			t.m = cfg.date_names['inv_local_long'][tonumber(t.m)];					-- convert it to a month name
		end
		t.d = t.d:gsub ('0(%d)', '%1');											-- strip leading '0' from day if present
	elseif 'ymd' == format_param then											-- when converting to ymd
		t.y = t.y:gsub ('%a', '');												-- strip CITREF disambiguator if present; anchor year already known so process can proceed; TODO: maint message?
		if 1582 &gt; tonumber (t.y) then											-- ymd format dates not allowed before 1582
			return;
		end
		t.m = string.format ('%02d', get_month_number (t.m));					-- make sure that month and day are two digits
		t.d = string.format ('%02d', t.d);
	elseif mon_len then															-- if mon_len is set to either 'short' or 'long'
		for _, mon in ipairs ({'m', 'm2'}) do									-- because there can be two month names, check both 
			if t[mon] then
				t[mon] = get_month_number (t[mon]);								-- get the month number for this month (is length agnostic)
				if 0 == t[mon] then return; end									-- seasons and named dates can't be converted
				t[mon] = (('s' == mon_len) and cfg.date_names['inv_local_short'][t[mon]]) or cfg.date_names['inv_local_long'][t[mon]];	-- fetch month name according to length
			end
		end
	end

	local new_date = string.format (re_formats[pattern_idx][format_param][1],	-- format string
		t[re_formats[pattern_idx][format_param][2]],							-- named captures from t{}
		t[re_formats[pattern_idx][format_param][3]],
		t[re_formats[pattern_idx][format_param][4]],
		t[re_formats[pattern_idx][format_param][5]],
		t[re_formats[pattern_idx][format_param][6]],
		t[re_formats[pattern_idx][format_param][7]],
		t[re_formats[pattern_idx][format_param][8]]
		);

	return new_date;
end


--[[-------------------------&lt; R E F O R M A T _ D A T E S &gt;--------------------------------------------------

Reformats existing dates into the format specified by format.

format is one of several manual keywords: dmy, dmy-all, mdy, mdy-all, ymd, ymd-all.  The -all version includes
access- and archive-dates; otherwise these dates are not reformatted.

This function allows automatic date formatting.  In ~/Configuration, the article source is searched for one of
the {{use xxx dates}} templates.  If found, xxx becomes the global date format as xxx-all.  If |cs1-dates= in
{{use xxx dates}} has legitimate value then that value determines how cs1|2 dates will be rendered.  Legitimate
values for |cs1-dates= are:
	l - all dates are rendered with long month names
	ls - publication dates use long month names; access-/archive-dates use abbreviated month names
	ly - publication dates use long month names; access-/archive-dates rendered in ymd format
	s - all dates are rendered with abbreviated (short) month names
	sy - publication dates use abbreviated month names; access-/archive-dates rendered in ymd format
	y - all dates are rendered in ymd format

the format argument for automatic date formatting will be the format specified by {{use xxx dates}} with the
value supplied by |cs1-dates so one of: xxx-l, xxx-ls, xxx-ly, xxx-s, xxx-sy, xxx-y, or simply xxx (|cs1-dates=
empty, omitted, or invalid) where xxx shall be either of dmy or mdy.

dates are extracted from date_parameters_list, reformatted (if appropriate), and then written back into the
list in the new format.  Dates in date_parameters_list are presumed here to be valid (no errors).  This function
returns true when a date has been reformatted, false else.  Actual reformatting is done by reformatter().

]]

local function reformat_dates (date_parameters_list, format)
	local all = false;															-- set to false to skip access- and archive-dates
	local len_p = 'l';															-- default publication date length shall be long
	local len_a = 'l';															-- default access-/archive-date length shall be long
	local result = false;
	local new_date;																
	
	if format:match('%a+%-all') then											-- manual df keyword; auto df keyword when length not specified in {{use xxx dates}}; 
		format = format:match('(%a+)%-all');									-- extract the format
		all = true;																-- all dates are long format dates because this keyword doesn't specify length
	elseif format:match('%a+%-[lsy][sy]?') then									-- auto df keywords; internal only
		all = true;																-- auto df applies to all dates; use length specified by capture len_p for all dates
		format, len_p, len_a = format:match('(%a+)%-([lsy])([sy]?)');			-- extract the format and length keywords
		if 'y' == len_p then													-- because allowed by MOS:DATEUNIFY (sort of) range dates and My dates not reformatted
			format = 'ymd';														-- override {{use xxx dates}}
		elseif (not is_set(len_a)) or (len_p == len_a) then						-- no access-/archive-date length specified or same length as publication dates then
			len_a = len_p;														-- in case len_a not set
		end
	end																			-- else only publication dates and they are long

	for param_name, param_val in pairs (date_parameters_list) do				-- for each date-holding parameter in the list
		if is_set (param_val.val) then											-- if the parameter has a value
			if not (not all and in_array (param_name, {'access-date', 'archive-date'})) then	-- skip access- or archive-date unless format is xxx-all; yeah, ugly; TODO: find a better way
				for pattern_idx, pattern in pairs (patterns_t) do
					if mw.ustring.match (param_val.val, pattern[1]) then
						if all and in_array (param_name, {'access-date', 'archive-date'}) then	-- if this date is an access- or archive-date
							new_date = reformatter (param_val.val, pattern_idx, (('y' == len_a) and 'ymd') or format, len_a);	-- choose ymd or dmy/mdy according to len_a setting
						else													-- all other dates
							new_date = reformatter (param_val.val, pattern_idx, format, len_p);
						end
						
						if new_date then										-- set when date was reformatted
							date_parameters_list[param_name].val = new_date;	-- update date in date list
							result = true;										-- and announce that changes have been made
							break;
						end
					end	-- if
				end		-- for
			end			-- if
		end				-- if
	end					-- for
	return result;																-- declare boolean result and done
end


--[[--------------------------&lt; D A T E _ H Y P H E N _ T O _ D A S H &gt;----------------------------------------

Loops through the list of date-holding parameters and converts any hyphen to an ndash.  Not called if the cs1|2
template has any date errors.

Modifies the date_parameters_list and returns true if hyphens are replaced, else returns false.

]]

local function date_hyphen_to_dash (date_parameters_list)
	local result = false;
	local n;
	for param_name, param_val in pairs(date_parameters_list) do					-- for each date-holding parameter in the list
		if is_set (param_val.val) and
			not mw.ustring.match (param_val.val, patterns_t.ymd[1]) then		-- for those that are not ymd dates (ustring because here digits may not be Western)
				param_val.val, n = param_val.val:gsub ('%-', '–');				-- replace any hyphen with ndash
				if 0 ~= n then
					date_parameters_list[param_name].val = param_val.val;		-- update the list
					result = true;
				end
		end
	end
	return result;																-- so we know if any hyphens were replaced
end


--[[-------------------------&lt; D A T E _ N A M E _ X L A T E &gt;------------------------------------------------

Attempts to translate English date names to local-language date names using names supplied by MediaWiki's
date parser function.  This is simple name-for-name replacement and may not work for all languages.

if xlat_dig is true, this function will also translate Western (English) digits to the local language's digits.
This will also translate ymd dates.

]]

local function date_name_xlate (date_parameters_list, xlt_dig)
	local xlate;
	local mode;																	-- long or short month names
	local modified = false;
	local date;
	
	local sources_t = {
		{cfg.date_names.en.long, cfg.date_names.inv_local_long},				-- for translating long English month names to long local month names
		{cfg.date_names.en.short, cfg.date_names.inv_local_short},				-- short month names
		{cfg.date_names.en.quarter, cfg.date_names.inv_local_quarter},			-- quarter date names
		{cfg.date_names.en.season, cfg.date_names.inv_local_season},			-- season date nam
		{cfg.date_names.en.named, cfg.date_names.inv_local_named},				-- named dates
		}

	local function is_xlateable (month)											-- local function to get local date name that replaces existing English-language date name
		for _, date_names_t in ipairs (sources_t) do							-- for each sequence table in date_names_t
			if date_names_t[1][month] then										-- if date name is English month (long or short), quarter, season or named and
				if date_names_t[2][date_names_t[1][month]] then					-- if there is a matching local date name
					return date_names_t[2][date_names_t[1][month]];				-- return the local date name
				end
			end
		end
	end

	for param_name, param_val in pairs(date_parameters_list) do					-- for each date-holding parameter in the list
		if is_set(param_val.val) then											-- if the parameter has a value
			date = param_val.val;
			for month in mw.ustring.gmatch (date, '[%a ]+') do					-- iterate through all date names in the date (single date or date range)
				month = mw.text.trim (month);									-- this because quarterly dates contain whitespace
				xlate = is_xlateable (month);									-- get translate &lt;month&gt;; returns translation or nil
				
				if xlate then		
					date = mw.ustring.gsub (date, month, xlate);				-- replace the English with the translation
					date_parameters_list[param_name].val = date;				-- save the translated date
					modified = true;
				end
			end

			if xlt_dig then														-- shall we also translate digits?
				date = date:gsub ('%d', cfg.date_names.xlate_digits);			-- translate digits from Western to 'local digits'
				date_parameters_list[param_name].val = date;					-- save the translated date
				modified = true;
			end
		end
	end
	
	return modified;
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	add_prop_cat = utilities_page_ptr.add_prop_cat ;							-- import functions from selected Module:Citation/CS1/Utilities module
	is_set = utilities_page_ptr.is_set;
	in_array = utilities_page_ptr.in_array;
	set_message = utilities_page_ptr.set_message;
	substitute = utilities_page_ptr.substitute;
	wrap_style = utilities_page_ptr.wrap_style;

	cfg = cfg_table_ptr;														-- import tables from selected Module:Citation/CS1/Configuration
end


--[[--------------------------&lt; A R C H I V E _ D A T E _ C H E C K &gt;------------------------------------------

Compare value in |archive-date= with the timestamp in Wayback machine urls.  Emits an error message with suggested
date from the |archive-url= timestamp in an appropriate format when the value in |archive-date= does not match
the timestamp.

this function never called when any date in a cs1|2 template has errors

error message suggests new |archive-date= value in an appropriate format specified by &lt;df&gt;.  &lt;df&gt; is either 
|df= or cfg.global_df in that order.  If &lt;df&gt; is nil, suggested date has format from |archive-date=.  There is
a caveat: when |df=dmy or |df=mdy, the reformatter leaves |access-date= and |archive-date= formats as they are.
The error message suggested date is passed to the formatter as YYYY-MM-DD so when |df=dmy or |df=mdy, the format
is not changed.

]]

local function archive_date_check (archive_date, archive_url_timestamp, df)
	local archive_date_format = 'dmy-y';										-- holds the date format of date in |archive-date; default to ymd; 'dmy' used here to spoof reformat_dates() 
	
	for _, v_t in ipairs ({{'dMy', 'dmy-all'}, {'Mdy', 'mdy-all'}}) do			-- is |archive-date= format dmy or mdy?
		if archive_date:match (patterns_t[v_t[1]][1]) then						-- does the pattern match?
			archive_date_format = cfg.keywords_xlate[v_t[2]];					-- get appropriate |df= supported keyword from the i18n translator table
			break;
		end
	end
	
	local dates_t = {};
	dates_t['archive-date'] = {val=archive_date, name=''};						-- setup to call reformat_dates(); never called when errors so &lt;name&gt; unset as not needed
	reformat_dates (dates_t, 'dmy-y');											-- reformat |archive-date= to ymd; 'dmy' used here to spoof reformat_dates()
	local archive_url_date = archive_url_timestamp:gsub ('(%d%d%d%d)(%d%d)(%d%d)%d*', '%1-%2-%3');	-- make ymd format date from timestamp

	if dates_t['archive-date'].val == archive_url_date then						-- are the two dates the same
		return;																	-- yes, done
	else
		dates_t['archive-date'] = {val=archive_url_date, name=''};				-- setup to call reformat_dates() with the timestamp date
		reformat_dates (dates_t, df or archive_date_format);					-- reformat timestamp to format specified by &lt;df&gt; or format used in |archive-date= 
		archive_url_date = dates_t['archive-date'].val;
		set_message ('err_archive_date_url_ts_mismatch', archive_url_date);		-- emit an error message
	end
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {																		-- return exported functions
	archive_date_check = archive_date_check,
	date_hyphen_to_dash = date_hyphen_to_dash,
	date_name_xlate = date_name_xlate,
	dates = dates,
	reformat_dates = reformat_dates,
	set_selected_modules = set_selected_modules,
	year_check = year_check,
	year_date_check = year_date_check,
	}</text>
      <sha1>h37xf2hxsrjgq13ms7lozl3uiigkklr</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Identifiers</title>
    <ns>828</ns>
    <id>28</id>
    <revision>
      <id>44</id>
      <parentid>43</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>43</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="78002" sha1="k1dr68mpitw4fjf8xuqkl74nhwowac7" xml:space="preserve">--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local has_accept_as_written, is_set, in_array, set_message, select_one,			-- functions in Module:Citation/CS1/Utilities
		substitute, make_wikilink;

local z;																		-- table of tables defined in Module:Citation/CS1/Utilities

local cfg;																		-- table of configuration tables that are defined in Module:Citation/CS1/Configuration


--[[--------------------------&lt; P A G E   S C O P E   V A R I A B L E S &gt;--------------------------------------

declare variables here that have page-wide scope that are not brought in from other modules; that are created here and used here

]]

local auto_link_urls = {};														-- holds identifier URLs for those identifiers that can auto-link |title=


--============================&lt;&lt; H E L P E R   F U N C T I O N S &gt;&gt;============================================

--[[--------------------------&lt; W I K I D A T A _ A R T I C L E _ N A M E _ G E T &gt;----------------------------

as an aid to internationalizing identifier-label wikilinks, gets identifier article names from Wikidata.

returns :&lt;lang code&gt;:&lt;article title&gt; when &lt;q&gt; has an &lt;article title&gt; for &lt;lang code&gt;; nil else

for identifiers that do not have q, returns nil

for wikis that do not have mw.wikibase installed, returns nil

]]

local function wikidata_article_name_get (q)
	if not is_set (q) or (q and not mw.wikibase) then							-- when no q number or when a q number but mw.wikibase not installed on this wiki
		return nil;																-- abandon
	end

	local wd_article;
	local this_wiki_code = cfg.this_wiki_code;									-- Wikipedia subdomain; 'en' for en.wikipedia.org

	wd_article = mw.wikibase.getSitelink (q, this_wiki_code .. 'wiki');			-- fetch article title from WD; nil when no title available at this wiki

	if wd_article then
		wd_article = table.concat ({':', this_wiki_code, ':', wd_article});		-- interwiki-style link without brackets if taken from WD; leading colon required
	end

	return wd_article;															-- article title from WD; nil else
end


--[[--------------------------&lt; L I N K _ L A B E L _ M A K E &gt;------------------------------------------------

common function to create identifier link label from handler table or from Wikidata

returns the first available of
	1. redirect from local wiki's handler table (if enabled)
	2. Wikidata (if there is a Wikidata entry for this identifier in the local wiki's language)
	3. label specified in the local wiki's handler table
	
]]

local function link_label_make (handler)
	local wd_article;
	
	if not (cfg.use_identifier_redirects and is_set (handler.redirect)) then	-- redirect has priority so if enabled and available don't fetch from Wikidata because expensive
		wd_article = wikidata_article_name_get (handler.q);						-- if Wikidata has an article title for this wiki, get it;
	end
	
	return (cfg.use_identifier_redirects and is_set (handler.redirect) and handler.redirect) or wd_article or handler.link;
end


--[[--------------------------&lt; E X T E R N A L _ L I N K _ I D &gt;----------------------------------------------

Formats a wiki-style external link

]]

local function external_link_id (options)
	local url_string = options.id;
	local ext_link;
	local this_wiki_code = cfg.this_wiki_code;									-- Wikipedia subdomain; 'en' for en.wikipedia.org
	local wd_article;															-- article title from Wikidata
	
	if options.encode == true or options.encode == nil then
		url_string = mw.uri.encode (url_string, 'PATH');
	end

	if options.auto_link and is_set (options.access) then
		auto_link_urls[options.auto_link] = table.concat ({options.prefix, url_string, options.suffix});
	end

	ext_link = mw.ustring.format ('[%s%s%s %s]', options.prefix, url_string, options.suffix or "", mw.text.nowiki (options.id));
	if is_set (options.access) then
		ext_link = substitute (cfg.presentation['ext-link-access-signal'], {cfg.presentation[options.access].class, cfg.presentation[options.access].title, ext_link});	-- add the free-to-read / paywall lock
	end

	return table.concat	({
		make_wikilink (link_label_make (options), options.label),				-- redirect, Wikidata link, or locally specified link (in that order)
		options.separator or '&amp;nbsp;',
		ext_link
		});
end


--[[--------------------------&lt; I N T E R N A L _ L I N K _ I D &gt;----------------------------------------------

Formats a wiki-style internal link

TODO: Does not currently need to support options.access, options.encode, auto-linking and COinS (as in external_link_id),
but may be needed in the future for :m:Interwiki_map custom-prefixes like :arxiv:, :bibcode:, :DOI:, :hdl:, :ISSN:,
:JSTOR:, :Openlibrary:, :PMID:, :RFC:.

]]

local function internal_link_id (options)
	local id = mw.ustring.gsub (options.id, '%d', cfg.date_names.local_digits);	-- translate 'local' digits to Western 0-9

	return table.concat (
		{
		make_wikilink (link_label_make (options), options.label),				-- wiki-link the identifier label
		options.separator or '&amp;nbsp;',											-- add the separator
		make_wikilink (
			table.concat (
				{
				options.prefix,
				id,																-- translated to Western digits
				options.suffix or ''
				}),
			substitute (cfg.presentation['bdi'], {'', mw.text.nowiki (options.id)})	-- bdi tags to prevent Latin script identifiers from being reversed at RTL language wikis
			);																	-- nowiki because MediaWiki still has magic links for ISBN and the like; TODO: is it really required?
		});
end


--[[--------------------------&lt; I S _ E M B A R G O E D &gt;------------------------------------------------------

Determines if a PMC identifier's online version is embargoed. Compares the date in |pmc-embargo-date= against
today's date.  If embargo date is in the future, returns the content of |pmc-embargo-date=; otherwise, returns
an empty string because the embargo has expired or because |pmc-embargo-date= was not set in this cite.

]]

local function is_embargoed (embargo)
	if is_set (embargo) then
		local lang = mw.getContentLanguage();
		local good1, embargo_date, todays_date;
		good1, embargo_date = pcall (lang.formatDate, lang, 'U', embargo);
		todays_date = lang:formatDate ('U');
	
		if good1 then															-- if embargo date is a good date
			if tonumber (embargo_date) &gt;= tonumber (todays_date) then			-- is embargo date is in the future?
				return embargo;													-- still embargoed
			else
				set_message ('maint_pmc_embargo');								-- embargo has expired; add main cat
				return '';														-- unset because embargo has expired
			end
		end
	end
	return '';																	-- |pmc-embargo-date= not set return empty string
end


--[=[-------------------------&lt; I S _ V A L I D _ R X I V _ D A T E &gt;------------------------------------------

for biorxiv, returns true if:
	2019-12-11T00:00Z &lt;= biorxiv_date &lt; today + 2 days
for medrxiv, returns true if:
	2020-01-01T00:00Z &lt;= medrxiv_date &lt; today + 2 days
	
The dated form of biorxiv identifier has a start date of 2019-12-11.  The Unix timestamp for that date is {{#time:U|2019-12-11}} = 1576022400
The medrxiv identifier has a start date of 2020-01-01.  The Unix timestamp for that date is {{#time:U|2020-01-01}} = 1577836800

&lt;rxiv_date&gt; is the date provided in those |biorxiv= parameter values that are dated and in |medrxiv= parameter values at time 00:00:00 UTC
&lt;today&gt; is the current date at time 00:00:00 UTC plus 48 hours
	if today's date is 2023-01-01T00:00:00 then
		adding 24 hours gives 2023-01-02T00:00:00 – one second more than today
		adding 24 hours gives 2023-01-03T00:00:00 – one second more than tomorrow

inputs:
	&lt;y&gt;, &lt;m&gt;, &lt;d&gt; – year, month, day parts of the date from the birxiv or medrxiv identifier
	&lt;select&gt; 'b' for biorxiv, 'm' for medrxiv; defaults to 'b'

]=]

local function is_valid_rxiv_date (y, m, d, select)
	if 0 == tonumber (m) and 12 &lt; tonumber (m) then								-- &lt;m&gt; must be a number 1–12
		return false;
	end
	if 0 == tonumber (d) and 31 &lt; tonumber (d) then								-- &lt;d&gt; must be a number 1–31; TODO: account for month length and leap yer?
		return false;
	end
	
	local rxiv_date = table.concat ({y, m, d}, '-');							-- make ymd date string
	local good1, good2;
	local rxiv_ts, tomorrow_ts;													-- to hold Unix timestamps representing the dates
	local lang_object = mw.getContentLanguage();

	good1, rxiv_ts = pcall (lang_object.formatDate, lang_object, 'U', rxiv_date);		-- convert rxiv_date value to Unix timestamp 
	good2, tomorrow_ts = pcall (lang_object.formatDate, lang_object, 'U', 'today + 2 days' );	-- today midnight + 2 days is one second more than all day tomorrow
	
	if good1 and good2 then														-- lang.formatDate() returns a timestamp in the local script which tonumber() may not understand
		rxiv_ts = tonumber (rxiv_ts) or lang_object:parseFormattedNumber (rxiv_ts);	-- convert to numbers for the comparison;
		tomorrow_ts = tonumber (tomorrow_ts) or lang_object:parseFormattedNumber (tomorrow_ts);
	else
		return false;															-- one or both failed to convert to Unix timestamp
	end

	local limit_ts = ((select and ('m' == select)) and 1577836800) or 1576022400;	-- choose the appropriate limit timesatmp

	return ((limit_ts &lt;= rxiv_ts) and (rxiv_ts &lt; tomorrow_ts))					-- limit_ts &lt;= rxiv_date &lt; tomorrow's date
end


--[[--------------------------&lt; IS _ V A L I D _ I S X N &gt;-----------------------------------------------------

ISBN-10 and ISSN validator code calculates checksum across all ISBN/ISSN digits including the check digit.
ISBN-13 is checked in isbn().

If the number is valid the result will be 0. Before calling this function, ISBN/ISSN must be checked for length
and stripped of dashes, spaces and other non-ISxN characters.

]]

local function is_valid_isxn (isxn_str, len)
	local temp = 0;
	isxn_str = { isxn_str:byte(1, len) };										-- make a table of byte values '0' → 0x30 .. '9' → 0x39, 'X' → 0x58
	len = len + 1;																-- adjust to be a loop counter
	for i, v in ipairs (isxn_str) do											-- loop through all of the bytes and calculate the checksum
		if v == string.byte ("X" ) then											-- if checkdigit is X (compares the byte value of 'X' which is 0x58)
			temp = temp + 10 * (len - i);										-- it represents 10 decimal
		else
			temp = temp + tonumber (string.char (v) )*(len-i);
		end
	end
	return temp % 11 == 0;														-- returns true if calculation result is zero
end


--[[--------------------------&lt; IS _ V A L I D _ I S X N _ 1 3 &gt;-----------------------------------------------

ISBN-13 and ISMN validator code calculates checksum across all 13 ISBN/ISMN digits including the check digit.
If the number is valid, the result will be 0. Before calling this function, ISBN-13/ISMN must be checked for length
and stripped of dashes, spaces and other non-ISxN-13 characters.

]]

local function is_valid_isxn_13 (isxn_str)
	local temp=0;
	
	isxn_str = { isxn_str:byte(1, 13) };										-- make a table of byte values '0' → 0x30 .. '9' → 0x39
	for i, v in ipairs (isxn_str) do
		temp = temp + (3 - 2*(i % 2)) * tonumber (string.char (v) );			-- multiply odd index digits by 1, even index digits by 3 and sum; includes check digit
	end
	return temp % 10 == 0;														-- sum modulo 10 is zero when ISBN-13/ISMN is correct
end


--[[--------------------------&lt; N O R M A L I Z E _ L C C N &gt;--------------------------------------------------

LCCN normalization (https://www.loc.gov/marc/lccn-namespace.html#normalization)
1. Remove all blanks.
2. If there is a forward slash (/) in the string, remove it, and remove all characters to the right of the forward slash.
3. If there is a hyphen in the string:
	a. Remove it.
	b. Inspect the substring following (to the right of) the (removed) hyphen. Then (and assuming that steps 1 and 2 have been carried out):
		1. All these characters should be digits, and there should be six or less. (not done in this function)
		2. If the length of the substring is less than 6, left-fill the substring with zeroes until the length is six.

Returns a normalized LCCN for lccn() to validate.  There is no error checking (step 3.b.1) performed in this function.

]]

local function normalize_lccn (lccn)
	lccn = lccn:gsub ("%s", "");												-- 1. strip whitespace

	if nil ~= string.find (lccn, '/') then
		lccn = lccn:match ("(.-)/");											-- 2. remove forward slash and all character to the right of it
	end

	local prefix
	local suffix
	prefix, suffix = lccn:match ("(.+)%-(.+)");									-- 3.a remove hyphen by splitting the string into prefix and suffix

	if nil ~= suffix then														-- if there was a hyphen
		suffix = string.rep("0", 6-string.len (suffix)) .. suffix;				-- 3.b.2 left fill the suffix with 0s if suffix length less than 6
		lccn = prefix..suffix;													-- reassemble the LCCN
	end
	
	return lccn;
end


--============================&lt;&lt; I D E N T I F I E R   F U N C T I O N S &gt;&gt;====================================

--[[--------------------------&lt; A R X I V &gt;--------------------------------------------------------------------

See: https://arxiv.org/help/arxiv_identifier

format and error check arXiv identifier.  There are three valid forms of the identifier:
the first form, valid only between date codes 9107 and 0703, is:
	arXiv:&lt;archive&gt;.&lt;class&gt;/&lt;date code&gt;&lt;number&gt;&lt;version&gt;
where:
	&lt;archive&gt; is a string of alpha characters - may be hyphenated; no other punctuation
	&lt;class&gt; is a string of alpha characters - may be hyphenated; no other punctuation; not the same as |class= parameter which is not supported in this form
	&lt;date code&gt; is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01
		first digit of YY for this form can only 9 and 0
	&lt;number&gt; is a three-digit number
	&lt;version&gt; is a 1 or more digit number preceded with a lowercase v; no spaces (undocumented)
	
the second form, valid from April 2007 through December 2014 is:
	arXiv:&lt;date code&gt;.&lt;number&gt;&lt;version&gt;
where:
	&lt;date code&gt; is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01
	&lt;number&gt; is a four-digit number
	&lt;version&gt; is a 1 or more digit number preceded with a lowercase v; no spaces

the third form, valid from January 2015 is:
	arXiv:&lt;date code&gt;.&lt;number&gt;&lt;version&gt;
where:
	&lt;date code&gt; and &lt;version&gt; are as defined for 0704-1412
	&lt;number&gt; is a five-digit number

]]

local function arxiv (options)
	local id = options.id;
	local class = options.Class;												-- TODO: lowercase?
	local handler = options.handler;
	local year, month, version;
	local err_msg = false;														-- assume no error message
	local text;																	-- output text
	
	if id:match("^%a[%a%.%-]+/[90]%d[01]%d%d%d%d$") or id:match("^%a[%a%.%-]+/[90]%d[01]%d%d%d%dv%d+$") then	-- test for the 9107-0703 format with or without version
		year, month = id:match("^%a[%a%.%-]+/([90]%d)([01]%d)%d%d%d[v%d]*$");
		year = tonumber (year);
		month = tonumber (month);
		if ((not (90 &lt; year or 8 &gt; year)) or (1 &gt; month or 12 &lt; month)) or		-- if invalid year or invalid month
			((91 == year and 7 &gt; month) or (7 == year and 3 &lt; month)) then		-- if years ok, are starting and ending months ok?
				err_msg = true;													-- flag for error message
		end

	elseif id:match("^%d%d[01]%d%.%d%d%d%d$") or id:match("^%d%d[01]%d%.%d%d%d%dv%d+$") then	-- test for the 0704-1412 with or without version
		year, month = id:match("^(%d%d)([01]%d)%.%d%d%d%d[v%d]*$");
		year = tonumber (year);
		month = tonumber (month);
		if ((7 &gt; year) or (14 &lt; year) or (1 &gt; month or 12 &lt; month)) or			-- is year invalid or is month invalid? (doesn't test for future years)
			((7 == year) and (4 &gt; month)) then									-- when year is 07, is month invalid (before April)?
				err_msg = true;													-- flag for error message
		end

	elseif id:match("^%d%d[01]%d%.%d%d%d%d%d$") or id:match("^%d%d[01]%d%.%d%d%d%d%dv%d+$") then	-- test for the 1501- format with or without version
		year, month = id:match("^(%d%d)([01]%d)%.%d%d%d%d%d[v%d]*$");
		year = tonumber (year);
		month = tonumber (month);
		if ((15 &gt; year) or (1 &gt; month or 12 &lt; month)) then						-- is year invalid or is month invalid? (doesn't test for future years)
			err_msg = true;														-- flag for error message
		end

	else
		err_msg = true;															-- not a recognized format; flag for error message
	end

	if err_msg then
		options.coins_list_t['ARXIV'] = nil;									-- when error, unset so not included in COinS
	end
	
	local err_msg_t = {};
	if err_msg then
		set_message ('err_bad_arxiv');
	end

	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = handler.access});

	if is_set (class) then
		if id:match ('^%d+') then
			text = table.concat ({text, ' [[https://arxiv.org/archive/', class, ' ', class, ']]'});	-- external link within square brackets, not wikilink
		else
			set_message ('err_class_ignored');
		end
	end

	return text;
end


--[[--------------------------&lt; B I B C O D E &gt;--------------------------------------------------------------------

Validates (sort of) and formats a bibcode ID.

Format for bibcodes is specified here: https://adsabs.harvard.edu/abs_doc/help_pages/data.html#bibcodes

But, this: 2015arXiv151206696F is apparently valid so apparently, the only things that really matter are length, 19 characters
and first four digits must be a year.  This function makes these tests:
	length must be 19 characters
	characters in position
		1–4 must be digits and must represent a year in the range of 1000 – next year
		5 must be a letter
		6–8 must be letter, digit, ampersand, or dot (ampersand cannot directly precede a dot; &amp;. )
		9–18 must be letter, digit, or dot
		19 must be a letter or dot

]]

local function bibcode (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;
	local ignore_invalid = options.accept;
	local err_type;
	local err_msg = '';
	local year;

	local text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode,
		access = access});
	
	if 19 ~= id:len() then
		err_type = cfg.err_msg_supl.length;
	else
		year = id:match ("^(%d%d%d%d)[%a][%w&amp;%.][%w&amp;%.][%w&amp;%.][%w.]+[%a%.]$");
		if not year then														-- if nil then no pattern match
			err_type = cfg.err_msg_supl.value;									-- so value error
		else
			local next_year = tonumber (os.date ('%Y')) + 1;					-- get the current year as a number and add one for next year
			year = tonumber (year);												-- convert year portion of bibcode to a number
			if (1000 &gt; year) or (year &gt; next_year) then
				err_type = cfg.err_msg_supl.year;								-- year out of bounds
			end
			if id:find('&amp;%.') then
				err_type = cfg.err_msg_supl.journal;							-- journal abbreviation must not have '&amp;.' (if it does it's missing a letter)
			end
			if id:match ('.........%.tmp%.') then								-- temporary bibcodes when positions 10–14 are '.tmp.'
				set_message ('maint_bibcode');
			end
		end
	end

	if is_set (err_type) and not ignore_invalid then							-- if there was an error detected and accept-as-written markup not used
		set_message ('err_bad_bibcode', {err_type});
		options.coins_list_t['BIBCODE'] = nil;									-- when error, unset so not included in COinS
	end

	return text;
end


--[[--------------------------&lt; B I O R X I V &gt;-----------------------------------------------------------------

Format bioRxiv ID and do simple error checking.  Before 2019-12-11, biorXiv IDs were 10.1101/ followed by exactly
6 digits.  After 2019-12-11, biorXiv IDs retained the six-digit identifier but prefixed that with a yyyy.mm.dd. 
date and suffixed with an optional version identifier.

The bioRxiv ID is the string of characters:
	https://doi.org/10.1101/078733 -&gt; 10.1101/078733
or a date followed by a six-digit number followed by an optional version indicator 'v' and one or more digits:
	https://www.biorxiv.org/content/10.1101/2019.12.11.123456v2 -&gt; 10.1101/2019.12.11.123456v2
	
see https://www.biorxiv.org/about-biorxiv

]]

local function biorxiv (options)
	local id = options.id;
	local handler = options.handler;
	local err_msg = true;														-- flag; assume that there will be an error
	
	local patterns = {
		'^10%.1101/%d%d%d%d%d%d$',												-- simple 6-digit identifier (before 2019-12-11)
		'^10%.1101/(20%d%d)%.(%d%d)%.(%d%d)%.%d%d%d%d%d%dv%d+$',				-- y.m.d. date + 6-digit identifier + version (after 2019-12-11)
		'^10%.1101/(20%d%d)%.(%d%d)%.(%d%d)%.%d%d%d%d%d%d$',					-- y.m.d. date + 6-digit identifier (after 2019-12-11)
		}
	
	for _, pattern in ipairs (patterns) do										-- spin through the patterns looking for a match
		if id:match (pattern) then
			local y, m, d = id:match (pattern);									-- found a match, attempt to get year, month and date from the identifier

			if m then															-- m is nil when id is the six-digit form
				if not is_valid_rxiv_date (y, m, d, 'b') then					-- validate the encoded date; 'b' for biorxiv limit
					break;														-- date fail; break out early so we don't unset the error message
				end
			end
			err_msg = nil;														-- we found a match so unset the error message
			break;																-- and done
		end
	end																			-- err_cat remains set here when no match

	if err_msg then
		options.coins_list_t['BIORXIV'] = nil;									-- when error, unset so not included in COinS
		set_message ('err_bad_biorxiv');										-- and set the error message
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator,
			encode = handler.encode, access = handler.access});
end


--[[--------------------------&lt; C I T E S E E R X &gt;------------------------------------------------------------

CiteSeerX use their own notion of "doi" (not to be confused with the identifiers resolved via doi.org).

The description of the structure of this identifier can be found at Help_talk:Citation_Style_1/Archive_26#CiteSeerX_id_structure

]]

local function citeseerx (options)
	local id = options.id;
	local handler = options.handler;
	local matched;

	local text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode,
		access = handler.access});
	
	matched = id:match ("^10%.1%.1%.[1-9]%d?%d?%d?%.[1-9]%d?%d?%d?$");
	if not matched then
		set_message ('err_bad_citeseerx' );
		options.coins_list_t['CITESEERX'] = nil;								-- when error, unset so not included in COinS
	end

	return text;
end


--[[--------------------------&lt; D O I &gt;------------------------------------------------------------------------

Formats a DOI and checks for DOI errors.

DOI names contain two parts: prefix and suffix separated by a forward slash.
	Prefix: directory indicator '10.' followed by a registrant code
	Suffix: character string of any length chosen by the registrant

This function checks a DOI name for: prefix/suffix.  If the DOI name contains spaces or endashes, or, if it ends
with a period or a comma, this function will emit a bad_doi error message.

DOI names are case-insensitive and can incorporate any printable Unicode characters so the test for spaces, endash,
and terminal punctuation may not be technically correct but it appears, that in practice these characters are rarely
if ever used in DOI names.

https://www.doi.org/doi_handbook/2_Numbering.html				-- 2.2 Syntax of a DOI name
https://www.doi.org/doi_handbook/2_Numbering.html#2.2.2			-- 2.2.2 DOI prefix

]]

local function doi (options)
	local id = options.id;
	local inactive = options.DoiBroken
	local access = options.access;
	local ignore_invalid = options.accept;
	local handler = options.handler;
	local err_flag;

	local function is_extended_free (registrant, suffix)						-- local function to check those few registrants that are mixed; identifiable by the doi suffix &lt;incipit&gt;
		if cfg.extended_registrants_t[registrant] then							-- if this registrant has known free-to-read extentions
			for _, incipit in ipairs (cfg.extended_registrants_t[registrant]) do	-- loop through the registrant's incipits
				if mw.ustring.find (suffix, '^' .. incipit) then				-- if found
					return true;
				end
			end
		end
	end

	local text;
	if is_set (inactive) then
		local inactive_year = inactive:match("%d%d%d%d");						-- try to get the year portion from the inactive date
		local inactive_month, good;

		if is_set (inactive_year) then
			if 4 &lt; inactive:len() then											-- inactive date has more than just a year (could be anything)
				local lang_obj = mw.getContentLanguage();						-- get a language object for this wiki
				good, inactive_month = pcall (lang_obj.formatDate, lang_obj, 'F', inactive);	-- try to get the month name from the inactive date
				if not good then
					inactive_month = nil;										-- something went wrong so make sure this is unset
				end
			end
		end																		-- otherwise, |doi-broken-date= has something but it isn't a date
		
		if is_set (inactive_year) and is_set (inactive_month) then
			set_message ('maint_doi_inactive_dated', {inactive_year, inactive_month, ' '});
		elseif is_set (inactive_year) then
			set_message ('maint_doi_inactive_dated', {inactive_year, '', ''});
		else
			set_message ('maint_doi_inactive');
		end
		inactive = " (" .. cfg.messages['inactive'] .. ' ' .. inactive .. ')';
	end

	local suffix;
	local registrant, suffix = mw.ustring.match (id, '^10%.([^/]+)/([^%s–]-[^%.,])$');	-- registrant and suffix set when DOI has the proper basic form

	local registrant_err_patterns = {											-- these patterns are for code ranges that are not supported 
		'^[^1-3]%d%d%d%d%.%d+$',												-- 5 digits with subcode (0xxxx, 40000+); accepts: 10000–39999
		'^[^1-7]%d%d%d%d$',														-- 5 digits without subcode (0xxxx, 60000+); accepts: 10000–69999
		'^[^1-9]%d%d%d%.%d+$',												-- 4 digits with subcode (0xxx); accepts: 1000–9999
		'^[^1-9]%d%d%d$',														-- 4 digits without subcode (0xxx); accepts: 1000–9999
		'^%d%d%d%d%d%d+',														-- 6 or more digits
		'^%d%d?%d?$',															-- less than 4 digits without subcode (3 digits with subcode is legitimate)
		'^%d%d?%.[%d%.]+',														-- 1 or 2 digits with subcode
		'^5555$',																-- test registrant will never resolve
		'[^%d%.]',																-- any character that isn't a digit or a dot
		}

	if not ignore_invalid then
		if registrant then														-- when DOI has proper form
			for i, pattern in ipairs (registrant_err_patterns) do				-- spin through error patterns
				if registrant:match (pattern) then								-- to validate registrant codes
					err_flag = set_message ('err_bad_doi');						-- when found, mark this DOI as bad
					break;														-- and done
				end
			end
		else
			err_flag = set_message ('err_bad_doi');								-- invalid directory or malformed
		end
	else
		set_message ('maint_doi_ignore');
	end

	if err_flag then
		options.coins_list_t['DOI'] = nil;										-- when error, unset so not included in COinS
	else
		if not access and (cfg.known_free_doi_registrants_t[registrant] or is_extended_free (registrant, suffix)) then		-- |doi-access=free not set and &lt;registrant&gt; is known to be free
			set_message ('maint_doi_unflagged_free');							-- set a maint cat
		end
	end
	
	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = access,
		auto_link = not (err_flag or is_set (inactive) or ignore_invalid) and 'doi' or nil -- do not auto-link when |doi-broken-date= has a value or when there is a DOI error or (to play it safe, after all, auto-linking is not essential) when invalid DOIs are ignored
		}) .. (inactive or '');

	return text;
end


--[[--------------------------&lt; H D L &gt;------------------------------------------------------------------------

Formats an HDL with minor error checking.

HDL names contain two parts: prefix and suffix separated by a forward slash.
	Prefix: character string using any character in the UCS-2 character set except '/'
	Suffix: character string of any length using any character in the UCS-2 character set chosen by the registrant

This function checks a HDL name for: prefix/suffix.  If the HDL name contains spaces, endashes, or, if it ends
with a period or a comma, this function will emit a bad_hdl error message.

HDL names are case-insensitive and can incorporate any printable Unicode characters so the test for endashes and
terminal punctuation may not be technically correct but it appears, that in practice these characters are rarely
if ever used in HDLs.

Query string parameters are named here: https://www.handle.net/proxy_servlet.html.  query strings are not displayed
but since '?' is an allowed character in an HDL, '?' followed by one of the query parameters is the only way we
have to detect the query string so that it isn't URL-encoded with the rest of the identifier.

]]

local function hdl (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;
	local query_params = {														-- list of known query parameters from https://www.handle.net/proxy_servlet.html
		'noredirect',
		'ignore_aliases',
		'auth',
		'cert',
		'index',
		'type',
		'urlappend',
		'locatt',
		'action',
		}
	
	local hdl, suffix, param = id:match ('(.-)(%?(%a+).+)$');					-- look for query string
	local found;

	if hdl then																	-- when there are query strings, this is the handle identifier portion
		for _, q in ipairs (query_params) do									-- spin through the list of query parameters
			if param:match ('^' .. q) then										-- if the query string begins with one of the parameters
				found = true;													-- announce a find
				break;															-- and stop looking
			end
		end
	end

	if found then
		id = hdl;																-- found so replace id with the handle portion; this will be URL-encoded, suffix will not
	else
		suffix = '';															-- make sure suffix is empty string for concatenation else
	end

	local text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, suffix = suffix, separator = handler.separator, encode = handler.encode, access = access})

	if nil == id:match("^[^%s–]-/[^%s–]-[^%.,]$") then							-- HDL must contain a forward slash, must not contain spaces, endashes, and must not end with period or comma
		set_message ('err_bad_hdl' );
		options.coins_list_t['HDL'] = nil;										-- when error, unset so not included in COinS
	end

	return text;
end


--[[--------------------------&lt; I S B N &gt;----------------------------------------------------------------------

Determines whether an ISBN string is valid

]]

local function isbn (options_t)
	local isbn_str = options_t.id;
	local ignore_invalid = options_t.accept;
	local handler = options_t.handler;
	local year = options_t.Year;												-- when set, valid anchor_year; may have a disambiguator which must be removed

	local function return_result (check, err_type)								-- local function to handle the various returns
		local ISBN = internal_link_id ({link = handler.link, label = handler.label, redirect = handler.redirect,
						prefix = handler.prefix, id = isbn_str, separator = handler.separator});
		if ignore_invalid then													-- if ignoring ISBN errors
			set_message ('maint_isbn_ignore');									-- add a maint category even when there is no error
		else																	-- here when not ignoring
			if not check then													-- and there is an error
				options_t.coins_list_t['ISBN'] = nil;								-- when error, unset so not included in COinS
				set_message ('err_bad_isbn', err_type);							-- set an error message
				return ISBN;										 			-- return id text
			end
		end
		return ISBN;															-- return id text
	end

	if year and not ignore_invalid then											-- 
		year = year:match ('%d%d%d%d?');										-- strip disambiguator if present
		if year and (1965 &gt; tonumber(year)) then
			set_message ('err_invalid_isbn_date');								-- set an error message
			return internal_link_id ({link = handler.link, label = handler.label, redirect = handler.redirect,
					prefix = handler.prefix, id = isbn_str, separator = handler.separator});
		end
	end

	if nil ~= isbn_str:match ('[^%s-0-9X]') then
		return return_result (false, cfg.err_msg_supl.char);					-- fail if isbn_str contains anything but digits, hyphens, or the uppercase X
	end

	local id = isbn_str:gsub ('[%s-]', '');										-- remove hyphens and whitespace

	local len = id:len();
 
	if len ~= 10 and len ~= 13 then
		return return_result (false, cfg.err_msg_supl.length);					-- fail if incorrect length
	end

	if len == 10 then
		if id:match ('^%d*X?$') == nil then										-- fail if isbn_str has 'X' anywhere but last position
			return return_result (false, cfg.err_msg_supl.form);									
		end
		if not is_valid_isxn (id, 10) then										-- test isbn-10 for numerical validity
			return return_result (false, cfg.err_msg_supl.check);				-- fail if isbn-10 is not numerically valid
		end
		if id:find ('^63[01]') then												-- 630xxxxxxx and 631xxxxxxx are (apparently) not valid isbn group ids but are used by amazon as numeric identifiers (asin)
			return return_result (false, cfg.err_msg_supl.group);				-- fail if isbn-10 begins with 630/1
		end
		return return_result (true, cfg.err_msg_supl.check);					-- pass if isbn-10 is numerically valid
	else
		if id:match ('^%d+$') == nil then
			return return_result (false, cfg.err_msg_supl.char);				-- fail if ISBN-13 is not all digits
		end
		if id:match ('^97[89]%d*$') == nil then
			return return_result (false, cfg.err_msg_supl.prefix);				-- fail when ISBN-13 does not begin with 978 or 979
		end
		if id:match ('^9790') then
			return return_result (false, cfg.err_msg_supl.group);				-- group identifier '0' is reserved to ISMN
		end
		return return_result (is_valid_isxn_13 (id), cfg.err_msg_supl.check);
	end
end


--[[--------------------------&lt; A S I N &gt;----------------------------------------------------------------------

Formats a link to Amazon.  Do simple error checking: ASIN must be mix of 10 numeric or uppercase alpha
characters.  If a mix, first character must be uppercase alpha; if all numeric, ASINs must be 10-digit
ISBN. If 10-digit ISBN, add a maintenance category so a bot or AWB script can replace |asin= with |isbn=.
Error message if not 10 characters, if not ISBN-10, if mixed and first character is a digit.

|asin=630....... and |asin=631....... are (apparently) not a legitimate ISBN though it checksums as one; these
do not cause this function to emit the maint_asin message

This function is positioned here because it calls isbn()

]]

local function asin (options)
	local id = options.id;
	local domain = options.ASINTLD;
	
	local err_flag;

	if not id:match("^[%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u]$") then
		err_flag = set_message ('err_bad_asin');								-- ASIN is not a mix of 10 uppercase alpha and numeric characters
	else
		if id:match("^%d%d%d%d%d%d%d%d%d[%dX]$") then							-- if 10-digit numeric (or 9 digits with terminal X)
			if is_valid_isxn (id, 10) then										-- see if ASIN value is or validates as ISBN-10
				if not id:find ('^63[01]') then									-- 630xxxxxxx and 631xxxxxxx are (apparently) not a valid isbn prefixes but are used by amazon as a numeric identifier
					err_flag = set_message ('err_bad_asin');					-- ASIN has ISBN-10 form but begins with something other than 630/1 so probably an isbn 
				end
			elseif not is_set (err_flag) then
				err_flag = set_message ('err_bad_asin');						-- ASIN is not ISBN-10
			end
		elseif not id:match("^%u[%d%u]+$") then
			err_flag = set_message ('err_bad_asin');							-- asin doesn't begin with uppercase alpha
		end
	end
	if (not is_set (domain)) or in_array (domain, {'us'}) then					-- default: United States
		domain = "com";
	elseif in_array (domain, {'jp', 'uk'}) then									-- Japan, United Kingdom
		domain = "co." .. domain;
	elseif in_array (domain, {'z.cn'}) then 									-- China
		domain = "cn";
	elseif in_array (domain, {'au', 'br', 'mx', 'sg', 'tr'}) then				-- Australia, Brazil, Mexico, Singapore, Turkey
		domain = "com." .. domain;
	elseif not in_array (domain, {'ae', 'ca', 'cn', 'de', 'es', 'fr', 'in', 'it', 'nl', 'pl', 'sa', 'se', 'co.jp', 'co.uk', 'com', 'com.au', 'com.br', 'com.mx', 'com.sg', 'com.tr'}) then -- Arabic Emirates, Canada, China, Germany, Spain, France, Indonesia, Italy, Netherlands, Poland, Saudi Arabia, Sweden (as of 2021-03 Austria (.at), Liechtenstein (.li) and Switzerland (.ch) still redirect to the German site (.de) with special settings, so don't maintain local ASINs for them)
		err_flag = set_message ('err_bad_asin_tld');							-- unsupported asin-tld value
	end
	local handler = options.handler;

	if not is_set (err_flag) then
		options.coins_list_t['ASIN'] = handler.prefix .. domain .. "/dp/" .. id;	-- asin for coins
	else
		options.coins_list_t['ASIN'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix .. domain .. "/dp/",
		id = id, encode = handler.encode, separator = handler.separator})
end


--[[--------------------------&lt; I S M N &gt;----------------------------------------------------------------------

Determines whether an ISMN string is valid.  Similar to ISBN-13, ISMN is 13 digits beginning 979-0-... and uses the
same check digit calculations.  See https://www.ismn-international.org/download/Web_ISMN_Users_Manual_2008-6.pdf
section 2, pages 9–12.

ismn value not made part of COinS metadata because we don't have a url or isn't a COinS-defined identifier (rft.xxx)
or an identifier registered at info-uri.info (info:)

]]

local function ismn (options)
	local id = options.id;
	local handler = options.handler;
	local text;
	local valid_ismn = true;
	local id_copy;

	id_copy = id;																-- save a copy because this testing is destructive
	id = id:gsub ('[%s-]', '');													-- remove hyphens and white space

	if 13 ~= id:len() or id:match ("^9790%d*$" ) == nil then					-- ISMN must be 13 digits and begin with 9790
		valid_ismn = false;
	else
		valid_ismn=is_valid_isxn_13 (id);										-- validate ISMN
	end

	--	text = internal_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,		-- use this (or external version) when there is some place to link to
	--		prefix = handler.prefix, id = id_copy, separator = handler.separator, encode = handler.encode})

	text = table.concat (														-- because no place to link to yet
		{
		make_wikilink (link_label_make (handler), handler.label),
		handler.separator,
		id_copy
		});

	if false == valid_ismn then
		options.coins_list_t['ISMN'] = nil;										-- when error, unset so not included in COinS; not really necessary here because ismn not made part of COinS
		set_message ('err_bad_ismn');											-- create an error message if the ISMN is invalid
	end 
	
	return text;
end


--[[--------------------------&lt; I S S N &gt;----------------------------------------------------------------------

Validate and format an ISSN.  This code fixes the case where an editor has included an ISSN in the citation but
has separated the two groups of four digits with a space.  When that condition occurred, the resulting link looked
like this:

	|issn=0819 4327 gives: [https://www.worldcat.org/issn/0819 4327 0819 4327]	-- can't have spaces in an external link
	
This code now prevents that by inserting a hyphen at the ISSN midpoint.  It also validates the ISSN for length
and makes sure that the checkdigit agrees with the calculated value.  Incorrect length (8 digits), characters
other than 0-9 and X, or checkdigit / calculated value mismatch will all cause a check ISSN error message.  The
ISSN is always displayed with a hyphen, even if the ISSN was given as a single group of 8 digits.

]]

local function issn (options)
	local id = options.id;
	local handler = options.handler;
	local ignore_invalid = options.accept;

	local issn_copy = id;														-- save a copy of unadulterated ISSN; use this version for display if ISSN does not validate
	local text;
	local valid_issn = true;

	id = id:gsub ('[%s-]', '');													-- remove hyphens and whitespace

	if 8 ~= id:len() or nil == id:match ("^%d*X?$" ) then						-- validate the ISSN: 8 digits long, containing only 0-9 or X in the last position
		valid_issn = false;														-- wrong length or improper character
	else
		valid_issn = is_valid_isxn (id, 8);										-- validate ISSN
	end

	if true == valid_issn then
		id = string.sub (id, 1, 4 ) .. "-" .. string.sub (id, 5 );				-- if valid, display correctly formatted version
	else
		id = issn_copy;															-- if not valid, show the invalid ISSN with error message
	end

	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode})

	if ignore_invalid then
		set_message ('maint_issn_ignore');
	else
		if false == valid_issn then
			options.coins_list_t['ISSN'] = nil;									-- when error, unset so not included in COinS
			set_message ('err_bad_issn', (options.hkey == 'EISSN') and 'e' or '');	-- create an error message if the ISSN is invalid
		end 
	end
	
	return text;
end


--[[--------------------------&lt; J F M &gt;-----------------------------------------------------------------------

A numerical identifier in the form nn.nnnn.nn

]]

local function jfm (options)
	local id = options.id;
	local handler = options.handler;
	local id_num;

	id_num = id:match ('^[Jj][Ff][Mm](.*)$');									-- identifier with jfm prefix; extract identifier

	if is_set (id_num) then
		set_message ('maint_jfm_format');
	else																		-- plain number without JFM prefix
		id_num = id;															-- if here id does not have prefix
	end

	if id_num and id_num:match('^%d%d%.%d%d%d%d%.%d%d$') then
		id = id_num;															-- jfm matches pattern
	else
		set_message ('err_bad_jfm' );											-- set an error message
		options.coins_list_t['JFM'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; J S T O R &gt;--------------------------------------------------------------------

Format a JSTOR with some error checking

]]

local function jstor (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;

	if id:find ('[Jj][Ss][Tt][Oo][Rr]') or id:find ('^https?://') or id:find ('%s') then
		set_message ('err_bad_jstor');											-- set an error message
		options.coins_list_t['JSTOR'] = nil;									-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = access});
end


--[[--------------------------&lt; L C C N &gt;----------------------------------------------------------------------

Format LCCN link and do simple error checking.  LCCN is a character string 8-12 characters long. The length of
the LCCN dictates the character type of the first 1-3 characters; the rightmost eight are always digits.
https://oclc-research.github.io/infoURI-Frozen/info-uri.info/info:lccn/reg.html

length = 8 then all digits
length = 9 then lccn[1] is lowercase alpha
length = 10 then lccn[1] and lccn[2] are both lowercase alpha or both digits
length = 11 then lccn[1] is lower case alpha, lccn[2] and lccn[3] are both lowercase alpha or both digits
length = 12 then lccn[1] and lccn[2] are both lowercase alpha

]]

local function lccn (options)
	local lccn = options.id;
	local handler = options.handler;
	local err_flag;																-- presume that LCCN is valid
	local id = lccn;															-- local copy of the LCCN

	id = normalize_lccn (id);													-- get canonical form (no whitespace, hyphens, forward slashes)
	local len = id:len();														-- get the length of the LCCN

	if 8 == len then
		if id:match("[^%d]") then												-- if LCCN has anything but digits (nil if only digits)
			err_flag = set_message ('err_bad_lccn');							-- set an error message
		end
	elseif 9 == len then														-- LCCN should be adddddddd
		if nil == id:match("%l%d%d%d%d%d%d%d%d") then							-- does it match our pattern?
			err_flag = set_message ('err_bad_lccn');							-- set an error message
		end
	elseif 10 == len then														-- LCCN should be aadddddddd or dddddddddd
		if id:match("[^%d]") then												-- if LCCN has anything but digits (nil if only digits) ...
			if nil == id:match("^%l%l%d%d%d%d%d%d%d%d") then					-- ... see if it matches our pattern
				err_flag = set_message ('err_bad_lccn');						-- no match, set an error message
			end
		end
	elseif 11 == len then														-- LCCN should be aaadddddddd or adddddddddd
		if not (id:match("^%l%l%l%d%d%d%d%d%d%d%d") or id:match("^%l%d%d%d%d%d%d%d%d%d%d")) then	-- see if it matches one of our patterns
			err_flag = set_message ('err_bad_lccn');							-- no match, set an error message
		end
	elseif 12 == len then														-- LCCN should be aadddddddddd
		if not id:match("^%l%l%d%d%d%d%d%d%d%d%d%d") then						-- see if it matches our pattern
			err_flag = set_message ('err_bad_lccn');							-- no match, set an error message
		end
	else
		err_flag = set_message ('err_bad_lccn');								-- wrong length, set an error message
	end

	if not is_set (err_flag) and nil ~= lccn:find ('%s') then
		err_flag = set_message ('err_bad_lccn');								-- lccn contains a space, set an error message
	end

	if is_set (err_flag) then
		options.coins_list_t['LCCN'] = nil;										-- when error, unset so not included in COinS
	end

	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = lccn, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; M E D R X I V &gt;-----------------------------------------------------------------

Format medRxiv ID and do simple error checking.  Similar to later bioRxiv IDs, medRxiv IDs are prefixed with a
yyyy.mm.dd. date and suffixed with an optional version identifier.  Ealiest date accepted is 2020.01.01

The medRxiv ID is a date followed by an eight-digit number followed by an optional version indicator 'v' and one or more digits:
	https://www.medrxiv.org/content/10.1101/2020.11.16.20232009v2 -&gt; 10.1101/2020.11.16.20232009v2

]]

local function medrxiv (options)
	local id = options.id;
	local handler = options.handler;
	local err_msg_flag = true;													-- flag; assume that there will be an error

	local patterns = {
		'%d%d%d%d%d%d%d%d$',													-- simple 8-digit identifier; these should be relatively rare
		'^10%.1101/(20%d%d)%.(%d%d)%.(%d%d)%.%d%d%d%d%d%d%d%dv%d+$',			-- y.m.d. date + 8-digit identifier + version (2020-01-01 and later)
		'^10%.1101/(20%d%d)%.(%d%d)%.(%d%d)%.%d%d%d%d%d%d%d%d$',				-- y.m.d. date + 8-digit identifier (2020-01-01 and later)
		}
	
	for _, pattern in ipairs (patterns) do										-- spin through the patterns looking for a match
		if id:match (pattern) then
			local y, m, d = id:match (pattern);									-- found a match, attempt to get year, month and date from the identifier

			if m then															-- m is nil when id is the 8-digit form
				if not is_valid_rxiv_date (y, m, d, 'b') then					-- validate the encoded date; 'b' for medrxiv limit
					break;														-- date fail; break out early so we don't unset the error message
				end
			end
			err_msg_flag = nil;													-- we found a match so unset the error message
			break;																-- and done
		end
	end																			-- &lt;err_msg_flag&gt; remains set here when no match

	if err_msg_flag then
		options.coins_list_t['MEDRXIV'] = nil;									-- when error, unset so not included in COinS
		set_message ('err_bad_medrxiv');										-- and set the error message
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator,
			encode = handler.encode, access = handler.access});
end


--[[--------------------------&lt; M R &gt;--------------------------------------------------------------------------

A seven digit number; if not seven digits, zero-fill leading digits to make seven digits.

]]

local function mr (options)
	local id = options.id;
	local handler = options.handler;
	local id_num;
	local id_len;

	id_num = id:match ('^[Mm][Rr](%d+)$');										-- identifier with mr prefix

	if is_set (id_num) then
		set_message ('maint_mr_format');										-- add maint cat
	else																		-- plain number without mr prefix
		id_num = id:match ('^%d+$');											-- if here id is all digits
	end

	id_len = id_num and id_num:len() or 0;
	if (7 &gt;= id_len) and (0 ~= id_len) then
		id = string.rep ('0', 7-id_len) .. id_num;								-- zero-fill leading digits
	else
		set_message ('err_bad_mr');												-- set an error message
		options.coins_list_t['MR'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; O C L C &gt;----------------------------------------------------------------------

Validate and format an OCLC ID.  https://www.oclc.org/batchload/controlnumber.en.html {{dead link}}
archived at: https://web.archive.org/web/20161228233804/https://www.oclc.org/batchload/controlnumber.en.html

]]

local function oclc (options)
	local id = options.id;
	local handler = options.handler;
	local number;

	if id:match('^ocm%d%d%d%d%d%d%d%d$') then									-- ocm prefix and 8 digits; 001 field (12 characters)
		number = id:match('ocm(%d+)');											-- get the number
	elseif id:match('^ocn%d%d%d%d%d%d%d%d%d$') then								-- ocn prefix and 9 digits; 001 field (12 characters)
		number = id:match('ocn(%d+)');											-- get the number
	elseif id:match('^on%d%d%d%d%d%d%d%d%d%d+$') then							-- on prefix and 10 or more digits; 001 field (12 characters)
		number = id:match('^on(%d%d%d%d%d%d%d%d%d%d+)$');						-- get the number
	elseif id:match('^%(OCoLC%)[1-9]%d*$') then									-- (OCoLC) prefix and variable number digits; no leading zeros; 035 field
		number = id:match('%(OCoLC%)([1-9]%d*)');								-- get the number
		if 9 &lt; number:len() then
			number = nil;														-- constrain to 1 to 9 digits; change this when OCLC issues 10-digit numbers
		end
	elseif id:match('^%d+$') then												-- no prefix
		number = id;															-- get the number
		if tonumber (id) &gt; handler.id_limit then
			number = nil;														-- unset when id value exceeds the limit
		end
	end

	if number then																-- proper format
		id = number;															-- exclude prefix, if any, from external link
	else
		set_message ('err_bad_oclc')											-- add an error message if the id is malformed
		options.coins_list_t['OCLC'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; O P E N L I B R A R Y &gt;--------------------------------------------------------

Formats an OpenLibrary link, and checks for associated errors.

]]

local function openlibrary (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;
	local ident, code = id:gsub('^OL', ''):match("^(%d+([AMW]))$");				-- strip optional OL prefix followed immediately by digits followed by 'A', 'M', or 'W';
	local err_flag;
	local prefix = {															-- these are appended to the handler.prefix according to code
		['A']='authors/OL',
		['M']='books/OL',
		['W']='works/OL',
		['X']='OL'																-- not a code; spoof when 'code' in id is invalid
		};

	if not ident then
		code = 'X';																-- no code or id completely invalid
		ident = id;																-- copy id to ident so that we display the flawed identifier
		err_flag = set_message ('err_bad_ol');
	end

	if not is_set (err_flag) then
		options.coins_list_t['OL'] = handler.prefix .. prefix[code] .. ident;	-- experiment for ol coins
	else
		options.coins_list_t['OL'] = nil;										-- when error, unset so not included in COinS
	end

	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix .. prefix[code],
		id = ident, separator = handler.separator, encode = handler.encode,
		access = access});
end


--[[--------------------------&lt; O S T I &gt;----------------------------------------------------------------------

Format OSTI and do simple error checking. OSTIs are sequential numbers beginning at 1 and counting up.  This
code checks the OSTI to see that it contains only digits and is less than test_limit specified in the configuration;
the value in test_limit will need to be updated periodically as more OSTIs are issued.

NB. 1018 is the lowest OSTI number found in the wild (so far) and resolving OK on the OSTI site

]]

local function osti (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;

	if id:match("[^%d]") then													-- if OSTI has anything but digits
		set_message ('err_bad_osti');											-- set an error message
		options.coins_list_t['OSTI'] = nil;										-- when error, unset so not included in COinS
	else																		-- OSTI is only digits
		local id_num = tonumber (id);											-- convert id to a number for range testing
		if 1018 &gt; id_num or handler.id_limit &lt; id_num then						-- if OSTI is outside test limit boundaries
			set_message ('err_bad_osti');										-- set an error message
			options.coins_list_t['OSTI'] = nil;									-- when error, unset so not included in COinS
		end
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = access});
end


--[[--------------------------&lt; P M C &gt;------------------------------------------------------------------------

Format a PMC, do simple error checking, and check for embargoed articles.

The embargo parameter takes a date for a value. If the embargo date is in the future the PMC identifier will not
be linked to the article.  If the embargo date is today or in the past, or if it is empty or omitted, then the
PMC identifier is linked to the article through the link at cfg.id_handlers['PMC'].prefix.

PMC embargo date testing is done in function is_embargoed () which is called earlier because when the citation
has |pmc=&lt;value&gt; but does not have a |url= then |title= is linked with the PMC link.  Function is_embargoed ()
returns the embargo date if the PMC article is still embargoed, otherwise it returns an empty string.

PMCs are sequential numbers beginning at 1 and counting up.  This code checks the PMC to see that it contains only digits and is less
than test_limit; the value in local variable test_limit will need to be updated periodically as more PMCs are issued.

]]

local function pmc (options)
	local id = options.id;
	local embargo = options.Embargo;											-- TODO: lowercase?
	local handler = options.handler;
	local err_flag;
	local id_num;
	local text;

	id_num = id:match ('^[Pp][Mm][Cc](%d+)$');									-- identifier with PMC prefix

	if is_set (id_num) then
		set_message ('maint_pmc_format');
	else																		-- plain number without PMC prefix
		id_num = id:match ('^%d+$');											-- if here id is all digits
	end

	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber (id_num);												-- convert id_num to a number for range testing
		if 1 &gt; id_num or handler.id_limit &lt; id_num then							-- if PMC is outside test limit boundaries
			err_flag = set_message ('err_bad_pmc');								-- set an error message
		else
			id = tostring (id_num);												-- make sure id is a string
		end
	else																		-- when id format incorrect
		err_flag = set_message ('err_bad_pmc');									-- set an error message
	end
	
	if is_set (embargo) and is_set (is_embargoed (embargo)) then				-- is PMC is still embargoed?
		text = table.concat (													-- still embargoed so no external link
			{
			make_wikilink (link_label_make (handler), handler.label),
			handler.separator,
			id,
			});
	else
		text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,	-- no embargo date or embargo has expired, ok to link to article
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = handler.access,
			auto_link = not err_flag and 'pmc' or nil							-- do not auto-link when PMC has error
			});
	end

	if err_flag then
		options.coins_list_t['PMC'] = nil;										-- when error, unset so not included in COinS
	end

	return text;
end


--[[--------------------------&lt; P M I D &gt;----------------------------------------------------------------------

Format PMID and do simple error checking.  PMIDs are sequential numbers beginning at 1 and counting up.  This
code checks the PMID to see that it contains only digits and is less than test_limit; the value in local variable
test_limit will need to be updated periodically as more PMIDs are issued.

]]

local function pmid (options)
	local id = options.id;
	local handler = options.handler;

	if id:match("[^%d]") then													-- if PMID has anything but digits
		set_message ('err_bad_pmid');											-- set an error message
		options.coins_list_t['PMID'] = nil;										-- when error, unset so not included in COinS
	else																		-- PMID is only digits
		local id_num = tonumber (id);											-- convert id to a number for range testing
		if 1 &gt; id_num or handler.id_limit &lt; id_num then							-- if PMID is outside test limit boundaries
			set_message ('err_bad_pmid');										-- set an error message
			options.coins_list_t['PMID'] = nil;									-- when error, unset so not included in COinS
		end
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; R F C &gt;------------------------------------------------------------------------

Format RFC and do simple error checking. RFCs are sequential numbers beginning at 1 and counting up.  This
code checks the RFC to see that it contains only digits and is less than test_limit specified in the configuration;
the value in test_limit will need to be updated periodically as more RFCs are issued.

An index of all RFCs is here: https://tools.ietf.org/rfc/

]]

local function rfc (options)
	local id = options.id;
	local handler = options.handler;

	if id:match("[^%d]") then													-- if RFC has anything but digits
		set_message ('err_bad_rfc');											-- set an error message
		options.coins_list_t['RFC'] = nil;										-- when error, unset so not included in COinS
	else																		-- RFC is only digits
		local id_num = tonumber (id);											-- convert id to a number for range testing
		if 1 &gt; id_num or handler.id_limit &lt; id_num then							-- if RFC is outside test limit boundaries
			set_message ('err_bad_rfc');										-- set an error message
			options.coins_list_t['RFC'] = nil;									-- when error, unset so not included in COinS
		end
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = handler.access});
end


--[[--------------------------&lt; S 2 C I D &gt;--------------------------------------------------------------------

Format an S2CID, do simple error checking

S2CIDs are sequential numbers beginning at 1 and counting up.  This code checks the S2CID to see that it is only
digits and is less than test_limit; the value in local variable test_limit will need to be updated periodically
as more S2CIDs are issued.

]]

local function s2cid (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;
	local id_num;
	local text;
	
	id_num = id:match ('^[1-9]%d*$');											-- id must be all digits; must not begin with 0; no open access flag

 	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber (id_num);												-- convert id_num to a number for range testing
		if handler.id_limit &lt; id_num then										-- if S2CID is outside test limit boundaries
			set_message ('err_bad_s2cid');										-- set an error message
			options.coins_list_t['S2CID'] = nil;								-- when error, unset so not included in COinS
		end
	else																		-- when id format incorrect
		set_message ('err_bad_s2cid');											-- set an error message
		options.coins_list_t['S2CID'] = nil;									-- when error, unset so not included in COinS
	end

	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = access});

	return text;
end


--[[--------------------------&lt; S B N &gt;------------------------------------------------------------------------

9-digit form of ISBN-10; uses same check-digit validation when SBN is prefixed with an additional '0' to make 10 digits

sbn value not made part of COinS metadata because we don't have a url or isn't a COinS-defined identifier (rft.xxx)
or an identifier registered at info-uri.info (info:)

]]

local function sbn (options)
	local id = options.id;
	local ignore_invalid = options.accept;
	local handler = options.handler;
	local function return_result (check, err_type)								-- local function to handle the various returns
		local SBN = internal_link_id ({link = handler.link, label = handler.label, redirect = handler.redirect,
						prefix = handler.prefix, id = id, separator = handler.separator});
		if not ignore_invalid then												-- if not ignoring SBN errors
			if not check then
				options.coins_list_t['SBN'] = nil;								-- when error, unset so not included in COinS; not really necessary here because sbn not made part of COinS
				set_message ('err_bad_sbn', {err_type});						-- display an error message
				return SBN; 
			end
		else
			set_message ('maint_isbn_ignore');									-- add a maint category even when there is no error (ToDo: Possibly switch to separate message for SBNs only)
		end
		return SBN;
	end

	if id:match ('[^%s-0-9X]') then
		return return_result (false, cfg.err_msg_supl.char);					-- fail if SBN contains anything but digits, hyphens, or the uppercase X
	end

	local ident = id:gsub ('[%s-]', '');										-- remove hyphens and whitespace; they interfere with the rest of the tests

	if  9 ~= ident:len() then
		return return_result (false, cfg.err_msg_supl.length);					-- fail if incorrect length
	end

	if ident:match ('^%d*X?$') == nil then
		return return_result (false, cfg.err_msg_supl.form);					-- fail if SBN has 'X' anywhere but last position
	end

	return return_result (is_valid_isxn ('0' .. ident, 10), cfg.err_msg_supl.check);
end


--[[--------------------------&lt; S S R N &gt;----------------------------------------------------------------------

Format an SSRN, do simple error checking

SSRNs are sequential numbers beginning at 100? and counting up.  This code checks the SSRN to see that it is
only digits and is greater than 99 and less than test_limit; the value in local variable test_limit will need
to be updated periodically as more SSRNs are issued.

]]

local function ssrn (options)
	local id = options.id;
	local handler = options.handler;
	local id_num;
	local text;
	
	id_num = id:match ('^%d+$');												-- id must be all digits

	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber (id_num);												-- convert id_num to a number for range testing
		if 100 &gt; id_num or handler.id_limit &lt; id_num then						-- if SSRN is outside test limit boundaries
			set_message ('err_bad_ssrn');										-- set an error message
			options.coins_list_t['SSRN'] = nil;									-- when error, unset so not included in COinS
		end
	else																		-- when id format incorrect
		set_message ('err_bad_ssrn');											-- set an error message
		options.coins_list_t['SSRN'] = nil;										-- when error, unset so not included in COinS
	end
	
	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = options.access});

	return text;
end


--[[--------------------------&lt; U S E N E T _ I D &gt;------------------------------------------------------------

Validate and format a usenet message id.  Simple error checking, looks for 'id-left@id-right' not enclosed in
'&lt;' and/or '&gt;' angle brackets.

]]

local function usenet_id (options)
	local id = options.id;
	local handler = options.handler;

	local text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode})
 
	if not id:match('^.+@.+$') or not id:match('^[^&lt;].*[^&gt;]$') then				-- doesn't have '@' or has one or first or last character is '&lt; or '&gt;'
		set_message ('err_bad_usenet_id')										-- add an error message if the message id is invalid
		options.coins_list_t['USENETID'] = nil;									-- when error, unset so not included in COinS
	end 
	
	return text;
end


--[[--------------------------&lt; Z B L &gt;-----------------------------------------------------------------------

A numerical identifier in the form nnnn.nnnnn - leading zeros in the first quartet optional

format described here: http://emis.mi.sanu.ac.rs/ZMATH/zmath/en/help/search/

temporary format is apparently eight digits.  Anything else is an error

]]

local function zbl (options)
	local id = options.id;
	local handler = options.handler;

	if id:match('^%d%d%d%d%d%d%d%d$') then										-- is this identifier using temporary format?
		set_message ('maint_zbl');												-- yes, add maint cat
	elseif not id:match('^%d?%d?%d?%d%.%d%d%d%d%d$') then						-- not temporary, is it normal format?
		set_message ('err_bad_zbl');											-- no, set an error message
		options.coins_list_t['ZBL'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--============================&lt;&lt; I N T E R F A C E   F U N C T I O N S &gt;&gt;==========================================

--[[--------------------------&lt; E X T R A C T _ I D S &gt;------------------------------------------------------------

Populates ID table from arguments using configuration settings. Loops through cfg.id_handlers and searches args for
any of the parameters listed in each cfg.id_handlers['...'].parameters.  If found, adds the parameter and value to
the identifier list.  Emits redundant error message if more than one alias exists in args

]]

local function extract_ids (args)
	local id_list = {};															-- list of identifiers found in args
	for k, v in pairs (cfg.id_handlers) do										-- k is uppercase identifier name as index to cfg.id_handlers; e.g. cfg.id_handlers['ISBN'], v is a table
		v = select_one (args, v.parameters, 'err_redundant_parameters' );		-- v.parameters is a table of aliases for k; here we pick one from args if present
		if is_set (v) then id_list[k] = v; end									-- if found in args, add identifier to our list
	end
	return id_list;
end


--[[--------------------------&lt; E X T R A C T _ I D _ A C C E S S _ L E V E L S &gt;--------------------------------------

Fetches custom id access levels from arguments using configuration settings. Parameters which have a predefined access
level (e.g. arxiv) do not use this function as they are directly rendered as free without using an additional parameter.

returns a table of k/v pairs where k is same as the identifier's key in cfg.id_handlers and v is the assigned (valid) keyword

access-level values must match the case used in cfg.keywords_lists['id-access'] (lowercase unless there is some special reason for something else)

]]

local function extract_id_access_levels (args, id_list)
	local id_accesses_list = {};
	for k, v in pairs (cfg.id_handlers) do
		local access_param = v.custom_access;									-- name of identifier's access-level parameter
		if is_set (access_param) then
			local access_level = args[access_param];							-- get the assigned value if there is one
			if is_set (access_level) then
				if not in_array (access_level, cfg.keywords_lists['id-access']) then	-- exact match required
					set_message ('err_invalid_param_val', {access_param, access_level});	
					access_level = nil;											-- invalid so unset
				end
				if not is_set (id_list[k]) then									-- identifier access-level must have a matching identifier
					set_message ('err_param_access_requires_param', {k:lower()});	-- parameter name is uppercase in cfg.id_handlers (k); lowercase for error message
				end
				id_accesses_list[k] = cfg.keywords_xlate[access_level];			-- get translated keyword
			end
		end
	end
	return id_accesses_list;
end


--[[--------------------------&lt; B U I L D _ I D _ L I S T &gt;----------------------------------------------------

render the identifiers into a sorted sequence table

&lt;ID_list_coins_t&gt; is a table of k/v pairs where k is same as key in cfg.id_handlers and v is the assigned value
&lt;options_t&gt; is a table of various k/v option pairs provided in the call to new_build_id_list();
	modified by	this function and passed to all identifier rendering functions
&lt;access_levels_t&gt; is a table of k/v pairs where k is same as key in cfg.id_handlers and v is the assigned value (if valid)

returns a sequence table of sorted (by hkey - 'handler' key) rendered identifier strings

]]

local function build_id_list (ID_list_coins_t, options_t, access_levels_t)
	local ID_list_t = {};
	local accept;
	local func_map = {															--function map points to functions associated with hkey identifier
		['ARXIV'] = arxiv,
		['ASIN'] = asin,
		['BIBCODE'] = bibcode,
		['BIORXIV'] = biorxiv,
		['CITESEERX'] = citeseerx,
		['DOI'] = doi,
		['EISSN'] = issn,
		['HDL'] = hdl,
		['ISBN'] = isbn,
		['ISMN'] = ismn,
		['ISSN'] = issn,
		['JFM'] = jfm,
		['JSTOR'] = jstor,
		['LCCN'] = lccn,
		['MEDRXIV'] = medrxiv,
		['MR'] = mr,
		['OCLC'] = oclc,
		['OL'] = openlibrary,
		['OSTI'] = osti,
		['PMC'] = pmc,
		['PMID'] = pmid,
		['RFC']  = rfc,
		['S2CID'] = s2cid,
		['SBN'] = sbn,
		['SSRN'] = ssrn,
		['USENETID'] = usenet_id,
		['ZBL'] = zbl,
		}

	for hkey, v in pairs (ID_list_coins_t) do
		v, accept = has_accept_as_written (v);									-- remove accept-as-written markup if present; accept is boolean true when markup removed; false else
																				-- every function gets the options table with value v and accept boolean
		options_t.hkey = hkey;													-- ~/Configuration handler key
		options_t.id = v;														-- add that identifier value to the options table
		options_t.accept = accept;												-- add the accept boolean flag
		options_t.access = access_levels_t[hkey];								-- add the access level for those that have an |&lt;identifier-access= parameter
		options_t.handler = cfg.id_handlers[hkey];
		options_t.coins_list_t = ID_list_coins_t;								-- pointer to ID_list_coins_t; for |asin= and |ol=; also to keep erroneous values out of the citation's metadata
		options_t.coins_list_t[hkey] = v;										-- id value without accept-as-written markup for metadata
		
		if options_t.handler.access and not in_array (options_t.handler.access, cfg.keywords_lists['id-access']) then
			error (cfg.messages['unknown_ID_access'] .. options_t.handler.access);	-- here when handler access key set to a value not listed in list of allowed id access keywords
		end

		if func_map[hkey] then
			local id_text = func_map[hkey] (options_t);							-- call the function to get identifier text and any error message
			table.insert (ID_list_t, {hkey, id_text});							-- add identifier text to the output sequence table
		else
			error (cfg.messages['unknown_ID_key'] .. hkey);						-- here when func_map doesn't have a function for hkey
		end
	end

	local function comp (a, b)													-- used by following table.sort()
		return a[1]:lower() &lt; b[1]:lower();										-- sort by hkey
	end

	table.sort (ID_list_t, comp);												-- sequence table of tables sort	
	for k, v in ipairs (ID_list_t) do											-- convert sequence table of tables to simple sequence table of strings
		ID_list_t[k] = v[2];													-- v[2] is the identifier rendering from the call to the various functions in func_map{}
	end
	
	return ID_list_t;
end


--[[--------------------------&lt; O P T I O N S _ C H E C K &gt;----------------------------------------------------

check that certain option parameters have their associated identifier parameters with values

&lt;ID_list_coins_t&gt; is a table of k/v pairs where k is same as key in cfg.id_handlers and v is the assigned value
&lt;ID_support_t&gt; is a sequence table of tables created in citation0() where each subtable has four elements:
	[1] is the support parameter's assigned value; empty string if not set
	[2] is a text string same as key in cfg.id_handlers
	[3] is cfg.error_conditions key used to create error message
	[4] is original ID support parameter name used to create error message
	
returns nothing; on error emits an appropriate error message

]]

local function options_check (ID_list_coins_t, ID_support_t)
	for _, v in ipairs (ID_support_t) do
		if is_set (v[1]) and not ID_list_coins_t[v[2]] then						-- when support parameter has a value but matching identifier parameter is missing or empty
			set_message (v[3], (v[4]));											-- emit the appropriate error message
		end
	end
end


--[[--------------------------&lt; I D E N T I F I E R _ L I S T S _ G E T &gt;--------------------------------------

Creates two identifier lists: a k/v table of identifiers and their values to be used locally and for use in the
COinS metadata, and a sequence table of the rendered identifier strings that will be included in the rendered
citation.

]]

local function identifier_lists_get (args_t, options_t, ID_support_t)
	local ID_list_coins_t = extract_ids (args_t);										-- get a table of identifiers and their values for use locally and for use in COinS
	options_check (ID_list_coins_t, ID_support_t);										-- ID support parameters must have matching identifier parameters 
	local ID_access_levels_t = extract_id_access_levels (args_t, ID_list_coins_t);		-- get a table of identifier access levels
	local ID_list_t = build_id_list (ID_list_coins_t, options_t, ID_access_levels_t);	-- get a sequence table of rendered identifier strings

	return ID_list_t, ID_list_coins_t;											-- return the tables
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table and imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	cfg = cfg_table_ptr;

	has_accept_as_written = utilities_page_ptr.has_accept_as_written;			-- import functions from select Module:Citation/CS1/Utilities module
	is_set = utilities_page_ptr.is_set;								
	in_array = utilities_page_ptr.in_array;
	set_message = utilities_page_ptr.set_message;
	select_one = utilities_page_ptr.select_one;
	substitute = utilities_page_ptr.substitute;
	make_wikilink = utilities_page_ptr.make_wikilink;

	z = utilities_page_ptr.z;													-- table of tables in Module:Citation/CS1/Utilities
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	auto_link_urls = auto_link_urls,											-- table of identifier URLs to be used when auto-linking |title=
	
	identifier_lists_get = identifier_lists_get,								-- experiment to replace individual calls to build_id_list(), extract_ids, extract_id_access_levels
	is_embargoed = is_embargoed;
	set_selected_modules = set_selected_modules;
	}</text>
      <sha1>k1dr68mpitw4fjf8xuqkl74nhwowac7</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/COinS</title>
    <ns>828</ns>
    <id>29</id>
    <revision>
      <id>46</id>
      <parentid>45</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>45</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="16743" sha1="2eba9cn0u4yseyeujt1vmrglxrgcllo" xml:space="preserve">--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local has_accept_as_written, is_set, in_array, remove_wiki_link, strip_apostrophe_markup;	-- functions in Module:Citation/CS1/Utilities

local cfg;																		-- table of configuration tables that are defined in Module:Citation/CS1/Configuration


--[[--------------------------&lt; M A K E _ C O I N S _ T I T L E &gt;----------------------------------------------

Makes a title for COinS from Title and / or ScriptTitle (or any other name-script pairs)

Apostrophe markup (bold, italics) is stripped from each value so that the COinS metadata isn't corrupted with strings
of %27%27...

]]

local function make_coins_title (title, script)
	title = has_accept_as_written (title);
	if is_set (title) then
		title = strip_apostrophe_markup (title);								-- strip any apostrophe markup
	else
		title = '';																-- if not set, make sure title is an empty string
	end
	if is_set (script) then
		script = script:gsub ('^%l%l%s*:%s*', '');								-- remove language prefix if present (script value may now be empty string)
		script = strip_apostrophe_markup (script);								-- strip any apostrophe markup
	else
		script = '';															-- if not set, make sure script is an empty string
	end
	if is_set (title) and is_set (script) then
		script = ' ' .. script;													-- add a space before we concatenate
	end
	return title .. script;														-- return the concatenation
end


--[[--------------------------&lt; E S C A P E _ L U A _ M A G I C _ C H A R S &gt;----------------------------------

Returns a string where all of Lua's magic characters have been escaped.  This is important because functions like
string.gsub() treat their pattern and replace strings as patterns, not literal strings.
]]

local function escape_lua_magic_chars (argument)
	argument = argument:gsub("%%", "%%%%");										-- replace % with %%
	argument = argument:gsub("([%^%$%(%)%.%[%]%*%+%-%?])", "%%%1");				-- replace all other Lua magic pattern characters
	return argument;
end


--[[--------------------------&lt; G E T _ C O I N S _ P A G E S &gt;------------------------------------------------

Extract page numbers from external wikilinks in any of the |page=, |pages=, or |at= parameters for use in COinS.

]]

local function get_coins_pages (pages)
	local pattern;
	if not is_set (pages) then return pages; end								-- if no page numbers then we're done
	
	while true do
		pattern = pages:match("%[(%w*:?//[^ ]+%s+)[%w%d].*%]");					-- pattern is the opening bracket, the URL and following space(s): "[url "
		if nil == pattern then break; end										-- no more URLs
		pattern = escape_lua_magic_chars (pattern);								-- pattern is not a literal string; escape Lua's magic pattern characters
		pages = pages:gsub(pattern, "");										-- remove as many instances of pattern as possible
	end
	
	pages = pages:gsub("[%[%]]", "");											-- remove the brackets
	pages = pages:gsub("–", "-" );												-- replace endashes with hyphens
	pages = pages:gsub("&amp;%w+;", "-" );											-- and replace HTML entities (&amp;ndash; etc.) with hyphens; do we need to replace numerical entities like &amp;#32; and the like?
	pages = pages:gsub ('%b&lt;&gt;', '');											-- remove html-like tags; spans are added to &lt;Pages&gt; by utilities.hyphen_to_dash() which should not appear in COinS metadata
	return pages;
end


--[=[-------------------------&lt; C O I N S _ R E P L A C E _ M A T H _ S T R I P M A R K E R &gt;------------------

There are three options for math markup rendering that depend on the editor's math preference settings.  These
settings are at [[Special:Preferences#mw-prefsection-rendering]] and are
	PNG images
	TeX source
	MathML with SVG or PNG fallback

All three are heavy with HTML and CSS which doesn't belong in the metadata.

Without this function, the metadata saved in the raw wikitext contained the rendering determined by the settings
of the last editor to save the page.

This function gets the rendered form of an equation according to the editor's preference before the page is saved.  It
then searches the rendering for the text equivalent of the rendered equation and replaces the rendering with that so
that the page is saved without extraneous HTML/CSS markup and with a reasonably readable text form of the equation.

When a replacement is made, this function returns true and the value with replacement; otherwise false and the initial
value.  To replace multipe equations it is necessary to call this function from within a loop.

]=]

local function coins_replace_math_stripmarker (value)
	local stripmarker = cfg.stripmarkers['math'];
	local rendering = value:match (stripmarker);								-- is there a math stripmarker

	if not rendering then														-- when value doesn't have a math stripmarker, abandon this test
		return false, value;
	end
	
	rendering = mw.text.unstripNoWiki (rendering);								-- convert stripmarker into rendered value (or nil? ''? when math render error)
	
	if rendering:match ('alt="[^"]+"') then										-- if PNG math option
		rendering = rendering:match ('alt="([^"]+)"');							-- extract just the math text
	elseif rendering:match ('$%s+.+%s+%$') then									-- if TeX math option; $ is legit character that is escapes as \$
		rendering = rendering:match ('$%s+(.+)%s+%$')							-- extract just the math text
	elseif rendering:match ('&lt;annotation[^&gt;]+&gt;.+&lt;/annotation&gt;') then			-- if MathML math option
		rendering = rendering:match ('&lt;annotation[^&gt;]+&gt;(.+)&lt;/annotation&gt;')		-- extract just the math text
	else
		return false, value;													-- had math stripmarker but not one of the three defined forms
	end
	
	return true, value:gsub (stripmarker, rendering, 1);
end


--[[--------------------------&lt; C O I N S _ C L E A N U P &gt;----------------------------------------------------

Cleanup parameter values for the metadata by removing or replacing invisible characters and certain HTML entities.

2015-12-10: there is a bug in mw.text.unstripNoWiki ().  It replaces math stripmarkers with the appropriate content
when it shouldn't.  See https://phabricator.wikimedia.org/T121085 and Wikipedia_talk:Lua#stripmarkers_and_mw.text.unstripNoWiki.28.29

TODO: move the replacement patterns and replacement values into a table in /Configuration similar to the invisible
characters table?

]]

local function coins_cleanup (value)
	local replaced = true;														-- default state to get the do loop running

	while replaced do															-- loop until all math stripmarkers replaced
		replaced, value = coins_replace_math_stripmarker (value);				-- replace math stripmarker with text representation of the equation
	end

	value = value:gsub (cfg.stripmarkers['math'], "MATH RENDER ERROR");			-- one or more couldn't be replaced; insert vague error message
	
	value = mw.text.unstripNoWiki (value);										-- replace nowiki stripmarkers with their content
	value = value:gsub ('&lt;span class="nowrap" style="padding%-left:0%.1em;"&gt;&amp;#39;(s?)&lt;/span&gt;', "'%1");	-- replace {{'}} or {{'s}} with simple apostrophe or apostrophe-s
	value = value:gsub ('&amp;nbsp;', ' ');											-- replace &amp;nbsp; entity with plain space
	value = value:gsub ('\226\128\138', ' ');									-- replace hair space with plain space
	if not mw.ustring.find (value, cfg.indic_script) then						-- don't remove zero-width joiner characters from indic script
		value = value:gsub ('&amp;zwj;', '');										-- remove &amp;zwj; entities
		value = mw.ustring.gsub (value, '[\226\128\141\226\128\139\194\173]', '');	-- remove zero-width joiner, zero-width space, soft hyphen
	end
	value = value:gsub ('[\009\010\013 ]+', ' ');								-- replace horizontal tab, line feed, carriage return with plain space
	return value;
end


--[[--------------------------&lt; C O I N S &gt;--------------------------------------------------------------------

COinS metadata (see &lt;http://ocoins.info/&gt;) allows automated tools to parse the citation information.

]]

local function COinS(data, class)
	if 'table' ~= type(data) or nil == next(data) then
		return '';
	end

	for k, v in pairs (data) do													-- spin through all of the metadata parameter values
		if 'ID_list' ~= k and 'Authors' ~= k then								-- except the ID_list and Author tables (author nowiki stripmarker done when Author table processed)
			data[k] = coins_cleanup (v);
		end
	end

	local ctx_ver = "Z39.88-2004";
	
	-- treat table strictly as an array with only set values.
	local OCinSoutput = setmetatable( {}, {
		__newindex = function(self, key, value)
			if is_set(value) then
				rawset( self, #self+1, table.concat{ key, '=', mw.uri.encode( remove_wiki_link( value ) ) } );
			end
		end
	});
	
	if in_array (class, {'arxiv', 'biorxiv', 'citeseerx', 'medrxiv', 'ssrn', 'journal', 'news', 'magazine'}) or
		(in_array (class, {'conference', 'interview', 'map', 'press release', 'web'}) and is_set(data.Periodical)) or
		('citation' == class and is_set(data.Periodical) and not is_set (data.Encyclopedia)) then
			OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:journal";			-- journal metadata identifier
			if in_array (class, {'arxiv', 'biorxiv', 'citeseerx', 'medrxiv', 'ssrn'}) then	-- set genre according to the type of citation template we are rendering
				OCinSoutput["rft.genre"] = "preprint";							-- cite arxiv, cite biorxiv, cite citeseerx, cite medrxiv, cite ssrn
			elseif 'conference' == class then
				OCinSoutput["rft.genre"] = "conference";						-- cite conference (when Periodical set)
			elseif 'web' == class then
				OCinSoutput["rft.genre"] = "unknown";							-- cite web (when Periodical set)
			else
				OCinSoutput["rft.genre"] = "article";							-- journal and other 'periodical' articles
			end
			OCinSoutput["rft.jtitle"] = data.Periodical;						-- journal only
			OCinSoutput["rft.atitle"] = data.Title;								-- 'periodical' article titles

																				-- these used only for periodicals
			OCinSoutput["rft.ssn"] = data.Season;								-- keywords: winter, spring, summer, fall
			OCinSoutput["rft.quarter"] = data.Quarter;							-- single digits 1-&gt;first quarter, etc.
			OCinSoutput["rft.chron"] = data.Chron;								-- free-form date components
			OCinSoutput["rft.volume"] = data.Volume;							-- does not apply to books
			OCinSoutput["rft.issue"] = data.Issue;
			OCinSoutput['rft.artnum'] = data.ArticleNumber;						-- {{cite journal}} only
			OCinSoutput["rft.pages"] = data.Pages;								-- also used in book metadata

	elseif 'thesis' ~= class then												-- all others except cite thesis are treated as 'book' metadata; genre distinguishes
		OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:book";					-- book metadata identifier
		if 'report' == class or 'techreport' == class then						-- cite report and cite techreport
			OCinSoutput["rft.genre"] = "report";
		elseif 'conference' == class then										-- cite conference when Periodical not set
			OCinSoutput["rft.genre"] = "conference";
			OCinSoutput["rft.atitle"] = data.Chapter;							-- conference paper as chapter in proceedings (book)
		elseif in_array (class, {'book', 'citation', 'encyclopaedia', 'interview', 'map'}) then
			if is_set (data.Chapter) then
				OCinSoutput["rft.genre"] = "bookitem";
				OCinSoutput["rft.atitle"] = data.Chapter;						-- book chapter, encyclopedia article, interview in a book, or map title
			else
				if 'map' == class or 'interview' == class then
					OCinSoutput["rft.genre"] = 'unknown';						-- standalone map or interview
				else
					OCinSoutput["rft.genre"] = 'book';							-- book and encyclopedia
				end
			end
		else	-- {'audio-visual', 'AV-media-notes', 'DVD-notes', 'episode', 'interview', 'mailinglist', 'map', 'newsgroup', 'podcast', 'press release', 'serial', 'sign', 'speech', 'web'}
			OCinSoutput["rft.genre"] = "unknown";
		end
		OCinSoutput["rft.btitle"] = data.Title;									-- book only
		OCinSoutput["rft.place"] = data.PublicationPlace;						-- book only
		OCinSoutput["rft.series"] = data.Series;								-- book only
		OCinSoutput["rft.pages"] = data.Pages;									-- book, journal
		OCinSoutput["rft.edition"] = data.Edition;								-- book only
		OCinSoutput["rft.pub"] = data.PublisherName;							-- book and dissertation
		
	else																		-- cite thesis
		OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:dissertation";			-- dissertation metadata identifier
		OCinSoutput["rft.title"] = data.Title;									-- dissertation (also patent but that is not yet supported)
		OCinSoutput["rft.degree"] = data.Degree;								-- dissertation only
		OCinSoutput['rft.inst'] = data.PublisherName;							-- book and dissertation
	end
	-- NB. Not currently supported are "info:ofi/fmt:kev:mtx:patent", "info:ofi/fmt:kev:mtx:dc", "info:ofi/fmt:kev:mtx:sch_svc", "info:ofi/fmt:kev:mtx:ctx"
																				-- and now common parameters (as much as possible)
	OCinSoutput["rft.date"] = data.Date;										-- book, journal, dissertation

	for k, v in pairs( data.ID_list ) do										-- what to do about these? For now assume that they are common to all?
		if k == 'ISBN' then v = v:gsub( "[^-0-9X]", "" ); end
		local id = cfg.id_handlers[k].COinS;
		if string.sub( id or "", 1, 4 ) == 'info' then							-- for ids that are in the info:registry
			OCinSoutput["rft_id"] = table.concat{ id, "/", v };
		elseif string.sub (id or "", 1, 3 ) == 'rft' then						-- for isbn, issn, eissn, etc. that have defined COinS keywords
			OCinSoutput[ id ] = v;
		elseif 'url' == id then													-- for urls that are assembled in ~/Identifiers; |asin= and |ol=
			OCinSoutput["rft_id"] = table.concat ({data.ID_list[k], "#id-name=", cfg.id_handlers[k].label});
		elseif id then															-- when cfg.id_handlers[k].COinS is not nil so urls created here
			OCinSoutput["rft_id"] = table.concat{ cfg.id_handlers[k].prefix, v, cfg.id_handlers[k].suffix or '', "#id-name=", cfg.id_handlers[k].label };	-- others; provide a URL and indicate identifier name as #fragment (human-readable, but transparent to browsers)
		end
	end

	local last, first;
	for k, v in ipairs( data.Authors ) do
		last, first = coins_cleanup (v.last), coins_cleanup (v.first or '');	-- replace any nowiki stripmarkers, non-printing or invisible characters
		if k == 1 then															-- for the first author name only
			if is_set(last) and is_set(first) then								-- set these COinS values if |first= and |last= specify the first author name
				OCinSoutput["rft.aulast"] = last;								-- book, journal, dissertation
				OCinSoutput["rft.aufirst"] = first;								-- book, journal, dissertation
			elseif is_set(last) then 
				OCinSoutput["rft.au"] = last;									-- book, journal, dissertation -- otherwise use this form for the first name
			end
		else																	-- for all other authors
			if is_set(last) and is_set(first) then
				OCinSoutput["rft.au"] = table.concat{ last, ", ", first };		-- book, journal, dissertation
			elseif is_set(last) then
				OCinSoutput["rft.au"] = last;									-- book, journal, dissertation
			end
			-- TODO: At present we do not report "et al.". Add anything special if this condition applies?
		end
	end

	OCinSoutput.rft_id = data.URL;
	OCinSoutput.rfr_id = table.concat{ "info:sid/", mw.site.server:match( "[^/]*$" ), ":", data.RawPage };

	-- TODO: Add optional extra info:
	-- rfr_dat=#REVISION&lt;version&gt; (referrer private data)
	-- ctx_id=&lt;data.RawPage&gt;#&lt;ref&gt; (identifier for the context object)
	-- ctx_tim=&lt;ts&gt; (timestamp in format yyyy-mm-ddThh:mm:ssTZD or yyyy-mm-dd)
	-- ctx_enc=info:ofi/enc:UTF-8 (character encoding)
	
	OCinSoutput = setmetatable( OCinSoutput, nil );

	-- sort with version string always first, and combine.
	-- table.sort( OCinSoutput );
	table.insert( OCinSoutput, 1, "ctx_ver=" .. ctx_ver ); -- such as "Z39.88-2004"
	return table.concat(OCinSoutput, "&amp;");
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table and imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	cfg = cfg_table_ptr;

	has_accept_as_written = utilities_page_ptr.has_accept_as_written;			-- import functions from selected Module:Citation/CS1/Utilities module
	is_set = utilities_page_ptr.is_set;
	in_array = utilities_page_ptr.in_array;
	remove_wiki_link = utilities_page_ptr.remove_wiki_link;
	strip_apostrophe_markup = utilities_page_ptr.strip_apostrophe_markup;
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	make_coins_title = make_coins_title,
	get_coins_pages = get_coins_pages,
	COinS = COinS,
	set_selected_modules = set_selected_modules,
	}</text>
      <sha1>2eba9cn0u4yseyeujt1vmrglxrgcllo</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/styles.css</title>
    <ns>828</ns>
    <id>30</id>
    <revision>
      <id>48</id>
      <parentid>47</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>47</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="4194" sha1="4vx8grkh20viq5i9qf98wumgw6uva7x" xml:space="preserve">/* Protection icon
the following line controls the page-protection icon in the upper right corner
it must remain within this comment
	{{sandbox other||{{pp-template}}}}

*/

/* Overrides
Some wikis do not override user agent default styles for HTML &lt;cite&gt; and &lt;q&gt;,
unlike en.wp. On en.wp, keep these the same as [[MediaWiki:Common.css]].

The word-wrap and :target styles were moved here from Common.css.
On en.wp, keep these the same as [[Template:Citation/styles.css]].
*/
cite.citation {
	font-style: inherit; /* Remove italics for &lt;cite&gt; */
	/* Break long urls, etc., rather than overflowing box */
	word-wrap: break-word;
}

.citation q {
	quotes: '"' '"' "'" "'"; /* Straight quote marks for &lt;q&gt; */
}

/* Highlight linked elements (such as clicked references) in blue */
.citation:target {
	/* ignore the linter - all browsers of interest implement this */
	background-color: rgba(0, 127, 255, 0.133);
}

/* ID and URL access
Both core and Common.css have selector .mw-parser-output a[href$=".pdf"].external
for PDF pages. All TemplateStyles pages are hoisted to .mw-parser-output. We need
to have specificity equal to a[href$=".pdf"].external for locks to override PDF icon.
That's essentially 2 classes and 1 element.

the .id-lock-... selectors are for use by non-citation templates like
{{Catalog lookup link}}

bg-size `contain` in Minerva and Timeless is too large, so we set a size for them
and then exclude them later
*/
.id-lock-free.id-lock-free a {
	background: url(//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg)
		right 0.1em center/9px no-repeat;
}

.id-lock-limited.id-lock-limited a,
.id-lock-registration.id-lock-registration a {
	background: url(//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg)
		right 0.1em center/9px no-repeat;
}

.id-lock-subscription.id-lock-subscription a {
	background: url(//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg)
		right 0.1em center/9px no-repeat;
}

/* Wikisource
Wikisource icon when |chapter= or |title= is wikilinked to Wikisource
as in cite wikisource
*/
.cs1-ws-icon a {
	background: url(//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg)
		right 0.1em center/12px no-repeat;
}

body:not(.skin-timeless):not(.skin-minerva) .id-lock-free a,
body:not(.skin-timeless):not(.skin-minerva) .id-lock-limited a,
body:not(.skin-timeless):not(.skin-minerva) .id-lock-registration a,
body:not(.skin-timeless):not(.skin-minerva) .id-lock-subscription a,
body:not(.skin-timeless):not(.skin-minerva) .cs1-ws-icon a {
	background-size: contain;
	/* Common.css has a padding set for PDF URLs. bg-contain expands to the
	 * size of the padding which makes the icons very large. we "reset" the
	 * padding here. 1em picked out of a hat based on console having a similar
	 * rule from elsewhere
	 */
	padding: 0 1em 0 0;
}

/* Errors and maintenance */
.cs1-code {
	/* &lt;code&gt;...&lt;/code&gt; style override: mediawiki's css definition is specified here:
	https://git.wikimedia.org/blob/mediawiki%2Fcore.git/
		69cd73811f7aadd093050dbf20ed70ef0b42a713/skins%2Fcommon%2FcommonElements.css#L199
	*/
	color: inherit;
	background: inherit;
	border: none;
	padding: inherit;
}

.cs1-hidden-error {
	display: none;
	color: var(--color-error, #d33);
}

.cs1-visible-error {
	color: var(--color-error, #d33);
}

.cs1-maint {
	display: none;
	color: #085;
	margin-left: 0.3em;
}

/* kerning */
.cs1-kern-left {
	padding-left: 0.2em;
}

.cs1-kern-right {
	padding-right: 0.2em;
}

/* selflinks – avoid bold font style when cs1|2 template links to the current page */
.citation .mw-selflink {
	font-weight: inherit;
}

@media screen {
	/* Small text size
	Set small text size in one place. 0.95 (here) * 0.9 (from references list) is
	~0.85, which is the lower bound for size for accessibility. Old styling for this
	was just 0.85. We could write the rule so that when this template is inside
	references/reflist, only then does it multiply by 0.95; else multiply by 0.85 */
	.cs1-format {
		font-size: 95%;
	}
	
	html.skin-theme-clientpref-night .cs1-maint {
		color: #18911f;
	}
}

@media screen and (prefers-color-scheme: dark) {
	html.skin-theme-clientpref-os .cs1-maint {
		color: #18911f;
	}
}</text>
      <sha1>4vx8grkh20viq5i9qf98wumgw6uva7x</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Main other</title>
    <ns>10</ns>
    <id>31</id>
    <revision>
      <id>50</id>
      <parentid>49</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>49</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="422" sha1="fqcj40f1ojeitvtz4m2eefrp1ymhi6o" xml:space="preserve">{{#switch:
  &lt;!--If no or empty "demospace" parameter then detect namespace--&gt;
  {{#if:{{{demospace|}}} 
  | {{lc: {{{demospace}}} }}    &lt;!--Use lower case "demospace"--&gt;
  | {{#ifeq:{{NAMESPACE}}|{{ns:0}}
    | main
    | other
    }} 
  }}
| main     = {{{1|}}}
| other
| #default = {{{2|}}}
}}&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories to the /doc subpage; interwikis go to Wikidata, thank you! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>fqcj40f1ojeitvtz4m2eefrp1ymhi6o</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Nobold</title>
    <ns>10</ns>
    <id>32</id>
    <revision>
      <id>52</id>
      <parentid>51</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>51</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="192" sha1="iaf63qvx3m2zxytvj4dw3wwalq5wusd" xml:space="preserve">&lt;templatestyles src="Nobold/styles.css"/&gt;&lt;span class="nobold"&gt;{{{1}}}&lt;/span&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- PLEASE ADD CATEGORIES AND INTERWIKIS TO THE /doc SUBPAGE, THANKS --&gt;
&lt;/noinclude&gt;</text>
      <sha1>iaf63qvx3m2zxytvj4dw3wwalq5wusd</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Nobold/styles.css</title>
    <ns>10</ns>
    <id>33</id>
    <revision>
      <id>54</id>
      <parentid>53</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>53</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="89" sha1="fenpgkszzubv5v79v09z2871g8mgdmr" xml:space="preserve">/* {{pp-template}} */
/* Styling for Template:Nobold */
.nobold {
	font-weight: normal;
}</text>
      <sha1>fenpgkszzubv5v79v09z2871g8mgdmr</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Check for unknown parameters</title>
    <ns>828</ns>
    <id>34</id>
    <revision>
      <id>56</id>
      <parentid>55</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>55</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3339" sha1="duq9iab2i1yitd2f8nw1por2veybp89" xml:space="preserve">-- This module may be used to compare the arguments passed to the parent
-- with a list of arguments, returning a specified result if an argument is
-- not on the list

require ('strict');

local p = {}

local function trim(s)
	return s:match('^%s*(.-)%s*$')
end

local function isnotempty(s)
	return s and s:match('%S')
end

local function clean(text)
	-- Return text cleaned for display and truncated if too long.
	-- Strip markers are replaced with dummy text representing the original wikitext.
	local pos, truncated
	local function truncate(text)
		if truncated then
			return ''
		end
		if mw.ustring.len(text) &gt; 25 then
			truncated = true
			text = mw.ustring.sub(text, 1, 25) .. '...'
		end
		return mw.text.nowiki(text)
	end
	local parts = {}
	for before, tag, remainder in text:gmatch('([^\127]*)\127[^\127]*%-(%l+)%-[^\127]*\127()') do
		pos = remainder
		table.insert(parts, truncate(before) .. '&amp;lt;' .. tag .. '&amp;gt;...&amp;lt;/' .. tag .. '&amp;gt;')
	end
	table.insert(parts, truncate(text:sub(pos or 1)))
	return table.concat(parts)
end

function p._check(args, pargs)
	if type(args) ~= "table" or type(pargs) ~= "table" then
		-- TODO: error handling
		return
	end

	-- create the list of known args, regular expressions, and the return string
	local knownargs = {}
	local regexps = {}
	for k, v in pairs(args) do
		if type(k) == 'number' then
			v = trim(v)
			knownargs[v] = 1
		elseif k:find('^regexp[1-9][0-9]*$') then
			table.insert(regexps, '^' .. v .. '$')
		end
	end

	-- loop over the parent args, and make sure they are on the list
	local ignoreblank = isnotempty(args['ignoreblank'])
	local showblankpos = isnotempty(args['showblankpositional'])
	local values = {}
	for k, v in pairs(pargs) do
		if type(k) == 'string' and knownargs[k] == nil then
			local knownflag = false
			for _, regexp in ipairs(regexps) do
				if mw.ustring.match(k, regexp) then
					knownflag = true
					break
				end
			end
			if not knownflag and ( not ignoreblank or isnotempty(v) )  then
				table.insert(values, clean(k))
			end
		elseif type(k) == 'number' and knownargs[tostring(k)] == nil then
			local knownflag = false
			for _, regexp in ipairs(regexps) do
				if mw.ustring.match(tostring(k), regexp) then
					knownflag = true
					break
				end
			end
			if not knownflag and ( showblankpos or isnotempty(v) ) then
				table.insert(values, k .. ' = ' .. clean(v))
			end
		end
	end

	-- add results to the output tables
	local res = {}
	if #values &gt; 0 then
		local unknown_text = args['unknown'] or 'Found _VALUE_, '

		if mw.getCurrentFrame():preprocess( "{{REVISIONID}}" ) == "" then
			local preview_text = args['preview']
			if isnotempty(preview_text) then
				preview_text = require('Module:If preview')._warning({preview_text})
			elseif preview_text == nil then
				preview_text = unknown_text
			end
			unknown_text = preview_text
		end
		for _, v in pairs(values) do
			-- Fix odd bug for | = which gets stripped to the empty string and
			-- breaks category links
			if v == '' then v = ' ' end

			-- avoid error with v = 'example%2' ("invalid capture index")
			local r = unknown_text:gsub('_VALUE_', {_VALUE_ = v})
			table.insert(res, r)
		end
	end

	return table.concat(res)
end

function p.check(frame)
	local args = frame.args
	local pargs = frame:getParent().args
	return p._check(args, pargs)
end

return p</text>
      <sha1>duq9iab2i1yitd2f8nw1por2veybp89</sha1>
    </revision>
  </page>
  <page>
    <title>Module:List</title>
    <ns>828</ns>
    <id>35</id>
    <revision>
      <id>58</id>
      <parentid>57</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>57</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5643" sha1="80u633hue68752ie9c34bo23bvxg416" xml:space="preserve">local libUtil = require('libraryUtil')
local checkType = libUtil.checkType
local mTableTools = require('Module:TableTools')

local p = {}

local listTypes = {
	['bulleted'] = true,
	['unbulleted'] = true,
	['horizontal'] = true,
	['ordered'] = true,
	['horizontal_ordered'] = true
}

function p.makeListData(listType, args)
	-- Constructs a data table to be passed to p.renderList.
	local data = {}

	-- Classes and TemplateStyles
	data.classes = {}
	data.templatestyles = ''
	if listType == 'horizontal' or listType == 'horizontal_ordered' then
		table.insert(data.classes, 'hlist')
		data.templatestyles = mw.getCurrentFrame():extensionTag{
			name = 'templatestyles', args = { src = 'Hlist/styles.css' }
		}
	elseif listType == 'unbulleted' then
		table.insert(data.classes, 'plainlist')
		data.templatestyles = mw.getCurrentFrame():extensionTag{
			name = 'templatestyles', args = { src = 'Plainlist/styles.css' }
		}
	end
	table.insert(data.classes, args.class)

	-- Main div style
	data.style = args.style

	-- Indent for horizontal lists
	if listType == 'horizontal' or listType == 'horizontal_ordered' then
		local indent = tonumber(args.indent)
		indent = indent and indent * 1.6 or 0
		if indent &gt; 0 then
			data.marginLeft = indent .. 'em'
		end
	end
	
	-- List style types for ordered lists
	-- This could be "1, 2, 3", "a, b, c", or a number of others. The list style
	-- type is either set by the "type" attribute or the "list-style-type" CSS
	-- property.
	if listType == 'ordered' or listType == 'horizontal_ordered' then 
		data.listStyleType = args.list_style_type or args['list-style-type']
		data.type = args['type']

		-- Detect invalid type attributes and attempt to convert them to
		-- list-style-type CSS properties.
		if data.type 
			and not data.listStyleType
			and not tostring(data.type):find('^%s*[1AaIi]%s*$')
		then
			data.listStyleType = data.type
			data.type = nil
		end
	end
	
	-- List tag type
	if listType == 'ordered' or listType == 'horizontal_ordered' then
		data.listTag = 'ol'
	else
		data.listTag = 'ul'
	end

	-- Start number for ordered lists
	data.start = args.start
	if listType == 'horizontal_ordered' then
		-- Apply fix to get start numbers working with horizontal ordered lists.
		local startNum = tonumber(data.start)
		if startNum then
			data.counterReset = 'listitem ' .. tostring(startNum - 1)
		end
	end

	-- List style
	 -- ul_style and ol_style are included for backwards compatibility. No
	 -- distinction is made for ordered or unordered lists.
	data.listStyle = args.list_style

	-- List items
	-- li_style is included for backwards compatibility. item_style was included
	-- to be easier to understand for non-coders.
	data.itemStyle = args.item_style or args.li_style
	data.items = {}
	for _, num in ipairs(mTableTools.numKeys(args)) do
		local item = {}
		item.content = args[num]
		item.style = args['item' .. tostring(num) .. '_style']
			or args['item_style' .. tostring(num)]
		item.value = args['item' .. tostring(num) .. '_value']
			or args['item_value' .. tostring(num)]
		table.insert(data.items, item)
	end
	
	return data
end

function p.renderList(data)
	-- Renders the list HTML.
	
	-- Return the blank string if there are no list items.
	if type(data.items) ~= 'table' or #data.items &lt; 1 then
		return ''
	end
	
	-- Render the main div tag.
	local root = mw.html.create('div')
	for _, class in ipairs(data.classes or {}) do
		root:addClass(class)
	end
	root:css{['margin-left'] = data.marginLeft}
	if data.style then
		root:cssText(data.style)
	end

	-- Render the list tag.
	local list = root:tag(data.listTag or 'ul')
	list
		:attr{start = data.start, type = data.type}
		:css{
			['counter-reset'] = data.counterReset,
			['list-style-type'] = data.listStyleType
		}
	if data.listStyle then
		list:cssText(data.listStyle)
	end

	-- Render the list items
	for _, t in ipairs(data.items or {}) do
		local item = list:tag('li')
		if data.itemStyle then
			item:cssText(data.itemStyle)
		end
		if t.style then
			item:cssText(t.style)
		end
		item
			:attr{value = t.value}
			:wikitext(t.content)
	end

	return data.templatestyles .. tostring(root)
end

function p.renderTrackingCategories(args)
	local isDeprecated = false -- Tracks deprecated parameters.
	for k, v in pairs(args) do
		k = tostring(k)
		if k:find('^item_style%d+$') or k:find('^item_value%d+$') then
			isDeprecated = true
			break
		end
	end
	local ret = ''
	if isDeprecated then
		ret = ret .. '[[Category:List templates with deprecated parameters]]'
	end
	return ret
end

function p.makeList(listType, args)
	if not listType or not listTypes[listType] then
		error(string.format(
			"bad argument #1 to 'makeList' ('%s' is not a valid list type)",
			tostring(listType)
		), 2)
	end
	checkType('makeList', 2, args, 'table')
	local data = p.makeListData(listType, args)
	local list = p.renderList(data)
	local trackingCategories = p.renderTrackingCategories(args)
	return list .. trackingCategories
end

for listType in pairs(listTypes) do
	p[listType] = function (frame)
		local mArguments = require('Module:Arguments')
		local origArgs = mArguments.getArgs(frame, {
			frameOnly = ((frame and frame.args and frame.args.frameonly or '') ~= ''),
			valueFunc = function (key, value)
			if not value or not mw.ustring.find(value, '%S') then return nil end
			if mw.ustring.find(value, '^%s*[%*#;:]') then
				return value
			else
				return value:match('^%s*(.-)%s*$')
			end
			return nil
		end
		})
		-- Copy all the arguments to a new table, for faster indexing.
		local args = {}
		for k, v in pairs(origArgs) do
			args[k] = v
		end
		return p.makeList(listType, args)
	end
end

return p</text>
      <sha1>80u633hue68752ie9c34bo23bvxg416</sha1>
    </revision>
  </page>
  <page>
    <title>Module:TableTools</title>
    <ns>828</ns>
    <id>36</id>
    <revision>
      <id>60</id>
      <parentid>59</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>59</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="16577" sha1="4n03zk6kcoeg4gz82mieeh94c1szcjy" xml:space="preserve">------------------------------------------------------------------------------------
--                                   TableTools                                   --
--                                                                                --
-- This module includes a number of functions for dealing with Lua tables.        --
-- It is a meta-module, meant to be called from other Lua modules, and should not --
-- be called directly from #invoke.                                               --
------------------------------------------------------------------------------------

local libraryUtil = require('libraryUtil')

local p = {}

-- Define often-used variables and functions.
local floor = math.floor
local infinity = math.huge
local checkType = libraryUtil.checkType
local checkTypeMulti = libraryUtil.checkTypeMulti

------------------------------------------------------------------------------------
-- isPositiveInteger
--
-- This function returns true if the given value is a positive integer, and false
-- if not. Although it doesn't operate on tables, it is included here as it is
-- useful for determining whether a given table key is in the array part or the
-- hash part of a table.
------------------------------------------------------------------------------------
function p.isPositiveInteger(v)
	return type(v) == 'number' and v &gt;= 1 and floor(v) == v and v &lt; infinity
end

------------------------------------------------------------------------------------
-- isNan
--
-- This function returns true if the given number is a NaN value, and false if
-- not. Although it doesn't operate on tables, it is included here as it is useful
-- for determining whether a value can be a valid table key. Lua will generate an
-- error if a NaN is used as a table key.
------------------------------------------------------------------------------------
function p.isNan(v)
	return type(v) == 'number' and v ~= v
end

------------------------------------------------------------------------------------
-- shallowClone
--
-- This returns a clone of a table. The value returned is a new table, but all
-- subtables and functions are shared. Metamethods are respected, but the returned
-- table will have no metatable of its own.
------------------------------------------------------------------------------------
function p.shallowClone(t)
	checkType('shallowClone', 1, t, 'table')
	local ret = {}
	for k, v in pairs(t) do
		ret[k] = v
	end
	return ret
end

------------------------------------------------------------------------------------
-- removeDuplicates
--
-- This removes duplicate values from an array. Non-positive-integer keys are
-- ignored. The earliest value is kept, and all subsequent duplicate values are
-- removed, but otherwise the array order is unchanged.
------------------------------------------------------------------------------------
function p.removeDuplicates(arr)
	checkType('removeDuplicates', 1, arr, 'table')
	local isNan = p.isNan
	local ret, exists = {}, {}
	for _, v in ipairs(arr) do
		if isNan(v) then
			-- NaNs can't be table keys, and they are also unique, so we don't need to check existence.
			ret[#ret + 1] = v
		elseif not exists[v] then
			ret[#ret + 1] = v
			exists[v] = true
		end
	end
	return ret
end

------------------------------------------------------------------------------------
-- numKeys
--
-- This takes a table and returns an array containing the numbers of any numerical
-- keys that have non-nil values, sorted in numerical order.
------------------------------------------------------------------------------------
function p.numKeys(t)
	checkType('numKeys', 1, t, 'table')
	local isPositiveInteger = p.isPositiveInteger
	local nums = {}
	for k in pairs(t) do
		if isPositiveInteger(k) then
			nums[#nums + 1] = k
		end
	end
	table.sort(nums)
	return nums
end

------------------------------------------------------------------------------------
-- affixNums
--
-- This takes a table and returns an array containing the numbers of keys with the
-- specified prefix and suffix. For example, for the table
-- {a1 = 'foo', a3 = 'bar', a6 = 'baz'} and the prefix "a", affixNums will return
-- {1, 3, 6}.
------------------------------------------------------------------------------------
function p.affixNums(t, prefix, suffix)
	checkType('affixNums', 1, t, 'table')
	checkType('affixNums', 2, prefix, 'string', true)
	checkType('affixNums', 3, suffix, 'string', true)

	local function cleanPattern(s)
		-- Cleans a pattern so that the magic characters ()%.[]*+-?^$ are interpreted literally.
		return s:gsub('([%(%)%%%.%[%]%*%+%-%?%^%$])', '%%%1')
	end

	prefix = prefix or ''
	suffix = suffix or ''
	prefix = cleanPattern(prefix)
	suffix = cleanPattern(suffix)
	local pattern = '^' .. prefix .. '([1-9]%d*)' .. suffix .. '$'

	local nums = {}
	for k in pairs(t) do
		if type(k) == 'string' then
			local num = mw.ustring.match(k, pattern)
			if num then
				nums[#nums + 1] = tonumber(num)
			end
		end
	end
	table.sort(nums)
	return nums
end

------------------------------------------------------------------------------------
-- numData
--
-- Given a table with keys like {"foo1", "bar1", "foo2", "baz2"}, returns a table
-- of subtables in the format
-- {[1] = {foo = 'text', bar = 'text'}, [2] = {foo = 'text', baz = 'text'}}.
-- Keys that don't end with an integer are stored in a subtable named "other". The
-- compress option compresses the table so that it can be iterated over with
-- ipairs.
------------------------------------------------------------------------------------
function p.numData(t, compress)
	checkType('numData', 1, t, 'table')
	checkType('numData', 2, compress, 'boolean', true)
	local ret = {}
	for k, v in pairs(t) do
		local prefix, num = mw.ustring.match(tostring(k), '^([^0-9]*)([1-9][0-9]*)$')
		if num then
			num = tonumber(num)
			local subtable = ret[num] or {}
			if prefix == '' then
				-- Positional parameters match the blank string; put them at the start of the subtable instead.
				prefix = 1
			end
			subtable[prefix] = v
			ret[num] = subtable
		else
			local subtable = ret.other or {}
			subtable[k] = v
			ret.other = subtable
		end
	end
	if compress then
		local other = ret.other
		ret = p.compressSparseArray(ret)
		ret.other = other
	end
	return ret
end

------------------------------------------------------------------------------------
-- compressSparseArray
--
-- This takes an array with one or more nil values, and removes the nil values
-- while preserving the order, so that the array can be safely traversed with
-- ipairs.
------------------------------------------------------------------------------------
function p.compressSparseArray(t)
	checkType('compressSparseArray', 1, t, 'table')
	local ret = {}
	local nums = p.numKeys(t)
	for _, num in ipairs(nums) do
		ret[#ret + 1] = t[num]
	end
	return ret
end

------------------------------------------------------------------------------------
-- sparseIpairs
--
-- This is an iterator for sparse arrays. It can be used like ipairs, but can
-- handle nil values.
------------------------------------------------------------------------------------
function p.sparseIpairs(t)
	checkType('sparseIpairs', 1, t, 'table')
	local nums = p.numKeys(t)
	local i = 0
	local lim = #nums
	return function ()
		i = i + 1
		if i &lt;= lim then
			local key = nums[i]
			return key, t[key]
		else
			return nil, nil
		end
	end
end

------------------------------------------------------------------------------------
-- size
--
-- This returns the size of a key/value pair table. It will also work on arrays,
-- but for arrays it is more efficient to use the # operator.
------------------------------------------------------------------------------------
function p.size(t)
	checkType('size', 1, t, 'table')
	local i = 0
	for _ in pairs(t) do
		i = i + 1
	end
	return i
end

local function defaultKeySort(item1, item2)
	-- "number" &lt; "string", so numbers will be sorted before strings.
	local type1, type2 = type(item1), type(item2)
	if type1 ~= type2 then
		return type1 &lt; type2
	elseif type1 == 'table' or type1 == 'boolean' or type1 == 'function' then
		return tostring(item1) &lt; tostring(item2)
	else
		return item1 &lt; item2
	end
end
------------------------------------------------------------------------------------
-- keysToList
--
-- Returns an array of the keys in a table, sorted using either a default
-- comparison function or a custom keySort function.
------------------------------------------------------------------------------------
function p.keysToList(t, keySort, checked)
	if not checked then
		checkType('keysToList', 1, t, 'table')
		checkTypeMulti('keysToList', 2, keySort, {'function', 'boolean', 'nil'})
	end

	local arr = {}
	local index = 1
	for k in pairs(t) do
		arr[index] = k
		index = index + 1
	end

	if keySort ~= false then
		keySort = type(keySort) == 'function' and keySort or defaultKeySort
		table.sort(arr, keySort)
	end

	return arr
end

------------------------------------------------------------------------------------
-- sortedPairs
--
-- Iterates through a table, with the keys sorted using the keysToList function.
-- If there are only numerical keys, sparseIpairs is probably more efficient.
------------------------------------------------------------------------------------
function p.sortedPairs(t, keySort)
	checkType('sortedPairs', 1, t, 'table')
	checkType('sortedPairs', 2, keySort, 'function', true)

	local arr = p.keysToList(t, keySort, true)

	local i = 0
	return function ()
		i = i + 1
		local key = arr[i]
		if key ~= nil then
			return key, t[key]
		else
			return nil, nil
		end
	end
end

------------------------------------------------------------------------------------
-- isArray
--
-- Returns true if the given value is a table and all keys are consecutive
-- integers starting at 1.
------------------------------------------------------------------------------------
function p.isArray(v)
	if type(v) ~= 'table' then
		return false
	end
	local i = 0
	for _ in pairs(v) do
		i = i + 1
		if v[i] == nil then
			return false
		end
	end
	return true
end

------------------------------------------------------------------------------------
-- isArrayLike
--
-- Returns true if the given value is iterable and all keys are consecutive
-- integers starting at 1.
------------------------------------------------------------------------------------
function p.isArrayLike(v)
	if not pcall(pairs, v) then
		return false
	end
	local i = 0
	for _ in pairs(v) do
		i = i + 1
		if v[i] == nil then
			return false
		end
	end
	return true
end

------------------------------------------------------------------------------------
-- invert
--
-- Transposes the keys and values in an array. For example, {"a", "b", "c"} -&gt;
-- {a = 1, b = 2, c = 3}. Duplicates are not supported (result values refer to
-- the index of the last duplicate) and NaN values are ignored.
------------------------------------------------------------------------------------
function p.invert(arr)
	checkType("invert", 1, arr, "table")
	local isNan = p.isNan
	local map = {}
	for i, v in ipairs(arr) do
		if not isNan(v) then
			map[v] = i
		end
	end

	return map
end

------------------------------------------------------------------------------------
-- listToSet
--
-- Creates a set from the array part of the table. Indexing the set by any of the
-- values of the array returns true. For example, {"a", "b", "c"} -&gt;
-- {a = true, b = true, c = true}. NaN values are ignored as Lua considers them
-- never equal to any value (including other NaNs or even themselves).
------------------------------------------------------------------------------------
function p.listToSet(arr)
	checkType("listToSet", 1, arr, "table")
	local isNan = p.isNan
	local set = {}
	for _, v in ipairs(arr) do
		if not isNan(v) then
			set[v] = true
		end
	end

	return set
end

------------------------------------------------------------------------------------
-- deepCopy
--
-- Recursive deep copy function. Preserves identities of subtables.
------------------------------------------------------------------------------------
local function _deepCopy(orig, includeMetatable, already_seen)
	if type(orig) ~= "table" then
		return orig
	end
	
	-- already_seen stores copies of tables indexed by the original table.
	local copy = already_seen[orig]
	if copy ~= nil then
		return copy
	end
	
	copy = {}
	already_seen[orig] = copy -- memoize before any recursion, to avoid infinite loops
	
	for orig_key, orig_value in pairs(orig) do
		copy[_deepCopy(orig_key, includeMetatable, already_seen)] = _deepCopy(orig_value, includeMetatable, already_seen)
	end
	
	if includeMetatable then
		local mt = getmetatable(orig)
		if mt ~= nil then
			setmetatable(copy, _deepCopy(mt, true, already_seen))
		end
	end
	
	return copy
end

function p.deepCopy(orig, noMetatable, already_seen)
	checkType("deepCopy", 3, already_seen, "table", true)
	return _deepCopy(orig, not noMetatable, already_seen or {})
end

------------------------------------------------------------------------------------
-- sparseConcat
--
-- Concatenates all values in the table that are indexed by a number, in order.
-- sparseConcat{a, nil, c, d}  =&gt;  "acd"
-- sparseConcat{nil, b, c, d}  =&gt;  "bcd"
------------------------------------------------------------------------------------
function p.sparseConcat(t, sep, i, j)
	local arr = {}

	local arr_i = 0
	for _, v in p.sparseIpairs(t) do
		arr_i = arr_i + 1
		arr[arr_i] = v
	end

	return table.concat(arr, sep, i, j)
end

------------------------------------------------------------------------------------
-- length
--
-- Finds the length of an array, or of a quasi-array with keys such as "data1",
-- "data2", etc., using an exponential search algorithm. It is similar to the
-- operator #, but may return a different value when there are gaps in the array
-- portion of the table. Intended to be used on data loaded with mw.loadData. For
-- other tables, use #.
-- Note: #frame.args in frame object always be set to 0, regardless of  the number
-- of unnamed template parameters, so use this function for frame.args.
------------------------------------------------------------------------------------
function p.length(t, prefix)
	-- requiring module inline so that [[Module:Exponential search]] which is
	-- only needed by this one function doesn't get millions of transclusions
	local expSearch = require("Module:Exponential search")
	checkType('length', 1, t, 'table')
	checkType('length', 2, prefix, 'string', true)
	return expSearch(function (i)
		local key
		if prefix then
			key = prefix .. tostring(i)
		else
			key = i
		end
		return t[key] ~= nil
	end) or 0
end

------------------------------------------------------------------------------------
-- inArray
--
-- Returns true if searchElement is a member of the array, and false otherwise.
-- Equivalent to JavaScript array.includes(searchElement) or
-- array.includes(searchElement, fromIndex), except fromIndex is 1 indexed
------------------------------------------------------------------------------------
function p.inArray(array, searchElement, fromIndex)
	checkType("inArray", 1, array, "table")
	-- if searchElement is nil, error?

	fromIndex = tonumber(fromIndex)
	if fromIndex then
		if (fromIndex &lt; 0) then
			fromIndex = #array + fromIndex + 1
		end
		if fromIndex &lt; 1 then fromIndex = 1 end
		for _, v in ipairs({unpack(array, fromIndex)}) do
			if v == searchElement then
				return true
			end
		end
	else
		for _, v in pairs(array) do
			if v == searchElement then
				return true
			end
		end
	end
	return false
end

------------------------------------------------------------------------------------
-- merge
--
-- Given the arrays, returns an array containing the elements of each input array
-- in sequence.
------------------------------------------------------------------------------------
function p.merge(...)
	local arrays = {...}
	local ret = {}
	for i, arr in ipairs(arrays) do
		checkType('merge', i, arr, 'table')
		for _, v in ipairs(arr) do
			ret[#ret + 1] = v
		end
	end
	return ret
end

------------------------------------------------------------------------------------
-- extend
--
-- Extends the first array in place by appending all elements from the second
-- array.
------------------------------------------------------------------------------------
function p.extend(arr1, arr2)
	checkType('extend', 1, arr1, 'table')
	checkType('extend', 2, arr2, 'table')

	for _, v in ipairs(arr2) do
		arr1[#arr1 + 1] = v
	end
end

return p</text>
      <sha1>4n03zk6kcoeg4gz82mieeh94c1szcjy</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Template link general</title>
    <ns>828</ns>
    <id>37</id>
    <revision>
      <id>62</id>
      <parentid>61</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>61</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4468" sha1="kj8qd6uwqhx6n0gkkkslldw0pq00bgy" xml:space="preserve">-- This implements Template:Template link general and various other templates in its family
local getArgs = require('Module:Arguments').getArgs
local p = {}

-- Is a string non-empty?
local function _ne(s) 
	return s ~= nil and s ~= ""
end

local nw = mw.text.nowiki

local function addTemplate(s)
	local i, _ = s:find(':', 1, true)
	if i == nil then
		return 'Template:' .. s
	end
	local ns = s:sub(1, i - 1)
	if ns == '' or mw.site.namespaces[ns] then
		return s
	else
		return 'Template:' .. s
	end
end

local function trimTemplate(s)
	local needle = 'template:'
	if s:sub(1, needle:len()):lower() == needle then
		return s:sub(needle:len() + 1)	
	else
		return s
	end
end

local function linkTitle(args)
	if _ne(args.nolink) then
		if _ne(args.subst) then
			return 'subst:' .. args['1']
		else
			return args['1']
		end
	end
	
	local titleObj
	local titlePart = '[['
	if args['1'] then
		-- This handles :Page and other NS
		titleObj = mw.title.new(args['1'], 'Template')
	else
		titleObj = mw.title.getCurrentTitle()
	end
	
	titlePart = titlePart .. (titleObj ~= nil and titleObj.fullText or
				addTemplate(args['1']))
	
	local textPart = args.alttext
	if not _ne(textPart) then
		if titleObj ~= nil then
			textPart = titleObj:inNamespace("Template") and args['1'] or titleObj.fullText
		else
			-- redlink
			textPart = args['1']
		end
	end
	
	if _ne(args.subst) then
		-- HACK: the ns thing above is probably broken
		textPart = 'subst:' .. textPart
	end
	
	if _ne(args.brace) then
		textPart = nw('{{') .. textPart .. nw('}}')
	elseif _ne(args.braceinside) then
		textPart = nw('{') .. textPart .. nw('}')
	end
	
	titlePart = titlePart .. '|' .. textPart .. ']]'
	if _ne(args.braceinside) then
		titlePart = nw('{') .. titlePart .. nw('}')
	end
	return titlePart
end

function p.main(frame)
	local args = getArgs(frame, {
		trim = true,
		removeBlanks = false
	})
	return p._main(args)
end

function p._main(args)
	local bold = _ne(args.bold) or _ne(args.boldlink) or _ne(args.boldname)
	local italic = _ne(args.italic) or _ne(args.italics)
	local dontBrace = _ne(args.brace) or _ne(args.braceinside)
	local code = _ne(args.code) or _ne(args.tt)
	local show_result = _ne(args._show_result)
	local expand = _ne(args._expand)
	
	-- Build the link part
	local titlePart = linkTitle(args)
	if bold then titlePart = "'''" .. titlePart .. "'''" end
	if _ne(args.nowrapname) then titlePart = '&lt;span class="nowrap"&gt;' .. titlePart .. '&lt;/span&gt;' end
	
	-- Build the arguments
	local textPart = ""
	local textPartBuffer = "&amp;#124;"
	local codeArguments = {}
	local codeArgumentsString = ""
	local i = 2
	local j = 1
	while args[i] do
		local val = args[i]
		if val ~= "" then
			if _ne(args.nowiki) then
				-- Unstrip nowiki tags first because calling nw on something that already contains nowiki tags will
				-- mangle the nowiki strip marker and result in literal UNIQ...QINU showing up
				val = nw(mw.text.unstripNoWiki(val))
			end
			local k, v = string.match(val, "(.*)=(.*)")
			if not k then
				codeArguments[j] = val
				j = j + 1
			else
				codeArguments[k] = v
			end
			codeArgumentsString = codeArgumentsString .. textPartBuffer .. val
			if italic then
				val = '&lt;span style="font-style:italic;"&gt;' .. val .. '&lt;/span&gt;'
			end
			textPart = textPart .. textPartBuffer .. val
		end
		i = i + 1
	end

	-- final wrap
	local ret = titlePart .. textPart
	if not dontBrace then ret = nw('{{') .. ret .. nw('}}') end
	if _ne(args.a) then ret = nw('*') .. '&amp;nbsp;' .. ret end
	if _ne(args.kbd) then ret = '&lt;kbd&gt;' .. ret .. '&lt;/kbd&gt;' end
	if code then
		ret = '&lt;code&gt;' .. ret .. '&lt;/code&gt;'
	elseif _ne(args.plaincode) then
		ret = '&lt;code style="border:none;background:transparent;color:inherit"&gt;' .. ret .. '&lt;/code&gt;'
	end
	if _ne(args.nowrap) then ret = '&lt;span class="nowrap"&gt;' .. ret .. '&lt;/span&gt;' end
	
	--[[ Wrap as html?? 
	local span = mw.html.create('span')
	span:wikitext(ret)
	--]]
	if _ne(args.debug) then ret = ret .. '\n&lt;pre&gt;' .. mw.text.encode(mw.dumpObject(args)) .. '&lt;/pre&gt;' end

	if show_result then
		local result = mw.getCurrentFrame():expandTemplate{title = addTemplate(args[1]), args = codeArguments}
		ret = ret .. " → " .. result
	end

	if expand then
		local query = mw.text.encode('{{' .. addTemplate(args[1]) .. string.gsub(codeArgumentsString, textPartBuffer, "|") .. '}}')
		local url = mw.uri.fullUrl('special:ExpandTemplates', 'wpInput=' .. query)
		mw.log()
		ret = ret .. " [" .. tostring(url) .. "]"
	end

	return ret
end

return p</text>
      <sha1>kj8qd6uwqhx6n0gkkkslldw0pq00bgy</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite web</title>
    <ns>10</ns>
    <id>38</id>
    <revision>
      <id>64</id>
      <parentid>63</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>63</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="122" sha1="rcgmbcxu7hvs583g1f3rzz4c4dkizda" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=web
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rcgmbcxu7hvs583g1f3rzz4c4dkizda</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Template other</title>
    <ns>10</ns>
    <id>39</id>
    <revision>
      <id>66</id>
      <parentid>65</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>65</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="435" sha1="0tcssjmltwl7y5v3f5wj2kqciaabqly" xml:space="preserve">{{#switch:
  &lt;!--If no or empty "demospace" parameter then detect namespace--&gt;
  {{#if:{{{demospace|}}}
  | {{lc: {{{demospace}}} }}    &lt;!--Use lower case "demospace"--&gt;
  | {{#ifeq:{{NAMESPACE}}|{{ns:Template}}
    | template
    | other
    }}
  }}
| template = {{{1|}}}
| other
| #default = {{{2|}}}
}}&lt;!--End switch--&gt;&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>0tcssjmltwl7y5v3f5wj2kqciaabqly</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Reflist</title>
    <ns>10</ns>
    <id>40</id>
    <revision>
      <id>68</id>
      <parentid>67</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>67</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1059" sha1="geeeydvb5368tzzflcyuzs20a5hlnbz" xml:space="preserve">&lt;templatestyles src="Reflist/styles.css" /&gt;&lt;div class="reflist &lt;!--
--&gt;{{#if:{{{1|}}}{{{colwidth|}}}|reflist-columns references-column-width}} &lt;!--
--&gt;{{#switch:{{{liststyle|{{{group|}}}}}}|upper-alpha|upper-roman|lower-alpha|lower-greek|lower-roman=reflist-{{{liststyle|{{{group}}}}}}}} &lt;!--
--&gt;{{#if:{{{1|}}}|{{#iferror:{{#ifexpr: {{{1|1}}} &gt; 1 }}||{{#switch:{{{1|}}}|1=|2=reflist-columns-2|#default=reflist-columns-3}} }}}}" &lt;!-- end class
--&gt;{{#if: {{{1|}}}&lt;!-- start style --&gt;
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }} |style="column-width: {{{1}}};"}}
    | {{#if: {{{colwidth|}}}|style="column-width: {{{colwidth}}};"}}
    }}&gt;
{{#tag:references|{{{refs|}}}|group={{{group|}}}|responsive={{#if:{{{1|}}}{{{colwidth|}}}|0|1}}}}&lt;/div&gt;{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using reflist with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Reflist]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | colwidth | group | liststyle | refs }}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>geeeydvb5368tzzflcyuzs20a5hlnbz</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Reflist/styles.css</title>
    <ns>10</ns>
    <id>41</id>
    <revision>
      <id>70</id>
      <parentid>69</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>69</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1473" sha1="n1076v46ma6f6p24w7nhtc3ft3kbc4h" xml:space="preserve">/* {{pp|small=yes}} */
.reflist {
	margin-bottom: 0.5em;
	list-style-type: decimal;
}

@media screen {
	/* can we remove the font size declarations? .references gets a font-size in
	 * common.css that is always 90, and there is nothing else in reflist out in
	 * the wild. May affect column sizes.
	 */
	 /* make smaller only on screens */
	.reflist {
		font-size: 90%;        /* Default font-size */
	}
}

.reflist .references {
	font-size: 100%;           /* Reset font-size when nested in .reflist */
	margin-bottom: 0;          /* Avoid double margin when nested in .reflist */
	list-style-type: inherit;  /* Enable custom list style types */
}

/* columns-2 and columns-3 are legacy for "2 or more" column view from when the
 * template was implemented with column-count.
 */
.reflist-columns-2 {
	column-width: 30em;
}

.reflist-columns-3 {
	column-width: 25em;
}

/* Reset top margin for lists embedded in columns */
.reflist-columns {
	margin-top: 0.3em;
}

.reflist-columns ol {
	margin-top: 0;
}

/* Avoid elements breaking between columns */
.reflist-columns li {
	page-break-inside: avoid; /* Removed from CSS in favor of break-inside c. 2020 */
	break-inside: avoid-column;
}

.reflist-upper-alpha {
	list-style-type: upper-alpha;
}

.reflist-upper-roman {
	list-style-type: upper-roman;
}

.reflist-lower-alpha {
	list-style-type: lower-alpha;
}

.reflist-lower-greek {
	list-style-type: lower-greek;
}

.reflist-lower-roman {
	list-style-type: lower-roman;
}</text>
      <sha1>n1076v46ma6f6p24w7nhtc3ft3kbc4h</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Smallcaps</title>
    <ns>10</ns>
    <id>42</id>
    <revision>
      <id>72</id>
      <parentid>71</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>71</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="306" sha1="khqsztk4mo066r4tq05x25e7qvmck4p" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;ifsubst | 1=&lt;span style="font-variant:small-caps"&gt;{{{1}}}&lt;/span&gt; | 2=&lt;templatestyles src="smallcaps/styles.css"/&gt;&lt;span class="smallcaps"&gt;{{{1}}}&lt;/span&gt; }}&lt;noinclude&gt;

&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>khqsztk4mo066r4tq05x25e7qvmck4p</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Smallcaps/styles.css</title>
    <ns>10</ns>
    <id>43</id>
    <revision>
      <id>74</id>
      <parentid>73</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>73</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="143" sha1="8lffmue4iv1b62pje3u895huur4gnpe" xml:space="preserve">/* {{pp-template}}
Styling for Template:Smallcaps */
span.smallcaps {
	font-variant: small-caps;
}

span.smallcaps-smaller {
	font-size: 85%;
}</text>
      <sha1>8lffmue4iv1b62pje3u895huur4gnpe</sha1>
    </revision>
  </page>
  <page>
    <title>Template:0</title>
    <ns>10</ns>
    <id>44</id>
    <revision>
      <id>76</id>
      <parentid>75</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>75</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="155" sha1="i4mo3weu20rgaw3qv8dfcm9ljmjmicn" xml:space="preserve">&lt;includeonly&gt;&lt;span aria-hidden="true" style="visibility:hidden;color:transparent;"&gt;{{{1|0}}}&lt;/span&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>i4mo3weu20rgaw3qv8dfcm9ljmjmicn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sidebar</title>
    <ns>10</ns>
    <id>45</id>
    <revision>
      <id>78</id>
      <parentid>77</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>77</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="68" sha1="jzouzofoaugku1umcgwhk1sk23s7qrm" xml:space="preserve">{{#invoke:Sidebar|sidebar}}&lt;noinclude&gt;
{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>jzouzofoaugku1umcgwhk1sk23s7qrm</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Small</title>
    <ns>10</ns>
    <id>46</id>
    <revision>
      <id>80</id>
      <parentid>79</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>79</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="466" sha1="sg2fmjr9tjbm1clxi8gtewxrhpyfqhl" xml:space="preserve">&lt;span style="font-size: 85%;"&gt;{{{1}}}&lt;/span&gt;&lt;includeonly&gt;&lt;!-- Tracking categories
--&gt;{{#invoke:Check for unknown parameters|check|unknown={{Main other|[[Category:Pages using small with unknown parameters|_VALUE_]]}}|preview=Page using [[Template:Small]] with unknown parameter "_VALUE_"|showblankpositional=1| 1 }}&lt;!--
--&gt;{{SAFESUBST:#if:{{{1|}}}||[[Category:Pages using small with an empty input parameter]]}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>sg2fmjr9tjbm1clxi8gtewxrhpyfqhl</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Smaller</title>
    <ns>10</ns>
    <id>47</id>
    <redirect title="Template:Small" />
    <revision>
      <id>82</id>
      <parentid>81</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>81</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="46" sha1="3z51arixnhrihpfrsykunpq1dagbnx1" xml:space="preserve">#REDIRECT [[Template:Small]]

{{r from merge}}</text>
      <sha1>3z51arixnhrihpfrsykunpq1dagbnx1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Plainlist</title>
    <ns>10</ns>
    <id>48</id>
    <revision>
      <id>84</id>
      <parentid>83</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>83</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="372" sha1="3oiy7lnp3psq95tdidyd4vhlmnjmzy8" xml:space="preserve">&lt;templatestyles src="Plainlist/styles.css"/&gt;&lt;div class="plainlist {{{class|}}}" {{safesubst&lt;noinclude /&gt;:#if:{{{style|}}}{{{indent|}}}|style="{{safesubst&lt;noinclude /&gt;:#if:{{{indent|}}}|margin-left: {{safesubst&lt;noinclude /&gt;:#expr:{{{indent}}}*1.6}}em;}} {{{style|}}}"}}&gt;{{safesubst&lt;noinclude /&gt;:#if:{{{1|}}}|
{{{1}}}
&lt;/div&gt;}}&lt;noinclude&gt;&lt;/div&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>3oiy7lnp3psq95tdidyd4vhlmnjmzy8</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Effective protection expiry</title>
    <ns>828</ns>
    <id>49</id>
    <revision>
      <id>86</id>
      <parentid>85</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>85</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1494" sha1="i1wms02y1w048cq6uttka18a5pjzp63" xml:space="preserve">local p = {}

-- Returns the expiry of a restriction of an action on a given title, or unknown if it cannot be known.
-- If no title is specified, the title of the page being displayed is used.
function p._main(action, pagename)
	local title
	if type(pagename) == 'table' and pagename.prefixedText then
		title = pagename
	elseif pagename then
		title = mw.title.new(pagename)
	else
		title = mw.title.getCurrentTitle()
	end
	pagename = title.prefixedText
	if action == 'autoreview' then
		local stabilitySettings = mw.ext.FlaggedRevs.getStabilitySettings(title)
		return stabilitySettings and stabilitySettings.expiry or 'unknown'
	elseif action ~= 'edit' and action ~= 'move' and action ~= 'create' and action ~= 'upload' then
		error( 'First parameter must be one of edit, move, create, upload, autoreview', 2 )
	end
	local rawExpiry = mw.getCurrentFrame():callParserFunction('PROTECTIONEXPIRY', action, pagename)
	if rawExpiry == 'infinity' then
		return 'infinity'
	elseif rawExpiry == '' then
		return 'unknown'
	else
		local year, month, day, hour, minute, second = rawExpiry:match(
			'^(%d%d%d%d)(%d%d)(%d%d)(%d%d)(%d%d)(%d%d)$'
		)
		if year then
			return string.format(
				'%s-%s-%sT%s:%s:%s',
				year, month, day, hour, minute, second
			)
		else
			error('internal error in Module:Effective protection expiry; malformed expiry timestamp')
		end
	end
end

setmetatable(p, { __index = function(t, k)
	return function(frame)
		return t._main(k, frame.args[1])
	end
end })

return p</text>
      <sha1>i1wms02y1w048cq6uttka18a5pjzp63</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Effective protection level</title>
    <ns>828</ns>
    <id>50</id>
    <revision>
      <id>88</id>
      <parentid>87</parentid>
      <timestamp>2025-07-09T04:31:20Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>87</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3581" sha1="lcolgmzxss8hd5im4xmd1ppgpgfv6gk" xml:space="preserve">local p = {}

-- Returns the permission required to perform a given action on a given title.
-- If no title is specified, the title of the page being displayed is used.
function p._main(action, pagename)
	local title
	if type(pagename) == 'table' and pagename.prefixedText then
		title = pagename
	elseif pagename then
		title = mw.title.new(pagename)
	else
		title = mw.title.getCurrentTitle()
	end
	pagename = title.prefixedText
	if action == 'autoreview' then
		local level = mw.ext.FlaggedRevs.getStabilitySettings(title)
		level = level and level.autoreview
		if level == 'review' then
			return 'reviewer'
		elseif level ~= '' then
			return level
		else
			return nil -- not '*'. a page not being PC-protected is distinct from it being PC-protected with anyone able to review. also not '', as that would mean PC-protected but nobody can review
		end
	elseif action ~= 'edit' and action ~= 'move' and action ~= 'create' and action ~= 'upload' and action ~= 'undelete' then
		error( 'First parameter must be one of edit, move, create, upload, undelete, autoreview', 2 )
	end
	if title.namespace == 8 then -- MediaWiki namespace
		if title.text:sub(-3) == '.js' or title.text:sub(-4) == '.css' or title.contentModel == 'javascript' or title.contentModel == 'css' then -- site JS or CSS page
			return 'interfaceadmin'
		else -- any non-JS/CSS MediaWiki page
			return 'sysop'
		end
	elseif title.namespace == 2 and title.isSubpage then
		if title.contentModel == 'javascript' or title.contentModel == 'css' then -- user JS or CSS page
			return 'interfaceadmin'
		elseif title.contentModel == 'json' then -- user JSON page
			return 'sysop'
		end
	end
	if action == 'undelete' then
		return 'sysop'
	end
	local level = title.protectionLevels[action] and title.protectionLevels[action][1]
	if level == 'sysop' or level == 'editprotected' then
		return 'sysop'
	elseif title.cascadingProtection.restrictions[action] and title.cascadingProtection.restrictions[action][1] then -- used by a cascading-protected page
		return 'sysop'
	elseif level == 'templateeditor' then
		return 'templateeditor'
	elseif action == 'move' then
		local blacklistentry = mw.ext.TitleBlacklist.test('edit', pagename) -- Testing action edit is correct, since this is for the source page. The target page name gets tested with action move.
		if blacklistentry and not blacklistentry.params.autoconfirmed then
			return 'templateeditor'
		elseif title.namespace == 6 then
			return 'filemover'
		elseif level == 'extendedconfirmed' then
			return 'extendedconfirmed'
		else
			return 'autoconfirmed'
		end
	end
	local blacklistentry = mw.ext.TitleBlacklist.test(action, pagename)
	if blacklistentry then
		if not blacklistentry.params.autoconfirmed then
			return 'templateeditor'
		elseif level == 'extendedconfirmed' then
			return 'extendedconfirmed'
		else
			return 'autoconfirmed'
		end
	elseif level == 'editsemiprotected' then -- create-semiprotected pages return this for some reason
		return 'autoconfirmed'
	elseif level then
		return level
	elseif action == 'upload' then
		return 'autoconfirmed'
	elseif action == 'create' and title.namespace % 2 == 0 and title.namespace ~= 118 then -- You need to be registered, but not autoconfirmed, to create non-talk pages other than drafts
		if title.namespace == 0 then
			return 'autoconfirmed' -- Per [[WP:ACPERM]], you need to be autoconfirmed to create pages in mainspace
		end
		return 'user'
	else
		return '*'
	end
end

setmetatable(p, { __index = function(t, k)
	return function(frame)
		return t._main(k, frame.args[1])
	end
end })

return p</text>
      <sha1>lcolgmzxss8hd5im4xmd1ppgpgfv6gk</sha1>
    </revision>
  </page>
  <page>
    <title>Module:File link</title>
    <ns>828</ns>
    <id>51</id>
    <revision>
      <id>90</id>
      <parentid>89</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>89</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2544" sha1="bzc22v133v9z5yc4aisazripn6l94p8" xml:space="preserve">-- This module provides a library for formatting file wikilinks.

local yesno = require('Module:Yesno')
local checkType = require('libraryUtil').checkType

local p = {}

function p._main(args)
	checkType('_main', 1, args, 'table')

	-- This is basically libraryUtil.checkTypeForNamedArg, but we are rolling our
	-- own function to get the right error level.
	local function checkArg(key, val, level)
		if type(val) ~= 'string' then
			error(string.format(
				"type error in '%s' parameter of '_main' (expected string, got %s)",
				key, type(val)
			), level)
		end
	end

	local ret = {}

	-- Adds a positional parameter to the buffer.
	local function addPositional(key)
		local val = args[key]
		if not val then
			return nil
		end
		checkArg(key, val, 4)
		ret[#ret + 1] = val
	end

	-- Adds a named parameter to the buffer. We assume that the parameter name
	-- is the same as the argument key.
	local function addNamed(key)
		local val = args[key]
		if not val then
			return nil
		end
		checkArg(key, val, 4)
		ret[#ret + 1] = key .. '=' .. val
	end

	-- Filename
	checkArg('file', args.file, 3)
	ret[#ret + 1] = 'File:' .. args.file

	-- Format
	if args.format then
		checkArg('format', args.format)
		if args.formatfile then
			checkArg('formatfile', args.formatfile)
			ret[#ret + 1] = args.format .. '=' .. args.formatfile
		else
			ret[#ret + 1] = args.format
		end
	end

	-- Border
	if yesno(args.border) then
		ret[#ret + 1] = 'border'
	end

	addPositional('location')
	addPositional('alignment')
	addPositional('size')
	addNamed('upright')
	addNamed('link')
	addNamed('alt')
	addNamed('page')
	addNamed('class')
	addNamed('lang')
	addNamed('start')
	addNamed('end')
	addNamed('thumbtime')
	addPositional('caption')

	return string.format('[[%s]]', table.concat(ret, '|'))
end

function p.main(frame)
	local origArgs = require('Module:Arguments').getArgs(frame, {
		wrappers = 'Template:File link'
	})
	if not origArgs.file then
		error("'file' parameter missing from [[Template:File link]]", 0)
	end

	-- Copy the arguments that were passed to a new table to avoid looking up
	-- every possible parameter in the frame object.
	local args = {}
	for k, v in pairs(origArgs) do
		-- Make _BLANK a special argument to add a blank parameter. For use in
		-- conditional templates etc. it is useful for blank arguments to be
		-- ignored, but we still need a way to specify them so that we can do
		-- things like [[File:Example.png|link=]].
		if v == '_BLANK' then
			v = ''
		end
		args[k] = v
	end
	return p._main(args)
end

return p</text>
      <sha1>bzc22v133v9z5yc4aisazripn6l94p8</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Hatnote</title>
    <ns>828</ns>
    <id>52</id>
    <revision>
      <id>92</id>
      <parentid>91</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>91</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6129" sha1="qps4k9ys6ba1dq9msz6m6lq3kfc4w6t" xml:space="preserve">--------------------------------------------------------------------------------
--                              Module:Hatnote                                --
--                                                                            --
-- This module produces hatnote links and links to related articles. It       --
-- implements the {{hatnote}} and {{format link}} meta-templates and includes --
-- helper functions for other Lua hatnote modules.                            --
--------------------------------------------------------------------------------

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local checkTypeForNamedArg = libraryUtil.checkTypeForNamedArg
local mArguments -- lazily initialise [[Module:Arguments]]
local yesno -- lazily initialise [[Module:Yesno]]
local formatLink -- lazily initialise [[Module:Format link]] ._formatLink

local p = {}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function getArgs(frame)
	-- Fetches the arguments from the parent frame. Whitespace is trimmed and
	-- blanks are removed.
	mArguments = require('Module:Arguments')
	return mArguments.getArgs(frame, {parentOnly = true})
end

local function removeInitialColon(s)
	-- Removes the initial colon from a string, if present.
	return s:match('^:?(.*)')
end

function p.defaultClasses(inline)
	-- Provides the default hatnote classes as a space-separated string; useful
	-- for hatnote-manipulation modules like [[Module:Hatnote group]].
	return
		(inline == 1 and 'hatnote-inline' or 'hatnote') .. ' ' ..
		'navigation-not-searchable'
end

function p.disambiguate(page, disambiguator)
	-- Formats a page title with a disambiguation parenthetical,
	-- i.e. "Example" → "Example (disambiguation)".
	checkType('disambiguate', 1, page, 'string')
	checkType('disambiguate', 2, disambiguator, 'string', true)
	disambiguator = disambiguator or 'disambiguation'
	return mw.ustring.format('%s (%s)', page, disambiguator)
end

function p.findNamespaceId(link, removeColon)
	-- Finds the namespace id (namespace number) of a link or a pagename. This
	-- function will not work if the link is enclosed in double brackets. Colons
	-- are trimmed from the start of the link by default. To skip colon
	-- trimming, set the removeColon parameter to false.
	checkType('findNamespaceId', 1, link, 'string')
	checkType('findNamespaceId', 2, removeColon, 'boolean', true)
	if removeColon ~= false then
		link = removeInitialColon(link)
	end
	local namespace = link:match('^(.-):')
	if namespace then
		local nsTable = mw.site.namespaces[namespace]
		if nsTable then
			return nsTable.id
		end
	end
	return 0
end

function p.makeWikitextError(msg, helpLink, addTrackingCategory, title)
	-- Formats an error message to be returned to wikitext. If
	-- addTrackingCategory is not false after being returned from
	-- [[Module:Yesno]], and if we are not on a talk page, a tracking category
	-- is added.
	checkType('makeWikitextError', 1, msg, 'string')
	checkType('makeWikitextError', 2, helpLink, 'string', true)
	yesno = require('Module:Yesno')
	title = title or mw.title.getCurrentTitle()
	-- Make the help link text.
	local helpText
	if helpLink then
		helpText = ' ([[' .. helpLink .. '|help]])'
	else
		helpText = ''
	end
	-- Make the category text.
	local category
	if not title.isTalkPage -- Don't categorise talk pages
		and title.namespace ~= 2 -- Don't categorise userspace
		and yesno(addTrackingCategory) ~= false -- Allow opting out
	then
		category = 'Hatnote templates with errors'
		category = mw.ustring.format(
			'[[%s:%s]]',
			mw.site.namespaces[14].name,
			category
		)
	else
		category = ''
	end
	return mw.ustring.format(
		'&lt;strong class="error"&gt;Error: %s%s.&lt;/strong&gt;%s',
		msg,
		helpText,
		category
	)
end

local curNs = mw.title.getCurrentTitle().namespace
p.missingTargetCat =
	--Default missing target category, exported for use in related modules
	((curNs ==  0) or (curNs == 14)) and
	'Articles with hatnote templates targeting a nonexistent page' or nil

function p.quote(title)
	--Wraps titles in quotation marks. If the title starts/ends with a quotation
	--mark, kerns that side as with {{-'}}
	local quotationMarks = {
		["'"]=true, ['"']=true, ['“']=true, ["‘"]=true, ['”']=true, ["’"]=true
	}
	local quoteLeft, quoteRight = -- Test if start/end are quotation marks
		quotationMarks[string.sub(title,  1,  1)],
		quotationMarks[string.sub(title, -1, -1)]
	if quoteLeft or quoteRight then
		title = mw.html.create("span"):wikitext(title)
	end
	if quoteLeft  then title:css("padding-left",  "0.15em") end
	if quoteRight then title:css("padding-right", "0.15em") end
	return '"' .. tostring(title) .. '"'
end

--------------------------------------------------------------------------------
-- Hatnote
--
-- Produces standard hatnote text. Implements the {{hatnote}} template.
--------------------------------------------------------------------------------
p[''] = function (frame) return p.hatnote(frame:newChild{ title = "Template:Hatnote" }) end

function p.hatnote(frame)
	local args = getArgs(frame)
	local s = args[1]
	if not s then
		return p.makeWikitextError(
			'no text specified',
			'Template:Hatnote#Errors',
			args.category
		)
	end
	return p._hatnote(s, {
		extraclasses = args.extraclasses,
		selfref = args.selfref
	})
end

function p._hatnote(s, options)
	checkType('_hatnote', 1, s, 'string')
	checkType('_hatnote', 2, options, 'table', true)
	options = options or {}
	local inline = options.inline
	local hatnote = mw.html.create(inline == 1 and 'span' or 'div')
	local extraclasses
	if type(options.extraclasses) == 'string' then
		extraclasses = options.extraclasses
	end

	hatnote
		:attr('role', 'note')
		:addClass(p.defaultClasses(inline))
		:addClass(extraclasses)
		:addClass(options.selfref and 'selfref' or nil)
		:wikitext(s)

	return mw.getCurrentFrame():extensionTag{
		name = 'templatestyles', args = { src = 'Module:Hatnote/styles.css' }
	} .. tostring(hatnote)
end

return p</text>
      <sha1>qps4k9ys6ba1dq9msz6m6lq3kfc4w6t</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Hatnote/styles.css</title>
    <ns>828</ns>
    <id>53</id>
    <revision>
      <id>94</id>
      <parentid>93</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>93</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="486" sha1="jwhkjblpyf93ejffkuu68hxj9zpt08y" xml:space="preserve">/* {{pp|small=y}} */
.hatnote {
	font-style: italic;
}

/* Limit structure CSS to divs because of [[Module:Hatnote inline]] */
div.hatnote {
	/* @noflip */
	padding-left: 1.6em;
	margin-bottom: 0.5em;
}

.hatnote i {
	font-style: normal;
}

/* The templatestyles element inserts a link element before hatnotes.
 * TODO: Remove link if/when WMF resolves T200206 */
.hatnote + link + .hatnote {
	margin-top: -0.5em;
}

@media print {
	body.ns-0 .hatnote {
		display: none !important;
	}
}</text>
      <sha1>jwhkjblpyf93ejffkuu68hxj9zpt08y</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Wd</title>
    <ns>828</ns>
    <id>54</id>
    <revision>
      <id>96</id>
      <parentid>95</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>95</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="73344" sha1="fw0wujzhw9loowczj4s2zaqoeawla5r" xml:space="preserve">-- Original module located at [[:en:Module:Wd]] and [[:en:Module:Wd/i18n]].

require("strict")
local p = {}
local module_arg = ...
local i18n
local i18nPath

local function loadI18n(aliasesP, frame)
	local title

	if frame then
		-- current module invoked by page/template, get its title from frame
		title = frame:getTitle()
	else
		-- current module included by other module, get its title from ...
		title = module_arg
	end

	if not i18n then
		i18nPath = title .. "/i18n"
		i18n = require(i18nPath).init(aliasesP)
	end
end

p.claimCommands = {
	property   = "property",
	properties = "properties",
	qualifier  = "qualifier",
	qualifiers = "qualifiers",
	reference  = "reference",
	references = "references"
}

p.generalCommands = {
	label       = "label",
	title       = "title",
	description = "description",
	alias       = "alias",
	aliases     = "aliases",
	badge       = "badge",
	badges      = "badges"
}

p.flags = {
	linked        = "linked",
	short         = "short",
	raw           = "raw",
	multilanguage = "multilanguage",
	unit          = "unit",
	-------------
	preferred     = "preferred",
	normal        = "normal",
	deprecated    = "deprecated",
	best          = "best",
	future        = "future",
	current       = "current",
	former        = "former",
	edit          = "edit",
	editAtEnd     = "edit@end",
	mdy           = "mdy",
	single        = "single",
	sourced       = "sourced"
}

p.args = {
	eid  = "eid",
	page = "page",
	date = "date",
	globalSiteId = "globalSiteId"
}

local aliasesP = {
	coord                   = "P625",
	-----------------------
	image                   = "P18",
	author                  = "P50",
	authorNameString        = "P2093",
	publisher               = "P123",
	importedFrom            = "P143",
	wikimediaImportURL      = "P4656",
	statedIn                = "P248",
	pages                   = "P304",
	language                = "P407",
	hasPart                 = "P527",
	publicationDate         = "P577",
	startTime               = "P580",
	endTime                 = "P582",
	chapter                 = "P792",
	retrieved               = "P813",
	referenceURL            = "P854",
	sectionVerseOrParagraph = "P958",
	archiveURL              = "P1065",
	title                   = "P1476",
	formatterURL            = "P1630",
	quote                   = "P1683",
	shortName               = "P1813",
	definingFormula         = "P2534",
	archiveDate             = "P2960",
	inferredFrom            = "P3452",
	typeOfReference         = "P3865",
	column                  = "P3903",
	subjectNamedAs          = "P1810",
	wikidataProperty        = "P1687",
	publishedIn             = "P1433"
}

local aliasesQ = {
	percentage              = "Q11229",
	prolepticJulianCalendar = "Q1985786",
	citeWeb                 = "Q5637226",
	citeQ                   = "Q22321052"
}

local parameters = {
	property  = "%p",
	qualifier = "%q",
	reference = "%r",
	alias     = "%a",
	badge     = "%b",
	separator = "%s",
	general   = "%x"
}

local formats = {
	property              = "%p[%s][%r]",
	qualifier             = "%q[%s][%r]",
	reference             = "%r",
	propertyWithQualifier = "%p[ &lt;span style=\"font-size:85\\%\"&gt;(%q)&lt;/span&gt;][%s][%r]",
	alias                 = "%a[%s]",
	badge                 = "%b[%s]"
}

local hookNames = {              -- {level_1, level_2}
	[parameters.property]         = {"getProperty"},
	[parameters.reference]        = {"getReferences", "getReference"},
	[parameters.qualifier]        = {"getAllQualifiers"},
	[parameters.qualifier.."\\d"] = {"getQualifiers", "getQualifier"},
	[parameters.alias]            = {"getAlias"},
	[parameters.badge]            = {"getBadge"}
}

-- default value objects, should NOT be mutated but instead copied
local defaultSeparators = {
	["sep"]      = {" "},
	["sep%s"]    = {","},
	["sep%q"]    = {"; "},
	["sep%q\\d"] = {", "},
	["sep%r"]    = nil,  -- none
	["punc"]     = nil   -- none
}

local rankTable = {
	["preferred"]  = 1,
	["normal"]     = 2,
	["deprecated"] = 3
}

local function replaceAlias(id)
	if aliasesP[id] then
		id = aliasesP[id]
	end

	return id
end

local function errorText(code, ...)
	local text = i18n["errors"][code]
	if arg then text = mw.ustring.format(text, unpack(arg)) end
	return text
end

local function throwError(errorMessage, ...)
	error(errorText(errorMessage, unpack(arg)))
end

local function replaceDecimalMark(num)
	return mw.ustring.gsub(num, "[.]", i18n['numeric']['decimal-mark'], 1)
end

local function padZeros(num, numDigits)
	local numZeros
	local negative = false

	if num &lt; 0 then
		negative = true
		num = num * -1
	end

	num = tostring(num)
	numZeros = numDigits - num:len()

	for _ = 1, numZeros do
		num = "0"..num
	end

	if negative then
		num = "-"..num
	end

	return num
end

local function replaceSpecialChar(chr)
	if chr == '_' then
		-- replace underscores with spaces
		return ' '
	else
		return chr
	end
end

local function replaceSpecialChars(str)
	local chr
	local esc = false
	local strOut = ""

	for i = 1, #str do
		chr = str:sub(i,i)

		if not esc then
			if chr == '\\' then
				esc = true
			else
				strOut = strOut .. replaceSpecialChar(chr)
			end
		else
			strOut = strOut .. chr
			esc = false
		end
	end

	return strOut
end

local function buildWikilink(target, label)
	if not label or target == label then
		return "[[" .. target .. "]]"
	else
		return "[[" .. target .. "|" .. label .. "]]"
	end
end

-- used to make frame.args mutable, to replace #frame.args (which is always 0)
-- with the actual amount and to simply copy tables
local function copyTable(tIn)
	if not tIn then
		return nil
	end

	local tOut = {}

	for i, v in pairs(tIn) do
		tOut[i] = v
	end

	return tOut
end

-- used to merge output arrays together;
-- note that it currently mutates the first input array
local function mergeArrays(a1, a2)
	for i = 1, #a2 do
		a1[#a1 + 1] = a2[i]
	end

	return a1
end

local function split(str, del)
	local out = {}
	local i, j = str:find(del)

	if i and j then
		out[1] = str:sub(1, i - 1)
		out[2] = str:sub(j + 1)
	else
		out[1] = str
	end

	return out
end

local function parseWikidataURL(url)
	local id

	if url:match('^http[s]?://') then
		id = split(url, "Q")

		if id[2] then
			return "Q" .. id[2]
		end
	end

	return nil
end

local function parseDate(dateStr, precision)
	precision = precision or "d"

	local i, j, index, ptr
	local parts = {nil, nil, nil}

	if dateStr == nil then
		return parts[1], parts[2], parts[3]  -- year, month, day
	end

	-- 'T' for snak values, '/' for outputs with '/Julian' attached
	i, j = dateStr:find("[T/]")

	if i then
		dateStr = dateStr:sub(1, i-1)
	end

	local from = 1

	if dateStr:sub(1,1) == "-" then
		-- this is a negative number, look further ahead
		from = 2
	end

	index = 1
	ptr = 1

	i, j = dateStr:find("-", from)

	if i then
		-- year
		parts[index] = tonumber(dateStr:sub(ptr, i-1), 10)  -- explicitly give base 10 to prevent error

		if parts[index] == -0 then
			parts[index] = tonumber("0")  -- for some reason, 'parts[index] = 0' may actually store '-0', so parse from string instead
		end

		if precision == "y" then
			-- we're done
			return parts[1], parts[2], parts[3]  -- year, month, day
		end

		index = index + 1
		ptr = i + 1

		i, j = dateStr:find("-", ptr)

		if i then
			-- month
			parts[index] = tonumber(dateStr:sub(ptr, i-1), 10)

			if precision == "m" then
				-- we're done
				return parts[1], parts[2], parts[3]  -- year, month, day
			end

			index = index + 1
			ptr = i + 1
		end
	end

	if dateStr:sub(ptr) ~= "" then
		-- day if we have month, month if we have year, or year
		parts[index] = tonumber(dateStr:sub(ptr), 10)
	end

	return parts[1], parts[2], parts[3]  -- year, month, day
end

local function datePrecedesDate(aY, aM, aD, bY, bM, bD)
	if aY == nil or bY == nil then
		return nil
	end
	aM = aM or 1
	aD = aD or 1
	bM = bM or 1
	bD = bD or 1

	if aY &lt; bY then
		return true
	end

	if aY &gt; bY then
		return false
	end

	if aM &lt; bM then
		return true
	end

	if aM &gt; bM then
		return false
	end

	if aD &lt; bD then
		return true
	end

	return false
end

local function getHookName(param, index)
	if hookNames[param] then
		return hookNames[param][index]
	elseif param:len() &gt; 2 then
		return hookNames[param:sub(1, 2).."\\d"][index]
	else
		return nil
	end
end

local function alwaysTrue()
	return true
end

-- The following function parses a format string.
--
-- The example below shows how a parsed string is structured in memory.
-- Variables other than 'str' and 'child' are left out for clarity's sake.
--
-- Example:
-- "A %p B [%s[%q1]] C [%r] D"
--
-- Structure:
-- [
--   {
--     str = "A "
--   },
--   {
--     str = "%p"
--   },
--   {
--     str = " B ",
--     child =
--     [
--       {
--         str = "%s",
--         child =
--         [
--           {
--             str = "%q1"
--           }
--         ]
--       }
--     ]
--   },
--   {
--     str = " C ",
--     child =
--     [
--       {
--         str = "%r"
--       }
--     ]
--   },
--   {
--     str = " D"
--   }
-- ]
--
local function parseFormat(str)
	local chr, esc, param, root, cur, prev, new
	local params = {}

	local function newObject(array)
		local obj = {}  -- new object
		obj.str = ""

		array[#array + 1] = obj  -- array{object}
		obj.parent = array

		return obj
	end

	local function endParam()
		if param &gt; 0 then
			if cur.str ~= "" then
				cur.str = "%"..cur.str
				cur.param = true
				params[cur.str] = true
				cur.parent.req[cur.str] = true
				prev = cur
				cur = newObject(cur.parent)
			end
			param = 0
		end
	end

	root = {}  -- array
	root.req = {}
	cur = newObject(root)
	prev = nil

	esc = false
	param = 0

	for i = 1, #str do
		chr = str:sub(i,i)

		if not esc then
			if chr == '\\' then
				endParam()
				esc = true
			elseif chr == '%' then
				endParam()
				if cur.str ~= "" then
					cur = newObject(cur.parent)
				end
				param = 2
			elseif chr == '[' then
				endParam()
				if prev and cur.str == "" then
					table.remove(cur.parent)
					cur = prev
				end
				cur.child = {}  -- new array
				cur.child.req = {}
				cur.child.parent = cur
				cur = newObject(cur.child)
			elseif chr == ']' then
				endParam()
				if cur.parent.parent then
					new = newObject(cur.parent.parent.parent)
					if cur.str == "" then
						table.remove(cur.parent)
					end
					cur = new
				end
			else
				if param &gt; 1 then
					param = param - 1
				elseif param == 1 then
					if not chr:match('%d') then
						endParam()
					end
				end

				cur.str = cur.str .. replaceSpecialChar(chr)
			end
		else
			cur.str = cur.str .. chr
			esc = false
		end

		prev = nil
	end

	endParam()

	-- make sure that at least one required parameter has been defined
	if not next(root.req) then
		throwError("missing-required-parameter")
	end

	-- make sure that the separator parameter "%s" is not amongst the required parameters
	if root.req[parameters.separator] then
		throwError("extra-required-parameter", parameters.separator)
	end

	return root, params
end

local function sortOnRank(claims)
	local rankPos
	local ranks = {{}, {}, {}, {}}  -- preferred, normal, deprecated, (default)
	local sorted = {}

	for _, v in ipairs(claims) do
		rankPos = rankTable[v.rank] or 4
		ranks[rankPos][#ranks[rankPos] + 1] = v
	end

	sorted = ranks[1]
	sorted = mergeArrays(sorted, ranks[2])
	sorted = mergeArrays(sorted, ranks[3])

	return sorted
end

local function isValueInTable(searchedItem, inputTable)
	for _, item in pairs(inputTable) do
		if item == searchedItem then
			return true
		end
	end
	return false
end

local Config = {}

-- allows for recursive calls
function Config:new()
	local cfg = {}
	setmetatable(cfg, self)
	self.__index = self

	cfg.separators = {
		-- single value objects wrapped in arrays so that we can pass by reference
		["sep"]   = {copyTable(defaultSeparators["sep"])},
		["sep%s"] = {copyTable(defaultSeparators["sep%s"])},
		["sep%q"] = {copyTable(defaultSeparators["sep%q"])},
		["sep%r"] = {copyTable(defaultSeparators["sep%r"])},
		["punc"]  = {copyTable(defaultSeparators["punc"])}
	}

	cfg.entity = nil
	cfg.entityID = nil
	cfg.propertyID = nil
	cfg.propertyValue = nil
	cfg.qualifierIDs = {}
	cfg.qualifierIDsAndValues = {}

	cfg.bestRank = true
	cfg.ranks = {true, true, false}  -- preferred = true, normal = true, deprecated = false
	cfg.foundRank = #cfg.ranks
	cfg.flagBest = false
	cfg.flagRank = false

	cfg.periods = {true, true, true}  -- future = true, current = true, former = true
	cfg.flagPeriod = false
	cfg.atDate = {parseDate(os.date('!%Y-%m-%d'))}  -- today as {year, month, day}

	cfg.mdyDate = false
	cfg.singleClaim = false
	cfg.sourcedOnly = false
	cfg.editable = false
	cfg.editAtEnd = false

	cfg.inSitelinks = false

	cfg.langCode = mw.language.getContentLanguage().code
	cfg.langName = mw.language.fetchLanguageName(cfg.langCode, cfg.langCode)
	cfg.langObj = mw.language.new(cfg.langCode)

	cfg.siteID = mw.wikibase.getGlobalSiteId()

	cfg.states = {}
	cfg.states.qualifiersCount = 0
	cfg.curState = nil

	cfg.prefetchedRefs = nil

	return cfg
end

local State = {}

function State:new(cfg, type)
	local stt = {}
	setmetatable(stt, self)
	self.__index = self

	stt.conf = cfg
	stt.type = type

	stt.results = {}

	stt.parsedFormat = {}
	stt.separator = {}
	stt.movSeparator = {}
	stt.puncMark = {}

	stt.linked = false
	stt.rawValue = false
	stt.shortName = false
	stt.anyLanguage = false
	stt.unitOnly = false
	stt.singleValue = false

	return stt
end

-- if id == nil then item connected to current page is used
function Config:getLabel(id, raw, link, short)
	local label = nil
	local prefix, title= "", nil

	if not id then
		id = mw.wikibase.getEntityIdForCurrentPage()

		if not id then
			return ""
		end
	end

	id = id:upper()  -- just to be sure

	if raw then
		-- check if given id actually exists
		if mw.wikibase.isValidEntityId(id) and mw.wikibase.entityExists(id) then
			label = id
		end

		prefix, title = "d:Special:EntityPage/", label -- may be nil
	else
		-- try short name first if requested
		if short then
			label = p._property{aliasesP.shortName, [p.args.eid] = id}  -- get short name

			if label == "" then
				label = nil
			end
		end

		-- get label
		if not label then
			label = mw.wikibase.getLabel(id)
		end
	end

	if not label then
		label = ""
	elseif link then
		-- build a link if requested
		if not title then
			if id:sub(1,1) == "Q" then
				title = mw.wikibase.getSitelink(id)
			elseif id:sub(1,1) == "P" then
				-- properties have no sitelink, link to Wikidata instead
				prefix, title = "d:Special:EntityPage/", id
			end
		end

		label = mw.text.nowiki(label) -- escape raw label text so it cannot be wikitext markup
		if title then
			label = buildWikilink(prefix .. title, label)
		end
	end

	return label
end

function Config:getEditIcon()
	local value = ""
	local prefix = ""
	local front = "&amp;nbsp;"
	local back = ""

	if self.entityID:sub(1,1) == "P" then
		prefix = "Property:"
	end

	if self.editAtEnd then
		front = '&lt;span style="float:'

		if self.langObj:isRTL() then
			front = front .. 'left'
		else
			front = front .. 'right'
		end

		front = front .. '"&gt;'
		back = '&lt;/span&gt;'
	end

	value = "[[File:OOjs UI icon edit-ltr-progressive.svg|frameless|text-top|10px|alt=" .. i18n['info']['edit-on-wikidata'] .. "|link=https://www.wikidata.org/wiki/" .. prefix .. self.entityID .. "?uselang=" .. self.langCode

	if self.propertyID then
		value = value .. "#" .. self.propertyID
	elseif self.inSitelinks then
		value = value .. "#sitelinks-wikipedia"
	end

	value = value .. "|" .. i18n['info']['edit-on-wikidata'] .. "]]"

	return front .. value .. back
end

-- used to create the final output string when it's all done, so that for references the
-- function extensionTag("ref", ...) is only called when they really ended up in the final output
function Config:concatValues(valuesArray)
	local outString = ""
	local j, skip

	for i = 1, #valuesArray do
		-- check if this is a reference
		if valuesArray[i].refHash then
			j = i - 1
			skip = false

			-- skip this reference if it is part of a continuous row of references that already contains the exact same reference
			while valuesArray[j] and valuesArray[j].refHash do
				if valuesArray[i].refHash == valuesArray[j].refHash then
					skip = true
					break
				end
				j = j - 1
			end

			if not skip then
				-- add &lt;ref&gt; tag with the reference's hash as its name (to deduplicate references)
				outString = outString .. mw.getCurrentFrame():extensionTag("ref", valuesArray[i][1], {name = valuesArray[i].refHash})
			end
		else
			outString = outString .. valuesArray[i][1]
		end
	end

	return outString
end

function Config:convertUnit(unit, raw, link, short, unitOnly)
	local space = " "
	local label = ""
	local itemID

	if unit == "" or unit == "1" then
		return nil
	end

	if unitOnly then
		space = ""
	end

	itemID = parseWikidataURL(unit)

	if itemID then
		if itemID == aliasesQ.percentage then
			return "%"
		else
			label = self:getLabel(itemID, raw, link, short)

			if label ~= "" then
				return space .. label
			end
		end
	end

	return ""
end

function State:getValue(snak)
	return self.conf:getValue(snak, self.rawValue, self.linked, self.shortName, self.anyLanguage, self.unitOnly, false, self.type:sub(1,2))
end

function Config:getValue(snak, raw, link, short, anyLang, unitOnly, noSpecial, type)
	if snak.snaktype == 'value' then
		local datatype = snak.datavalue.type
		local subtype = snak.datatype
		local datavalue = snak.datavalue.value

		if datatype == 'string' then
			if subtype == 'url' and link then
				-- create link explicitly
				if raw then
					-- will render as a linked number like [1]
					return "[" .. datavalue .. "]"
				else
					return "[" .. datavalue .. " " .. datavalue .. "]"
				end
			elseif subtype == 'commonsMedia' then
				if link then
					return buildWikilink("c:File:" .. datavalue, datavalue)
				elseif not raw then
					return "[[File:" .. datavalue .. "]]"
				else
					return datavalue
				end
			elseif subtype == 'geo-shape' and link then
				return buildWikilink("c:" .. datavalue, datavalue)
			elseif subtype == 'math' and not raw then
				local attribute = nil

				if (type == parameters.property or (type == parameters.qualifier and self.propertyID == aliasesP.hasPart)) and snak.property == aliasesP.definingFormula then
					attribute = {qid = self.entityID}
				end

				return mw.getCurrentFrame():extensionTag("math", datavalue, attribute)
			elseif subtype == 'external-id' and link then
				local url = p._property{aliasesP.formatterURL, [p.args.eid] = snak.property}  -- get formatter URL

				if url ~= "" then
					url = mw.ustring.gsub(url, "$1", datavalue)
					return "[" .. url .. " " .. datavalue .. "]"
				else
					return datavalue
				end
			else
				return datavalue
			end
		elseif datatype == 'monolingualtext' then
			if anyLang or datavalue['language'] == self.langCode then
				return datavalue['text']
			else
				return nil
			end
		elseif datatype == 'quantity' then
			local value = ""
			local unit

			if not unitOnly then
				-- get value and strip + signs from front
				value = mw.ustring.gsub(datavalue['amount'], "^%+(.+)$", "%1")

				if raw then
					return value
				end

				-- replace decimal mark based on locale
				value = replaceDecimalMark(value)

				-- add delimiters for readability
				value = i18n.addDelimiters(value)
			end

			unit = self:convertUnit(datavalue['unit'], raw, link, short, unitOnly)

			if unit then
				value = value .. unit
			end

			return value
		elseif datatype == 'time' then
			local y, m, d, p, yDiv, yRound, yFull, value, calendarID, dateStr
			local yFactor = 1
			local sign = 1
			local prefix = ""
			local suffix = ""
			local mayAddCalendar = false
			local calendar = ""
			local precision = datavalue['precision']

			if precision == 11 then
				p = "d"
			elseif precision == 10 then
				p = "m"
			else
				p = "y"
				yFactor = 10^(9-precision)
			end

			y, m, d = parseDate(datavalue['time'], p)

			if y &lt; 0 then
				sign = -1
				y = y * sign
			end

			-- if precision is tens/hundreds/thousands/millions/billions of years
			if precision &lt;= 8 then
				yDiv = y / yFactor

				-- if precision is tens/hundreds/thousands of years
				if precision &gt;= 6 then
					mayAddCalendar = true

					if precision &lt;= 7 then
						-- round centuries/millenniums up (e.g. 20th century or 3rd millennium)
						yRound = math.ceil(yDiv)

						if not raw then
							if precision == 6 then
								suffix = i18n['datetime']['suffixes']['millennium']
							else
								suffix = i18n['datetime']['suffixes']['century']
							end

							suffix = i18n.getOrdinalSuffix(yRound) .. suffix
						else
							-- if not verbose, take the first year of the century/millennium
							-- (e.g. 1901 for 20th century or 2001 for 3rd millennium)
							yRound = (yRound - 1) * yFactor + 1
						end
					else
						-- precision == 8
						-- round decades down (e.g. 2010s)
						yRound = math.floor(yDiv) * yFactor

						if not raw then
							prefix = i18n['datetime']['prefixes']['decade-period']
							suffix = i18n['datetime']['suffixes']['decade-period']
						end
					end

					if raw and sign &lt; 0 then
						-- if BCE then compensate for "counting backwards"
						-- (e.g. -2019 for 2010s BCE, -2000 for 20th century BCE or -3000 for 3rd millennium BCE)
						yRound = yRound + yFactor - 1
					end
				else
					local yReFactor, yReDiv, yReRound

					-- round to nearest for tens of thousands of years or more
					yRound = math.floor(yDiv + 0.5)

					if yRound == 0 then
						if precision &lt;= 2 and y ~= 0 then
							yReFactor = 1e6
							yReDiv = y / yReFactor
							yReRound = math.floor(yReDiv + 0.5)

							if yReDiv == yReRound then
								-- change precision to millions of years only if we have a whole number of them
								precision = 3
								yFactor = yReFactor
								yRound = yReRound
							end
						end

						if yRound == 0 then
							-- otherwise, take the unrounded (original) number of years
							precision = 5
							yFactor = 1
							yRound = y
							mayAddCalendar = true
						end
					end

					if precision &gt;= 1 and y ~= 0 then
						yFull = yRound * yFactor

						yReFactor = 1e9
						yReDiv = yFull / yReFactor
						yReRound = math.floor(yReDiv + 0.5)

						if yReDiv == yReRound then
							-- change precision to billions of years if we're in that range
							precision = 0
							yFactor = yReFactor
							yRound = yReRound
						else
							yReFactor = 1e6
							yReDiv = yFull / yReFactor
							yReRound = math.floor(yReDiv + 0.5)

							if yReDiv == yReRound then
								-- change precision to millions of years if we're in that range
								precision = 3
								yFactor = yReFactor
								yRound = yReRound
							end
						end
					end

					if not raw then
						if precision == 3 then
							suffix = i18n['datetime']['suffixes']['million-years']
						elseif precision == 0 then
							suffix = i18n['datetime']['suffixes']['billion-years']
						else
							yRound = yRound * yFactor
							if yRound == 1 then
								suffix = i18n['datetime']['suffixes']['year']
							else
								suffix = i18n['datetime']['suffixes']['years']
							end
						end
					else
						yRound = yRound * yFactor
					end
				end
			else
				yRound = y
				mayAddCalendar = true
			end

			if mayAddCalendar then
				calendarID = parseWikidataURL(datavalue['calendarmodel'])

				if calendarID and calendarID == aliasesQ.prolepticJulianCalendar then
					if not raw then
						if link then
							calendar = " ("..buildWikilink(i18n['datetime']['julian-calendar'], i18n['datetime']['julian'])..")"
						else
							calendar = " ("..i18n['datetime']['julian']..")"
						end
					else
						calendar = "/"..i18n['datetime']['julian']
					end
				end
			end

			if not raw then
				local ce = nil

				if sign &lt; 0 then
					ce = i18n['datetime']['BCE']
				elseif precision &lt;= 5 then
					ce = i18n['datetime']['CE']
				end

				if ce then
					if link then
						ce = buildWikilink(i18n['datetime']['common-era'], ce)
					end
					suffix = suffix .. " " .. ce
				end

				value = tostring(yRound)

				if m then
					dateStr = self.langObj:formatDate("F", "1-"..m.."-1")

					if d then
						if self.mdyDate then
							dateStr = dateStr .. " " .. d .. ","
						else
							dateStr = d .. " " .. dateStr
						end
					end

					value = dateStr .. " " .. value
				end

				value = prefix .. value .. suffix .. calendar
			else
				value = padZeros(yRound * sign, 4)

				if m then
					value = value .. "-" .. padZeros(m, 2)

					if d then
						value = value .. "-" .. padZeros(d, 2)
					end
				end

				value = value .. calendar
			end

			return value
		elseif datatype == 'globecoordinate' then
			-- logic from https://github.com/DataValues/Geo (v4.0.1)

			local precision, unitsPerDegree, numDigits, strFormat, value, globe
			local latitude, latConv, latValue, latLink
			local longitude, lonConv, lonValue, lonLink
			local latDirection, latDirectionN, latDirectionS, latDirectionEN
			local lonDirection, lonDirectionE, lonDirectionW, lonDirectionEN
			local degSymbol, minSymbol, secSymbol, separator

			local latDegrees = nil
			local latMinutes = nil
			local latSeconds = nil
			local lonDegrees = nil
			local lonMinutes = nil
			local lonSeconds = nil

			local latDegSym = ""
			local latMinSym = ""
			local latSecSym = ""
			local lonDegSym = ""
			local lonMinSym = ""
			local lonSecSym = ""

			local latDirectionEN_N = "N"
			local latDirectionEN_S = "S"
			local lonDirectionEN_E = "E"
			local lonDirectionEN_W = "W"

			if not raw then
				latDirectionN = i18n['coord']['latitude-north']
				latDirectionS = i18n['coord']['latitude-south']
				lonDirectionE = i18n['coord']['longitude-east']
				lonDirectionW = i18n['coord']['longitude-west']

				degSymbol = i18n['coord']['degrees']
				minSymbol = i18n['coord']['minutes']
				secSymbol = i18n['coord']['seconds']
				separator = i18n['coord']['separator']
			else
				latDirectionN = latDirectionEN_N
				latDirectionS = latDirectionEN_S
				lonDirectionE = lonDirectionEN_E
				lonDirectionW = lonDirectionEN_W

				degSymbol = "/"
				minSymbol = "/"
				secSymbol = "/"
				separator = "/"
			end

			latitude = datavalue['latitude']
			longitude = datavalue['longitude']

			if latitude &lt; 0 then
				latDirection = latDirectionS
				latDirectionEN = latDirectionEN_S
				latitude = math.abs(latitude)
			else
				latDirection = latDirectionN
				latDirectionEN = latDirectionEN_N
			end

			if longitude &lt; 0 then
				lonDirection = lonDirectionW
				lonDirectionEN = lonDirectionEN_W
				longitude = math.abs(longitude)
			else
				lonDirection = lonDirectionE
				lonDirectionEN = lonDirectionEN_E
			end

			precision = datavalue['precision']

			if not precision or precision &lt;= 0 then
				precision = 1 / 3600  -- precision not set (correctly), set to arcsecond
			end

			-- remove insignificant detail
			latitude = math.floor(latitude / precision + 0.5) * precision
			longitude = math.floor(longitude / precision + 0.5) * precision

			if precision &gt;= 1 - (1 / 60) and precision &lt; 1 then
				precision = 1
			elseif precision &gt;= (1 / 60) - (1 / 3600) and precision &lt; (1 / 60) then
				precision = 1 / 60
			end

			if precision &gt;= 1 then
				unitsPerDegree = 1
			elseif precision &gt;= (1 / 60)  then
				unitsPerDegree = 60
			else
				unitsPerDegree = 3600
			end

			numDigits = math.ceil(-math.log10(unitsPerDegree * precision))

			if numDigits &lt;= 0 then
				numDigits = tonumber("0")  -- for some reason, 'numDigits = 0' may actually store '-0', so parse from string instead
			end

			strFormat = "%." .. numDigits .. "f"

			if precision &gt;= 1 then
				latDegrees = strFormat:format(latitude)
				lonDegrees = strFormat:format(longitude)

				if not raw then
					latDegSym = replaceDecimalMark(latDegrees) .. degSymbol
					lonDegSym = replaceDecimalMark(lonDegrees) .. degSymbol
				else
					latDegSym = latDegrees .. degSymbol
					lonDegSym = lonDegrees .. degSymbol
				end
			else
				latConv = math.floor(latitude * unitsPerDegree * 10^numDigits + 0.5) / 10^numDigits
				lonConv = math.floor(longitude * unitsPerDegree * 10^numDigits + 0.5) / 10^numDigits

				if precision &gt;= (1 / 60) then
					latMinutes = latConv
					lonMinutes = lonConv
				else
					latSeconds = latConv
					lonSeconds = lonConv

					latMinutes = math.floor(latSeconds / 60)
					lonMinutes = math.floor(lonSeconds / 60)

					latSeconds = strFormat:format(latSeconds - (latMinutes * 60))
					lonSeconds = strFormat:format(lonSeconds - (lonMinutes * 60))

					if not raw then
						latSecSym = replaceDecimalMark(latSeconds) .. secSymbol
						lonSecSym = replaceDecimalMark(lonSeconds) .. secSymbol
					else
						latSecSym = latSeconds .. secSymbol
						lonSecSym = lonSeconds .. secSymbol
					end
				end

				latDegrees = math.floor(latMinutes / 60)
				lonDegrees = math.floor(lonMinutes / 60)

				latDegSym = latDegrees .. degSymbol
				lonDegSym = lonDegrees .. degSymbol

				latMinutes = latMinutes - (latDegrees * 60)
				lonMinutes = lonMinutes - (lonDegrees * 60)

				if precision &gt;= (1 / 60) then
					latMinutes = strFormat:format(latMinutes)
					lonMinutes = strFormat:format(lonMinutes)

					if not raw then
						latMinSym = replaceDecimalMark(latMinutes) .. minSymbol
						lonMinSym = replaceDecimalMark(lonMinutes) .. minSymbol
					else
						latMinSym = latMinutes .. minSymbol
						lonMinSym = lonMinutes .. minSymbol
					end
				else
					latMinSym = latMinutes .. minSymbol
					lonMinSym = lonMinutes .. minSymbol
				end
			end

			latValue = latDegSym .. latMinSym .. latSecSym .. latDirection
			lonValue = lonDegSym .. lonMinSym .. lonSecSym .. lonDirection

			value = latValue .. separator .. lonValue

			if link then
				globe = parseWikidataURL(datavalue['globe'])

				if globe then
					globe = mw.wikibase.getLabelByLang(globe, "en"):lower()
				else
					globe = "earth"
				end

				latLink = table.concat({latDegrees, latMinutes, latSeconds}, "_")
				lonLink = table.concat({lonDegrees, lonMinutes, lonSeconds}, "_")

				value = "[https://geohack.toolforge.org/geohack.php?language="..self.langCode.."&amp;params="..latLink.."_"..latDirectionEN.."_"..lonLink.."_"..lonDirectionEN.."_globe:"..globe.." "..value.."]"
			end

			return value
		elseif datatype == 'wikibase-entityid' then
			local label
			local itemID = datavalue['numeric-id']

			if subtype == 'wikibase-item' then
				itemID = "Q" .. itemID
			elseif subtype == 'wikibase-property' then
				itemID = "P" .. itemID
			else
				return '&lt;strong class="error"&gt;' .. errorText('unknown-data-type', subtype) .. '&lt;/strong&gt;'
			end

			label = self:getLabel(itemID, raw, link, short)

			if label == "" then
				label = nil
			end

			return label
		else
			return '&lt;strong class="error"&gt;' .. errorText('unknown-data-type', datatype) .. '&lt;/strong&gt;'
		end
	elseif snak.snaktype == 'somevalue' and not noSpecial then
		if raw then
			return " "  -- single space represents 'somevalue'
		else
			return i18n['values']['unknown']
		end
	elseif snak.snaktype == 'novalue' and not noSpecial then
		if raw then
			return ""  -- empty string represents 'novalue'
		else
			return i18n['values']['none']
		end
	else
		return nil
	end
end

function Config:getSingleRawQualifier(claim, qualifierID)
	local qualifiers

	if claim.qualifiers then qualifiers = claim.qualifiers[qualifierID] end

	if qualifiers and qualifiers[1] then
		return self:getValue(qualifiers[1], true)  -- raw = true
	else
		return nil
	end
end

function Config:snakEqualsValue(snak, value)
	local snakValue = self:getValue(snak, true)  -- raw = true

	if snakValue and snak.snaktype == 'value' and snak.datavalue.type == 'wikibase-entityid' then value = value:upper() end

	return snakValue == value
end

function Config:setRank(rank)
	local rankPos

	if rank == p.flags.best then
		self.bestRank = true
		self.flagBest = true  -- mark that 'best' flag was given
		return
	end

	if rank:sub(1,9) == p.flags.preferred then
		rankPos = 1
	elseif rank:sub(1,6) == p.flags.normal then
		rankPos = 2
	elseif rank:sub(1,10) == p.flags.deprecated then
		rankPos = 3
	else
		return
	end

	-- one of the rank flags was given, check if another one was given before
	if not self.flagRank then
		self.ranks = {false, false, false}  -- no other rank flag given before, so unset ranks
		self.bestRank = self.flagBest       -- unsets bestRank only if 'best' flag was not given before
		self.flagRank = true                -- mark that a rank flag was given
	end

	if rank:sub(-1) == "+" then
		for i = rankPos, 1, -1 do
			self.ranks[i] = true
		end
	elseif rank:sub(-1) == "-" then
		for i = rankPos, #self.ranks do
			self.ranks[i] = true
		end
	else
		self.ranks[rankPos] = true
	end
end

function Config:setPeriod(period)
	local periodPos

	if period == p.flags.future then
		periodPos = 1
	elseif period == p.flags.current then
		periodPos = 2
	elseif period == p.flags.former then
		periodPos = 3
	else
		return
	end

	-- one of the period flags was given, check if another one was given before
	if not self.flagPeriod then
		self.periods = {false, false, false}  -- no other period flag given before, so unset periods
		self.flagPeriod = true                -- mark that a period flag was given
	end

	self.periods[periodPos] = true
end

function Config:qualifierMatches(claim, id, value)
	local qualifiers

	if claim.qualifiers then qualifiers = claim.qualifiers[id] end
	if qualifiers then
		for _, v in pairs(qualifiers) do
			if self:snakEqualsValue(v, value) then
				return true
			end
		end
	elseif value == "" then
		-- if the qualifier is not present then treat it the same as the special value 'novalue'
		return true
	end

	return false
end

function Config:rankMatches(rankPos)
	if self.bestRank then
		return (self.ranks[rankPos] and self.foundRank &gt;= rankPos)
	else
		return self.ranks[rankPos]
	end
end

function Config:timeMatches(claim)
	local startTime = nil
	local startTimeY = nil
	local startTimeM = nil
	local startTimeD = nil
	local endTime = nil
	local endTimeY = nil
	local endTimeM = nil
	local endTimeD = nil

	if self.periods[1] and self.periods[2] and self.periods[3] then
		-- any time
		return true
	end

	startTime = self:getSingleRawQualifier(claim, aliasesP.startTime)
	if startTime and startTime ~= "" and startTime ~= " " then
		startTimeY, startTimeM, startTimeD = parseDate(startTime)
	end

	endTime = self:getSingleRawQualifier(claim, aliasesP.endTime)
	if endTime and endTime ~= "" and endTime ~= " " then
		endTimeY, endTimeM, endTimeD = parseDate(endTime)
	end

	if startTimeY ~= nil and endTimeY ~= nil and datePrecedesDate(endTimeY, endTimeM, endTimeD, startTimeY, startTimeM, startTimeD) then
		-- invalidate end time if it precedes start time
		endTimeY = nil
		endTimeM = nil
		endTimeD = nil
	end

	if self.periods[1] then
		-- future
		if startTimeY and datePrecedesDate(self.atDate[1], self.atDate[2], self.atDate[3], startTimeY, startTimeM, startTimeD) then
			return true
		end
	end

	if self.periods[2] then
		-- current
		if (startTimeY == nil or not datePrecedesDate(self.atDate[1], self.atDate[2], self.atDate[3], startTimeY, startTimeM, startTimeD)) and
		   (endTimeY == nil or datePrecedesDate(self.atDate[1], self.atDate[2], self.atDate[3], endTimeY, endTimeM, endTimeD)) then
			return true
		end
	end

	if self.periods[3] then
		-- former
		if endTimeY and not datePrecedesDate(self.atDate[1], self.atDate[2], self.atDate[3], endTimeY, endTimeM, endTimeD) then
			return true
		end
	end

	return false
end

function Config:processFlag(flag)
	if not flag then
		return false
	end

	if flag == p.flags.linked then
		self.curState.linked = true
		return true
	elseif flag == p.flags.raw then
		self.curState.rawValue = true

		if self.curState == self.states[parameters.reference] then
			-- raw reference values end with periods and require a separator (other than none)
			self.separators["sep%r"][1] = {" "}
		end

		return true
	elseif flag == p.flags.short then
		self.curState.shortName = true
		return true
	elseif flag == p.flags.multilanguage then
		self.curState.anyLanguage = true
		return true
	elseif flag == p.flags.unit then
		self.curState.unitOnly = true
		return true
	elseif flag == p.flags.mdy then
		self.mdyDate = true
		return true
	elseif flag == p.flags.single then
		self.singleClaim = true
		return true
	elseif flag == p.flags.sourced then
		self.sourcedOnly = true
		return true
	elseif flag == p.flags.edit then
		self.editable = true
		return true
	elseif flag == p.flags.editAtEnd then
		self.editable = true
		self.editAtEnd = true
		return true
	elseif flag == p.flags.best or flag:match('^'..p.flags.preferred..'[+-]?$') or flag:match('^'..p.flags.normal..'[+-]?$') or flag:match('^'..p.flags.deprecated..'[+-]?$') then
		self:setRank(flag)
		return true
	elseif flag == p.flags.future or flag == p.flags.current or flag == p.flags.former then
		self:setPeriod(flag)
		return true
	elseif flag == "" then
		-- ignore empty flags and carry on
		return true
	else
		return false
	end
end

function Config:processFlagOrCommand(flag)
	local param = ""

	if not flag then
		return false
	end

	if flag == p.claimCommands.property or flag == p.claimCommands.properties then
		param = parameters.property
	elseif flag == p.claimCommands.qualifier or flag == p.claimCommands.qualifiers then
		self.states.qualifiersCount = self.states.qualifiersCount + 1
		param = parameters.qualifier .. self.states.qualifiersCount
		self.separators["sep"..param] = {copyTable(defaultSeparators["sep%q\\d"])}
	elseif flag == p.claimCommands.reference or flag == p.claimCommands.references then
		param = parameters.reference
	else
		return self:processFlag(flag)
	end

	if self.states[param] then
		return false
	end

	-- create a new state for each command
	self.states[param] = State:new(self, param)

	-- use "%x" as the general parameter name
	self.states[param].parsedFormat = parseFormat(parameters.general)  -- will be overwritten for param=="%p"

	-- set the separator
	self.states[param].separator = self.separators["sep"..param]  -- will be nil for param=="%p", which will be set separately

	if flag == p.claimCommands.property or flag == p.claimCommands.qualifier or flag == p.claimCommands.reference then
		self.states[param].singleValue = true
	end

	self.curState = self.states[param]

	return true
end

function Config:processSeparators(args)
	local sep

	for i, v in pairs(self.separators) do
		if args[i] then
			sep = replaceSpecialChars(args[i])

			if sep ~= "" then
				self.separators[i][1] = {sep}
			else
				self.separators[i][1] = nil
			end
		end
	end
end

function Config:setFormatAndSeparators(state, parsedFormat)
	state.parsedFormat = parsedFormat
	state.separator = self.separators["sep"]
	state.movSeparator = self.separators["sep"..parameters.separator]
	state.puncMark = self.separators["punc"]
end

-- determines if a claim has references by prefetching them from the claim using getReferences,
-- which applies some filtering that determines if a reference is actually returned,
-- and caches the references for later use
function State:isSourced(claim)
	self.conf.prefetchedRefs = self:getReferences(claim)
	return (#self.conf.prefetchedRefs &gt; 0)
end

function State:resetCaches()
	-- any prefetched references of the previous claim must not be used
	self.conf.prefetchedRefs = nil
end

function State:claimMatches(claim)
	local matches, rankPos

	-- first of all, reset any cached values used for the previous claim
	self:resetCaches()

	-- if a property value was given, check if it matches the claim's property value
	if self.conf.propertyValue then
		matches = self.conf:snakEqualsValue(claim.mainsnak, self.conf.propertyValue)
	else
		matches = true
	end

	-- if any qualifier values were given, check if each matches one of the claim's qualifier values
	for i, v in pairs(self.conf.qualifierIDsAndValues) do
		matches = (matches and self.conf:qualifierMatches(claim, i, v))
	end

	-- check if the claim's rank and time period match
	rankPos = rankTable[claim.rank] or 4
	matches = (matches and self.conf:rankMatches(rankPos) and self.conf:timeMatches(claim))

	-- if only claims with references must be returned, check if this one has any
	if self.conf.sourcedOnly then
		matches = (matches and self:isSourced(claim))  -- prefetches and caches references
	end

	return matches, rankPos
end

function State:out()
	local result  -- collection of arrays with value objects
	local valuesArray  -- array with value objects
	local sep = nil  -- value object
	local out = {}  -- array with value objects

	local function walk(formatTable, result)
		local valuesArray = {}  -- array with value objects

		for i, v in pairs(formatTable.req) do
			if not result[i] or not result[i][1] then
				-- we've got no result for a parameter that is required on this level,
				-- so skip this level (and its children) by returning an empty result
				return {}
			end
		end

		for _, v in ipairs(formatTable) do
			if v.param then
				valuesArray = mergeArrays(valuesArray, result[v.str])
			elseif v.str ~= "" then
				valuesArray[#valuesArray + 1] = {v.str}
			end

			if v.child then
				valuesArray = mergeArrays(valuesArray, walk(v.child, result))
			end
		end

		return valuesArray
	end

	-- iterate through the results from back to front, so that we know when to add separators
	for i = #self.results, 1, -1 do
		result = self.results[i]

		-- if there is already some output, then add the separators
		if #out &gt; 0 then
			sep = self.separator[1]  -- fixed separator
			result[parameters.separator] = {self.movSeparator[1]}  -- movable separator
		else
			sep = nil
			result[parameters.separator] = {self.puncMark[1]}  -- optional punctuation mark
		end

		valuesArray = walk(self.parsedFormat, result)

		if #valuesArray &gt; 0 then
			if sep then
				valuesArray[#valuesArray + 1] = sep
			end

			out = mergeArrays(valuesArray, out)
		end
	end

	-- reset state before next iteration
	self.results = {}

	return out
end

-- level 1 hook
function State:getProperty(claim)
	local value = {self:getValue(claim.mainsnak)}  -- create one value object

	if #value &gt; 0 then
		return {value}  -- wrap the value object in an array and return it
	else
		return {}  -- return empty array if there was no value
	end
end

-- level 1 hook
function State:getQualifiers(claim, param)
	local qualifiers

	if claim.qualifiers then qualifiers = claim.qualifiers[self.conf.qualifierIDs[param]] end
	if qualifiers then
		-- iterate through claim's qualifier statements to collect their values;
		-- return array with multiple value objects
		return self.conf.states[param]:iterate(qualifiers, {[parameters.general] = hookNames[parameters.qualifier.."\\d"][2], count = 1})  -- pass qualifier state with level 2 hook
	else
		return {}  -- return empty array
	end
end

-- level 2 hook
function State:getQualifier(snak)
	local value = {self:getValue(snak)}  -- create one value object

	if #value &gt; 0 then
		return {value}  -- wrap the value object in an array and return it
	else
		return {}  -- return empty array if there was no value
	end
end

-- level 1 hook
function State:getAllQualifiers(claim, param, result, hooks)
	local out = {}  -- array with value objects
	local sep = self.conf.separators["sep"..parameters.qualifier][1]  -- value object

	-- iterate through the output of the separate "qualifier(s)" commands
	for i = 1, self.conf.states.qualifiersCount do

		-- if a hook has not been called yet, call it now
		if not result[parameters.qualifier..i] then
			self:callHook(parameters.qualifier..i, hooks, claim, result)
		end

		-- if there is output for this particular "qualifier(s)" command, then add it
		if result[parameters.qualifier..i] and result[parameters.qualifier..i][1] then

			-- if there is already some output, then add the separator
			if #out &gt; 0 and sep then
				out[#out + 1] = sep
			end

			out = mergeArrays(out, result[parameters.qualifier..i])
		end
	end

	return out
end

-- level 1 hook
function State:getReferences(claim)
	if self.conf.prefetchedRefs then
		-- return references that have been prefetched by isSourced
		return self.conf.prefetchedRefs
	end

	if claim.references then
		-- iterate through claim's reference statements to collect their values;
		-- return array with multiple value objects
		return self.conf.states[parameters.reference]:iterate(claim.references, {[parameters.general] = hookNames[parameters.reference][2], count = 1})  -- pass reference state with level 2 hook
	else
		return {}  -- return empty array
	end
end

-- level 2 hook
function State:getReference(statement)
	local citeParamMapping = i18n['cite']['param-mapping']
	local citeConfig = i18n['cite']['config']
	local citeTypes = i18n['cite']['output-types']
	
	-- will hold rendered properties of the reference which are not directly from statement.snaks, 
	-- Namely, these are a backup title from "subject named as" and a URL generated from an external ID.
    local additionalProcessedProperties = {}
    -- for each citation type, there will be an associative array that associates lists of rendered properties
    -- to citation-template parameters
    local groupedProcessedProperties = {}
    -- like above, but only associates one rendered property to each parameter; if the above variable
    -- contains more strings for a parameter, the strings will be assigned to numbered params (e.g. "author1")
	local citeParams = {}

	local citeErrors = {}
	local referenceEmpty = true  -- will be set to false if at least one parameter is left unremoved

	local version = 11  -- increment this each time the below logic is changed to avoid conflict errors

	if not statement.snaks then
		return {}
	end

	-- don't use bot-added references referencing Wikimedia projects or containing "inferred from" (such references are not usable on Wikipedia)
	if statement.snaks[aliasesP.importedFrom] or statement.snaks[aliasesP.wikimediaImportURL] or statement.snaks[aliasesP.inferredFrom] then
		return {}
	end
	
	-- don't include "type of reference"
	if statement.snaks[aliasesP.typeOfReference] then
		statement.snaks[aliasesP.typeOfReference] = nil
	end

	-- don't include "image" to prevent littering
	if statement.snaks[aliasesP.image] then
		statement.snaks[aliasesP.image] = nil
	end

	-- don't include "language" if it is equal to the local one
	if self:getReferenceDetail(statement.snaks, aliasesP.language) == self.conf.langName then
		statement.snaks[aliasesP.language] = nil
	end
    
    if statement.snaks[aliasesP.statedIn] and not statement.snaks[aliasesP.referenceURL] then
    	-- "stated in" was given but "reference URL" was not.
    	-- get "Wikidata property" properties from the item in "stated in"
    	-- if any of the returned properties of the external-id datatype is in statement.snaks, generate a link from it and use the link in the reference
    	
    	-- find the "Wikidata property" properties in the item from "stated in"
    	local wikidataPropertiesOfSource = mw.text.split(p._properties{p.flags.raw, aliasesP.wikidataProperty, [p.args.eid] = self.conf:getValue(statement.snaks[aliasesP.statedIn][1], true, false)}, ", ", true)
    	for i, wikidataPropertyOfSource in pairs(wikidataPropertiesOfSource) do
    		if statement.snaks[wikidataPropertyOfSource] and statement.snaks[wikidataPropertyOfSource][1].datatype == "external-id" then
    			local tempLink = self:getReferenceDetail(statement.snaks, wikidataPropertyOfSource, false, true)  -- not raw, linked
    			if mw.ustring.match(tempLink, "^%[%Z- %Z+%]$") then  -- getValue returned a URL in square brackets.
    				-- the link is in wiki markup, so strip the square brackets and the display text
    				-- gsub also returns another, discarted value, therefore the result is assigned to tempLink first
    				tempLink = mw.ustring.gsub(tempLink, "^%[(%Z-) %Z+%]$", "%1")
    		    	additionalProcessedProperties[aliasesP.referenceURL] = {tempLink}
    			    statement.snaks[wikidataPropertyOfSource] = nil
    			    break
    			end
    		end
    	end
    end
    
    -- don't include "subject named as", but use it as the title when "title" is not present but a URL is
    if statement.snaks[aliasesP.subjectNamedAs] then
    	if not statement.snaks[aliasesP.title] and (statement.snaks[aliasesP.referenceURL] or additionalProcessedProperties[aliasesP.referenceURL]) then
    		additionalProcessedProperties[aliasesP.title] = {self:getReferenceDetail(statement.snaks, aliasesP.subjectNamedAs, false, false, true)}  -- not raw, not linked, anyLang
    	end
    	statement.snaks[aliasesP.subjectNamedAs] = nil
    end
    
    -- initialize groupedProcessedProperties and citeParams
    for _, citeType in ipairs(citeTypes) do
    	groupedProcessedProperties[citeType] = {}
    	citeParams[citeType] = {}
    end

	-- fill groupedProcessedProperties
	for refProperty in pairs(statement.snaks) do
		-- add the parameter to each matching type of citation
		for _, citeType in ipairs(citeTypes) do
			repeat  -- just a simple wrapper to emulate "continue"
				-- skip if there already have been errors
				if citeErrors[citeType] then
					break
				end
				
				-- set mappingKey and prefix
				local mappingKey
				local prefix = ""
				if statement.snaks[refProperty][1].datatype == 'external-id' then
					mappingKey = "external-id"
					prefix = self.conf:getLabel(refProperty)
		
					if prefix ~= "" then
						prefix = prefix .. " "
					end
				else
					mappingKey = refProperty
				end
				
				local paramName = citeParamMapping[citeType][mappingKey]
				-- skip properties with empty parameter name
				if paramName == "" then
					break
				end
				
				referenceEmpty = false

				-- handle unknown properties in the reference
				if not paramName then
					local error_message = errorText("unknown-property-in-ref", refProperty)
					assert(error_message)  -- Should not be nil
					citeErrors[citeType] = error_message
					break
				end
				
				-- set processedProperty
				local processedProperty
				local raw = false  -- if the value is wanted raw
				if isValueInTable(paramName, citeConfig[citeType]["raw-value-params"] or {}) then
					raw = true
				end
				if isValueInTable(paramName, citeConfig[citeType]["numbered-params"] or {}) then
					-- Multiple values may be given.
					processedProperty = self:getReferenceDetails(statement.snaks, refProperty, raw, self.linked, true)  -- anyLang = true
				else
					-- If multiple values are given, all but the first suitable one are discarted.
					processedProperty = {self:getReferenceDetail(statement.snaks, refProperty, raw, self.linked and (statement.snaks[refProperty][1].datatype ~= 'url'), true)}  -- link = true/false, anyLang = true
				end
		
				if #processedProperty == 0 then
					break	
				end
                
                -- add an entry to groupedProcessedProperties
                if not groupedProcessedProperties[citeType][paramName] then
                	groupedProcessedProperties[citeType][paramName] = {}
                end
                for _, propertyValue in pairs(processedProperty) do
                	table.insert(groupedProcessedProperties[citeType][paramName], prefix .. propertyValue)
                end
            until true
		end
	end
	
	-- handle additional properties
	for refProperty in pairs(additionalProcessedProperties) do
		for _, citeType in ipairs(citeTypes) do
			repeat
				-- skip if there already have been errors
				if citeErrors[citeType] then
					break
				end
				
                local paramName = citeParamMapping[citeType][refProperty]
				-- handle unknown properties in the reference
				if not paramName then
					-- Skip this additional property, but do not cause an error.
					break
				end
				if paramName == "" then
					break
				end
				
				referenceEmpty = false
                
                if not groupedProcessedProperties[citeType][paramName] then
                	groupedProcessedProperties[citeType][paramName] = {}
                end
                for _, propertyValue in pairs(additionalProcessedProperties[refProperty]) do
                	table.insert(groupedProcessedProperties[citeType][paramName], propertyValue)
                end
			until true
		end
	end
	
	-- fill citeParams
	for _, citeType in ipairs(citeTypes) do
		for paramName, paramValues in pairs(groupedProcessedProperties[citeType]) do
			if #paramValues == 1 or not isValueInTable(paramName, citeConfig[citeType]["numbered-params"] or {}) then
				citeParams[citeType][paramName] = paramValues[1]
			else
				-- There is more than one value for this parameter - the values will
				-- go into separate numbered parameters (e.g. "author1", "author2")
				for paramNum, paramValue in pairs(paramValues) do
					citeParams[citeType][paramName .. paramNum] = paramValue
				end
			end
		end
	end
	
	-- handle missing mandatory parameters for the templates
	for _, citeType in ipairs(citeTypes) do
		for _, requiredCiteParam in pairs(citeConfig[citeType]["mandatory-params"] or {}) do
			if not citeParams[citeType][requiredCiteParam] then  -- The required param is not present.
				if citeErrors[citeType] then  -- Do not override the previous error, if it exists.
					break
				end
				local error_message = errorText("missing-mandatory-param", requiredCiteParam)
				assert(error_message)  -- Should not be nil
				citeErrors[citeType] = error_message
			end
		end
	end
	
	local citeTypeToUse = nil

    -- choose the output template
    for _, citeType in ipairs(citeTypes) do
    	if not citeErrors[citeType] then
    		citeTypeToUse = citeType 
    		break
    	end
    end

	-- set refContent
	local refContent = ""
	if citeTypeToUse then
		local templateToUse = citeConfig[citeTypeToUse]["template"]
		local paramsToUse = citeParams[citeTypeToUse]
		
		if not templateToUse or templateToUse == "" then 
			throwError("no-such-reference-template", tostring(templateToUse), i18nPath, citeTypeToUse)
		end
		
		-- if this module is being substituted then build a regular template call, otherwise expand the template
		if mw.isSubsting() then
			for i, v in pairs(paramsToUse) do
				refContent = refContent .. "|" .. i .. "=" .. v
			end

			refContent = "{{" .. templateToUse .. refContent .. "}}"
		else
			xpcall(
				function () refContent = mw.getCurrentFrame():expandTemplate{title=templateToUse, args=paramsToUse} end,
				function () throwError("no-such-reference-template", templateToUse, i18nPath, citeTypeToUse) end
			)
		end

	-- If the citation couldn't be displayed using any template, but is not empty (barring ignored propeties), throw an error.
	elseif not referenceEmpty then
		refContent = errorText("malformed-reference-header")
	    for _, citeType in ipairs(citeTypes) do
	    	refContent = refContent .. errorText("template-failure-reason", citeConfig[citeType]["template"], citeErrors[citeType])
	    end
		refContent = refContent .. errorText("malformed-reference-footer")
	end

    -- wrap refContent
	local ref = {}
	if refContent ~= "" then
		ref = {refContent}

		if not self.rawValue then
			-- this should become a &lt;ref&gt; tag, so save the reference's hash for later
			ref.refHash = "wikidata-" .. statement.hash .. "-v" .. (tonumber(i18n['version']) + version)
		end
		return {ref}
	else
		return {}
	end
end

-- gets a detail of one particular type for a reference
function State:getReferenceDetail(snaks, dType, raw, link, anyLang)
	local switchLang = anyLang
	local value = nil

	if not snaks[dType] then
		return nil
	end

	-- if anyLang, first try the local language and otherwise any language
	repeat
		for _, v in ipairs(snaks[dType]) do
			value = self.conf:getValue(v, raw, link, false, anyLang and not switchLang, false, true)  -- noSpecial = true

			if value then
				break
			end
		end

		if value or not anyLang then
			break
		end

		switchLang = not switchLang
	until anyLang and switchLang

	return value
end

-- gets the details of one particular type for a reference
function State:getReferenceDetails(snaks, dType, raw, link, anyLang)
	local values = {}

	if not snaks[dType] then
		return {}
	end

	for _, v in ipairs(snaks[dType]) do
		-- if nil is returned then it will not be added to the table
		values[#values + 1] = self.conf:getValue(v, raw, link, false, anyLang, false, true)  -- noSpecial = true
	end

	return values
end

-- level 1 hook
function State:getAlias(object)
	local value = object.value
	local title = nil

	if value and self.linked then
		if self.conf.entityID:sub(1,1) == "Q" then
			title = mw.wikibase.getSitelink(self.conf.entityID)
		elseif self.conf.entityID:sub(1,1) == "P" then
			title = "d:Property:" .. self.conf.entityID
		end

		if title then
			value = buildWikilink(title, value)
		end
	end

	value = {value}  -- create one value object

	if #value &gt; 0 then
		return {value}  -- wrap the value object in an array and return it
	else
		return {}  -- return empty array if there was no value
	end
end

-- level 1 hook
function State:getBadge(value)
	value = self.conf:getLabel(value, self.rawValue, self.linked, self.shortName)

	if value == "" then
		value = nil
	end

	value = {value}  -- create one value object

	if #value &gt; 0 then
		return {value}  -- wrap the value object in an array and return it
	else
		return {}  -- return empty array if there was no value
	end
end

function State:callHook(param, hooks, statement, result)
	-- call a parameter's hook if it has been defined and if it has not been called before
	if not result[param] and hooks[param] then
		local valuesArray = self[hooks[param]](self, statement, param, result, hooks)  -- array with value objects

		-- add to the result
		if #valuesArray &gt; 0 then
			result[param] = valuesArray
			result.count = result.count + 1
		else
			result[param] = {}  -- an empty array to indicate that we've tried this hook already
			return true  -- miss == true
		end
	end

	return false
end

-- iterate through claims, claim's qualifiers or claim's references to collect values
function State:iterate(statements, hooks, matchHook)
	matchHook = matchHook or alwaysTrue

	local matches = false
	local rankPos = nil
	local result, gotRequired

	for _, v in ipairs(statements) do
		-- rankPos will be nil for non-claim statements (e.g. qualifiers, references, etc.)
		matches, rankPos = matchHook(self, v)

		if matches then
			result = {count = 0}  -- collection of arrays with value objects

			local function walk(formatTable)
				local miss

				for i2, v2 in pairs(formatTable.req) do
					-- call a hook, adding its return value to the result
					miss = self:callHook(i2, hooks, v, result)

					if miss then
						-- we miss a required value for this level, so return false
						return false
					end

					if result.count == hooks.count then
						-- we're done if all hooks have been called;
						-- returning at this point breaks the loop
						return true
					end
				end

				for _, v2 in ipairs(formatTable) do
					if result.count == hooks.count then
						-- we're done if all hooks have been called;
						-- returning at this point prevents further childs from being processed
						return true
					end

					if v2.child then
						walk(v2.child)
					end
				end

				return true
			end
			gotRequired = walk(self.parsedFormat)

			-- only append the result if we got values for all required parameters on the root level
			if gotRequired then
				-- if we have a rankPos (only with matchHook() for complete claims), then update the foundRank
				if rankPos and self.conf.foundRank &gt; rankPos then
					self.conf.foundRank = rankPos
				end

				-- append the result
				self.results[#self.results + 1] = result

				-- break if we only need a single value
				if self.singleValue then
					break
				end
			end
		end
	end

	return self:out()
end

local function getEntityId(arg, eid, page, allowOmitPropPrefix, globalSiteId)
	local id = nil
	local prop = nil

	if arg then
		if arg:sub(1,1) == ":" then
			page = arg
			eid = nil
		elseif arg:sub(1,1):upper() == "Q" or arg:sub(1,9):lower() == "property:" or allowOmitPropPrefix then
			eid = arg
			page = nil
		else
			prop = arg
		end
	end

	if eid then
		if eid:sub(1,9):lower() == "property:" then
			id = replaceAlias(mw.text.trim(eid:sub(10)))

			if id:sub(1,1):upper() ~= "P" then
				id = ""
			end
		else
			id = replaceAlias(eid)
		end
	elseif page then
		if page:sub(1,1) == ":" then
			page = mw.text.trim(page:sub(2))
		end

		id = mw.wikibase.getEntityIdForTitle(page, globalSiteId) or ""
	end

	if not id then
		id = mw.wikibase.getEntityIdForCurrentPage() or ""
	end

	id = id:upper()

	if not mw.wikibase.isValidEntityId(id) then
		id = ""
	end

	return id, prop
end

local function nextArg(args)
	local arg = args[args.pointer]

	if arg then
		args.pointer = args.pointer + 1
		return mw.text.trim(arg)
	else
		return nil
	end
end

local function claimCommand(args, funcName)
	local cfg = Config:new()
	cfg:processFlagOrCommand(funcName)  -- process first command (== function name)

	local lastArg, parsedFormat, formatParams, claims, value
	local hooks = {count = 0}

	-- set the date if given;
	-- must come BEFORE processing the flags
	if args[p.args.date] then
		cfg.atDate = {parseDate(args[p.args.date])}
		cfg.periods = {false, true, false}  -- change default time constraint to 'current'
	end

	-- process flags and commands
	repeat
		lastArg = nextArg(args)
	until not cfg:processFlagOrCommand(lastArg)

	-- get the entity ID from either the positional argument, the eid argument or the page argument
	cfg.entityID, cfg.propertyID = getEntityId(lastArg, args[p.args.eid], args[p.args.page], false, args[p.args.globalSiteId])

	if cfg.entityID == "" then
		return ""  -- we cannot continue without a valid entity ID
	end

	cfg.entity = mw.wikibase.getEntity(cfg.entityID)

	if not cfg.propertyID then
		cfg.propertyID = nextArg(args)
	end

	cfg.propertyID = replaceAlias(cfg.propertyID)

	if not cfg.entity or not cfg.propertyID then
		return ""  -- we cannot continue without an entity or a property ID
	end

	cfg.propertyID = cfg.propertyID:upper()

	if not cfg.entity.claims or not cfg.entity.claims[cfg.propertyID] then
		return ""  -- there is no use to continue without any claims
	end

	claims = cfg.entity.claims[cfg.propertyID]

	if cfg.states.qualifiersCount &gt; 0 then
		-- do further processing if "qualifier(s)" command was given

		if #args - args.pointer + 1 &gt; cfg.states.qualifiersCount then
			-- claim ID or literal value has been given

			cfg.propertyValue = nextArg(args)
		end

		for i = 1, cfg.states.qualifiersCount do
			-- check if given qualifier ID is an alias and add it
			cfg.qualifierIDs[parameters.qualifier..i] = replaceAlias(nextArg(args) or ""):upper()
		end
	elseif cfg.states[parameters.reference] then
		-- do further processing if "reference(s)" command was given

		cfg.propertyValue = nextArg(args)
	end

	-- check for special property value 'somevalue' or 'novalue'
	if cfg.propertyValue then
		cfg.propertyValue = replaceSpecialChars(cfg.propertyValue)

		if cfg.propertyValue ~= "" and mw.text.trim(cfg.propertyValue) == "" then
			cfg.propertyValue = " "  -- single space represents 'somevalue', whereas empty string represents 'novalue'
		else
			cfg.propertyValue = mw.text.trim(cfg.propertyValue)
		end
	end

	-- parse the desired format, or choose an appropriate format
	if args["format"] then
		parsedFormat, formatParams = parseFormat(args["format"])
	elseif cfg.states.qualifiersCount &gt; 0 then  -- "qualifier(s)" command given
		if cfg.states[parameters.property] then  -- "propert(y|ies)" command given
			parsedFormat, formatParams = parseFormat(formats.propertyWithQualifier)
		else
			parsedFormat, formatParams = parseFormat(formats.qualifier)
		end
	elseif cfg.states[parameters.property] then  -- "propert(y|ies)" command given
		parsedFormat, formatParams = parseFormat(formats.property)
	else  -- "reference(s)" command given
		parsedFormat, formatParams = parseFormat(formats.reference)
	end

	-- if a "qualifier(s)" command and no "propert(y|ies)" command has been given, make the movable separator a semicolon
	if cfg.states.qualifiersCount &gt; 0 and not cfg.states[parameters.property] then
		cfg.separators["sep"..parameters.separator][1] = {";"}
	end

	-- if only "reference(s)" has been given, set the default separator to none (except when raw)
	if cfg.states[parameters.reference] and not cfg.states[parameters.property] and cfg.states.qualifiersCount == 0
	   and not cfg.states[parameters.reference].rawValue then
		cfg.separators["sep"][1] = nil
	end

	-- if exactly one "qualifier(s)" command has been given, make "sep%q" point to "sep%q1" to make them equivalent
	if cfg.states.qualifiersCount == 1 then
		cfg.separators["sep"..parameters.qualifier] = cfg.separators["sep"..parameters.qualifier.."1"]
	end

	-- process overridden separator values;
	-- must come AFTER tweaking the default separators
	cfg:processSeparators(args)

	-- define the hooks that should be called (getProperty, getQualifiers, getReferences);
	-- only define a hook if both its command ("propert(y|ies)", "reference(s)", "qualifier(s)") and its parameter ("%p", "%r", "%q1", "%q2", "%q3") have been given
	for i, v in pairs(cfg.states) do
		-- e.g. 'formatParams["%q1"] or formatParams["%q"]' to define hook even if "%q1" was not defined to be able to build a complete value for "%q"
		if formatParams[i] or formatParams[i:sub(1, 2)] then
			hooks[i] = getHookName(i, 1)
			hooks.count = hooks.count + 1
		end
	end

	-- the "%q" parameter is not attached to a state, but is a collection of the results of multiple states (attached to "%q1", "%q2", "%q3", ...);
	-- so if this parameter is given then this hook must be defined separately, but only if at least one "qualifier(s)" command has been given
	if formatParams[parameters.qualifier] and cfg.states.qualifiersCount &gt; 0 then
		hooks[parameters.qualifier] = getHookName(parameters.qualifier, 1)
		hooks.count = hooks.count + 1
	end

	-- create a state for "properties" if it doesn't exist yet, which will be used as a base configuration for each claim iteration;
	-- must come AFTER defining the hooks
	if not cfg.states[parameters.property] then
		cfg.states[parameters.property] = State:new(cfg, parameters.property)

		-- if the "single" flag has been given then this state should be equivalent to "property" (singular)
		if cfg.singleClaim then
			cfg.states[parameters.property].singleValue = true
		end
	end

	-- if the "sourced" flag has been given then create a state for "reference" if it doesn't exist yet, using default values,
	-- which must exist in order to be able to determine if a claim has any references;
	-- must come AFTER defining the hooks
	if cfg.sourcedOnly and not cfg.states[parameters.reference] then
		cfg:processFlagOrCommand(p.claimCommands.reference)  -- use singular "reference" to minimize overhead
	end

	-- set the parsed format and the separators (and optional punctuation mark);
	-- must come AFTER creating the additonal states
	cfg:setFormatAndSeparators(cfg.states[parameters.property], parsedFormat)

	-- process qualifier matching values, analogous to cfg.propertyValue
	for i, v in pairs(args) do
		i = tostring(i)

		if i:match('^[Pp]%d+$') or aliasesP[i] then
			v = replaceSpecialChars(v)

			-- check for special qualifier value 'somevalue'
			if v ~= "" and mw.text.trim(v) == "" then
				v = " "  -- single space represents 'somevalue'
			end

			cfg.qualifierIDsAndValues[replaceAlias(i):upper()] = v
		end
	end

	-- first sort the claims on rank to pre-define the order of output (preferred first, then normal, then deprecated)
	claims = sortOnRank(claims)

	-- then iterate through the claims to collect values
	value = cfg:concatValues(cfg.states[parameters.property]:iterate(claims, hooks, State.claimMatches))  -- pass property state with level 1 hooks and matchHook

	-- if desired, add a clickable icon that may be used to edit the returned values on Wikidata
	if cfg.editable and value ~= "" then
		value = value .. cfg:getEditIcon()
	end

	return value
end

local function generalCommand(args, funcName)
	local cfg = Config:new()
	cfg.curState = State:new(cfg)

	local lastArg
	local value = nil

	repeat
		lastArg = nextArg(args)
	until not cfg:processFlag(lastArg)

	-- get the entity ID from either the positional argument, the eid argument or the page argument
	cfg.entityID = getEntityId(lastArg, args[p.args.eid], args[p.args.page], true, args[p.args.globalSiteId])

	if cfg.entityID == "" or not mw.wikibase.entityExists(cfg.entityID) then
		return ""  -- we cannot continue without an entity
	end

	-- serve according to the given command
	if funcName == p.generalCommands.label then
		value = cfg:getLabel(cfg.entityID, cfg.curState.rawValue, cfg.curState.linked, cfg.curState.shortName)
	elseif funcName == p.generalCommands.title then
		cfg.inSitelinks = true

		if cfg.entityID:sub(1,1) == "Q" then
			value = mw.wikibase.getSitelink(cfg.entityID)
		end

		if cfg.curState.linked and value then
			value = buildWikilink(value)
		end
	elseif funcName == p.generalCommands.description then
		value = mw.wikibase.getDescription(cfg.entityID)
	else
		local parsedFormat, formatParams
		local hooks = {count = 0}

		cfg.entity = mw.wikibase.getEntity(cfg.entityID)

		if funcName == p.generalCommands.alias or funcName == p.generalCommands.badge then
			cfg.curState.singleValue = true
		end

		if funcName == p.generalCommands.alias or funcName == p.generalCommands.aliases then
			if not cfg.entity.aliases or not cfg.entity.aliases[cfg.langCode] then
				return ""  -- there is no use to continue without any aliasses
			end

			local aliases = cfg.entity.aliases[cfg.langCode]

			-- parse the desired format, or parse the default aliases format
			if args["format"] then
				parsedFormat, formatParams = parseFormat(args["format"])
			else
				parsedFormat, formatParams = parseFormat(formats.alias)
			end

			-- process overridden separator values;
			-- must come AFTER tweaking the default separators
			cfg:processSeparators(args)

			-- define the hook that should be called (getAlias);
			-- only define the hook if the parameter ("%a") has been given
			if formatParams[parameters.alias] then
				hooks[parameters.alias] = getHookName(parameters.alias, 1)
				hooks.count = hooks.count + 1
			end

			-- set the parsed format and the separators (and optional punctuation mark)
			cfg:setFormatAndSeparators(cfg.curState, parsedFormat)

			-- iterate to collect values
			value = cfg:concatValues(cfg.curState:iterate(aliases, hooks))
		elseif funcName == p.generalCommands.badge or funcName == p.generalCommands.badges then
			if not cfg.entity.sitelinks or not cfg.entity.sitelinks[cfg.siteID] or not cfg.entity.sitelinks[cfg.siteID].badges then
				return ""  -- there is no use to continue without any badges
			end

			local badges = cfg.entity.sitelinks[cfg.siteID].badges

			cfg.inSitelinks = true

			-- parse the desired format, or parse the default aliases format
			if args["format"] then
				parsedFormat, formatParams = parseFormat(args["format"])
			else
				parsedFormat, formatParams = parseFormat(formats.badge)
			end

			-- process overridden separator values;
			-- must come AFTER tweaking the default separators
			cfg:processSeparators(args)

			-- define the hook that should be called (getBadge);
			-- only define the hook if the parameter ("%b") has been given
			if formatParams[parameters.badge] then
				hooks[parameters.badge] = getHookName(parameters.badge, 1)
				hooks.count = hooks.count + 1
			end

			-- set the parsed format and the separators (and optional punctuation mark)
			cfg:setFormatAndSeparators(cfg.curState, parsedFormat)

			-- iterate to collect values
			value = cfg:concatValues(cfg.curState:iterate(badges, hooks))
		end
	end

	value = value or ""

	if cfg.editable and value ~= "" then
		-- if desired, add a clickable icon that may be used to edit the returned value on Wikidata
		value = value .. cfg:getEditIcon()
	end

	return value
end

-- modules that include this module should call the functions with an underscore prepended, e.g.: p._property(args)
local function establishCommands(commandList, commandFunc)
	for _, commandName in pairs(commandList) do
		local function wikitextWrapper(frame)
			local args = copyTable(frame.args)
			args.pointer = 1
			loadI18n(aliasesP, frame)
			return commandFunc(args, commandName)
		end
		p[commandName] = wikitextWrapper

		local function luaWrapper(args)
			args = copyTable(args)
			args.pointer = 1
			loadI18n(aliasesP)
			return commandFunc(args, commandName)
		end
		p["_" .. commandName] = luaWrapper
	end
end

establishCommands(p.claimCommands, claimCommand)
establishCommands(p.generalCommands, generalCommand)

-- main function that is supposed to be used by wrapper templates
function p.main(frame)
	if not mw.wikibase then return nil end

	local f, args

	loadI18n(aliasesP, frame)

	-- get the parent frame to take the arguments that were passed to the wrapper template
	frame = frame:getParent() or frame

	if not frame.args[1] then
		throwError("no-function-specified")
	end

	f = mw.text.trim(frame.args[1])

	if f == "main" then
		throwError("main-called-twice")
	end

	assert(p["_"..f], errorText('no-such-function', f))

	-- copy arguments from immutable to mutable table
	args = copyTable(frame.args)

	-- remove the function name from the list
	table.remove(args, 1)

	return p["_"..f](args)
end

return p</text>
      <sha1>fw0wujzhw9loowczj4s2zaqoeawla5r</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Wd/i18n</title>
    <ns>828</ns>
    <id>55</id>
    <revision>
      <id>98</id>
      <parentid>97</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>97</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6416" sha1="9x26xqgg01idb8drjyqhb64or1txdtn" xml:space="preserve">-- The values and functions in this submodule should be localized per wiki.

local p = {}

function p.init(aliasesP)
	p = {
		["version"] = "7",  -- increment this each time the below parameters are changed to avoid reference conflict errors
		["errors"] = {
			["unknown-data-type"]          = "Unknown or unsupported datatype '%s'.",
			["missing-required-parameter"] = "No required parameters defined, needing at least one",
			["extra-required-parameter"]   = "Parameter '%s' must be defined as optional",
			["no-function-specified"]      = "You must specify a function to call",  -- equal to the standard module error message
			["main-called-twice"]          = 'The function "main" cannot be called twice',
			["no-such-function"]           = 'The function "%s" does not exist',  -- equal to the standard module error message
            ["no-such-reference-template"] = 'Error: template "%s", which is set in %s as the output template for the citation-output type "%s", does not exist',
            -- Parts of the error message signalling a malformed reference.
            ["malformed-reference-header"] = "&lt;span style=\"color:#dd3333\"&gt;\nError: Unable to display the reference from Wikidata properly. Technical details:\n",
            ["malformed-reference-footer"] = "See [[Module:wd/doc#References|the documentation]] for further details.\n&lt;/span&gt;\n[[Category:Module:Wd reference errors]]",
            ["template-failure-reason"]    = "* Reason for the failure of {{tl|%s}}: %s\n",
            ["missing-mandatory-param"]    = 'The output template call would miss the mandatory parameter &lt;code&gt;%s&lt;/code&gt;.',
            ["unknown-property-in-ref"]    = 'The Wikidata reference contains the property {{property|%s}}, which is not assigned to any parameter of this template.'
		},
		["info"] = {
			["edit-on-wikidata"] = "Edit this on Wikidata"
		},
		["numeric"] = {
			["decimal-mark"] = ".",
			["delimiter"]    = ","
		},
		["datetime"] = {
			["prefixes"] = {
				["decade-period"] = ""
			},
			["suffixes"] = {
				["decade-period"] = "s",
				["millennium"]    = " millennium",
				["century"]       = " century",
				["million-years"] = " million years",
				["billion-years"] = " billion years",
				["year"]          = " year",
				["years"]         = " years"
			},
			["julian-calendar"] = "Julian calendar",  -- linked page title
			["julian"]          = "Julian",
			["BCE"]             = "BCE",
			["CE"]              = "CE",
			["common-era"]      = "Common Era"  -- linked page title
		},
		["coord"] = {
			["latitude-north"] = "N",
			["latitude-south"] = "S",
			["longitude-east"] = "E",
			["longitude-west"] = "W",
			["degrees"]        = "°",
			["minutes"]        = "'",
			["seconds"]        = '"',
			["separator"]      = ", "
		},
		["values"] = {
			["unknown"] = "unknown",
			["none"]    = "none"
		},
		["cite"] = {
			["output-types"] = {"web", "q"},  -- In this order, the output types will be tried
			["param-mapping"] = {
				["web"] = {
					-- &lt;= left side: all allowed reference properties for *web page sources* per https://www.wikidata.org/wiki/Help:Sources
					-- =&gt; right side: corresponding parameter names in (equivalent of) [[:en:Template:Cite web]] (if non-existent, keep empty i.e. "")
					[aliasesP.statedIn]                = "website",
					[aliasesP.referenceURL]            = "url",
					[aliasesP.publicationDate]         = "date",
					[aliasesP.retrieved]               = "access-date",
					[aliasesP.title]                   = "title",
					[aliasesP.archiveURL]              = "archive-url",
					[aliasesP.archiveDate]             = "archive-date",
					[aliasesP.language]                = "language",
					[aliasesP.author]                  = "author",
					[aliasesP.authorNameString]        = "author",
					[aliasesP.publisher]               = "publisher",
					[aliasesP.quote]                   = "quote",
					[aliasesP.pages]                   = "pages",  -- extra option
					[aliasesP.publishedIn]             = "website",
					[aliasesP.sectionVerseOrParagraph] = "at"
				},
				["q"] = {
					-- &lt;= left side: all allowed reference properties for *sources other than web pages* per https://www.wikidata.org/wiki/Help:Sources
					-- =&gt; right side: corresponding parameter names in (equivalent of) [[:en:Template:Cite Q]] (if non-existent, keep empty i.e. "")
					[aliasesP.statedIn]                = "1",
					[aliasesP.pages]                   = "pages",
					[aliasesP.column]                  = "at",
					[aliasesP.chapter]                 = "chapter",
					[aliasesP.sectionVerseOrParagraph] = "section",
					["external-id"]                    = "id",  -- used for any type of database property ID
					[aliasesP.title]                   = "title",
					[aliasesP.publicationDate]         = "date",
					[aliasesP.retrieved]               = "access-date"
				}
			},
			["config"] = {
				-- supported fields:
				--     - template: name of the template used for output
				--     - numbered-params: citation params accepting an arbitrary number of values by numbering the params (e.g. author1, author2)
				--     - raw-value-params: params taking a raw value (which means the property is rendered with getValue with raw=true)
				--     - mandatory-params: params that are required be in the template call (after potentially appending numbers to params listed in numbered-params)
				-- Leaving out the "template" field causes the output type to be ignored.
				["web"] = {
					["template"] = "Cite web",
					["numbered-params"] = {"author"},
					["mandatory-params"] = {"url"}
				},
				["q"] = {
					["template"] = "Cite Q",
					["raw-value-params"] = {"1"},  -- the first, unnamed parameter of CiteQ takes a QID, not the name of the item cited
					["mandatory-params"] = {"1"}
				}
			}
		}
	}

	p.getOrdinalSuffix = function(num)
		if tostring(num):sub(-2,-2) == '1' then
			return "th"  -- 10th, 11th, 12th, 13th, ... 19th
		end

		num = tostring(num):sub(-1)

		if num == '1' then
			return "st"
		elseif num == '2' then
			return "nd"
		elseif num == '3' then
			return "rd"
		else
			return "th"
		end
	end

	p.addDelimiters = function(n)
		local left, num, right = string.match(n, "^([^%d]*%d)(%d*)(.-)$")

		if left and num and right then
			return left .. (num:reverse():gsub("(%d%d%d)", "%1" .. p['numeric']['delimiter']):reverse()) .. right
		else
			return n
		end
	end

	return p
end

return p</text>
      <sha1>9x26xqgg01idb8drjyqhb64or1txdtn</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Protection banner</title>
    <ns>828</ns>
    <id>56</id>
    <revision>
      <id>100</id>
      <parentid>99</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>99</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="26590" sha1="2lyr6ebd580cvha7qta16zrremxkzxz" xml:space="preserve">-- This module implements {{pp-meta}} and its daughter templates such as
-- {{pp-dispute}}, {{pp-vandalism}} and {{pp-sock}}.

-- Initialise necessary modules.
require('strict')
local makeFileLink = require('Module:File link')._main
local effectiveProtectionLevel = require('Module:Effective protection level')._main
local effectiveProtectionExpiry = require('Module:Effective protection expiry')._main
local yesno = require('Module:Yesno')

-- Lazily initialise modules and objects we don't always need.
local getArgs, makeMessageBox, lang

-- Set constants.
local CONFIG_MODULE = 'Module:Protection banner/config'

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function makeCategoryLink(cat, sort)
	if cat then
		return string.format(
			'[[%s:%s|%s]]',
			mw.site.namespaces[14].name,
			cat,
			sort
		)
	end
end

-- Validation function for the expiry and the protection date
local function validateDate(dateString, dateType)
	if not lang then
		lang = mw.language.getContentLanguage()
	end
	local success, result = pcall(lang.formatDate, lang, 'U', dateString)
	if success then
		result = tonumber(result)
		if result then
			return result
		end
	end
	error(string.format(
		'invalid %s: %s',
		dateType,
		tostring(dateString)
	), 4)
end

local function makeFullUrl(page, query, display)
	return string.format(
		'[%s %s]',
		tostring(mw.uri.fullUrl(page, query)),
		display
	)
end

-- Given a directed graph formatted as node -&gt; table of direct successors,
-- get a table of all nodes reachable from a given node (though always
-- including the given node).
local function getReachableNodes(graph, start)
	local toWalk, retval = {[start] = true}, {}
	while true do
		-- Can't use pairs() since we're adding and removing things as we're iterating
		local k = next(toWalk) -- This always gets the "first" key
		if k == nil then
			return retval
		end
		toWalk[k] = nil
		retval[k] = true
		for _,v in ipairs(graph[k]) do
			if not retval[v] then
				toWalk[v] = true
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Protection class
--------------------------------------------------------------------------------

local Protection = {}
Protection.__index = Protection

Protection.supportedActions = {
	edit = true,
	move = true,
	autoreview = true,
	upload = true
}

Protection.bannerConfigFields = {
	'text',
	'explanation',
	'tooltip',
	'alt',
	'link',
	'image'
}

function Protection.new(args, cfg, title)
	local obj = {}
	obj._cfg = cfg
	obj.title = title or mw.title.getCurrentTitle()

	-- Set action
	if not args.action then
		obj.action = 'edit'
	elseif Protection.supportedActions[args.action] then
		obj.action = args.action
	else
		error(string.format(
			'invalid action: %s',
			tostring(args.action)
		), 3)
	end

	-- Set level
	obj.level = args.demolevel or effectiveProtectionLevel(obj.action, obj.title)
	if not obj.level or (obj.action == 'move' and obj.level == 'autoconfirmed') then
		-- Users need to be autoconfirmed to move pages anyway, so treat
		-- semi-move-protected pages as unprotected.
		obj.level = '*'
	end

	-- Set expiry
	local effectiveExpiry = effectiveProtectionExpiry(obj.action, obj.title)
	if effectiveExpiry == 'infinity' then
		obj.expiry = 'indef'
	elseif effectiveExpiry ~= 'unknown' then
		obj.expiry = validateDate(effectiveExpiry, 'expiry date')
	end

	-- Set reason
	if args[1] then
		obj.reason = mw.ustring.lower(args[1])
		if obj.reason:find('|') then
			error('reasons cannot contain the pipe character ("|")', 3)
		end
	end

	-- Set protection date
	if args.date then
		obj.protectionDate = validateDate(args.date, 'protection date')
	end
	
	-- Set banner config
	do
		obj.bannerConfig = {}
		local configTables = {}
		if cfg.banners[obj.action] then
			configTables[#configTables + 1] = cfg.banners[obj.action][obj.reason]
		end
		if cfg.defaultBanners[obj.action] then
			configTables[#configTables + 1] = cfg.defaultBanners[obj.action][obj.level]
			configTables[#configTables + 1] = cfg.defaultBanners[obj.action].default
		end
		configTables[#configTables + 1] = cfg.masterBanner
		for i, field in ipairs(Protection.bannerConfigFields) do
			for j, t in ipairs(configTables) do
				if t[field] then
					obj.bannerConfig[field] = t[field]
					break
				end
			end
		end
	end
	return setmetatable(obj, Protection)
end

function Protection:isUserScript()
	-- Whether the page is a user JavaScript or CSS page.
	local title = self.title
	return title.namespace == 2 and (
		title.contentModel == 'javascript' or title.contentModel == 'css'
	)
end

function Protection:isProtected()
	return self.level ~= '*'
end

function Protection:shouldShowLock()
	-- Whether we should output a banner/padlock
	return self:isProtected() and not self:isUserScript()
end

-- Whether this page needs a protection category.
Protection.shouldHaveProtectionCategory = Protection.shouldShowLock

function Protection:isTemporary()
	return type(self.expiry) == 'number'
end

function Protection:makeProtectionCategory()
	if not self:shouldHaveProtectionCategory() then
		return ''
	end

	local cfg = self._cfg
	local title = self.title
	
	-- Get the expiry key fragment.
	local expiryFragment
	if self.expiry == 'indef' then
		expiryFragment = self.expiry
	elseif type(self.expiry) == 'number' then
		expiryFragment = 'temp'
	end

	-- Get the namespace key fragment.
	local namespaceFragment = cfg.categoryNamespaceKeys[title.namespace]
	if not namespaceFragment and title.namespace % 2 == 1 then
			namespaceFragment = 'talk'
	end

	-- Define the order that key fragments are tested in. This is done with an
	-- array of tables containing the value to be tested, along with its
	-- position in the cfg.protectionCategories table.
	local order = {
		{val = expiryFragment,    keypos = 1},
		{val = namespaceFragment, keypos = 2},
		{val = self.reason,       keypos = 3},
		{val = self.level,        keypos = 4},
		{val = self.action,       keypos = 5}
	}

	--[[
	-- The old protection templates used an ad-hoc protection category system,
	-- with some templates prioritising namespaces in their categories, and
	-- others prioritising the protection reason. To emulate this in this module
	-- we use the config table cfg.reasonsWithNamespacePriority to set the
	-- reasons for which namespaces have priority over protection reason.
	-- If we are dealing with one of those reasons, move the namespace table to
	-- the end of the order table, i.e. give it highest priority. If not, the
	-- reason should have highest priority, so move that to the end of the table
	-- instead.
	--]]
	table.insert(order, table.remove(order, self.reason and cfg.reasonsWithNamespacePriority[self.reason] and 2 or 3))
 
	--[[
	-- Define the attempt order. Inactive subtables (subtables with nil "value"
	-- fields) are moved to the end, where they will later be given the key
	-- "all". This is to cut down on the number of table lookups in
	-- cfg.protectionCategories, which grows exponentially with the number of
	-- non-nil keys. We keep track of the number of active subtables with the
	-- noActive parameter.
	--]]
	local noActive, attemptOrder
	do
		local active, inactive = {}, {}
		for i, t in ipairs(order) do
			if t.val then
				active[#active + 1] = t
			else
				inactive[#inactive + 1] = t
			end
		end
		noActive = #active
		attemptOrder = active
		for i, t in ipairs(inactive) do
			attemptOrder[#attemptOrder + 1] = t
		end
	end
 
	--[[
	-- Check increasingly generic key combinations until we find a match. If a
	-- specific category exists for the combination of key fragments we are
	-- given, that match will be found first. If not, we keep trying different
	-- key fragment combinations until we match using the key
	-- "all-all-all-all-all".
	--
	-- To generate the keys, we index the key subtables using a binary matrix
	-- with indexes i and j. j is only calculated up to the number of active
	-- subtables. For example, if there were three active subtables, the matrix
	-- would look like this, with 0 corresponding to the key fragment "all", and
	-- 1 corresponding to other key fragments.
	-- 
	--   j 1  2  3
	-- i  
	-- 1   1  1  1
	-- 2   0  1  1
	-- 3   1  0  1
	-- 4   0  0  1
	-- 5   1  1  0
	-- 6   0  1  0
	-- 7   1  0  0
	-- 8   0  0  0
	-- 
	-- Values of j higher than the number of active subtables are set
	-- to the string "all".
	--
	-- A key for cfg.protectionCategories is constructed for each value of i.
	-- The position of the value in the key is determined by the keypos field in
	-- each subtable.
	--]]
	local cats = cfg.protectionCategories
	for i = 1, 2^noActive do
		local key = {}
		for j, t in ipairs(attemptOrder) do
			if j &gt; noActive then
				key[t.keypos] = 'all'
			else
				local quotient = i / 2 ^ (j - 1)
				quotient = math.ceil(quotient)
				if quotient % 2 == 1 then
					key[t.keypos] = t.val
				else
					key[t.keypos] = 'all'
				end
			end
		end
		key = table.concat(key, '|')
		local attempt = cats[key]
		if attempt then
			return makeCategoryLink(attempt, title.text)
		end
	end
	return ''
end

function Protection:isIncorrect()
	local expiry = self.expiry
	return not self:shouldHaveProtectionCategory()
		or type(expiry) == 'number' and expiry &lt; os.time()
end

function Protection:isTemplateProtectedNonTemplate()
	local action, namespace = self.action, self.title.namespace
	return self.level == 'templateeditor'
		and (
			(action ~= 'edit' and action ~= 'move')
			or (namespace ~= 10 and namespace ~= 828)
		)
end

function Protection:makeCategoryLinks()
	local msg = self._cfg.msg
	local ret = {self:makeProtectionCategory()}
	if self:isIncorrect() then
		ret[#ret + 1] = makeCategoryLink(
			msg['tracking-category-incorrect'],
			self.title.text
		)
	end
	if self:isTemplateProtectedNonTemplate() then
		ret[#ret + 1] = makeCategoryLink(
			msg['tracking-category-template'],
			self.title.text
		)
	end
	return table.concat(ret)
end

--------------------------------------------------------------------------------
-- Blurb class
--------------------------------------------------------------------------------

local Blurb = {}
Blurb.__index = Blurb

Blurb.bannerTextFields = {
	text = true,
	explanation = true,
	tooltip = true,
	alt = true,
	link = true
}

function Blurb.new(protectionObj, args, cfg)
	return setmetatable({
		_cfg = cfg,
		_protectionObj = protectionObj,
		_args = args
	}, Blurb)
end

-- Private methods --

function Blurb:_formatDate(num)
	-- Formats a Unix timestamp into dd Month, YYYY format.
	lang = lang or mw.language.getContentLanguage()
	local success, date = pcall(
		lang.formatDate,
		lang,
		self._cfg.msg['expiry-date-format'] or 'j F Y',
		'@' .. tostring(num)
	)
	if success then
		return date
	end
end

function Blurb:_getExpandedMessage(msgKey)
	return self:_substituteParameters(self._cfg.msg[msgKey])
end

function Blurb:_substituteParameters(msg)
	if not self._params then
		local parameterFuncs = {}

		parameterFuncs.CURRENTVERSION     = self._makeCurrentVersionParameter
		parameterFuncs.EDITREQUEST        = self._makeEditRequestParameter
		parameterFuncs.EXPIRY             = self._makeExpiryParameter
		parameterFuncs.EXPLANATIONBLURB   = self._makeExplanationBlurbParameter
		parameterFuncs.IMAGELINK          = self._makeImageLinkParameter
		parameterFuncs.INTROBLURB         = self._makeIntroBlurbParameter
		parameterFuncs.INTROFRAGMENT      = self._makeIntroFragmentParameter
		parameterFuncs.PAGETYPE           = self._makePagetypeParameter
		parameterFuncs.PROTECTIONBLURB    = self._makeProtectionBlurbParameter
		parameterFuncs.PROTECTIONDATE     = self._makeProtectionDateParameter
		parameterFuncs.PROTECTIONLEVEL    = self._makeProtectionLevelParameter
		parameterFuncs.PROTECTIONLOG      = self._makeProtectionLogParameter
		parameterFuncs.TALKPAGE           = self._makeTalkPageParameter
		parameterFuncs.TOOLTIPBLURB       = self._makeTooltipBlurbParameter
		parameterFuncs.TOOLTIPFRAGMENT    = self._makeTooltipFragmentParameter
		parameterFuncs.VANDAL             = self._makeVandalTemplateParameter
		
		self._params = setmetatable({}, {
			__index = function (t, k)
				local param
				if parameterFuncs[k] then
					param = parameterFuncs[k](self)
				end
				param = param or ''
				t[k] = param
				return param
			end
		})
	end
	
	msg = msg:gsub('${(%u+)}', self._params)
	return msg
end

function Blurb:_makeCurrentVersionParameter()
	-- A link to the page history or the move log, depending on the kind of
	-- protection.
	local pagename = self._protectionObj.title.prefixedText
	if self._protectionObj.action == 'move' then
		-- We need the move log link.
		return makeFullUrl(
			'Special:Log',
			{type = 'move', page = pagename},
			self:_getExpandedMessage('current-version-move-display')
		)
	else
		-- We need the history link.
		return makeFullUrl(
			pagename,
			{action = 'history'},
			self:_getExpandedMessage('current-version-edit-display')
		)
	end
end

function Blurb:_makeEditRequestParameter()
	local mEditRequest = require('Module:Submit an edit request')
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	
	-- Get the edit request type.
	local requestType
	if action == 'edit' then
		if level == 'autoconfirmed' then
			requestType = 'semi'
		elseif level == 'extendedconfirmed' then
			requestType = 'extended'
		elseif level == 'templateeditor' then
			requestType = 'template'
		end
	end
	requestType = requestType or 'full'
	
	-- Get the display value.
	local display = self:_getExpandedMessage('edit-request-display')

	return mEditRequest._link{type = requestType, display = display}
end

function Blurb:_makeExpiryParameter()
	local expiry = self._protectionObj.expiry
	if type(expiry) == 'number' then
		return self:_formatDate(expiry)
	else
		return expiry
	end
end

function Blurb:_makeExplanationBlurbParameter()
	-- Cover special cases first.
	if self._protectionObj.title.namespace == 8 then
		-- MediaWiki namespace
		return self:_getExpandedMessage('explanation-blurb-nounprotect')
	end

	-- Get explanation blurb table keys
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local talkKey = self._protectionObj.title.isTalkPage and 'talk' or 'subject'

	-- Find the message in the explanation blurb table and substitute any
	-- parameters.
	local explanations = self._cfg.explanationBlurbs
	local msg
	if explanations[action][level] and explanations[action][level][talkKey] then
		msg = explanations[action][level][talkKey]
	elseif explanations[action][level] and explanations[action][level].default then
		msg = explanations[action][level].default
	elseif explanations[action].default and explanations[action].default[talkKey] then
		msg = explanations[action].default[talkKey]
	elseif explanations[action].default and explanations[action].default.default then
		msg = explanations[action].default.default
	else
		error(string.format(
			'could not find explanation blurb for action "%s", level "%s" and talk key "%s"',
			action,
			level,
			talkKey
		), 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeImageLinkParameter()
	local imageLinks = self._cfg.imageLinks
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if imageLinks[action][level] then
		msg = imageLinks[action][level]
	elseif imageLinks[action].default then
		msg = imageLinks[action].default
	else
		msg = imageLinks.edit.default
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeIntroBlurbParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('intro-blurb-expiry')
	else
		return self:_getExpandedMessage('intro-blurb-noexpiry')
	end
end

function Blurb:_makeIntroFragmentParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('intro-fragment-expiry')
	else
		return self:_getExpandedMessage('intro-fragment-noexpiry')
	end
end

function Blurb:_makePagetypeParameter()
	local pagetypes = self._cfg.pagetypes
	return pagetypes[self._protectionObj.title.namespace]
		or pagetypes.default
		or error('no default pagetype defined', 8)
end

function Blurb:_makeProtectionBlurbParameter()
	local protectionBlurbs = self._cfg.protectionBlurbs
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if protectionBlurbs[action][level] then
		msg = protectionBlurbs[action][level]
	elseif protectionBlurbs[action].default then
		msg = protectionBlurbs[action].default
	elseif protectionBlurbs.edit.default then
		msg = protectionBlurbs.edit.default
	else
		error('no protection blurb defined for protectionBlurbs.edit.default', 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeProtectionDateParameter()
	local protectionDate = self._protectionObj.protectionDate
	if type(protectionDate) == 'number' then
		return self:_formatDate(protectionDate)
	else
		return protectionDate
	end
end

function Blurb:_makeProtectionLevelParameter()
	local protectionLevels = self._cfg.protectionLevels
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if protectionLevels[action][level] then
		msg = protectionLevels[action][level]
	elseif protectionLevels[action].default then
		msg = protectionLevels[action].default
	elseif protectionLevels.edit.default then
		msg = protectionLevels.edit.default
	else
		error('no protection level defined for protectionLevels.edit.default', 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeProtectionLogParameter()
	local pagename = self._protectionObj.title.prefixedText
	if self._protectionObj.action == 'autoreview' then
		-- We need the pending changes log.
		return makeFullUrl(
			'Special:Log',
			{type = 'stable', page = pagename},
			self:_getExpandedMessage('pc-log-display')
		)
	else
		-- We need the protection log.
		return makeFullUrl(
			'Special:Log',
			{type = 'protect', page = pagename},
			self:_getExpandedMessage('protection-log-display')
		)
	end
end

function Blurb:_makeTalkPageParameter()
	return string.format(
		'[[%s:%s#%s|%s]]',
		mw.site.namespaces[self._protectionObj.title.namespace].talk.name,
		self._protectionObj.title.text,
		self._args.section or 'top',
		self:_getExpandedMessage('talk-page-link-display')
	)
end

function Blurb:_makeTooltipBlurbParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('tooltip-blurb-expiry')
	else
		return self:_getExpandedMessage('tooltip-blurb-noexpiry')
	end
end

function Blurb:_makeTooltipFragmentParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('tooltip-fragment-expiry')
	else
		return self:_getExpandedMessage('tooltip-fragment-noexpiry')
	end
end

function Blurb:_makeVandalTemplateParameter()
	return mw.getCurrentFrame():expandTemplate{
		title="vandal-m",
		args={self._args.user or self._protectionObj.title.baseText}
	}
end

-- Public methods --

function Blurb:makeBannerText(key)
	-- Validate input.
	if not key or not Blurb.bannerTextFields[key] then
		error(string.format(
			'"%s" is not a valid banner config field',
			tostring(key)
		), 2)
	end

	-- Generate the text.
	local msg = self._protectionObj.bannerConfig[key]
	if type(msg) == 'string' then
		return self:_substituteParameters(msg)
	elseif type(msg) == 'function' then
		msg = msg(self._protectionObj, self._args)
		if type(msg) ~= 'string' then
			error(string.format(
				'bad output from banner config function with key "%s"'
					.. ' (expected string, got %s)',
				tostring(key),
				type(msg)
			), 4)
		end
		return self:_substituteParameters(msg)
	end
end

--------------------------------------------------------------------------------
-- BannerTemplate class
--------------------------------------------------------------------------------

local BannerTemplate = {}
BannerTemplate.__index = BannerTemplate

function BannerTemplate.new(protectionObj, cfg)
	local obj = {}
	obj._cfg = cfg

	-- Set the image filename.
	local imageFilename = protectionObj.bannerConfig.image
	if imageFilename then
		obj._imageFilename = imageFilename
	else
		-- If an image filename isn't specified explicitly in the banner config,
		-- generate it from the protection status and the namespace.
		local action = protectionObj.action
		local level = protectionObj.level
		local namespace = protectionObj.title.namespace
		local reason = protectionObj.reason
		
		-- Deal with special cases first.
		if (
			namespace == 10
			or namespace == 828
			or reason and obj._cfg.indefImageReasons[reason]
			)
			and action == 'edit'
			and level == 'sysop'
			and not protectionObj:isTemporary()
		then
			-- Fully protected modules and templates get the special red "indef"
			-- padlock.
			obj._imageFilename = obj._cfg.msg['image-filename-indef']
		else
			-- Deal with regular protection types.
			local images = obj._cfg.images
			if images[action] then
				if images[action][level] then
					obj._imageFilename = images[action][level]
				elseif images[action].default then
					obj._imageFilename = images[action].default
				end
			end
		end
	end
	return setmetatable(obj, BannerTemplate)
end

function BannerTemplate:renderImage()
	local filename = self._imageFilename
		or self._cfg.msg['image-filename-default']
		or 'Transparent.gif'
	return makeFileLink{
		file = filename,
		size = (self.imageWidth or 20) .. 'px',
		alt = self._imageAlt,
		link = self._imageLink,
		caption = self.imageCaption
	}
end

--------------------------------------------------------------------------------
-- Banner class
--------------------------------------------------------------------------------

local Banner = setmetatable({}, BannerTemplate)
Banner.__index = Banner

function Banner.new(protectionObj, blurbObj, cfg)
	local obj = BannerTemplate.new(protectionObj, cfg) -- This doesn't need the blurb.
	obj.imageWidth = 40
	obj.imageCaption = blurbObj:makeBannerText('alt') -- Large banners use the alt text for the tooltip.
	obj._reasonText = blurbObj:makeBannerText('text')
	obj._explanationText = blurbObj:makeBannerText('explanation')
	obj._page = protectionObj.title.prefixedText -- Only makes a difference in testing.
	return setmetatable(obj, Banner)
end

function Banner:__tostring()
	-- Renders the banner.
	makeMessageBox = makeMessageBox or require('Module:Message box').main
	local reasonText = self._reasonText or error('no reason text set', 2)
	local explanationText = self._explanationText
	local mbargs = {
		page = self._page,
		type = 'protection',
		image = self:renderImage(),
		text = string.format(
			"'''%s'''%s",
			reasonText,
			explanationText and '&lt;br /&gt;' .. explanationText or ''
		)
	}
	return makeMessageBox('mbox', mbargs)
end

--------------------------------------------------------------------------------
-- Padlock class
--------------------------------------------------------------------------------

local Padlock = setmetatable({}, BannerTemplate)
Padlock.__index = Padlock

function Padlock.new(protectionObj, blurbObj, cfg)
	local obj = BannerTemplate.new(protectionObj, cfg) -- This doesn't need the blurb.
	obj.imageWidth = 20
	obj.imageCaption = blurbObj:makeBannerText('tooltip')
	obj._imageAlt = blurbObj:makeBannerText('alt')
	obj._imageLink = blurbObj:makeBannerText('link')
	obj._indicatorName = cfg.padlockIndicatorNames[protectionObj.action]
		or cfg.padlockIndicatorNames.default
		or 'pp-default'
	return setmetatable(obj, Padlock)
end

function Padlock:__tostring()
	local frame = mw.getCurrentFrame()
	-- The nowiki tag helps prevent whitespace at the top of articles.
	return frame:extensionTag{name = 'nowiki'} .. frame:extensionTag{
		name = 'indicator',
		args = {name = self._indicatorName},
		content = self:renderImage()
	}
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p = {}

function p._exportClasses()
	-- This is used for testing purposes.
	return {
		Protection = Protection,
		Blurb = Blurb,
		BannerTemplate = BannerTemplate,
		Banner = Banner,
		Padlock = Padlock,
	}
end

function p._main(args, cfg, title)
	args = args or {}
	cfg = cfg or require(CONFIG_MODULE)

	local protectionObj = Protection.new(args, cfg, title)

	local ret = {}

	-- If a page's edit protection is equally or more restrictive than its
	-- protection from some other action, then don't bother displaying anything
	-- for the other action (except categories).
	if not yesno(args.catonly) and (protectionObj.action == 'edit' or
		args.demolevel or
		not getReachableNodes(
			cfg.hierarchy,
			protectionObj.level
		)[effectiveProtectionLevel('edit', protectionObj.title)])
	then
		-- Initialise the blurb object
		local blurbObj = Blurb.new(protectionObj, args, cfg)
	
		-- Render the banner
		if protectionObj:shouldShowLock() then
			ret[#ret + 1] = tostring(
				(yesno(args.small) and Padlock or Banner)
				.new(protectionObj, blurbObj, cfg)
			)
		end
	end

	-- Render the categories
	if yesno(args.category) ~= false then
		ret[#ret + 1] = protectionObj:makeCategoryLinks()
	end
	
	-- For arbitration enforcement, flagging [[WP:PIA]] pages to enable [[Special:AbuseFilter/1339]] to flag edits to them
	if protectionObj.level == "extendedconfirmed" then
		if require("Module:TableTools").inArray(protectionObj.title.talkPageTitle.categories, "Wikipedia pages subject to the extended confirmed restriction related to the Arab-Israeli conflict") then
			ret[#ret + 1] = "&lt;p class='PIA-flag' style='display:none; visibility:hidden;' title='This page is subject to the extended confirmed restriction related to the Arab-Israeli conflict.'&gt;&lt;/p&gt;"
		end
	end
	
	return table.concat(ret)	
end

function p.main(frame, cfg)
	cfg = cfg or require(CONFIG_MODULE)

	-- Find default args, if any.
	local parent = frame.getParent and frame:getParent()
	local defaultArgs = parent and cfg.wrappers[parent:getTitle():gsub('/sandbox$', '')]

	-- Find user args, and use the parent frame if we are being called from a
	-- wrapper template.
	getArgs = getArgs or require('Module:Arguments').getArgs
	local userArgs = getArgs(frame, {
		parentOnly = defaultArgs,
		frameOnly = not defaultArgs
	})

	-- Build the args table. User-specified args overwrite default args.
	local args = {}
	for k, v in pairs(defaultArgs or {}) do
		args[k] = v
	end
	for k, v in pairs(userArgs) do
		args[k] = v
	end
	return p._main(args, cfg)
end

return p</text>
      <sha1>2lyr6ebd580cvha7qta16zrremxkzxz</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Protection banner/config</title>
    <ns>828</ns>
    <id>57</id>
    <revision>
      <id>102</id>
      <parentid>101</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>101</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="46537" sha1="4j9s25hqt968zd5fewsvtkzzg34omaf" xml:space="preserve">-- This module provides configuration data for [[Module:Protection banner]].

return {

--------------------------------------------------------------------------------
--
--                                BANNER DATA
--
--------------------------------------------------------------------------------

--[[
-- Banner data consists of six fields:
-- * text - the main protection text that appears at the top of protection
--   banners.
-- * explanation - the text that appears below the main protection text, used
--   to explain the details of the protection.
-- * tooltip - the tooltip text you see when you move the mouse over a small
--   padlock icon.
-- * link - the page that the small padlock icon links to.
-- * alt - the alt text for the small padlock icon. This is also used as tooltip
--   text for the large protection banners.
-- * image - the padlock image used in both protection banners and small padlock
--   icons.
--
-- The module checks in three separate tables to find a value for each field.
-- First it checks the banners table, which has values specific to the reason
-- for the page being protected. Then the module checks the defaultBanners
-- table, which has values specific to each protection level. Finally, the
-- module checks the masterBanner table, which holds data for protection
-- templates to use if no data has been found in the previous two tables.
--
-- The values in the banner data can take parameters. These are specified
-- using ${TEXTLIKETHIS} (a dollar sign preceding a parameter name
-- enclosed in curly braces).
--
--                          Available parameters:
--
-- ${CURRENTVERSION} - a link to the page history or the move log, with the
-- display message "current-version-edit-display" or
-- "current-version-move-display".
--
-- ${EDITREQUEST} - a link to create an edit request for the current page.
--
-- ${EXPLANATIONBLURB} - an explanation blurb, e.g. "Please discuss any changes
-- on the talk page; you may submit a request to ask an administrator to make
-- an edit if it is minor or supported by consensus."
--
-- ${IMAGELINK} - a link to set the image to, depending on the protection
-- action and protection level.
--
-- ${INTROBLURB} - the PROTECTIONBLURB parameter, plus the expiry if an expiry
-- is set. E.g. "Editing of this page by new or unregistered users is currently 
-- disabled until dd Month YYYY."
--
-- ${INTROFRAGMENT} - the same as ${INTROBLURB}, but without final punctuation
-- so that it can be used in run-on sentences.
--
-- ${PAGETYPE} - the type of the page, e.g. "article" or "template".
-- Defined in the cfg.pagetypes table.
--
-- ${PROTECTIONBLURB} - a blurb explaining the protection level of the page, e.g.
-- "Editing of this page by new or unregistered users is currently disabled"
--
-- ${PROTECTIONDATE} - the protection date, if it has been supplied to the
-- template.
--
-- ${PROTECTIONLEVEL} - the protection level, e.g. "fully protected" or
-- "semi-protected".
--
-- ${PROTECTIONLOG} - a link to the protection log or the pending changes log,
-- depending on the protection action.
--
-- ${TALKPAGE} - a link to the talk page. If a section is specified, links
-- straight to that talk page section.
--
-- ${TOOLTIPBLURB} - uses the PAGETYPE, PROTECTIONTYPE and EXPIRY parameters to
-- create a blurb like "This template is semi-protected", or "This article is
-- move-protected until DD Month YYYY".
--
-- ${VANDAL} - links for the specified username (or the root page name)
-- using Module:Vandal-m.
--
--                                 Functions
--
-- For advanced users, it is possible to use Lua functions instead of strings
-- in the banner config tables. Using functions gives flexibility that is not
-- possible just by using parameters. Functions take two arguments, the
-- protection object and the template arguments, and they must output a string.
--
-- For example:
--
-- text = function (protectionObj, args)
--     if protectionObj.level == 'autoconfirmed' then
--         return 'foo'
--     else
--         return 'bar'
--     end
-- end
--
-- Some protection object properties and methods that may be useful:
-- protectionObj.action - the protection action
-- protectionObj.level - the protection level
-- protectionObj.reason - the protection reason
-- protectionObj.expiry - the expiry. Nil if unset, the string "indef" if set
--     to indefinite, and the protection time in unix time if temporary.
-- protectionObj.protectionDate - the protection date in unix time, or nil if
--     unspecified.
-- protectionObj.bannerConfig - the banner config found by the module. Beware
--     of editing the config field used by the function, as it could create an
--     infinite loop.
-- protectionObj:isProtected - returns a boolean showing whether the page is
--     protected.
-- protectionObj:isTemporary - returns a boolean showing whether the expiry is
--     temporary.
-- protectionObj:isIncorrect - returns a boolean showing whether the protection
--     template is incorrect.
--]]

-- The master banner data, used if no values have been found in banners or
-- defaultBanners.
masterBanner = {
	text = '${INTROBLURB}',
	explanation = '${EXPLANATIONBLURB}',
	tooltip = '${TOOLTIPBLURB}',
	link = '${IMAGELINK}',
	alt = 'Page ${PROTECTIONLEVEL}'
},

-- The default banner data. This holds banner data for different protection
-- levels.
-- *required* - this table needs edit, move, autoreview and upload subtables.
defaultBanners = {
	edit = {},
	move = {},
	autoreview = {
		default = {
			alt = 'Page protected with pending changes',
			tooltip = 'All edits by unregistered and new users are subject to review prior to becoming visible to unregistered users',
			image = 'Pending-protection-shackle.svg'
		}
	},
	upload = {}
},

-- The banner data. This holds banner data for different protection reasons.
-- In fact, the reasons specified in this table control which reasons are
-- valid inputs to the first positional parameter.
--
-- There is also a non-standard "description" field that can be used for items
-- in this table. This is a description of the protection reason for use in the
-- module documentation.
--
-- *required* - this table needs edit, move, autoreview and upload subtables.
banners = {
	edit = {
		blp = {
			description = 'For pages protected to promote compliance with the'
				.. ' [[Wikipedia:Biographies of living persons'
				.. '|biographies of living persons]] policy',
			text = '${INTROFRAGMENT} to promote compliance with'
				.. ' [[Wikipedia:Biographies of living persons'
				.. "|Wikipedia's&amp;nbsp;policy on&amp;nbsp;the&amp;nbsp;biographies"
				.. ' of&amp;nbsp;living&amp;nbsp;people]].',
			tooltip = '${TOOLTIPFRAGMENT} to promote compliance with the policy on'
				.. ' biographies of living persons',
		},
		dmca = {
			description = 'For pages protected by the Wikimedia Foundation'
				.. ' due to [[Digital Millennium Copyright Act]] takedown requests',
			explanation = function (protectionObj, args)
				local ret = 'Pursuant to a rights owner notice under the Digital'
					.. ' Millennium Copyright Act (DMCA) regarding some content'
					.. ' in this article, the Wikimedia Foundation acted under'
					.. ' applicable law and took down and restricted the content'
					.. ' in question.'
				if args.notice then
					ret = ret .. ' A copy of the received notice can be found here: '
						.. args.notice .. '.'
				end
				ret = ret .. ' For more information, including websites discussing'
					.. ' how to file a counter-notice, please see'
					.. " [[Wikipedia:Office actions]] and the article's ${TALKPAGE}."
					.. "'''Do not remove this template from the article until the"
					.. " restrictions are withdrawn'''."
				return ret
			end,
			image = 'Office-protection-shackle.svg',
			link = 'Wikipedia:Protection policy#office',
		},
		dispute = {
			description = 'For pages protected due to editing disputes',
			text = function (protectionObj, args)
				-- Find the value of "disputes".
				local display = 'disputes'
				local disputes
				if args.section then
					disputes = string.format(
						'[[%s:%s#%s|%s]]',
						mw.site.namespaces[protectionObj.title.namespace].talk.name,
						protectionObj.title.text,
						args.section,
						display
					)
				else
					disputes = display
				end

				-- Make the blurb, depending on the expiry.
				local msg
				if type(protectionObj.expiry) == 'number' then
					msg = '${INTROFRAGMENT} or until editing %s have been resolved.'
				else
					msg = '${INTROFRAGMENT} until editing %s have been resolved.'
				end
				return string.format(msg, disputes)
			end,
			explanation = "This protection is '''not''' an endorsement of the"
				.. ' ${CURRENTVERSION}. ${EXPLANATIONBLURB}',
			tooltip = '${TOOLTIPFRAGMENT} due to editing disputes',
		},
		ecp = {
			description = 'For articles in topic areas authorized by'
				.. ' [[Wikipedia:Arbitration Committee|ArbCom]] or'
				.. ' meets the criteria for community use',
			tooltip = 'This ${PAGETYPE} is ${PROTECTIONLEVEL}',
			alt = 'Extended-protected ${PAGETYPE}',
		},
		mainpage = {
			description = 'For pages protected for being displayed on the [[Main Page]]',
			text = 'This file is currently'
				.. ' [[Wikipedia:This page is protected|protected]] from'
				.. ' editing because it is currently or will soon be displayed'
				.. ' on the [[Main Page]].',
			explanation = 'Images on the Main Page are protected due to their high'
				.. ' visibility. Please discuss any necessary changes on the ${TALKPAGE}.'
				.. '&lt;br /&gt;&lt;span style="font-size:90%;"&gt;'
				.. "'''Administrators:''' Once this image is definitely off the Main Page,"
				.. ' please unprotect this file, or reduce to semi-protection,'
				.. ' as appropriate.&lt;/span&gt;',
		},
		office = {
			description = 'For pages protected by the Wikimedia Foundation',
			text = function (protectionObj, args)
				local ret = 'This ${PAGETYPE} is currently under the'
					.. ' scrutiny of the'
					.. ' [[Wikipedia:Office actions|Wikimedia Foundation Office]]'
					.. ' and is protected.'
				if protectionObj.protectionDate then
					ret = ret .. ' It has been protected since ${PROTECTIONDATE}.'
				end
				return ret
			end,
			explanation = "If you can edit this page, please discuss all changes and"
				.. " additions on the ${TALKPAGE} first. '''Do not remove protection from this"
				.. " page unless you are authorized by the Wikimedia Foundation to do"
				.. " so.'''",
			image = 'Office-protection-shackle.svg',
			link = 'Wikipedia:Protection policy#office',
		},
		reset = {
			description = 'For pages protected by the Wikimedia Foundation and'
				.. ' "reset" to a bare-bones version',
 			text = 'This ${PAGETYPE} is currently under the'
					.. ' scrutiny of the'
					.. ' [[Wikipedia:Office actions|Wikimedia Foundation Office]]'
					.. ' and is protected.',
			explanation = function (protectionObj, args)
				local ret = ''
				if protectionObj.protectionDate then
					ret = ret .. 'On ${PROTECTIONDATE} this ${PAGETYPE} was'
				else
					ret = ret .. 'This ${PAGETYPE} has been'
				end
				ret = ret .. ' reduced to a'
				.. ' simplified, "bare bones" version so that it may be completely'
				.. ' rewritten to ensure it meets the policies of'
				.. ' [[WP:NPOV|Neutral Point of View]] and [[WP:V|Verifiability]].'
				.. ' Standard Wikipedia policies will apply to its rewriting—which'
				.. ' will eventually be open to all editors—and will be strictly'
				.. ' enforced. The ${PAGETYPE} has been ${PROTECTIONLEVEL} while'
				.. ' it is being rebuilt.\n\n'
				.. 'Any insertion of material directly from'
				.. ' pre-protection revisions of the ${PAGETYPE} will be removed, as'
				.. ' will any material added to the ${PAGETYPE} that is not properly'
				.. ' sourced. The associated talk page(s) were also cleared on the'
				.. " same date.\n\n"
				.. "If you can edit this page, please discuss all changes and"
				.. " additions on the ${TALKPAGE} first. '''Do not override"
				.. " this action, and do not remove protection from this page,"
				.. " unless you are authorized by the Wikimedia Foundation"
				.. " to do so. No editor may remove this notice.'''"

				return ret
			end,
			image = 'Office-protection-shackle.svg',
			link = 'Wikipedia:Protection policy#office',
		},
		sock = {
			description = 'For pages protected due to'
				.. ' [[Wikipedia:Sock puppetry|sock puppetry]]',
			text = '${INTROFRAGMENT} to prevent [[Wikipedia:Sock puppetry|sock puppets]] of'
				.. ' [[Wikipedia:Blocking policy|blocked]] or'
				.. ' [[Wikipedia:Banning policy|banned users]]'
				.. ' from editing it.',
			tooltip = '${TOOLTIPFRAGMENT} to prevent sock puppets of blocked or banned users from'
				.. ' editing it',
		},
		template = {
			description = 'For [[Wikipedia:High-risk templates|high-risk]]'
				.. ' templates and Lua modules',
			text = 'This is a permanently [[Help:Protection|protected]] ${PAGETYPE},'
				.. ' as it is [[Wikipedia:High-risk templates|high-risk]].',
			explanation = 'Please discuss any changes on the ${TALKPAGE}; you may'
				.. ' ${EDITREQUEST} to ask an'
				.. ' [[Wikipedia:Administrators|administrator]] or'
				.. ' [[Wikipedia:Template editor|template editor]] to make an edit if'
				.. ' it is [[Help:Minor edit#When to mark an edit as a minor edit'
				.. '|uncontroversial]] or supported by'
				.. ' [[Wikipedia:Consensus|consensus]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.',
			tooltip = 'This high-risk ${PAGETYPE} is permanently ${PROTECTIONLEVEL}'
				.. ' to prevent vandalism',
			alt = 'Permanently protected ${PAGETYPE}',
		},
		usertalk = {
			description = 'For pages protected against disruptive edits by a'
				.. ' particular user',
			text = '${INTROFRAGMENT} to prevent ${VANDAL} from using it to make disruptive edits,'
				.. ' such as abusing the'
				.. ' &amp;#123;&amp;#123;[[Template:unblock|unblock]]&amp;#125;&amp;#125; template.',
			explanation = 'If you cannot edit this user talk page and you need to'
				.. ' make a change or leave a message, you can'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for edits to a protected page'
				.. '|request an edit]],'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]],'
				.. ' [[Special:Userlogin|log in]],'
				.. ' or [[Special:UserLogin/signup|create an account]].',
		},
		vandalism = {
			description = 'For pages protected against'
				.. ' [[Wikipedia:Vandalism|vandalism]]',
			text = '${INTROFRAGMENT} due to [[Wikipedia:Vandalism|vandalism]].',
			explanation = function (protectionObj, args)
				local ret = ''
				if protectionObj.level == 'sysop' then
					ret = ret .. "This protection is '''not''' an endorsement of the"
						.. ' ${CURRENTVERSION}. '
				end
				return ret .. '${EXPLANATIONBLURB}'
			end,
			tooltip = '${TOOLTIPFRAGMENT} due to vandalism',
		}
	},
	move = {
		dispute = {
			description = 'For pages protected against page moves due to'
				.. ' disputes over the page title',
			explanation = "This protection is '''not''' an endorsement of the"
				.. ' ${CURRENTVERSION}. ${EXPLANATIONBLURB}',
			image = 'Move-protection-shackle.svg'
		},
		vandalism = {
			description = 'For pages protected against'
				.. ' [[Wikipedia:Vandalism#Page-move vandalism'
				.. ' |page-move vandalism]]'
		}
	},
	autoreview = {},
	upload = {}
},

--------------------------------------------------------------------------------
--
--                            GENERAL DATA TABLES
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Protection blurbs
--------------------------------------------------------------------------------

-- This table produces the protection blurbs available with the
-- ${PROTECTIONBLURB} parameter. It is sorted by protection action and
-- protection level, and is checked by the module in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
protectionBlurbs = {
	edit = {
		default = 'This ${PAGETYPE} is currently [[Help:Protection|'
			.. 'protected]] from editing',
		autoconfirmed = 'Editing of this ${PAGETYPE} by [[Wikipedia:User access'
			.. ' levels#New users|new]] or [[Wikipedia:User access levels#Unregistered'
			.. ' users|unregistered]] users is currently [[Help:Protection|disabled]]',
		extendedconfirmed = 'This ${PAGETYPE} is currently under extended confirmed protection',
	},
	move = {
		default = 'This ${PAGETYPE} is currently [[Help:Protection|protected]]'
			.. ' from [[Help:Moving a page|page moves]]'
	},
	autoreview = {
		default = 'All edits made to this ${PAGETYPE} by'
			.. ' [[Wikipedia:User access levels#New users|new]] or'
			.. ' [[Wikipedia:User access levels#Unregistered users|unregistered]]'
			.. ' users are currently'
			.. ' [[Wikipedia:Pending changes|subject to review]]'
	},
	upload = {
		default = 'Uploading new versions of this ${PAGETYPE} is currently disabled'
	}
},


--------------------------------------------------------------------------------
-- Explanation blurbs
--------------------------------------------------------------------------------

-- This table produces the explanation blurbs available with the
-- ${EXPLANATIONBLURB} parameter. It is sorted by protection action,
-- protection level, and whether the page is a talk page or not. If the page is
-- a talk page it will have a talk key of "talk"; otherwise it will have a talk
-- key of "subject". The table is checked in the following order:
-- 1. page's protection action, page's protection level, page's talk key
-- 2. page's protection action, page's protection level, default talk key
-- 3. page's protection action, default protection level, page's talk key
-- 4. page's protection action, default protection level, default talk key
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
explanationBlurbs = {
	edit = {
		autoconfirmed = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details. If you'
				.. ' cannot edit this ${PAGETYPE} and you wish to make a change, you can'
				.. ' ${EDITREQUEST}, discuss changes on the ${TALKPAGE},'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details. If you'
				.. ' cannot edit this ${PAGETYPE} and you wish to make a change, you can'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].',
		},
		extendedconfirmed = {
			default = 'Extended confirmed protection prevents edits from all unregistered editors'
				.. ' and registered users with fewer than 30 days tenure and 500 edits.'
				.. ' The [[Wikipedia:Protection policy#extended|policy on community use]]'
				.. ' specifies that extended confirmed protection can be applied to combat'
				.. ' disruption, if semi-protection has proven to be ineffective.'
				.. ' Extended confirmed protection may also be applied to enforce'
				.. ' [[Wikipedia:Arbitration Committee|arbitration sanctions]].'
				.. ' Please discuss any changes on the ${TALKPAGE}; you may'
				.. ' ${EDITREQUEST} to ask for uncontroversial changes supported by'
				.. ' [[Wikipedia:Consensus|consensus]].'
		},
		default = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' Please discuss any changes on the ${TALKPAGE}; you'
				.. ' may ${EDITREQUEST} to ask an'
				.. ' [[Wikipedia:Administrators|administrator]] to make an edit if it'
				.. ' is [[Help:Minor edit#When to mark an edit as a minor edit'
				.. '|uncontroversial]] or supported by [[Wikipedia:Consensus'
				.. '|consensus]]. You may also [[Wikipedia:Requests for'
				.. ' page protection#Current requests for reduction in protection level'
				.. '|request]] that this page be unprotected.',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' You may [[Wikipedia:Requests for page'
				.. ' protection#Current requests for edits to a protected page|request an'
				.. ' edit]] to this page, or [[Wikipedia:Requests for'
				.. ' page protection#Current requests for reduction in protection level'
				.. '|ask]] for it to be unprotected.'
		}
	},
	move = {
		default = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but cannot be moved'
				.. ' until unprotected. Please discuss any suggested moves on the'
				.. ' ${TALKPAGE} or at [[Wikipedia:Requested moves]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but cannot be moved'
				.. ' until unprotected. Please discuss any suggested moves at'
				.. ' [[Wikipedia:Requested moves]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.'
		}
	},
	autoreview = {
		default = {
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' Edits to this ${PAGETYPE} by new and unregistered users'
				.. ' will not be visible to readers until they are accepted by'
				.. ' a reviewer. To avoid the need for your edits to be'
				.. ' reviewed, you may'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].'
		},
	},
	upload = {
		default = {
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but new versions of the file'
				.. ' cannot be uploaded until it is unprotected. You can'
				.. ' request that a new version be uploaded by using a'
				.. ' [[Wikipedia:Edit requests|protected edit request]], or you'
				.. ' can  [[Wikipedia:Requests for page protection|request]]'
				.. ' that the file be unprotected.'
		}
	}
},

--------------------------------------------------------------------------------
-- Protection levels
--------------------------------------------------------------------------------

-- This table provides the data for the ${PROTECTIONLEVEL} parameter, which
-- produces a short label for different protection levels. It is sorted by
-- protection action and protection level, and is checked in the following
-- order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
protectionLevels = {
	edit = {
		default = 'protected',
		templateeditor = 'template-protected',
		extendedconfirmed = 'extended-confirmed-protected',
		autoconfirmed = 'semi-protected',
	},
	move = {
		default = 'move-protected'
	},
	autoreview = {
	},
	upload = {
		default = 'upload-protected'
	}
},

--------------------------------------------------------------------------------
-- Images
--------------------------------------------------------------------------------

-- This table lists different padlock images for each protection action and
-- protection level. It is used if an image is not specified in any of the
-- banner data tables, and if the page does not satisfy the conditions for using
-- the ['image-filename-indef'] image. It is checked in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
images = {
	edit = {
		default = 'Full-protection-shackle.svg',
		templateeditor = 'Template-protection-shackle.svg',
		extendedconfirmed = 'Extended-protection-shackle.svg',
		autoconfirmed = 'Semi-protection-shackle.svg'
	},
	move = {
		default = 'Move-protection-shackle.svg',
	},
	autoreview = {
		default = 'Pending-protection-shackle.svg'
	},
	upload = {
		default = 'Upload-protection-shackle.svg'
	}
},

-- Pages with a reason specified in this table will show the special "indef"
-- padlock, defined in the 'image-filename-indef' message, if no expiry is set.
indefImageReasons = {
	template = true
},

--------------------------------------------------------------------------------
-- Image links
--------------------------------------------------------------------------------

-- This table provides the data for the ${IMAGELINK} parameter, which gets
-- the image link for small padlock icons based on the page's protection action
-- and protection level. It is checked in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
imageLinks = {
	edit = {
		default = 'Wikipedia:Protection policy#full',
		templateeditor = 'Wikipedia:Protection policy#template',
		extendedconfirmed = 'Wikipedia:Protection policy#extended',
		autoconfirmed = 'Wikipedia:Protection policy#semi'
	},
	move = {
		default = 'Wikipedia:Protection policy#move'
	},
	autoreview = {
		default = 'Wikipedia:Protection policy#pending'
	},
	upload = {
		default = 'Wikipedia:Protection policy#upload'
	}
},

--------------------------------------------------------------------------------
-- Padlock indicator names
--------------------------------------------------------------------------------

-- This table provides the "name" attribute for the &lt;indicator&gt; extension tag
-- with which small padlock icons are generated. All indicator tags on a page
-- are displayed in alphabetical order based on this attribute, and with
-- indicator tags with duplicate names, the last tag on the page wins.
-- The attribute is chosen based on the protection action; table keys must be a
-- protection action name or the string "default".
padlockIndicatorNames = {
	autoreview = 'pp-autoreview',
	default = 'pp-default'
},

--------------------------------------------------------------------------------
-- Protection categories
--------------------------------------------------------------------------------

--[[
-- The protection categories are stored in the protectionCategories table.
-- Keys to this table are made up of the following strings:
--
-- 1. the expiry date
-- 2. the namespace
-- 3. the protection reason (e.g. "dispute" or "vandalism")
-- 4. the protection level (e.g. "sysop" or "autoconfirmed")
-- 5. the action (e.g. "edit" or "move")
-- 
-- When the module looks up a category in the table, first it will will check to
-- see a key exists that corresponds to all five parameters. For example, a
-- user page semi-protected from vandalism for two weeks would have the key
-- "temp-user-vandalism-autoconfirmed-edit". If no match is found, the module
-- changes the first part of the key to "all" and checks the table again. It
-- keeps checking increasingly generic key combinations until it finds the
-- field, or until it reaches the key "all-all-all-all-all".
--
-- The module uses a binary matrix to determine the order in which to search.
-- This is best demonstrated by a table. In this table, the "0" values
-- represent "all", and the "1" values represent the original data (e.g.
-- "indef" or "file" or "vandalism").
--
--        expiry    namespace reason   level     action
-- order
-- 1      1         1         1        1         1
-- 2      0         1         1        1         1
-- 3      1         0         1        1         1
-- 4      0         0         1        1         1
-- 5      1         1         0        1         1
-- 6      0         1         0        1         1
-- 7      1         0         0        1         1
-- 8      0         0         0        1         1
-- 9      1         1         1        0         1
-- 10     0         1         1        0         1
-- 11     1         0         1        0         1
-- 12     0         0         1        0         1
-- 13     1         1         0        0         1
-- 14     0         1         0        0         1
-- 15     1         0         0        0         1
-- 16     0         0         0        0         1
-- 17     1         1         1        1         0
-- 18     0         1         1        1         0
-- 19     1         0         1        1         0
-- 20     0         0         1        1         0
-- 21     1         1         0        1         0
-- 22     0         1         0        1         0
-- 23     1         0         0        1         0
-- 24     0         0         0        1         0
-- 25     1         1         1        0         0
-- 26     0         1         1        0         0
-- 27     1         0         1        0         0
-- 28     0         0         1        0         0
-- 29     1         1         0        0         0
-- 30     0         1         0        0         0
-- 31     1         0         0        0         0
-- 32     0         0         0        0         0
--
-- In this scheme the action has the highest priority, as it is the last
-- to change, and the expiry has the least priority, as it changes the most.
-- The priorities of the expiry, the protection level and the action are
-- fixed, but the priorities of the reason and the namespace can be swapped
-- through the use of the cfg.bannerDataNamespaceHasPriority table.
--]]

-- If the reason specified to the template is listed in this table,
-- namespace data will take priority over reason data in the protectionCategories
-- table.
reasonsWithNamespacePriority = {
	vandalism = true,
},

-- The string to use as a namespace key for the protectionCategories table for each
-- namespace number.
categoryNamespaceKeys = {
	[  2] = 'user',
	[  3] = 'user',
	[  4] = 'project',
	[  6] = 'file',
	[  8] = 'mediawiki',
	[ 10] = 'template',
	[ 12] = 'project',
	[ 14] = 'category',
	[100] = 'portal',
	[828] = 'module',
},

protectionCategories = {
	['all|all|all|all|all']                     = 'Wikipedia fully protected pages',
	['all|all|office|all|all']                  = 'Wikipedia Office-protected pages',
	['all|all|reset|all|all']                   = 'Wikipedia Office-protected pages',
	['all|all|dmca|all|all']                    = 'Wikipedia Office-protected pages',
	['all|all|mainpage|all|all']                = 'Wikipedia fully protected main page files',
	['all|all|all|extendedconfirmed|all']       = 'Wikipedia extended-confirmed-protected pages',
	['all|all|ecp|extendedconfirmed|all']       = 'Wikipedia extended-confirmed-protected pages',
	['all|template|all|all|edit']               = 'Wikipedia fully protected templates',
	['all|all|all|autoconfirmed|edit']          = 'Wikipedia semi-protected pages',
	['indef|all|all|autoconfirmed|edit']        = 'Wikipedia indefinitely semi-protected pages',
	['all|all|blp|autoconfirmed|edit']          = 'Wikipedia indefinitely semi-protected biographies of living people',
	['temp|all|blp|autoconfirmed|edit']         = 'Wikipedia temporarily semi-protected biographies of living people',
	['all|all|dispute|autoconfirmed|edit']      = 'Wikipedia pages semi-protected due to dispute',
	['all|all|sock|autoconfirmed|edit']         = 'Wikipedia pages semi-protected from banned users',
	['all|all|vandalism|autoconfirmed|edit']    = 'Wikipedia pages semi-protected against vandalism',
	['all|category|all|autoconfirmed|edit']     = 'Wikipedia semi-protected categories',
	['all|file|all|autoconfirmed|edit']         = 'Wikipedia semi-protected files',
	['all|portal|all|autoconfirmed|edit']       = 'Wikipedia semi-protected portals',
	['all|project|all|autoconfirmed|edit']      = 'Wikipedia semi-protected project pages',
	['all|talk|all|autoconfirmed|edit']         = 'Wikipedia semi-protected talk pages',
	['all|template|all|autoconfirmed|edit']     = 'Wikipedia semi-protected templates',
	['all|user|all|autoconfirmed|edit']         = 'Wikipedia semi-protected user and user talk pages',
	['all|all|all|templateeditor|move']         = 'Wikipedia template-protected pages other than templates and modules',
	['all|all|all|templateeditor|edit']         = 'Wikipedia template-protected pages other than templates and modules',
	['all|template|all|templateeditor|edit']    = 'Wikipedia template-protected templates',
	['all|template|all|templateeditor|move']    = 'Wikipedia template-protected templates', -- move-protected templates
	['all|all|blp|sysop|edit']                  = 'Wikipedia indefinitely protected biographies of living people',
	['temp|all|blp|sysop|edit']                 = 'Wikipedia temporarily protected biographies of living people',
	['all|all|dispute|sysop|edit']              = 'Wikipedia pages protected due to dispute',
	['all|all|sock|sysop|edit']                 = 'Wikipedia pages protected from banned users',
	['all|all|vandalism|sysop|edit']            = 'Wikipedia pages protected against vandalism',
	['all|category|all|sysop|edit']             = 'Wikipedia fully protected categories',
	['all|file|all|sysop|edit']                 = 'Wikipedia fully protected files',
	['all|project|all|sysop|edit']              = 'Wikipedia fully protected project pages',
	['all|talk|all|sysop|edit']                 = 'Wikipedia fully protected talk pages',
	['all|template|all|extendedconfirmed|edit'] = 'Wikipedia extended-confirmed-protected templates',
	['all|template|all|sysop|edit']             = 'Wikipedia fully protected templates',
	['all|user|all|sysop|edit']                 = 'Wikipedia fully protected user and user talk pages',
	['all|module|all|all|edit']                 = 'Wikipedia fully protected modules',
	['all|module|all|templateeditor|edit']      = 'Wikipedia template-protected modules',
	['all|module|all|extendedconfirmed|edit']   = 'Wikipedia extended-confirmed-protected modules',
	['all|module|all|autoconfirmed|edit']       = 'Wikipedia semi-protected modules',
	['all|all|all|sysop|move']                  = 'Wikipedia move-protected pages',
	['indef|all|all|sysop|move']                = 'Wikipedia indefinitely move-protected pages',
	['all|all|dispute|sysop|move']              = 'Wikipedia pages move-protected due to dispute',
	['all|all|vandalism|sysop|move']            = 'Wikipedia pages move-protected due to vandalism',
	['all|portal|all|sysop|move']               = 'Wikipedia move-protected portals',
	['all|project|all|sysop|move']              = 'Wikipedia move-protected project pages',
	['all|talk|all|sysop|move']                 = 'Wikipedia move-protected talk pages',
	['all|template|all|sysop|move']             = 'Wikipedia move-protected templates',
	['all|user|all|sysop|move']                 = 'Wikipedia move-protected user and user talk pages',
	['all|all|all|autoconfirmed|autoreview']    = 'Wikipedia pending changes protected pages',
	['all|file|all|all|upload']                 = 'Wikipedia upload-protected files',
},

--------------------------------------------------------------------------------
-- Expiry category config
--------------------------------------------------------------------------------

-- This table configures the expiry category behaviour for each protection
-- action.
-- * If set to true, setting that action will always categorise the page if
--   an expiry parameter is not set.
-- * If set to false, setting that action will never categorise the page.
-- * If set to nil, the module will categorise the page if:
--   1) an expiry parameter is not set, and
--   2) a reason is provided, and
--   3) the specified reason is not blacklisted in the reasonsWithoutExpiryCheck
--      table.

expiryCheckActions = {
	edit = nil,
	move = false,
	autoreview = true,
	upload = false
},

reasonsWithoutExpiryCheck = {
	blp = true,
	template = true,
},

--------------------------------------------------------------------------------
-- Pagetypes
--------------------------------------------------------------------------------

-- This table produces the page types available with the ${PAGETYPE} parameter.
-- Keys are namespace numbers, or the string "default" for the default value.
pagetypes = {
	[0] = 'article',
	[6] = 'file',
	[10] = 'template',
	[14] = 'category',
	[828] = 'module',
	default = 'page'
},

--------------------------------------------------------------------------------
-- Strings marking indefinite protection
--------------------------------------------------------------------------------

-- This table contains values passed to the expiry parameter that mean the page
-- is protected indefinitely.
indefStrings = {
	['indef'] = true,
	['indefinite'] = true,
	['indefinitely'] = true,
	['infinite'] = true,
},

--------------------------------------------------------------------------------
-- Group hierarchy
--------------------------------------------------------------------------------

-- This table maps each group to all groups that have a superset of the original
-- group's page editing permissions.
hierarchy = {
	sysop = {},
	reviewer = {'sysop'},
	filemover = {'sysop'},
	templateeditor = {'sysop'},
	extendedconfirmed = {'sysop'},
	autoconfirmed = {'reviewer', 'filemover', 'templateeditor', 'extendedconfirmed'},
	user = {'autoconfirmed'},
	['*'] = {'user'}
},

--------------------------------------------------------------------------------
-- Wrapper templates and their default arguments
--------------------------------------------------------------------------------

-- This table contains wrapper templates used with the module, and their
-- default arguments. Templates specified in this table should contain the
-- following invocation, and no other template content:
--
-- {{#invoke:Protection banner|main}}
--
-- If other content is desired, it can be added between
-- &lt;noinclude&gt;...&lt;/noinclude&gt; tags.
--
-- When a user calls one of these wrapper templates, they will use the
-- default arguments automatically. However, users can override any of the
-- arguments.
wrappers = {
	['Template:Pp']                         = {},
	['Template:Protection padlock']         = {},
	['Template:Pp-extended']                = {'ecp'},
	['Template:Pp-blp']                     = {'blp'},
	-- we don't need Template:Pp-create
	['Template:Pp-dispute']                 = {'dispute'},
	['Template:Pp-main-page']               = {'mainpage'},
	['Template:Pp-move']                    = {action = 'move', catonly = 'yes'},
	['Template:Pp-move-dispute']            = {'dispute', action = 'move', catonly = 'yes'},
	-- we don't need Template:Pp-move-indef
	['Template:Pp-move-vandalism']          = {'vandalism', action = 'move', catonly = 'yes'},
	['Template:Pp-office']                  = {'office'},
	['Template:Pp-office-dmca']             = {'dmca'},
	['Template:Pp-pc']                      = {action = 'autoreview', small = true},
	['Template:Pp-pc1']                     = {action = 'autoreview', small = true},
	['Template:Pp-reset']                   = {'reset'},
	['Template:Pp-semi-indef']              = {small = true},
	['Template:Pp-sock']                    = {'sock'},
	['Template:Pp-template']                = {'template', small = true},
	['Template:Pp-upload']                  = {action = 'upload'},
	['Template:Pp-usertalk']                = {'usertalk'},
	['Template:Pp-vandalism']               = {'vandalism'},
},

--------------------------------------------------------------------------------
-- 
--                                 MESSAGES
-- 
--------------------------------------------------------------------------------

msg = {

--------------------------------------------------------------------------------
-- Intro blurb and intro fragment
--------------------------------------------------------------------------------

-- These messages specify what is produced by the ${INTROBLURB} and
-- ${INTROFRAGMENT} parameters. If the protection is temporary they use the
-- intro-blurb-expiry or intro-fragment-expiry, and if not they use
-- intro-blurb-noexpiry or intro-fragment-noexpiry.
-- It is possible to use banner parameters in these messages.
['intro-blurb-expiry'] = '${PROTECTIONBLURB} until ${EXPIRY}.',
['intro-blurb-noexpiry'] = '${PROTECTIONBLURB}.',
['intro-fragment-expiry'] = '${PROTECTIONBLURB} until ${EXPIRY},',
['intro-fragment-noexpiry'] = '${PROTECTIONBLURB}',

--------------------------------------------------------------------------------
-- Tooltip blurb
--------------------------------------------------------------------------------

-- These messages specify what is produced by the ${TOOLTIPBLURB} parameter.
-- If the protection is temporary the tooltip-blurb-expiry message is used, and
-- if not the tooltip-blurb-noexpiry message is used.
-- It is possible to use banner parameters in these messages.
['tooltip-blurb-expiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL} until ${EXPIRY}.',
['tooltip-blurb-noexpiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL}.',
['tooltip-fragment-expiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL} until ${EXPIRY},',
['tooltip-fragment-noexpiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL}',

--------------------------------------------------------------------------------
-- Special explanation blurb
--------------------------------------------------------------------------------

-- An explanation blurb for pages that cannot be unprotected, e.g. for pages
-- in the MediaWiki namespace.
-- It is possible to use banner parameters in this message.
['explanation-blurb-nounprotect'] = 'See the [[Wikipedia:Protection policy|'
	.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
	.. ' Please discuss any changes on the ${TALKPAGE}; you'
	.. ' may ${EDITREQUEST} to ask an'
	.. ' [[Wikipedia:Administrators|administrator]] to make an edit if it'
	.. ' is [[Help:Minor edit#When to mark an edit as a minor edit'
	.. '|uncontroversial]] or supported by [[Wikipedia:Consensus'
	.. '|consensus]].',

--------------------------------------------------------------------------------
-- Protection log display values
--------------------------------------------------------------------------------

-- These messages determine the display values for the protection log link
-- or the pending changes log link produced by the ${PROTECTIONLOG} parameter.
-- It is possible to use banner parameters in these messages.
['protection-log-display'] = 'protection log',
['pc-log-display'] = 'pending changes log',

--------------------------------------------------------------------------------
-- Current version display values
--------------------------------------------------------------------------------

-- These messages determine the display values for the page history link
-- or the move log link produced by the ${CURRENTVERSION} parameter.
-- It is possible to use banner parameters in these messages.
['current-version-move-display'] = 'current title',
['current-version-edit-display'] = 'current version',

--------------------------------------------------------------------------------
-- Talk page
--------------------------------------------------------------------------------

-- This message determines the display value of the talk page link produced
-- with the ${TALKPAGE} parameter.
-- It is possible to use banner parameters in this message.
['talk-page-link-display'] = 'talk page',

--------------------------------------------------------------------------------
-- Edit requests
--------------------------------------------------------------------------------

-- This message determines the display value of the edit request link produced
-- with the ${EDITREQUEST} parameter.
-- It is possible to use banner parameters in this message.
['edit-request-display'] = 'submit an edit request',

--------------------------------------------------------------------------------
-- Expiry date format
--------------------------------------------------------------------------------

-- This is the format for the blurb expiry date. It should be valid input for
-- the first parameter of the #time parser function.
['expiry-date-format'] = 'F j, Y "at" H:i e',

--------------------------------------------------------------------------------
-- Tracking categories
--------------------------------------------------------------------------------

-- These messages determine which tracking categories the module outputs.
['tracking-category-incorrect'] = 'Wikipedia pages with incorrect protection templates',
['tracking-category-template'] = 'Wikipedia template-protected pages other than templates and modules',

--------------------------------------------------------------------------------
-- Images
--------------------------------------------------------------------------------

-- These are images that are not defined by their protection action and protection level.
['image-filename-indef'] = 'Full-protection-shackle.svg',
['image-filename-default'] = 'Transparent.gif',

--------------------------------------------------------------------------------
-- End messages
--------------------------------------------------------------------------------
}

--------------------------------------------------------------------------------
-- End configuration
--------------------------------------------------------------------------------
}</text>
      <sha1>4j9s25hqt968zd5fewsvtkzzg34omaf</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Sidebar</title>
    <ns>828</ns>
    <id>58</id>
    <revision>
      <id>104</id>
      <parentid>103</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>103</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12861" sha1="6x3cinmciqbr9e2030fl1gw7wlxc8lp" xml:space="preserve">require('strict')
local cfg = mw.loadData('Module:Sidebar/configuration')

local p = {}

local getArgs = require('Module:Arguments').getArgs

--[[
Categorizes calling templates and modules with a 'style' parameter of any sort
for tracking to convert to TemplateStyles.

TODO after a long cleanup: Catch sidebars in other namespaces than Template and Module.
TODO would probably want to remove /log and /archive as CS1 does
]]
local function categorizeTemplatesWithInlineStyles(args)
	local title = mw.title.getCurrentTitle()
	if title.namespace ~= 10 and title.namespace ~= 828 then return '' end
	for _, pattern in ipairs (cfg.i18n.pattern.uncategorized_conversion_titles) do
		if title.text:match(pattern) then return '' end
	end
	
	for key, _ in pairs(args) do
		if mw.ustring.find(key, cfg.i18n.pattern.style_conversion) or key == 'width' then
			return cfg.i18n.category.conversion
		end
	end
end

--[[
For compatibility with the original {{sidebar with collapsible lists}}
implementation, which passed some parameters through {{#if}} to trim their
whitespace. This also triggered the automatic newline behavior.
]]
-- See ([[meta:Help:Newlines and spaces#Automatic newline]])
local function trimAndAddAutomaticNewline(s)
	s = mw.ustring.gsub(s, "^%s*(.-)%s*$", "%1")
	if mw.ustring.find(s, '^[#*:;]') or mw.ustring.find(s, '^{|') then
		return '\n' .. s
	else
		return s
	end
end

--[[
Finds whether a sidebar has a subgroup sidebar.
]]
local function hasSubgroup(s)
	if mw.ustring.find(s, cfg.i18n.pattern.subgroup) then
		return true
	else
		return false
	end
end

local function has_navbar(navbar_mode, sidebar_name)
	return navbar_mode ~= cfg.i18n.navbar_none and
		navbar_mode ~= cfg.i18n.navbar_off and
		(
			sidebar_name or
			mw.getCurrentFrame():getParent():getTitle():gsub(cfg.i18n.pattern.sandbox, '') ~=
			cfg.i18n.title_not_to_add_navbar
		)
end

local function has_list_class(args, htmlclass)
	local patterns = {
		'^' .. htmlclass .. '$',
		'%s' .. htmlclass .. '$',
		'^' .. htmlclass .. '%s',
		'%s' .. htmlclass .. '%s'
	}
	
	for arg, value in pairs(args) do
		if type(arg) == 'string' and mw.ustring.find(arg, 'class') then
			for _, pattern in ipairs(patterns) do
				if mw.ustring.find(args[arg] or '', pattern) then
					return true
				end
			end
		end
	end
	return false
end

-- there are a lot of list classes in the wild, so we add their TemplateStyles
local function add_list_styles(args)
	local frame = mw.getCurrentFrame()
	local function add_list_templatestyles(htmlclass, templatestyles)
		if has_list_class(args, htmlclass) then
			return frame:extensionTag{
				name = 'templatestyles', args = { src = templatestyles }
			}
		else
			return ''
		end
	end
	
	local plainlist_styles = add_list_templatestyles('plainlist', cfg.i18n.plainlist_templatestyles)
	local hlist_styles = add_list_templatestyles('hlist', cfg.i18n.hlist_templatestyles)
	
	-- a second workaround for [[phab:T303378]]
	-- when that issue is fixed, we can actually use has_navbar not to emit the
	-- tag here if we want
	if has_navbar(args.navbar, args.name) and hlist_styles == '' then
		hlist_styles = frame:extensionTag{
			name = 'templatestyles', args = { src = cfg.i18n.hlist_templatestyles}
		}
	end

	-- hlist -&gt; plainlist is best-effort to preserve old Common.css ordering. [hlist_note]
	return hlist_styles .. plainlist_styles
end

-- work around [[phab:T303378]]
-- for each arg: find all the templatestyles strip markers, insert them into a
-- table. then remove all templatestyles markers from the arg
local function move_hiding_templatestyles(args)
	local gfind = string.gfind
	local gsub = string.gsub
	local templatestyles_markers = {}
	local strip_marker_pattern = '(\127[^\127]*UNIQ%-%-templatestyles%-%x+%-QINU[^\127]*\127)'
	for k, arg in pairs(args) do
		for marker in gfind(arg, strip_marker_pattern) do
			table.insert(templatestyles_markers, marker)
		end
		args[k] = gsub(arg, strip_marker_pattern, '')
	end
	return templatestyles_markers
end

--[[
Main sidebar function. Takes the frame, args, and an optional collapsibleClass.
The collapsibleClass is and should be used only for sidebars with collapsible
lists, as in p.collapsible.
]]
function p.sidebar(frame, args, collapsibleClass)
	if not args then
		args = getArgs(frame)
	end
	local hiding_templatestyles = table.concat(move_hiding_templatestyles(args))
	local root = mw.html.create()
	local child = args.child and mw.text.trim(args.child) == cfg.i18n.child_yes

	root = root:tag('table')
	if not child then
		root 
			:addClass(cfg.i18n.class.sidebar)
			-- force collapsibleclass to be sidebar-collapse otherwise output nothing
			:addClass(collapsibleClass == cfg.i18n.class.collapse and cfg.i18n.class.collapse or nil)
			:addClass('nomobile')
			:addClass(args.float == cfg.i18n.float_none and cfg.i18n.class.float_none or nil)
			:addClass(args.float == cfg.i18n.float_left and cfg.i18n.class.float_left or nil)
			:addClass(args.wraplinks ~= cfg.i18n.wrap_true and cfg.i18n.class.wraplinks or nil)
			:addClass(args.bodyclass or args.class)
			:css('width', args.width or nil)
			:cssText(args.bodystyle or args.style)

		if args.outertitle then
			root
				:tag('caption')
					:addClass(cfg.i18n.class.outer_title)
					:addClass(args.outertitleclass)
					:cssText(args.outertitlestyle)
					:wikitext(args.outertitle)
		end

		if args.topimage then
			local imageCell = root:tag('tr'):tag('td')

			imageCell
				:addClass(cfg.i18n.class.top_image)
				:addClass(args.topimageclass)
				:cssText(args.topimagestyle)
				:wikitext(args.topimage)

			if args.topcaption then
				imageCell
					:tag('div')
						:addClass(cfg.i18n.class.top_caption)
						:cssText(args.topcaptionstyle)
						:wikitext(args.topcaption)
			end
		end

		if args.pretitle then
			root
				:tag('tr')
					:tag('td')
						:addClass(args.topimage and cfg.i18n.class.pretitle_with_top_image
							or cfg.i18n.class.pretitle)
						:addClass(args.pretitleclass)
						:cssText(args.basestyle)
						:cssText(args.pretitlestyle)
						:wikitext(args.pretitle)
		end
	else
		root
			:addClass(cfg.i18n.class.subgroup)
			:addClass(args.bodyclass or args.class)
			:cssText(args.bodystyle or args.style)
	end

	if args.title then
		if child then
			root
				:wikitext(args.title)
		else
			root
				:tag('tr')
					:tag('th')
						:addClass(args.pretitle and cfg.i18n.class.title_with_pretitle
							or cfg.i18n.class.title)
						:addClass(args.titleclass)
						:cssText(args.basestyle)
						:cssText(args.titlestyle)
						:wikitext(args.title)
		end
	end

	if args.image then
		local imageCell = root:tag('tr'):tag('td')

		imageCell
			:addClass(cfg.i18n.class.image)
			:addClass(args.imageclass)
			:cssText(args.imagestyle)
			:wikitext(args.image)

		if args.caption then
			imageCell
				:tag('div')
					:addClass(cfg.i18n.class.caption)
					:cssText(args.captionstyle)
					:wikitext(args.caption)
		end
	end

	if args.above then
		root
			:tag('tr')
				:tag('td')
					:addClass(cfg.i18n.class.above)
					:addClass(args.aboveclass)
					:cssText(args.abovestyle)
					:newline() -- newline required for bullet-points to work
					:wikitext(args.above)
	end

	local rowNums = {}
	for k, v in pairs(args) do
		k = '' .. k
		local num = k:match('^heading(%d+)$') or k:match('^content(%d+)$')
		if num then table.insert(rowNums, tonumber(num)) end
	end
	table.sort(rowNums)
	-- remove duplicates from the list (e.g. 3 will be duplicated if both heading3
	-- and content3 are specified)
	for i = #rowNums, 1, -1 do
		if rowNums[i] == rowNums[i - 1] then
			table.remove(rowNums, i)
		end
	end

	for i, num in ipairs(rowNums) do
		local heading = args['heading' .. num]
		if heading then
			root
				:tag('tr')
					:tag('th')
						:addClass(cfg.i18n.class.heading)
						:addClass(args.headingclass)
						:addClass(args['heading' .. num .. 'class'])
						:cssText(args.basestyle)
						:cssText(args.headingstyle)
						:cssText(args['heading' .. num .. 'style'])
						:newline()
						:wikitext(heading)
		end

		local content = args['content' .. num]
		if content then
			root
				:tag('tr')
					:tag('td')
						:addClass(hasSubgroup(content) and cfg.i18n.class.content_with_subgroup
							or cfg.i18n.class.content)
						:addClass(args.contentclass)
						:addClass(args['content' .. num .. 'class'])
						:cssText(args.contentstyle)
						:cssText(args['content' .. num .. 'style'])
						:newline()
						:wikitext(content)
						:done()
					 -- Without a linebreak after the &lt;/td&gt;, a nested list like
					 -- "* {{hlist| ...}}" doesn't parse correctly.
					:newline()
		end
	end

	if args.below then
		root
			:tag('tr')
				:tag('td')
					:addClass(cfg.i18n.class.below)
					:addClass(args.belowclass)
					:cssText(args.belowstyle)
					:newline()
					:wikitext(args.below)
	end

	if not child and has_navbar(args.navbar, args.name) then
		root
			:tag('tr')
				:tag('td')
					:addClass(cfg.i18n.class.navbar)
					:cssText(args.navbarstyle)
					:wikitext(require('Module:Navbar')._navbar{
						args.name,
						mini = 1,
						fontstyle = args.navbarfontstyle
					})
	end
	
	local base_templatestyles = frame:extensionTag{
		name = 'templatestyles', args = { src = cfg.i18n.templatestyles }
	}
	
	local templatestyles = ''
	if args['templatestyles'] and args['templatestyles'] ~= '' then
		templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['templatestyles'] }
		}
	end
	
	local child_templatestyles = ''
	if args['child templatestyles'] and args['child templatestyles'] ~= '' then
		child_templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['child templatestyles'] }
		}
	end
	
	local grandchild_templatestyles = ''
	if args['grandchild templatestyles'] and args['grandchild templatestyles'] ~= '' then
		grandchild_templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['grandchild templatestyles'] }
		}
	end

	return table.concat({
		add_list_styles(args), -- see [hlist_note] above about ordering
		base_templatestyles,
		templatestyles,
		child_templatestyles,
		grandchild_templatestyles,
		hiding_templatestyles,
		tostring(root),
		(child and cfg.i18n.category.child or ''),
		categorizeTemplatesWithInlineStyles(args)
	})
end

local function list_title(args, is_centered_list_titles, num)
	
	local title_text = trimAndAddAutomaticNewline(args['list' .. num .. 'title']
		or cfg.i18n.default_list_title)

	local title
	if is_centered_list_titles then
		-- collapsible can be finicky, so provide some CSS/HTML to support
		title = mw.html.create('div')
			:addClass(cfg.i18n.class.list_title_centered)
			:wikitext(title_text)
	else
		title = mw.html.create()
			:wikitext(title_text)
	end
		
	local title_container = mw.html.create('div')
		:addClass(cfg.i18n.class.list_title)
		-- don't /need/ a listnumtitleclass because you can do
		-- .templateclass .listnumclass .sidebar-list-title
		:addClass(args.listtitleclass)
		:cssText(args.basestyle)
		:cssText(args.listtitlestyle)
		:cssText('color: var(--color-base)')
		:cssText(args['list' .. num .. 'titlestyle'])
		:node(title)
		:done()
	
	return title_container
end

--[[
Main entry point for sidebar with collapsible lists.
Does the work of creating the collapsible lists themselves and including them
into the args.
]]
function p.collapsible(frame)
	local args = getArgs(frame)
	if not args.name and
		frame:getParent():getTitle():gsub(cfg.i18n.pattern.collapse_sandbox, '') ==
		cfg.i18n.collapse_title_not_to_add_navbar then
		args.navbar = cfg.i18n.navbar_none
	end

	local contentArgs = {}
	
	local is_centered_list_titles = false
	if args['centered list titles'] and args['centered list titles'] ~= '' then
		is_centered_list_titles = true
	end

	for k, v in pairs(args) do
		local num = string.match(k, '^list(%d+)$')
		if num then
			local expand = args.expanded and
				(args.expanded == 'all' or args.expanded == args['list' .. num .. 'name'])
			local row = mw.html.create('div')
			row
				:addClass(cfg.i18n.class.list)
				:addClass('mw-collapsible')
				:addClass((not expand) and 'mw-collapsed' or nil)
				:addClass(args['list' .. num .. 'class'])
				:cssText(args.listframestyle)
				:cssText(args['list' .. num .. 'framestyle'])
				:node(list_title(args, is_centered_list_titles, num))
				:tag('div')
					:addClass(cfg.i18n.class.list_content)
					:addClass('mw-collapsible-content')
					-- don't /need/ a listnumstyleclass because you can do
					-- .templatename .listnumclass .sidebar-list
					:addClass(args.listclass)
					:cssText(args.liststyle)
					:cssText(args['list' .. num .. 'style'])
					:wikitext(trimAndAddAutomaticNewline(args['list' .. num]))

			contentArgs['content' .. num] = tostring(row)
		end
	end

	for k, v in pairs(contentArgs) do
		args[k] = v
	end

	return p.sidebar(frame, args, cfg.i18n.class.collapse)
end

return p</text>
      <sha1>6x3cinmciqbr9e2030fl1gw7wlxc8lp</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Sidebar/configuration</title>
    <ns>828</ns>
    <id>59</id>
    <revision>
      <id>106</id>
      <parentid>105</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>105</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1796" sha1="ppudujplp1136qu7hp1z0z4rq8ga0wl" xml:space="preserve">return {
	i18n = {
		child_yes = 'yes',
		float_none = 'none',
		float_left = 'left',
		wrap_true = 'true',
		navbar_none = 'none',
		navbar_off = 'off',
		default_list_title = 'List',
		title_not_to_add_navbar = 'Template:Sidebar',
		collapse_title_not_to_add_navbar = 'Template:Sidebar with collapsible lists',
		templatestyles = 'Module:Sidebar/styles.css',
		hlist_templatestyles = 'Hlist/styles.css',
		plainlist_templatestyles = 'Plainlist/styles.css',
		category = {
			child = '[[Category:Pages using sidebar with the child parameter]]',
			conversion = '[[Category:Sidebars with styles needing conversion]]'
		},
		pattern = {
			collapse_sandbox = '/sandbox$',
			sandbox = '/sandbox$',
			subgroup = 'sidebar%-subgroup',
			style_conversion = 'style$',
			uncategorized_conversion_titles = {
				'/[Ss]andbox',
				'/[Tt]estcases',
				'/[Dd]oc$'
			}
		},
		class = {
			sidebar = 'sidebar',
			subgroup = 'sidebar-subgroup',
			collapse = 'sidebar-collapse',
			float_none = 'sidebar-none',
			float_left = 'sidebar-left',
			wraplinks = 'nowraplinks',
			outer_title = 'sidebar-outer-title',
			top_image = 'sidebar-top-image',
			top_caption = 'sidebar-top-caption',
			pretitle = 'sidebar-pretitle',
			pretitle_with_top_image = 'sidebar-pretitle-with-top-image',
			title = 'sidebar-title',
			title_with_pretitle = 'sidebar-title-with-pretitle',
			image = 'sidebar-image',
			caption = 'sidebar-caption',
			above = 'sidebar-above',
			heading = 'sidebar-heading',
			content = 'sidebar-content',
			content_with_subgroup = 'sidebar-content-with-subgroup',
			below = 'sidebar-below',
			navbar = 'sidebar-navbar',
			list = 'sidebar-list',
			list_title = 'sidebar-list-title',
			list_title_centered = 'sidebar-list-title-c',
			list_content = 'sidebar-list-content'
		}
	}
}</text>
      <sha1>ppudujplp1136qu7hp1z0z4rq8ga0wl</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Sidebar/styles.css</title>
    <ns>828</ns>
    <id>60</id>
    <revision>
      <id>108</id>
      <parentid>107</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>107</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="4899" sha1="j9rltrco0eevefcj27cgv3uari248t0" xml:space="preserve">/* {{pp-template}} */
/* TODO: Invert width design to be "mobile first" */
.sidebar {
	/* TODO: Ask if we should have max-width 22em instead */
	width: 22em;
	/* @noflip */
	float: right;
	/* @noflip */
	clear: right;
	/* @noflip */
	margin: 0.5em 0 1em 1em;
	background: var(--background-color-neutral-subtle, #f8f9fa);
	border: 1px solid var(--border-color-base, #a2a9b1);
	padding: 0.2em;
	text-align: center;
	line-height: 1.4em;
	font-size: 88%;
	border-collapse: collapse;
	/* Timeless has display: none on .nomobile at mobile resolutions, so we
	 * unhide it with display: table and let precedence and proximity win.
	 */
	display: table; 
}

/* Unfortunately, so does Minerva desktop, except Minerva drops an
 * !important on the declaration. So we have to be mean for Minerva users.
 * Mobile removes the element entirely with `wgMFRemovableClasses` in 
 * https://github.com/wikimedia/operations-mediawiki-config/blob/master/
 wmf-config/InitialiseSettings.php#L16992
 * which is why displaying it categorically with display: table works.
 * We don't really want to expose the generic user in the wild on mobile to have
 * to deal with sidebars. (Maybe the ones with collapsible lists, so that
 * might be an improvement. That is blocked on [[:phab:T111565]].)
 */
body.skin-minerva .sidebar {
	display: table !important;
	/* also, minerva is way too aggressive about other stylings on tables.
	 * TODO remove when this template gets moved to a div. plans on talk page.
	 * We always float right on Minerva because that's a lot of extra CSS
	 * otherwise. */
    float: right !important;
    margin: 0.5em 0 1em 1em !important;
}

.sidebar-subgroup {
	width: 100%;
	margin: 0;
	border-spacing: 0;
}

.sidebar-left {
	/* @noflip */
	float: left;
	/* @noflip */
	clear: left;
	/* @noflip */
	margin: 0.5em 1em 1em 0;
}

.sidebar-none {
	float: none;
	clear: both;
	/* @noflip */
	margin: 0.5em 1em 1em 0;
}

.sidebar-outer-title {
	padding: 0 0.4em 0.2em;
	font-size: 125%;
	line-height: 1.2em;
	font-weight: bold;
}

.sidebar-top-image {
	padding: 0.4em;
}

.sidebar-top-caption,
.sidebar-pretitle-with-top-image,
.sidebar-caption {
	padding: 0.2em 0.4em 0;
	line-height: 1.2em;
}

.sidebar-pretitle {
	padding: 0.4em 0.4em 0;
	line-height: 1.2em;
}

.sidebar-title,
.sidebar-title-with-pretitle {
	padding: 0.2em 0.8em;
	font-size: 145%;
	line-height: 1.2em;
}

.sidebar-title-with-pretitle {
	padding: 0.1em 0.4em;
}

.sidebar-image {
	padding: 0.2em 0.4em 0.4em;
}

.sidebar-heading {
	padding: 0.1em 0.4em;
}

.sidebar-content {
	padding: 0 0.5em 0.4em;
}

.sidebar-content-with-subgroup {
	padding: 0.1em 0.4em 0.2em;
}

.sidebar-above,
.sidebar-below {
	padding: 0.3em 0.8em;
	font-weight: bold;
}

.sidebar-collapse .sidebar-above,
.sidebar-collapse .sidebar-below {
	border-top: 1px solid #aaa;
	border-bottom: 1px solid #aaa;
}

.sidebar-navbar {
	text-align: right;
	font-size: 115%;
	padding: 0 0.4em 0.4em;
}

.sidebar-list-title {
	padding: 0 0.4em;
	text-align: left;
	font-weight: bold;
	line-height: 1.6em;
	font-size: 105%;
}

/* centered text with mw-collapsible headers is finicky */
.sidebar-list-title-c {
	padding: 0 0.4em;
	text-align: center;
	margin: 0 3.3em;
}

@media (max-width: 640px) {
	/* users have wide latitude to set arbitrary width and margin :(
	   "Super-specific" selector to prevent overriding this appearance by
	   lower level sidebars too */
	body.mediawiki .sidebar {
		width: 100% !important;
		clear: both;
		float: none !important; /* Remove when we div based; Minerva is dumb */
		margin-left: 0 !important;
		margin-right: 0 !important;
	}
	/* TODO: We might consider making all links wrap at small resolutions and then
	 * only introduce nowrap at higher resolutions. Do when we invert the media
	 * query.
	 */
}

/* Fixes: T367463 */
body.skin--responsive .sidebar a &gt; img {
	max-width: none !important;
}

/* Disable backgrounds via style attribute in night mode Eg.https://phabricator.wikimedia.org/F55243859
 * https://en.wikipedia.org/w/index.php?title=Laissez-faire
 */

@media screen {
    html.skin-theme-clientpref-night .sidebar:not( .notheme ) .sidebar-list-title,
    html.skin-theme-clientpref-night .sidebar:not( .notheme ) .sidebar-title-with-pretitle {
	  background: transparent !important;
    }

    html.skin-theme-clientpref-night .sidebar:not( .notheme ) .sidebar-title-with-pretitle a {
     	color: var( --color-progressive ) !important;
    }
}

@media screen and (prefers-color-scheme: dark) {
	html.skin-theme-clientpref-os .sidebar:not( .notheme ) .sidebar-list-title,
	html.skin-theme-clientpref-os .sidebar:not( .notheme ) .sidebar-title-with-pretitle {
		background: transparent !important;
	}
	
	html.skin-theme-clientpref-os .sidebar:not( .notheme ) .sidebar-title-with-pretitle a {
		color: var( --color-progressive ) !important;
	}
}

@media print {
	body.ns-0 .sidebar {
		display: none !important;
	}
}</text>
      <sha1>j9rltrco0eevefcj27cgv3uari248t0</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Anchor</title>
    <ns>10</ns>
    <id>61</id>
    <revision>
      <id>110</id>
      <parentid>109</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>109</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="177" sha1="enb6c4d9v8ozj2bh2wvmo7698r1sot4" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:anchor|main}}&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>enb6c4d9v8ozj2bh2wvmo7698r1sot4</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ombox</title>
    <ns>10</ns>
    <id>62</id>
    <revision>
      <id>112</id>
      <parentid>111</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>111</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="146" sha1="1o93yrjvq6v2ylug2k0uaaltljurje2" xml:space="preserve">{{#invoke:Message box|ombox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>1o93yrjvq6v2ylug2k0uaaltljurje2</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Anchor</title>
    <ns>828</ns>
    <id>63</id>
    <revision>
      <id>114</id>
      <parentid>113</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>113</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="647" sha1="qn9l8z10vmc8ghld7804a9aaffg6g8o" xml:space="preserve">-- This module implements {{anchor}}.

local getArgs = require('Module:Arguments').getArgs
local tableTools = require('Module:TableTools')

local p = {}

function p.main(frame)
	-- Get the positional arguments from #invoke, remove any nil values,
	-- and pass them to p._main.
	local args = getArgs(frame)
	local argArray = tableTools.compressSparseArray(args)
	return p._main(unpack(argArray))
end

function p._main(...)
	-- Generate the list of anchors.
	local anchors = {...}
	local ret = {}
	for _, anchor in ipairs(anchors) do
		ret[#ret + 1] = '&lt;span class="anchor" id="' .. anchor .. '"&gt;&lt;/span&gt;'
	end
	return table.concat(ret)
end

return p</text>
      <sha1>qn9l8z10vmc8ghld7804a9aaffg6g8o</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Efn</title>
    <ns>10</ns>
    <id>64</id>
    <revision>
      <id>116</id>
      <parentid>115</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>115</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="667" sha1="95uusiggd4cbf2ushwzxco3q2lmfbi1" xml:space="preserve">&lt;includeonly&gt;{{safesubst&lt;noinclude /&gt;:#if:{{{name|}}}
 |{{#tag:ref|{{{1|{{{reference|{{{content|{{{text|}}}}}}}}}}}}|name={{{name|}}}|group={{safesubst&lt;noinclude /&gt;:#switch: {{{group|}}}
    | note
    | upper-alpha
    | upper-roman
    | lower-alpha
    | lower-greek
    | lower-roman = {{{group|}}}
    | #default = lower-alpha
   }}}}
 |{{#tag:ref|{{{1|{{{reference|{{{content|{{{text|}}}}}}}}}}}}|group={{safesubst&lt;noinclude /&gt;:#switch: {{{group|}}}
    | note
    | upper-alpha
    | upper-roman
    | lower-alpha
    | lower-greek
    | lower-roman = {{{group|}}}
    | #default = lower-alpha
   }}}}
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>95uusiggd4cbf2ushwzxco3q2lmfbi1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Notelist</title>
    <ns>10</ns>
    <id>65</id>
    <revision>
      <id>118</id>
      <parentid>117</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>117</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="628" sha1="ttl05oyjrjjibaztk1xwnv8vtuovzpm" xml:space="preserve">{{safesubst&lt;noinclude /&gt;:reflist|{{{1|{{{colwidth|}}}}}}|refs={{{refs|{{{notes|}}}}}}|group={{safesubst&lt;noinclude /&gt;:#switch: {{{group|}}}
    | note
    | upper-alpha
    | upper-roman
    | lower-alpha
    | lower-greek
    | lower-roman = {{{group|}}}
    | #default = lower-alpha
   }}}}{{safesubst&lt;noinclude /&gt;:#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using notelist with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Notelist]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | colwidth | group | notes | refs }}&lt;noinclude&gt;
{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>ttl05oyjrjjibaztk1xwnv8vtuovzpm</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Color contrast</title>
    <ns>828</ns>
    <id>66</id>
    <revision>
      <id>120</id>
      <parentid>119</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>119</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6967" sha1="bx0blwcv5isqzm2jrxnp01lj4148n73" xml:space="preserve">--
-- This module implements
--  {{Color contrast ratio}}
--  {{Greater color contrast ratio}}
--  {{ColorToLum}}
--  {{RGBColorToLum}}
--
local p = {}
local HTMLcolor = mw.loadData( 'Module:Color contrast/colors' )

local function sRGB (v)
	if (v &lt;= 0.03928) then
		v = v / 12.92
	else
		v = math.pow((v+0.055)/1.055, 2.4)
	end
	return v
end

local function rgbdec2lum(R, G, B)
	if ( 0 &lt;= R and R &lt; 256 and 0 &lt;= G and G &lt; 256 and 0 &lt;= B and B &lt; 256 ) then
		return 0.2126 * sRGB(R/255) + 0.7152 * sRGB(G/255) + 0.0722 * sRGB(B/255)
	else
		return ''
	end
end

local function hsl2lum(h, s, l)
	if ( 0 &lt;= h and h &lt; 360 and 0 &lt;= s and s &lt;= 1 and 0 &lt;= l and l &lt;= 1 ) then
		local c = (1 - math.abs(2*l - 1))*s
		local x = c*(1 - math.abs( math.fmod(h/60, 2) - 1) )
		local m = l - c/2

		local r, g, b = m, m, m
		if( 0 &lt;= h and h &lt; 60 ) then
			r = r + c
			g = g + x
		elseif( 60 &lt;= h and h &lt; 120 ) then
			r = r + x
			g = g + c
		elseif( 120 &lt;= h and h &lt; 180 ) then
			g = g + c
			b = b + x
		elseif( 180 &lt;= h and h &lt; 240 ) then
			g = g + x
			b = b + c
		elseif( 240 &lt;= h and h &lt; 300 ) then
			r = r + x
			b = b + c
		elseif( 300 &lt;= h and h &lt; 360 ) then
			r = r + c
			b = b + x
		end
		return rgbdec2lum(255*r, 255*g, 255*b)
	else
		return ''
	end
end

local function color2lum(c)

	if (c == nil) then
		return ''
	end

	-- html '#' entity
	c = c:gsub("&amp;#35;", "#")

	-- whitespace
	c = c:match( '^%s*(.-)[%s;]*$' )

	-- unstrip nowiki strip markers
	c = mw.text.unstripNoWiki(c)

	-- lowercase
	c = c:lower()

	-- first try to look it up
	local L = HTMLcolor[c]
	if (L ~= nil) then
		return L
	end

	-- convert from hsl
	if mw.ustring.match(c,'^hsl%([%s]*[0-9][0-9%.]*[%s]*,[%s]*[0-9][0-9%.]*%%[%s]*,[%s]*[0-9][0-9%.]*%%[%s]*%)$') then
		local h, s, l = mw.ustring.match(c,'^hsl%([%s]*([0-9][0-9%.]*)[%s]*,[%s]*([0-9][0-9%.]*)%%[%s]*,[%s]*([0-9][0-9%.]*)%%[%s]*%)$')
		return hsl2lum(tonumber(h), tonumber(s)/100, tonumber(l)/100)
	end

	-- convert from rgb
	if mw.ustring.match(c,'^rgb%([%s]*[0-9][0-9]*[%s]*,[%s]*[0-9][0-9]*[%s]*,[%s]*[0-9][0-9]*[%s]*%)$') then
		local R, G, B = mw.ustring.match(c,'^rgb%([%s]*([0-9][0-9]*)[%s]*,[%s]*([0-9][0-9]*)[%s]*,[%s]*([0-9][0-9]*)[%s]*%)$')
		return rgbdec2lum(tonumber(R), tonumber(G), tonumber(B))
	end

	-- convert from rgb percent
	if mw.ustring.match(c,'^rgb%([%s]*[0-9][0-9%.]*%%[%s]*,[%s]*[0-9][0-9%.]*%%[%s]*,[%s]*[0-9][0-9%.]*%%[%s]*%)$') then
		local R, G, B = mw.ustring.match(c,'^rgb%([%s]*([0-9][0-9%.]*)%%[%s]*,[%s]*([0-9][0-9%.]*)%%[%s]*,[%s]*([0-9][0-9%.]*)%%[%s]*%)$')
		return rgbdec2lum(255*tonumber(R)/100, 255*tonumber(G)/100, 255*tonumber(B)/100)
	end

	-- remove leading # (if there is one) and whitespace
	c = mw.ustring.match(c, '^[%s#]*([a-f0-9]*)[%s]*$')

	-- split into rgb
	local cs = mw.text.split(c or '', '')
	if( #cs == 6 ) then
		local R = 16*tonumber('0x' .. cs[1]) + tonumber('0x' .. cs[2])
		local G = 16*tonumber('0x' .. cs[3]) + tonumber('0x' .. cs[4])
		local B = 16*tonumber('0x' .. cs[5]) + tonumber('0x' .. cs[6])

		return rgbdec2lum(R, G, B)
	elseif ( #cs == 3 ) then
		local R = 16*tonumber('0x' .. cs[1]) + tonumber('0x' .. cs[1])
		local G = 16*tonumber('0x' .. cs[2]) + tonumber('0x' .. cs[2])
		local B = 16*tonumber('0x' .. cs[3]) + tonumber('0x' .. cs[3])

		return rgbdec2lum(R, G, B)
	end

	-- failure, return blank
	return ''
end

-- This exports the function for use in other modules.
-- The colour is passed as a string.
function p._lum(color)
	return color2lum(color)
end

function p._greatercontrast(args)
	local bias = tonumber(args['bias'] or '0') or 0
	local css = (args['css'] and args['css'] ~= '') and true or false
	local v1 = color2lum(args[1] or '')
	local c2 = args[2] or 'white'
	local v2 = color2lum(c2)
	local c3 = args[3] or 'black'
	local v3 = color2lum(c3)
	local ratio1 = -1;
	local ratio2 = -1;
	if (type(v1) == 'number' and type(v2) == 'number') then
		ratio1 = (v2 + 0.05)/(v1 + 0.05)
		ratio1 = (ratio1 &lt; 1) and 1/ratio1 or ratio1
	end
	if (type(v1) == 'number' and type(v3) == 'number') then
		ratio2 = (v3 + 0.05)/(v1 + 0.05)
		ratio2 = (ratio2 &lt; 1) and 1/ratio2 or ratio2
	end

	if css then
		local c1 = args[1] or ''
		if mw.ustring.match(c1, '^[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]$') or
			mw.ustring.match(c1, '^[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]$') then
				c1 = '#' .. c1
		end
		if mw.ustring.match(c2, '^[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]$') or
			mw.ustring.match(c2, '^[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]$') then
				c2 = '#' .. c2
		end
		if mw.ustring.match(v3, '^[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]$') or
			mw.ustring.match(v3, '^[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]$') then
				c3 = '#' .. c3
		end
		return 'background-color:' .. c1 .. '; color:' .. ((ratio1 &gt; 0) and (ratio2 &gt; 0) and ((ratio1 + bias &gt; ratio2) and c2 or c3) or '') .. ';'
	end

	return (ratio1 &gt; 0) and (ratio2 &gt; 0) and ((ratio1 + bias &gt; ratio2) and c2 or c3) or ''
end

function p._ratio(args)
	local v1 = color2lum(args[1])
	local v2 = color2lum(args[2])
	if (type(v1) == 'number' and type(v2) == 'number') then
		-- v1 should be the brighter of the two.
		if v2 &gt; v1 then
			v1, v2 = v2, v1
		end
		return (v1 + 0.05)/(v2 + 0.05)
	else
		return args['error'] or '?'
	end
end

function p._styleratio(args)
	local style = (args[1] or ''):lower()
	local bg, fg = 'white', 'black'
	local lum_bg, lum_fg = 1, 0

	if args[2] then
		local lum = color2lum(args[2])
		if lum ~= '' then bg, lum_bg = args[2], lum end
	end
	if args[3] then
		local lum = color2lum(args[3])
		if lum ~= '' then fg, lum_fg = args[3], lum end
	end

	local slist = mw.text.split(mw.ustring.gsub(mw.ustring.gsub(style or '', '&amp;#[Xx]23;', '#'), '&amp;#35;', '#'), ';')
	for k = 1,#slist do
		local s = slist[k]
		local k,v = s:match( '^[%s]*([^:]-):([^:]-)[%s;]*$' )
		k = k or ''
		v = v or ''
		if (k:match('^[%s]*(background)[%s]*$') or k:match('^[%s]*(background%-color)[%s]*$')) then
			local lum = color2lum(v)
			if( lum ~= '' ) then bg, lum_bg = v, lum end
		elseif (k:match('^[%s]*(color)[%s]*$')) then
			local lum = color2lum(v)
			if( lum ~= '' ) then bg, lum_fg = v, lum end
		end
	end
	if lum_bg &gt; lum_fg then
		return (lum_bg + 0.05)/(lum_fg + 0.05)
	else
		return (lum_fg + 0.05)/(lum_bg + 0.05)
	end
end

--[[
Use {{#invoke:Color contrast|somecolor}} directly or
{{#invoke:Color contrast}} from a wrapper template.

Parameters:
	-- |1=	— required; A color to check.
--]]
function p.lum(frame)
	local color = frame.args[1] or frame:getParent().args[1]
	return p._lum(color)
end

function p.ratio(frame)
	local args = frame.args[1] and frame.args or frame:getParent().args
	return p._ratio(args)
end

function p.styleratio(frame)
	local args = frame.args[1] and frame.args or frame:getParent().args
	return p._styleratio(args)
end

function p.greatercontrast(frame)
	local args = frame.args[1] and frame.args or frame:getParent().args
	return p._greatercontrast(args)
end

return p</text>
      <sha1>bx0blwcv5isqzm2jrxnp01lj4148n73</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Color contrast/colors</title>
    <ns>828</ns>
    <id>67</id>
    <revision>
      <id>122</id>
      <parentid>121</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>121</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6119" sha1="chi69ar1btd4wp6xbk3uez6sfu0vipn" xml:space="preserve">return {
	aliceblue            = 0.92880068253475,
	antiquewhite         = 0.84646951707754,
	aqua                 = 0.7874,
	aquamarine           = 0.8078549208338,
	azure                = 0.97265264954166,
	beige                = 0.8988459998705,
	bisque               = 0.80732327372979,
	black                = 0,
	blanchedalmond       = 0.85084439608156,
	blue                 = 0.0722,
	blueviolet           = 0.12622014321946,
	brown                = 0.098224287876511,
	burlywood            = 0.51559844533893,
	cadetblue            = 0.29424681085422,
	chartreuse           = 0.76032025902623,
	chocolate            = 0.23898526114557,
	coral                = 0.37017930872924,
	cornflowerblue       = 0.30318641994179,
	cornsilk             = 0.93562110372965,
	crimson              = 0.16042199953026,
	cyan                 = 0.7874,
	darkblue             = 0.018640801980939,
	darkcyan             = 0.20329317839046,
	darkgoldenrod        = 0.27264703559993,
	darkgray             = 0.39675523072563,
	darkgreen            = 0.091143429047575,
	darkgrey             = 0.39675523072563,
	darkkhaki            = 0.45747326349994,
	darkmagenta          = 0.07353047651207,
	darkolivegreen       = 0.12651920884889,
	darkorange           = 0.40016167026524,
	darkorchid           = 0.13413142174857,
	darkred              = 0.054889674531132,
	darksalmon           = 0.40541471563381,
	darkseagreen         = 0.43789249325969,
	darkslateblue        = 0.065792846227988,
	darkslategray        = 0.067608151928044,
	darkslategrey        = 0.067608151928044,
	darkturquoise        = 0.4874606277449,
	darkviolet           = 0.10999048339343,
	deeppink             = 0.23866895828276,
	deepskyblue          = 0.44481603395575,
	dimgray              = 0.14126329114027,
	dimgrey              = 0.14126329114027,
	dodgerblue           = 0.27442536991456,
	firebrick            = 0.10724525535015,
	floralwhite          = 0.95922484825004,
	forestgreen          = 0.18920812076002,
	fuchsia              = 0.2848,
	gainsboro            = 0.71569350050648,
	ghostwhite           = 0.94311261886323,
	gold                 = 0.69860877428159,
	goldenrod            = 0.41919977809569,
	gray                 = 0.2158605001139,
	green                = 0.15438342968146,
	greenyellow          = 0.80609472611453,
	grey                 = 0.2158605001139,
	honeydew             = 0.96336535554782,
	hotpink              = 0.34658438169715,
	indianred            = 0.21406134963884,
	indigo               = 0.03107561486337,
	ivory                = 0.99071270600615,
	khaki                = 0.77012343394121,
	lavender             = 0.80318750514521,
	lavenderblush        = 0.90172748631046,
	lawngreen            = 0.73905893124963,
	lemonchiffon         = 0.94038992245622,
	lightblue            = 0.63709141280807,
	lightcoral           = 0.35522120733135,
	lightcyan            = 0.94587293494829,
	lightgoldenrodyellow = 0.93348351018297,
	lightgray            = 0.65140563741982,
	lightgreen           = 0.69091979956865,
	lightgrey            = 0.65140563741982,
	lightpink            = 0.58566152734898,
	lightsalmon          = 0.4780675225206,
	lightseagreen        = 0.35050145117042,
	lightskyblue         = 0.56195637618331,
	lightslategray       = 0.23830165007287,
	lightslategrey       = 0.23830165007287,
	lightsteelblue       = 0.53983888284666,
	lightyellow          = 0.98161818392882,
	lime                 = 0.7152,
	limegreen            = 0.44571042246098,
	linen                = 0.88357340984379,
	magenta              = 0.2848,
	maroon               = 0.045891942324215,
	mediumaquamarine     = 0.49389703310801,
	mediumblue           = 0.044077780212328,
	mediumorchid         = 0.21639251153773,
	mediumpurple         = 0.22905858091648,
	mediumseagreen       = 0.34393112338131,
	mediumslateblue      = 0.20284629471622,
	mediumspringgreen    = 0.70704308194184,
	mediumturquoise      = 0.5133827926448,
	mediumvioletred      = 0.14371899849357,
	midnightblue         = 0.02071786635086,
	mintcream            = 0.97834604947588,
	mistyrose            = 0.82183047859185,
	moccasin             = 0.80083000991567,
	navajowhite          = 0.76519682342785,
	navy                 = 0.015585128108224,
	oldlace              = 0.91900633405549,
	olive                = 0.20027537200568,
	olivedrab            = 0.22593150951929,
	orange               = 0.4817026703631,
	orangered            = 0.25516243753416,
	orchid               = 0.31348806761439,
	palegoldenrod        = 0.78792647887614,
	palegreen            = 0.77936759006353,
	paleturquoise        = 0.76436077921714,
	palevioletred        = 0.28754994117889,
	papayawhip           = 0.87797100199835,
	peachpuff            = 0.74905589878251,
	peru                 = 0.30113074877936,
	pink                 = 0.63271070702466,
	plum                 = 0.45734221587969,
	powderblue           = 0.68254586500605,
	purple               = 0.061477070432439,
	rebeccapurple        = 0.07492341159447,
	red                  = 0.2126,
	rosybrown            = 0.32319457649407,
	royalblue            = 0.16663210743188,
	saddlebrown          = 0.097922285020521,
	salmon               = 0.36977241527596,
	sandybrown           = 0.46628543696283,
	seagreen             = 0.19734199706275,
	seashell             = 0.92737862206922,
	sienna               = 0.13697631337098,
	silver               = 0.52711512570581,
	skyblue              = 0.55291668518184,
	slateblue            = 0.14784278062136,
	slategray            = 0.20896704076536,
	slategrey            = 0.20896704076536,
	snow                 = 0.96533341834849,
	springgreen          = 0.73052306068529,
	steelblue            = 0.20562642207625,
	tan                  = 0.48237604163921,
	teal                 = 0.16996855778968,
	thistle              = 0.56818401093733,
	tomato               = 0.30638612719415,
	turquoise            = 0.5895536427578,
	violet               = 0.40315452986676,
	wheat                = 0.74909702820482,
	white                = 1,
	whitesmoke           = 0.91309865179342,
	yellow               = 0.9278,
	yellowgreen          = 0.50762957208707,
}</text>
      <sha1>chi69ar1btd4wp6xbk3uez6sfu0vipn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Color</title>
    <ns>10</ns>
    <id>68</id>
    <revision>
      <id>124</id>
      <parentid>123</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>123</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="335" sha1="mir66vdgg1ofukylprfapm1rh3vaahk" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;ifsubst|1=&lt;span|2=&lt;templatestyles src="Template:Color/styles.css" /&gt;&lt;span class="tmp-color"}} style="color:{{{1|}}}"&gt;{{{2|{{{1|}}}}}}&lt;includeonly&gt;&lt;/span&gt;&lt;/includeonly&gt;&lt;noinclude&gt;{{Documentation}}&lt;!-- PLEASE ADD THIS TEMPLATE'S CATEGORIES AND INTERWIKIS TO THE /doc SUBPAGE, THANKS --&gt;&lt;/noinclude&gt;</text>
      <sha1>mir66vdgg1ofukylprfapm1rh3vaahk</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Para</title>
    <ns>10</ns>
    <id>69</id>
    <revision>
      <id>126</id>
      <parentid>125</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>125</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="608" sha1="0p8ksf0z4xhqkt9wrqh7fa1q0ga6u3s" xml:space="preserve">&lt;code class="tpl-para" style="word-break:break-word;{{SAFESUBST:&lt;noinclude /&gt;#if:{{{plain|}}}|border: none; background-color: inherit;}} {{SAFESUBST:&lt;noinclude /&gt;#if:{{{plain|}}}{{{mxt|}}}{{{green|}}}{{{!mxt|}}}{{{red|}}}|color: {{SAFESUBST:&lt;noinclude /&gt;#if:{{{mxt|}}}{{{green|}}}|#006400|{{SAFESUBST:&lt;noinclude /&gt;#if:{{{!mxt|}}}{{{red|}}}|#8B0000|inherit}}}};}} {{SAFESUBST:&lt;noinclude /&gt;#if:{{{style|}}}|{{{style}}}}}"&gt;&amp;#124;{{SAFESUBST:&lt;noinclude /&gt;#if:{{{1|}}}|{{{1}}}&amp;#61;}}{{{2|}}}&lt;/code&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;!--Categories and interwikis go near the bottom of the /doc subpage.--&gt;
&lt;/noinclude&gt;</text>
      <sha1>0p8ksf0z4xhqkt9wrqh7fa1q0ga6u3s</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Hatnote</title>
    <ns>10</ns>
    <id>70</id>
    <revision>
      <id>128</id>
      <parentid>127</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>127</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="171" sha1="8nnude79i1y2v6yy2z7j285k1k4v8p3" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Hatnote|hatnote}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>8nnude79i1y2v6yy2z7j285k1k4v8p3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Str left</title>
    <ns>10</ns>
    <id>71</id>
    <revision>
      <id>130</id>
      <parentid>129</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>129</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="184" sha1="3rrdme1fpv80h1kdk9b7zwlkqd34dfk" xml:space="preserve">&lt;includeonly&gt;{{safesubst:padleft:|{{{2|1}}}|{{{1}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>3rrdme1fpv80h1kdk9b7zwlkqd34dfk</sha1>
    </revision>
  </page>
  <page>
    <title>Template:;</title>
    <ns>10</ns>
    <id>72</id>
    <revision>
      <id>132</id>
      <parentid>131</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>131</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="154" sha1="56krc2nl4adk2du4isfrd7ydd55f8ht" xml:space="preserve">&amp;#59;&lt;noinclude&gt;

{{Documentation}}
&lt;!-- PLEASE ADD THIS TEMPLATE'S CATEGORIES TO THE /doc SUBPAGE; INTERWIKIS GO TO WIKIDATA, THANK YOU! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>56krc2nl4adk2du4isfrd7ydd55f8ht</sha1>
    </revision>
  </page>
  <page>
    <title>Template:No redirect</title>
    <ns>10</ns>
    <id>73</id>
    <revision>
      <id>134</id>
      <parentid>133</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>133</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="440" sha1="3msltq2spqk7jkcqdh5ees1s93leh57" xml:space="preserve">{{safesubst:&lt;noinclude/&gt;#if: {{safesubst:&lt;noinclude/&gt;#invoke:Redirect|isRedirect|{{{1}}}}}
| &lt;span class="plainlinks"&gt;[{{safesubst:&lt;noinclude/&gt;fullurl:{{{1}}}|redirect=no}} {{{2|{{{1}}}}}}]&lt;/span&gt;&lt;span style="display: none"&gt;[[{{{1}}}]]&lt;/span&gt;
| {{safesubst:&lt;noinclude/&gt;#if:{{{2|}}}|[[:{{safesubst:&lt;noinclude/&gt;FULLPAGENAME:{{{1}}}}}|{{{2}}}]]|[[:{{safesubst:&lt;noinclude/&gt;FULLPAGENAME:{{{1}}}}}]]}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>3msltq2spqk7jkcqdh5ees1s93leh57</sha1>
    </revision>
  </page>
  <page>
    <title>Template:!((</title>
    <ns>10</ns>
    <id>74</id>
    <revision>
      <id>136</id>
      <parentid>135</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>135</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="42" sha1="kx6wfr2em4x51ldy401n0q58z3lvxb8" xml:space="preserve">[[&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>kx6wfr2em4x51ldy401n0q58z3lvxb8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ensure AAA contrast ratio</title>
    <ns>10</ns>
    <id>75</id>
    <revision>
      <id>138</id>
      <parentid>137</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>137</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="316" sha1="thvg1zc4vzn6yvyb0zfry8s1v9a3kbj" xml:space="preserve">&lt;includeonly&gt;{{#if:{{{base|}}}|{{#ifexpr:{{#invoke:Color contrast|ratio|{{{base}}}|{{{other|}}}|error=21}} &lt; 7 OR {{#invoke:Color contrast|ratio|{{{base}}}|black|error=0}} &lt; 7 AND {{#invoke:Color contrast|ratio|{{{base}}}|white|error=0}} &lt; 7|{{{category|}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>thvg1zc4vzn6yvyb0zfry8s1v9a3kbj</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Documentation</title>
    <ns>10</ns>
    <id>76</id>
    <revision>
      <id>140</id>
      <parentid>139</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>139</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="151" sha1="ii1kftoonz87mztj4siz1yhyqeg6agm" xml:space="preserve">{{#invoke:documentation|main|_content={{ {{#invoke:documentation|contentTitle}}}}}}&lt;noinclude&gt;
&lt;!-- Add categories to the /doc subpage --&gt;
&lt;/noinclude&gt;</text>
      <sha1>ii1kftoonz87mztj4siz1yhyqeg6agm</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Documentation</title>
    <ns>828</ns>
    <id>77</id>
    <revision>
      <id>142</id>
      <parentid>141</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>141</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="35178" sha1="fttwrouvv52xj3xc0iv9fbm0og9nf2z" xml:space="preserve">-- This module implements {{documentation}}.

-- Get required modules.
local getArgs = require('Module:Arguments').getArgs

-- Get the config table.
local cfg = mw.loadData('Module:Documentation/config')

local p = {}

-- Often-used functions.
local ugsub = mw.ustring.gsub
local format = mw.ustring.format

----------------------------------------------------------------------------
-- Helper functions
--
-- These are defined as local functions, but are made available in the p
-- table for testing purposes.
----------------------------------------------------------------------------

local function message(cfgKey, valArray, expectType)
	--[[
	-- Gets a message from the cfg table and formats it if appropriate.
	-- The function raises an error if the value from the cfg table is not
	-- of the type expectType. The default type for expectType is 'string'.
	-- If the table valArray is present, strings such as $1, $2 etc. in the
	-- message are substituted with values from the table keys [1], [2] etc.
	-- For example, if the message "foo-message" had the value 'Foo $2 bar $1.',
	-- message('foo-message', {'baz', 'qux'}) would return "Foo qux bar baz."
	--]]
	local msg = cfg[cfgKey]
	expectType = expectType or 'string'
	if type(msg) ~= expectType then
		error('message: type error in message cfg.' .. cfgKey .. ' (' .. expectType .. ' expected, got ' .. type(msg) .. ')', 2)
	end
	if not valArray then
		return msg
	end

	local function getMessageVal(match)
		match = tonumber(match)
		return valArray[match] or error('message: no value found for key $' .. match .. ' in message cfg.' .. cfgKey, 4)
	end

	return ugsub(msg, '$([1-9][0-9]*)', getMessageVal)
end

p.message = message

local function makeWikilink(page, display)
	if display then
		return format('[[%s|%s]]', page, display)
	else
		return format('[[%s]]', page)
	end
end

p.makeWikilink = makeWikilink

local function makeCategoryLink(cat, sort)
	local catns = mw.site.namespaces[14].name
	return makeWikilink(catns .. ':' .. cat, sort)
end

p.makeCategoryLink = makeCategoryLink

local function makeUrlLink(url, display)
	return format('[%s %s]', url, display)
end

p.makeUrlLink = makeUrlLink

local function makeToolbar(...)
	local ret = {}
	local lim = select('#', ...)
	if lim &lt; 1 then
		return nil
	end
	for i = 1, lim do
		ret[#ret + 1] = select(i, ...)
	end
	-- 'documentation-toolbar'
	return format(
		'&lt;span class="%s"&gt;(%s)&lt;/span&gt;',
		message('toolbar-class'),
		table.concat(ret, ' &amp;#124; ')
	)
end	

p.makeToolbar = makeToolbar

----------------------------------------------------------------------------
-- Argument processing
----------------------------------------------------------------------------

local function makeInvokeFunc(funcName)
	return function (frame)
		local args = getArgs(frame, {
			valueFunc = function (key, value)
				if type(value) == 'string' then
					value = value:match('^%s*(.-)%s*$') -- Remove whitespace.
					if key == 'heading' or value ~= '' then
						return value
					else
						return nil
					end
				else
					return value
				end
			end
		})
		return p[funcName](args)
	end
end

----------------------------------------------------------------------------
-- Entry points
----------------------------------------------------------------------------

function p.nonexistent(frame)
	if mw.title.getCurrentTitle().subpageText == 'testcases' then
		return frame:expandTemplate{title = 'module test cases notice'}
	else
		return p.main(frame)
	end
end

p.main = makeInvokeFunc('_main')

function p._main(args)
	--[[
	-- This function defines logic flow for the module.
	-- @args - table of arguments passed by the user
	--]]
	local env = p.getEnvironment(args)
	local root = mw.html.create()
	root
		:wikitext(p._getModuleWikitext(args, env))
		:wikitext(p.protectionTemplate(env))
		:wikitext(p.sandboxNotice(args, env))
		:tag('div')
			-- 'documentation-container'
			:addClass(message('container'))
			:attr('role', 'complementary')
			:attr('aria-labelledby', args.heading ~= '' and 'documentation-heading' or nil)
			:attr('aria-label', args.heading == '' and 'Documentation' or nil)
			:newline()
			:tag('div')
				-- 'documentation'
				:addClass(message('main-div-classes'))
				:newline()
				:wikitext(p._startBox(args, env))
				:wikitext(p._content(args, env))
				:tag('div')
					-- 'documentation-clear'
					:addClass(message('clear'))
					:done()
				:newline()
				:done()
			:wikitext(p._endBox(args, env))
			:done()
		:wikitext(p.addTrackingCategories(env))
	-- 'Module:Documentation/styles.css'
	return mw.getCurrentFrame():extensionTag (
		'templatestyles', '', {src=cfg['templatestyles']
	}) .. tostring(root)
end

----------------------------------------------------------------------------
-- Environment settings
----------------------------------------------------------------------------

function p.getEnvironment(args)
	--[[
	-- Returns a table with information about the environment, including title
	-- objects and other namespace- or path-related data.
	-- @args - table of arguments passed by the user
	--
	-- Title objects include:
	-- env.title - the page we are making documentation for (usually the current title)
	-- env.templateTitle - the template (or module, file, etc.)
	-- env.docTitle - the /doc subpage.
	-- env.sandboxTitle - the /sandbox subpage.
	-- env.testcasesTitle - the /testcases subpage.
	--
	-- Data includes:
	-- env.protectionLevels - the protection levels table of the title object.
	-- env.subjectSpace - the number of the title's subject namespace.
	-- env.docSpace - the number of the namespace the title puts its documentation in.
	-- env.docpageBase - the text of the base page of the /doc, /sandbox and /testcases pages, with namespace.
	-- env.compareUrl - URL of the Special:ComparePages page comparing the sandbox with the template.
	-- 
	-- All table lookups are passed through pcall so that errors are caught. If an error occurs, the value
	-- returned will be nil.
	--]]
	
	local env, envFuncs = {}, {}

	-- Set up the metatable. If triggered we call the corresponding function in the envFuncs table. The value
	-- returned by that function is memoized in the env table so that we don't call any of the functions
	-- more than once. (Nils won't be memoized.)
	setmetatable(env, {
		__index = function (t, key)
			local envFunc = envFuncs[key]
			if envFunc then
				local success, val = pcall(envFunc)
				if success then
					env[key] = val -- Memoise the value.
					return val
				end
			end
			return nil
		end
	})	

	function envFuncs.title()
		-- The title object for the current page, or a test page passed with args.page.
		local title
		local titleArg = args.page
		if titleArg then
			title = mw.title.new(titleArg)
		else
			title = mw.title.getCurrentTitle()
		end
		return title
	end

	function envFuncs.templateTitle()
		--[[
		-- The template (or module, etc.) title object.
		-- Messages:
		-- 'sandbox-subpage' --&gt; 'sandbox'
		-- 'testcases-subpage' --&gt; 'testcases'
		--]]
		local subjectSpace = env.subjectSpace
		local title = env.title
		local subpage = title.subpageText
		if subpage == message('sandbox-subpage') or subpage == message('testcases-subpage') or (subpage == message('doc-subpage') and mw.title.getCurrentTitle().namespace == env.docSpace) then
			return mw.title.makeTitle(subjectSpace, title.baseText)
		else
			return mw.title.makeTitle(subjectSpace, title.text)
		end
	end

	function envFuncs.docTitle()
		--[[
		-- Title object of the /doc subpage.
		-- Messages:
		-- 'doc-subpage' --&gt; 'doc'
		--]]
		local title = env.title
		local docname = args[1] -- User-specified doc page.
		local docpage
		if docname then
			docpage = docname
		else
			docpage = env.docpageBase .. '/' .. message('doc-subpage')
		end
		return mw.title.new(docpage)
	end
	
	function envFuncs.sandboxTitle()
		--[[
		-- Title object for the /sandbox subpage.
		-- Messages:
		-- 'sandbox-subpage' --&gt; 'sandbox'
		--]]
		return mw.title.new(env.docpageBase .. '/' .. message('sandbox-subpage'))
	end
	
	function envFuncs.testcasesTitle()
		--[[
		-- Title object for the /testcases subpage.
		-- Messages:
		-- 'testcases-subpage' --&gt; 'testcases'
		--]]
		return mw.title.new(env.docpageBase .. '/' .. message('testcases-subpage'))
	end

	function envFuncs.protectionLevels()
		-- The protection levels table of the title object.
		return env.title.protectionLevels
	end

	function envFuncs.subjectSpace()
		-- The subject namespace number.
		return mw.site.namespaces[env.title.namespace].subject.id
	end

	function envFuncs.docSpace()
		-- The documentation namespace number. For most namespaces this is the
		-- same as the subject namespace. However, pages in the Article, File,
		-- MediaWiki or Category namespaces must have their /doc, /sandbox and
		-- /testcases pages in talk space.
		local subjectSpace = env.subjectSpace
		if subjectSpace == 0 or subjectSpace == 6 or subjectSpace == 8 or subjectSpace == 14 then
			return subjectSpace + 1
		else
			return subjectSpace
		end
	end

	function envFuncs.docpageBase()
		-- The base page of the /doc, /sandbox, and /testcases subpages.
		-- For some namespaces this is the talk page, rather than the template page.
		local templateTitle = env.templateTitle
		local docSpace = env.docSpace
		local docSpaceText = mw.site.namespaces[docSpace].name
		-- Assemble the link. docSpace is never the main namespace, so we can hardcode the colon.
		return docSpaceText .. ':' .. templateTitle.text
	end
	
	function envFuncs.compareUrl()
		-- Diff link between the sandbox and the main template using [[Special:ComparePages]].
		local templateTitle = env.templateTitle
		local sandboxTitle = env.sandboxTitle
		if templateTitle.exists and sandboxTitle.exists then
			local compareUrl = mw.uri.canonicalUrl(
				'Special:ComparePages',
				{ page1 = templateTitle.prefixedText, page2 = sandboxTitle.prefixedText}
			)
			return tostring(compareUrl)
		else
			return nil
		end
	end		

	return env
end	

----------------------------------------------------------------------------
-- Auxiliary templates
----------------------------------------------------------------------------

p.getModuleWikitext = makeInvokeFunc('_getModuleWikitext')

function p._getModuleWikitext(args, env)
	local currentTitle = mw.title.getCurrentTitle()
	if currentTitle.contentModel ~= 'Scribunto' then return end
	pcall(require, currentTitle.prefixedText) -- if it fails, we don't care
	local moduleWikitext =  package.loaded["Module:Module wikitext"]
	if moduleWikitext then
		return moduleWikitext.main()
	end
end

function p.sandboxNotice(args, env)
	--[=[
	-- Generates a sandbox notice for display above sandbox pages.
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- 
	-- Messages:
	-- 'sandbox-notice-image' --&gt; '[[File:Sandbox.svg|50px|alt=|link=]]'
	-- 'sandbox-notice-blurb' --&gt; 'This is the $1 for $2.'
	-- 'sandbox-notice-diff-blurb' --&gt; 'This is the $1 for $2 ($3).'
	-- 'sandbox-notice-pagetype-template' --&gt; '[[Wikipedia:Template test cases|template sandbox]] page'
	-- 'sandbox-notice-pagetype-module' --&gt; '[[Wikipedia:Template test cases|module sandbox]] page'
	-- 'sandbox-notice-pagetype-other' --&gt; 'sandbox page'
	-- 'sandbox-notice-compare-link-display' --&gt; 'diff'
	-- 'sandbox-notice-testcases-blurb' --&gt; 'See also the companion subpage for $1.'
	-- 'sandbox-notice-testcases-link-display' --&gt; 'test cases'
	-- 'sandbox-category' --&gt; 'Template sandboxes'
	-- 'module-sandbox-category' --&gt; 'Module sandboxes'
	-- 'other-sandbox-category' --&gt; 'Sandboxes outside of template or module namespace'
	--]=]
	local title = env.title
	local sandboxTitle = env.sandboxTitle
	local templateTitle = env.templateTitle
	local subjectSpace = env.subjectSpace
	if not (subjectSpace and title and sandboxTitle and templateTitle
		and mw.title.equals(title, sandboxTitle)) then
		return nil
	end
	-- Build the table of arguments to pass to {{ombox}}. We need just two fields, "image" and "text".
	local omargs = {}
	omargs.image = message('sandbox-notice-image')
	-- Get the text. We start with the opening blurb, which is something like
	-- "This is the template sandbox for [[Template:Foo]] (diff)."
	local text = '__EXPECTUNUSEDTEMPLATE__'
	local pagetype, sandboxCat
	if subjectSpace == 10 then
		pagetype = message('sandbox-notice-pagetype-template')
		sandboxCat = message('sandbox-category')
	elseif subjectSpace == 828 then
		pagetype = message('sandbox-notice-pagetype-module')
		sandboxCat = message('module-sandbox-category')
	else
		pagetype = message('sandbox-notice-pagetype-other')
		sandboxCat = message('other-sandbox-category')
	end
	local templateLink = makeWikilink(templateTitle.prefixedText)
	local compareUrl = env.compareUrl
	if compareUrl then
		local compareDisplay = message('sandbox-notice-compare-link-display')
		local compareLink = makeUrlLink(compareUrl, compareDisplay)
		text = text .. message('sandbox-notice-diff-blurb', {pagetype, templateLink, compareLink})
	else
		text = text .. message('sandbox-notice-blurb', {pagetype, templateLink})
	end
	-- Get the test cases page blurb if the page exists. This is something like
	-- "See also the companion subpage for [[Template:Foo/testcases|test cases]]."
	local testcasesTitle = env.testcasesTitle
	if testcasesTitle and testcasesTitle.exists then
		if testcasesTitle.contentModel == "Scribunto" then
			local testcasesLinkDisplay = message('sandbox-notice-testcases-link-display')
			local testcasesRunLinkDisplay = message('sandbox-notice-testcases-run-link-display')
			local testcasesLink = makeWikilink(testcasesTitle.prefixedText, testcasesLinkDisplay)
			local testcasesRunLink = makeWikilink(testcasesTitle.talkPageTitle.prefixedText, testcasesRunLinkDisplay)
			text = text .. '&lt;br /&gt;' .. message('sandbox-notice-testcases-run-blurb', {testcasesLink, testcasesRunLink})
		else
			local testcasesLinkDisplay = message('sandbox-notice-testcases-link-display')
			local testcasesLink = makeWikilink(testcasesTitle.prefixedText, testcasesLinkDisplay)
			text = text .. '&lt;br /&gt;' .. message('sandbox-notice-testcases-blurb', {testcasesLink})
		end
	end
	
	-- Add the sandbox to the sandbox category.
	omargs.text = text .. makeCategoryLink(sandboxCat)

	-- 'documentation-clear'
	return '&lt;div class="' .. message('clear') .. '"&gt;&lt;/div&gt;'
		.. require('Module:Message box').main('ombox', omargs)
end

function p.protectionTemplate(env)
	-- Generates the padlock icon in the top right.
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- Messages:
	-- 'protection-template' --&gt; 'pp-template'
	-- 'protection-template-args' --&gt; {docusage = 'yes'}
	local protectionLevels = env.protectionLevels
	if not protectionLevels then
		return nil
	end
	local editProt = protectionLevels.edit and protectionLevels.edit[1]
	local moveProt = protectionLevels.move and protectionLevels.move[1]
	if editProt then
		-- The page is edit-protected.
		return require('Module:Protection banner')._main{
			message('protection-reason-edit'), small = true
		}
	elseif moveProt and moveProt ~= 'autoconfirmed' then
		-- The page is move-protected but not edit-protected. Exclude move
		-- protection with the level "autoconfirmed", as this is equivalent to
		-- no move protection at all.
		return require('Module:Protection banner')._main{
			action = 'move', small = true
		}
	else
		return nil
	end
end

----------------------------------------------------------------------------
-- Start box
----------------------------------------------------------------------------

p.startBox = makeInvokeFunc('_startBox')

function p._startBox(args, env)
	--[[
	-- This function generates the start box.
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- 
	-- The actual work is done by p.makeStartBoxLinksData and p.renderStartBoxLinks which make
	-- the [view] [edit] [history] [purge] links, and by p.makeStartBoxData and p.renderStartBox
	-- which generate the box HTML.
	--]]
	env = env or p.getEnvironment(args)
	local links
	local content = args.content
	if not content or args[1] then
		-- No need to include the links if the documentation is on the template page itself.
		local linksData = p.makeStartBoxLinksData(args, env)
		if linksData then
			links = p.renderStartBoxLinks(linksData)
		end
	end
	-- Generate the start box html.
	local data = p.makeStartBoxData(args, env, links)
	if data then
		return p.renderStartBox(data)
	else
		-- User specified no heading.
		return nil
	end
end

function p.makeStartBoxLinksData(args, env)
	--[[
	-- Does initial processing of data to make the [view] [edit] [history] [purge] links.
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- 
	-- Messages:
	-- 'view-link-display' --&gt; 'view'
	-- 'edit-link-display' --&gt; 'edit'
	-- 'history-link-display' --&gt; 'history'
	-- 'purge-link-display' --&gt; 'purge'
	-- 'module-preload' --&gt; 'Template:Documentation/preload-module-doc'
	-- 'docpage-preload' --&gt; 'Template:Documentation/preload'
	-- 'create-link-display' --&gt; 'create'
	--]]
	local subjectSpace = env.subjectSpace
	local title = env.title
	local docTitle = env.docTitle
	if not title or not docTitle then
		return nil
	end
	if docTitle.isRedirect then 
		docTitle = docTitle.redirectTarget
	end

	-- Create link if /doc doesn't exist.
	local preload = args.preload
	if not preload then
		if subjectSpace == 828 then -- Module namespace
			preload = message('module-preload')
		else
			preload = message('docpage-preload')
		end
	end
	
	return {
		title = title,
		docTitle = docTitle,
		-- View, display, edit, and purge links if /doc exists.
		viewLinkDisplay = message('view-link-display'),
		editLinkDisplay = message('edit-link-display'),
		historyLinkDisplay = message('history-link-display'),
		purgeLinkDisplay = message('purge-link-display'),
		preload = preload,
		createLinkDisplay = message('create-link-display')
	}
end

function p.renderStartBoxLinks(data)
	--[[
	-- Generates the [view][edit][history][purge] or [create][purge] links from the data table.
	-- @data - a table of data generated by p.makeStartBoxLinksData
	--]]
	local docTitle = data.docTitle
	-- yes, we do intend to purge the template page on which the documentation appears
	local purgeLink = makeWikilink("Special:Purge/" .. data.title.prefixedText, data.purgeLinkDisplay)
	
	if docTitle.exists then
		local viewLink = makeWikilink(docTitle.prefixedText, data.viewLinkDisplay)
		local editLink = makeWikilink("Special:EditPage/" .. docTitle.prefixedText, data.editLinkDisplay)
		local historyLink = makeWikilink("Special:PageHistory/" .. docTitle.prefixedText, data.historyLinkDisplay)
		return "&amp;#91;" .. viewLink .. "&amp;#93; &amp;#91;" .. editLink .. "&amp;#93; &amp;#91;" .. historyLink .. "&amp;#93; &amp;#91;" .. purgeLink .. "&amp;#93;"
	else
		local createLink = makeUrlLink(docTitle:canonicalUrl{action = 'edit', preload = data.preload}, data.createLinkDisplay)
		return  "&amp;#91;" .. createLink .. "&amp;#93; &amp;#91;" .. purgeLink .. "&amp;#93;"
	end
	return ret
end

function p.makeStartBoxData(args, env, links)
	--[=[
	-- Does initial processing of data to pass to the start-box render function, p.renderStartBox.
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- @links - a string containing the [view][edit][history][purge] links - could be nil if there's an error.
	--
	-- Messages:
	-- 'documentation-icon-wikitext' --&gt; '[[File:Test Template Info-Icon - Version (2).svg|50px|link=|alt=]]'
	-- 'template-namespace-heading' --&gt; 'Template documentation'
	-- 'module-namespace-heading' --&gt; 'Module documentation'
	-- 'file-namespace-heading' --&gt; 'Summary'
	-- 'other-namespaces-heading' --&gt; 'Documentation'
	-- 'testcases-create-link-display' --&gt; 'create'
	--]=]
	local subjectSpace = env.subjectSpace
	if not subjectSpace then
		-- Default to an "other namespaces" namespace, so that we get at least some output
		-- if an error occurs.
		subjectSpace = 2
	end
	local data = {}
	
	-- Heading
	local heading = args.heading -- Blank values are not removed.
	if heading == '' then
		-- Don't display the start box if the heading arg is defined but blank.
		return nil
	end
	if heading then
		data.heading = heading
	elseif subjectSpace == 10 then -- Template namespace
		data.heading = message('documentation-icon-wikitext') .. ' ' .. message('template-namespace-heading')
	elseif subjectSpace == 828 then -- Module namespace
		data.heading = message('documentation-icon-wikitext') .. ' ' .. message('module-namespace-heading')
	elseif subjectSpace == 6 then -- File namespace
		data.heading = message('file-namespace-heading')
	else
		data.heading = message('other-namespaces-heading')
	end
	
	-- Heading CSS
	local headingStyle = args['heading-style']
	if headingStyle then
		data.headingStyleText = headingStyle
	else
		-- 'documentation-heading'
		data.headingClass = message('main-div-heading-class')
	end
	
	-- Data for the [view][edit][history][purge] or [create] links.
	if links then
		-- 'mw-editsection-like plainlinks'
		data.linksClass = message('start-box-link-classes')
		data.links = links
	end
	
	return data
end

function p.renderStartBox(data)
	-- Renders the start box html.
	-- @data - a table of data generated by p.makeStartBoxData.
	local sbox = mw.html.create('div')
	sbox
		-- 'documentation-startbox'
		:addClass(message('start-box-class'))
		:newline()
		:tag('span')
			:addClass(data.headingClass)
			:attr('id', 'documentation-heading')
			:cssText(data.headingStyleText)
			:wikitext(data.heading)
	local links = data.links
	if links then
		sbox:tag('span')
			:addClass(data.linksClass)
			:attr('id', data.linksId)
			:wikitext(links)
	end
	return tostring(sbox)
end

----------------------------------------------------------------------------
-- Documentation content
----------------------------------------------------------------------------

p.content = makeInvokeFunc('_content')

function p._content(args, env)
	-- Displays the documentation contents
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	env = env or p.getEnvironment(args)
	local docTitle = env.docTitle
	local content = args.content
	if not content and docTitle and docTitle.exists then
		content = args._content or mw.getCurrentFrame():expandTemplate{title = docTitle.prefixedText}
	end
	-- The line breaks below are necessary so that "=== Headings ===" at the start and end
	-- of docs are interpreted correctly.
	return '\n' .. (content or '') .. '\n' 
end

p.contentTitle = makeInvokeFunc('_contentTitle')

function p._contentTitle(args, env)
	env = env or p.getEnvironment(args)
	local docTitle = env.docTitle
	if not args.content and docTitle and docTitle.exists then
		return docTitle.prefixedText
	else
		return ''
	end
end

----------------------------------------------------------------------------
-- End box
----------------------------------------------------------------------------

p.endBox = makeInvokeFunc('_endBox')

function p._endBox(args, env)
	--[=[
	-- This function generates the end box (also known as the link box).
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- 
	--]=]
	
	-- Get environment data.
	env = env or p.getEnvironment(args)
	local subjectSpace = env.subjectSpace
	local docTitle = env.docTitle
	if not subjectSpace or not docTitle then
		return nil
	end
		
	-- Check whether we should output the end box at all. Add the end
	-- box by default if the documentation exists or if we are in the
	-- user, module or template namespaces.
	local linkBox = args['link box']
	if linkBox == 'off'
		or not (
			docTitle.exists
			or subjectSpace == 2
			or subjectSpace == 828
			or subjectSpace == 10
		)
	then
		return nil
	end

	-- Assemble the link box.
	local text = ''
	if linkBox then
		text = text .. linkBox
	else
		text = text .. (p.makeDocPageBlurb(args, env) or '') -- "This documentation is transcluded from [[Foo]]." 
		if subjectSpace == 2 or subjectSpace == 10 or subjectSpace == 828 then
			-- We are in the user, template or module namespaces.
			-- Add sandbox and testcases links.
			-- "Editors can experiment in this template's sandbox and testcases pages."
			text = text .. (p.makeExperimentBlurb(args, env) or '') .. '&lt;br /&gt;'
			if not args.content and not args[1] then
				-- "Please add categories to the /doc subpage."
				-- Don't show this message with inline docs or with an explicitly specified doc page,
				-- as then it is unclear where to add the categories.
				text = text .. (p.makeCategoriesBlurb(args, env) or '')
			end
			text = text .. ' ' .. (p.makeSubpagesBlurb(args, env) or '') --"Subpages of this template"
		end
	end
	
	local box = mw.html.create('div')
	-- 'documentation-metadata'
	box:attr('role', 'note')
		:addClass(message('end-box-class'))
		-- 'plainlinks'
		:addClass(message('end-box-plainlinks'))
		:wikitext(text)
		:done()

	return '\n' .. tostring(box)
end

function p.makeDocPageBlurb(args, env)
	--[=[
	-- Makes the blurb "This documentation is transcluded from [[Template:Foo]] (edit, history)".
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- 
	-- Messages:
	-- 'edit-link-display' --&gt; 'edit'
	-- 'history-link-display' --&gt; 'history'
	-- 'transcluded-from-blurb' --&gt; 
	-- 'The above [[Wikipedia:Template documentation|documentation]] 
	-- is [[Help:Transclusion|transcluded]] from $1.'
	-- 'module-preload' --&gt; 'Template:Documentation/preload-module-doc'
	-- 'create-link-display' --&gt; 'create'
	-- 'create-module-doc-blurb' --&gt;
	-- 'You might want to $1 a documentation page for this [[Wikipedia:Lua|Scribunto module]].'
	--]=]
	local docTitle = env.docTitle
	if not docTitle then
		return nil
	end
	if docTitle.exists then
		-- /doc exists; link to it.
		local docLink = makeWikilink(docTitle.prefixedText)
		local editDisplay = message('edit-link-display')
		local editLink = makeWikilink("Special:EditPage/" .. docTitle.prefixedText, editDisplay)
		local historyDisplay = message('history-link-display')
		local historyLink = makeWikilink("Special:PageHistory/" .. docTitle.prefixedText, historyDisplay)
		return message('transcluded-from-blurb', {docLink})
			.. ' '
			.. makeToolbar(editLink, historyLink)
			.. '&lt;br /&gt;'
	elseif env.subjectSpace == 828 then
		-- /doc does not exist; ask to create it.
		local createUrl = docTitle:canonicalUrl{action = 'edit', preload = message('module-preload')}
		local createDisplay = message('create-link-display')
		local createLink = makeUrlLink(createUrl, createDisplay)
		return message('create-module-doc-blurb', {createLink})
			.. '&lt;br /&gt;'
	end
end

function p.makeExperimentBlurb(args, env)
	--[[
	-- Renders the text "Editors can experiment in this template's sandbox (edit | diff) and testcases (edit) pages."
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- 
	-- Messages:
	-- 'sandbox-link-display' --&gt; 'sandbox'
	-- 'sandbox-edit-link-display' --&gt; 'edit'
	-- 'compare-link-display' --&gt; 'diff'
	-- 'module-sandbox-preload' --&gt; 'Template:Documentation/preload-module-sandbox'
	-- 'template-sandbox-preload' --&gt; 'Template:Documentation/preload-sandbox'
	-- 'sandbox-create-link-display' --&gt; 'create'
	-- 'mirror-edit-summary' --&gt; 'Create sandbox version of $1'
	-- 'mirror-link-display' --&gt; 'mirror'
	-- 'mirror-link-preload' --&gt; 'Template:Documentation/mirror'
	-- 'sandbox-link-display' --&gt; 'sandbox'
	-- 'testcases-link-display' --&gt; 'testcases'
	-- 'testcases-edit-link-display'--&gt; 'edit'
	-- 'template-sandbox-preload' --&gt; 'Template:Documentation/preload-sandbox'
	-- 'testcases-create-link-display' --&gt; 'create'
	-- 'testcases-link-display' --&gt; 'testcases'
	-- 'testcases-edit-link-display' --&gt; 'edit'
	-- 'module-testcases-preload' --&gt; 'Template:Documentation/preload-module-testcases'
	-- 'template-testcases-preload' --&gt; 'Template:Documentation/preload-testcases'
	-- 'experiment-blurb-module' --&gt; 'Editors can experiment in this module's $1 and $2 pages.'
	-- 'experiment-blurb-template' --&gt; 'Editors can experiment in this template's $1 and $2 pages.'
	--]]
	local subjectSpace = env.subjectSpace
	local templateTitle = env.templateTitle
	local sandboxTitle = env.sandboxTitle
	local testcasesTitle = env.testcasesTitle
	local templatePage = templateTitle.prefixedText
	if not subjectSpace or not templateTitle or not sandboxTitle or not testcasesTitle then
		return nil
	end
	-- Make links.
	local sandboxLinks, testcasesLinks
	if sandboxTitle.exists then
		local sandboxPage = sandboxTitle.prefixedText
		local sandboxDisplay = message('sandbox-link-display')
		local sandboxLink = makeWikilink(sandboxPage, sandboxDisplay)
		local sandboxEditDisplay = message('sandbox-edit-link-display')
		local sandboxEditLink = makeWikilink("Special:EditPage/" .. sandboxPage, sandboxEditDisplay)
		local compareUrl = env.compareUrl
		local compareLink
		if compareUrl then
			local compareDisplay = message('compare-link-display')
			compareLink = makeUrlLink(compareUrl, compareDisplay)
		end
		sandboxLinks = sandboxLink .. ' ' .. makeToolbar(sandboxEditLink, compareLink)
	else
		local sandboxPreload
		if subjectSpace == 828 then
			sandboxPreload = message('module-sandbox-preload')
		else
			sandboxPreload = message('template-sandbox-preload')
		end
		local sandboxCreateUrl = sandboxTitle:canonicalUrl{action = 'edit', preload = sandboxPreload}
		local sandboxCreateDisplay = message('sandbox-create-link-display')
		local sandboxCreateLink = makeUrlLink(sandboxCreateUrl, sandboxCreateDisplay)
		local mirrorSummary = message('mirror-edit-summary', {makeWikilink(templatePage)})
		local mirrorPreload = message('mirror-link-preload')
		local mirrorUrl = sandboxTitle:canonicalUrl{action = 'edit', preload = mirrorPreload, summary = mirrorSummary}
		if subjectSpace == 828 then
			mirrorUrl = sandboxTitle:canonicalUrl{action = 'edit', preload = templateTitle.prefixedText, summary = mirrorSummary}
		end
		local mirrorDisplay = message('mirror-link-display')
		local mirrorLink = makeUrlLink(mirrorUrl, mirrorDisplay)
		sandboxLinks = message('sandbox-link-display') .. ' ' .. makeToolbar(sandboxCreateLink, mirrorLink)
	end
	if testcasesTitle.exists then
		local testcasesPage = testcasesTitle.prefixedText
		local testcasesDisplay = message('testcases-link-display')
		local testcasesLink = makeWikilink(testcasesPage, testcasesDisplay)
		local testcasesEditUrl = testcasesTitle:canonicalUrl{action = 'edit'}
		local testcasesEditDisplay = message('testcases-edit-link-display')
		local testcasesEditLink = makeWikilink("Special:EditPage/" .. testcasesPage, testcasesEditDisplay)
		-- for Modules, add testcases run link if exists
		if testcasesTitle.contentModel == "Scribunto"  and testcasesTitle.talkPageTitle and testcasesTitle.talkPageTitle.exists then
			local testcasesRunLinkDisplay = message('testcases-run-link-display')
			local testcasesRunLink = makeWikilink(testcasesTitle.talkPageTitle.prefixedText, testcasesRunLinkDisplay)
			testcasesLinks = testcasesLink .. ' ' .. makeToolbar(testcasesEditLink, testcasesRunLink)
		else
			testcasesLinks = testcasesLink .. ' ' .. makeToolbar(testcasesEditLink)
		end
	else
		local testcasesPreload
		if subjectSpace == 828 then
			testcasesPreload = message('module-testcases-preload')
		else
			testcasesPreload = message('template-testcases-preload')
		end
		local testcasesCreateUrl = testcasesTitle:canonicalUrl{action = 'edit', preload = testcasesPreload}
		local testcasesCreateDisplay = message('testcases-create-link-display')
		local testcasesCreateLink = makeUrlLink(testcasesCreateUrl, testcasesCreateDisplay)
		testcasesLinks = message('testcases-link-display') .. ' ' .. makeToolbar(testcasesCreateLink)
	end
	local messageName
	if subjectSpace == 828 then
		messageName = 'experiment-blurb-module'
	else
		messageName = 'experiment-blurb-template'
	end
	return message(messageName, {sandboxLinks, testcasesLinks})
end

function p.makeCategoriesBlurb(args, env)
	--[[
	-- Generates the text "Please add categories to the /doc subpage."
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	-- Messages:
	-- 'doc-link-display' --&gt; '/doc'
	-- 'add-categories-blurb' --&gt; 'Please add categories to the $1 subpage.'
	--]]
	local docTitle = env.docTitle
	if not docTitle then
		return nil
	end
	local docPathLink = makeWikilink(docTitle.prefixedText, message('doc-link-display'))
	return message('add-categories-blurb', {docPathLink})
end

function p.makeSubpagesBlurb(args, env)
	--[[
	-- Generates the "Subpages of this template" link.
	-- @args - a table of arguments passed by the user
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	
	-- Messages:
	-- 'template-pagetype' --&gt; 'template'
	-- 'module-pagetype' --&gt; 'module'
	-- 'default-pagetype' --&gt; 'page'
	-- 'subpages-link-display' --&gt; 'Subpages of this $1'
	--]]
	local subjectSpace = env.subjectSpace
	local templateTitle = env.templateTitle
	if not subjectSpace or not templateTitle then
		return nil
	end
	local pagetype
	if subjectSpace == 10 then
		pagetype = message('template-pagetype')
	elseif subjectSpace == 828 then
		pagetype = message('module-pagetype')
	else
		pagetype = message('default-pagetype')
	end
	local subpagesLink = makeWikilink(
		'Special:PrefixIndex/' .. templateTitle.prefixedText .. '/',
		message('subpages-link-display', {pagetype})
	)
	return message('subpages-blurb', {subpagesLink})
end

----------------------------------------------------------------------------
-- Tracking categories
----------------------------------------------------------------------------

function p.addTrackingCategories(env)
	--[[
	-- Check if {{documentation}} is transcluded on a /doc or /testcases page.
	-- @env - environment table containing title objects, etc., generated with p.getEnvironment
	
	-- Messages:
	-- 'display-strange-usage-category' --&gt; true
	-- 'doc-subpage' --&gt; 'doc'
	-- 'testcases-subpage' --&gt; 'testcases'
	-- 'strange-usage-category' --&gt; 'Wikipedia pages with strange ((documentation)) usage'
	-- 
	-- /testcases pages in the module namespace are not categorised, as they may have
	-- {{documentation}} transcluded automatically.
	--]]
	local title = env.title
	local subjectSpace = env.subjectSpace
	if not title or not subjectSpace then
		return nil
	end
	local subpage = title.subpageText
	if message('display-strange-usage-category', nil, 'boolean')
		and (
			subpage == message('doc-subpage')
			or subjectSpace ~= 828 and subpage == message('testcases-subpage')
		)
	then
		return makeCategoryLink(message('strange-usage-category'))
	end
	return ''
end

return p</text>
      <sha1>fttwrouvv52xj3xc0iv9fbm0og9nf2z</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Documentation/config</title>
    <ns>828</ns>
    <id>78</id>
    <revision>
      <id>144</id>
      <parentid>143</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>143</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="17747" sha1="a4mz1srhm8rh02cxt53a9azlcc4hx9f" xml:space="preserve">----------------------------------------------------------------------------------------------------
--
--                               Configuration for Module:Documentation
--
-- Here you can set the values of the parameters and messages used in Module:Documentation to
-- localise it to your wiki and your language. Unless specified otherwise, values given here
-- should be string values.
----------------------------------------------------------------------------------------------------

local cfg = {} -- Do not edit this line.

----------------------------------------------------------------------------------------------------
-- Protection template configuration
----------------------------------------------------------------------------------------------------

-- cfg['protection-reason-edit']
-- The protection reason for edit-protected templates to pass to
-- [[Module:Protection banner]].
cfg['protection-reason-edit'] = 'template'

--[[
----------------------------------------------------------------------------------------------------
-- Sandbox notice configuration
--
-- On sandbox pages the module can display a template notifying users that the current page is a
-- sandbox, and the location of test cases pages, etc. The module decides whether the page is a
-- sandbox or not based on the value of cfg['sandbox-subpage']. The following settings configure the
-- messages that the notices contains.
----------------------------------------------------------------------------------------------------
--]]

-- cfg['sandbox-notice-image']
-- The image displayed in the sandbox notice.
cfg['sandbox-notice-image'] = '[[File:Sandbox.svg|50px|alt=|link=]]'

--[[
-- cfg['sandbox-notice-pagetype-template']
-- cfg['sandbox-notice-pagetype-module']
-- cfg['sandbox-notice-pagetype-other']
-- The page type of the sandbox page. The message that is displayed depends on the current subject
-- namespace. This message is used in either cfg['sandbox-notice-blurb'] or
-- cfg['sandbox-notice-diff-blurb'].
--]]
cfg['sandbox-notice-pagetype-template'] = '[[Wikipedia:Template test cases|template sandbox]] page'
cfg['sandbox-notice-pagetype-module'] = '[[Wikipedia:Template test cases|module sandbox]] page'
cfg['sandbox-notice-pagetype-other'] = 'sandbox page'

--[[
-- cfg['sandbox-notice-blurb']
-- cfg['sandbox-notice-diff-blurb']
-- cfg['sandbox-notice-diff-display']
-- Either cfg['sandbox-notice-blurb'] or cfg['sandbox-notice-diff-blurb'] is the opening sentence
-- of the sandbox notice. The latter has a diff link, but the former does not. $1 is the page
-- type, which is either cfg['sandbox-notice-pagetype-template'],
-- cfg['sandbox-notice-pagetype-module'] or cfg['sandbox-notice-pagetype-other'] depending what
-- namespace we are in. $2 is a link to the main template page, and $3 is a diff link between
-- the sandbox and the main template. The display value of the diff link is set by 
-- cfg['sandbox-notice-compare-link-display'].
--]]
cfg['sandbox-notice-blurb'] = 'This is the $1 for $2.'
cfg['sandbox-notice-diff-blurb'] = 'This is the $1 for $2 ($3).'
cfg['sandbox-notice-compare-link-display'] = 'diff'

--[[
-- cfg['sandbox-notice-testcases-blurb']
-- cfg['sandbox-notice-testcases-link-display']
-- cfg['sandbox-notice-testcases-run-blurb']
-- cfg['sandbox-notice-testcases-run-link-display']
-- cfg['sandbox-notice-testcases-blurb'] is a sentence notifying the user that there is a test cases page
-- corresponding to this sandbox that they can edit. $1 is a link to the test cases page.
-- cfg['sandbox-notice-testcases-link-display'] is the display value for that link.
-- cfg['sandbox-notice-testcases-run-blurb'] is a sentence notifying the user that there is a test cases page
-- corresponding to this sandbox that they can edit, along with a link to run it. $1 is a link to the test
-- cases page, and $2 is a link to the page to run it.
-- cfg['sandbox-notice-testcases-run-link-display'] is the display value for the link to run the test
-- cases.
--]]
cfg['sandbox-notice-testcases-blurb'] = 'See also the companion subpage for $1.'
cfg['sandbox-notice-testcases-link-display'] = 'test cases'
cfg['sandbox-notice-testcases-run-blurb'] = 'See also the companion subpage for $1 ($2).'
cfg['sandbox-notice-testcases-run-link-display'] = 'run'

-- cfg['sandbox-category'] - A category to add to all template sandboxes.
-- cfg['module-sandbox-category'] - A category to add to all module sandboxes.
-- cfg['module-sandbox-category'] - A category to add to all sandboxe not in templates or modules.
cfg['sandbox-category'] = 'Template sandboxes'
cfg['module-sandbox-category'] = 'Module sandboxes'
cfg['other-sandbox-category'] = 'Sandboxes outside of template or module namespace'


----------------------------------------------------------------------------------------------------
-- Start box configuration
----------------------------------------------------------------------------------------------------

-- cfg['documentation-icon-wikitext']
-- The wikitext for the icon shown at the top of the template.
cfg['documentation-icon-wikitext'] = '[[File:Test Template Info-Icon - Version (2).svg|50px|link=|alt=]]'

-- cfg['template-namespace-heading']
-- The heading shown in the template namespace.
cfg['template-namespace-heading'] = 'Template documentation'

-- cfg['module-namespace-heading']
-- The heading shown in the module namespace.
cfg['module-namespace-heading'] = 'Module documentation'

-- cfg['file-namespace-heading']
-- The heading shown in the file namespace.
cfg['file-namespace-heading'] = 'Summary'

-- cfg['other-namespaces-heading']
-- The heading shown in other namespaces.
cfg['other-namespaces-heading'] = 'Documentation'

-- cfg['view-link-display']
-- The text to display for "view" links.
cfg['view-link-display'] = 'view'

-- cfg['edit-link-display']
-- The text to display for "edit" links.
cfg['edit-link-display'] = 'edit'

-- cfg['history-link-display']
-- The text to display for "history" links.
cfg['history-link-display'] = 'history'

-- cfg['purge-link-display']
-- The text to display for "purge" links.
cfg['purge-link-display'] = 'purge'

-- cfg['create-link-display']
-- The text to display for "create" links.
cfg['create-link-display'] = 'create'

----------------------------------------------------------------------------------------------------
-- Link box (end box) configuration
----------------------------------------------------------------------------------------------------

-- cfg['transcluded-from-blurb']
-- Notice displayed when the docs are transcluded from another page. $1 is a wikilink to that page.
cfg['transcluded-from-blurb'] = 'The above [[Wikipedia:Template documentation|documentation]] is [[Help:Transclusion|transcluded]] from $1.'

--[[
-- cfg['create-module-doc-blurb']
-- Notice displayed in the module namespace when the documentation subpage does not exist.
-- $1 is a link to create the documentation page with the preload cfg['module-preload'] and the
-- display cfg['create-link-display'].
--]]
cfg['create-module-doc-blurb'] = 'You might want to $1 a documentation page for this [[Wikipedia:Lua|Scribunto module]].'

----------------------------------------------------------------------------------------------------
-- Experiment blurb configuration
----------------------------------------------------------------------------------------------------

--[[
-- cfg['experiment-blurb-template']
-- cfg['experiment-blurb-module']
-- The experiment blurb is the text inviting editors to experiment in sandbox and test cases pages.
-- It is only shown in the template and module namespaces. With the default English settings, it
-- might look like this:
--
-- Editors can experiment in this template's sandbox (edit | diff) and testcases (edit) pages.
--
-- In this example, "sandbox", "edit", "diff", "testcases", and "edit" would all be links.
--
-- There are two versions, cfg['experiment-blurb-template'] and cfg['experiment-blurb-module'], depending
-- on what namespace we are in.
-- 
-- Parameters:
--
-- $1 is a link to the sandbox page. If the sandbox exists, it is in the following format:
--
--     cfg['sandbox-link-display'] (cfg['sandbox-edit-link-display'] | cfg['compare-link-display'])
-- 
-- If the sandbox doesn't exist, it is in the format:
--
--     cfg['sandbox-link-display'] (cfg['sandbox-create-link-display'] | cfg['mirror-link-display'])
-- 
-- The link for cfg['sandbox-create-link-display'] link preloads the page with cfg['template-sandbox-preload']
-- or cfg['module-sandbox-preload'], depending on the current namespace. The link for cfg['mirror-link-display']
-- loads a default edit summary of cfg['mirror-edit-summary'].
--
-- $2 is a link to the test cases page. If the test cases page exists, it is in the following format:
--
--     cfg['testcases-link-display'] (cfg['testcases-edit-link-display'] | cfg['testcases-run-link-display'])
--
-- If the test cases page doesn't exist, it is in the format:
-- 
--     cfg['testcases-link-display'] (cfg['testcases-create-link-display'])
--
-- If the test cases page doesn't exist, the link for cfg['testcases-create-link-display'] preloads the
-- page with cfg['template-testcases-preload'] or cfg['module-testcases-preload'], depending on the current
-- namespace.
--]]
cfg['experiment-blurb-template'] = "Editors can experiment in this template's $1 and $2 pages."
cfg['experiment-blurb-module'] = "Editors can experiment in this module's $1 and $2 pages."

----------------------------------------------------------------------------------------------------
-- Sandbox link configuration
----------------------------------------------------------------------------------------------------

-- cfg['sandbox-subpage']
-- The name of the template subpage typically used for sandboxes.
cfg['sandbox-subpage'] = 'sandbox'

-- cfg['template-sandbox-preload']
-- Preload file for template sandbox pages.
cfg['template-sandbox-preload'] = 'Template:Documentation/preload-sandbox'

-- cfg['module-sandbox-preload']
-- Preload file for Lua module sandbox pages.
cfg['module-sandbox-preload'] = 'Template:Documentation/preload-module-sandbox'

-- cfg['sandbox-link-display']
-- The text to display for "sandbox" links.
cfg['sandbox-link-display'] = 'sandbox'

-- cfg['sandbox-edit-link-display']
-- The text to display for sandbox "edit" links.
cfg['sandbox-edit-link-display'] = 'edit'

-- cfg['sandbox-create-link-display']
-- The text to display for sandbox "create" links.
cfg['sandbox-create-link-display'] = 'create'

-- cfg['compare-link-display']
-- The text to display for "compare" links.
cfg['compare-link-display'] = 'diff'

-- cfg['mirror-edit-summary']
-- The default edit summary to use when a user clicks the "mirror" link. $1 is a wikilink to the
-- template page.
cfg['mirror-edit-summary'] = 'Create sandbox version of $1'

-- cfg['mirror-link-display']
-- The text to display for "mirror" links.
cfg['mirror-link-display'] = 'mirror'

-- cfg['mirror-link-preload']
-- The page to preload when a user clicks the "mirror" link.
cfg['mirror-link-preload'] = 'Template:Documentation/mirror'

----------------------------------------------------------------------------------------------------
-- Test cases link configuration
----------------------------------------------------------------------------------------------------

-- cfg['testcases-subpage']
-- The name of the template subpage typically used for test cases.
cfg['testcases-subpage'] = 'testcases'

-- cfg['template-testcases-preload']
-- Preload file for template test cases pages.
cfg['template-testcases-preload'] = 'Template:Documentation/preload-testcases'

-- cfg['module-testcases-preload']
-- Preload file for Lua module test cases pages.
cfg['module-testcases-preload'] = 'Template:Documentation/preload-module-testcases'

-- cfg['testcases-link-display']
-- The text to display for "testcases" links.
cfg['testcases-link-display'] = 'testcases'

-- cfg['testcases-edit-link-display']
-- The text to display for test cases "edit" links.
cfg['testcases-edit-link-display'] = 'edit'

-- cfg['testcases-run-link-display']
-- The text to display for test cases "run" links.
cfg['testcases-run-link-display'] = 'run'

-- cfg['testcases-create-link-display']
-- The text to display for test cases "create" links.
cfg['testcases-create-link-display'] = 'create'

----------------------------------------------------------------------------------------------------
-- Add categories blurb configuration
----------------------------------------------------------------------------------------------------

--[[
-- cfg['add-categories-blurb']
-- Text to direct users to add categories to the /doc subpage. Not used if the "content" or
-- "docname fed" arguments are set, as then it is not clear where to add the categories. $1 is a
-- link to the /doc subpage with a display value of cfg['doc-link-display'].
--]]
cfg['add-categories-blurb'] = 'Add categories to the $1 subpage.'

-- cfg['doc-link-display']
-- The text to display when linking to the /doc subpage.
cfg['doc-link-display'] = '/doc'

----------------------------------------------------------------------------------------------------
-- Subpages link configuration
----------------------------------------------------------------------------------------------------

--[[
-- cfg['subpages-blurb']
-- The "Subpages of this template" blurb. $1 is a link to the main template's subpages with a
-- display value of cfg['subpages-link-display']. In the English version this blurb is simply
-- the link followed by a period, and the link display provides the actual text.
--]]
cfg['subpages-blurb'] = '$1.'

--[[
-- cfg['subpages-link-display']
-- The text to display for the "subpages of this page" link. $1 is cfg['template-pagetype'],
-- cfg['module-pagetype'] or cfg['default-pagetype'], depending on whether the current page is in
-- the template namespace, the module namespace, or another namespace.
--]]
cfg['subpages-link-display'] = 'Subpages of this $1'

-- cfg['template-pagetype']
-- The pagetype to display for template pages.
cfg['template-pagetype'] = 'template'

-- cfg['module-pagetype']
-- The pagetype to display for Lua module pages.
cfg['module-pagetype'] = 'module'

-- cfg['default-pagetype']
-- The pagetype to display for pages other than templates or Lua modules.
cfg['default-pagetype'] = 'page'

----------------------------------------------------------------------------------------------------
-- Doc link configuration
----------------------------------------------------------------------------------------------------

-- cfg['doc-subpage']
-- The name of the subpage typically used for documentation pages.
cfg['doc-subpage'] = 'doc'

-- cfg['docpage-preload']
-- Preload file for template documentation pages in all namespaces.
cfg['docpage-preload'] = 'Template:Documentation/preload'

-- cfg['module-preload']
-- Preload file for Lua module documentation pages.
cfg['module-preload'] = 'Template:Documentation/preload-module-doc'

----------------------------------------------------------------------------------------------------
-- HTML and CSS configuration
----------------------------------------------------------------------------------------------------

-- cfg['templatestyles']
-- The name of the TemplateStyles page where CSS is kept.
-- Sandbox CSS will be at Module:Documentation/sandbox/styles.css when needed.
cfg['templatestyles'] = 'Module:Documentation/styles.css'

-- cfg['container']
-- Class which can be used to set flex or grid CSS on the
-- two child divs documentation and documentation-metadata
cfg['container'] = 'documentation-container'

-- cfg['main-div-classes']
-- Classes added to the main HTML "div" tag.
cfg['main-div-classes'] = 'documentation'

-- cfg['main-div-heading-class']
-- Class for the main heading for templates and modules and assoc. talk spaces
cfg['main-div-heading-class'] = 'documentation-heading'

-- cfg['start-box-class']
-- Class for the start box
cfg['start-box-class'] = 'documentation-startbox'

-- cfg['start-box-link-classes']
-- Classes used for the [view][edit][history] or [create] links in the start box.
-- mw-editsection-like is per [[Wikipedia:Village pump (technical)/Archive 117]]
cfg['start-box-link-classes'] = 'mw-editsection-like plainlinks'

-- cfg['end-box-class']
-- Class for the end box.
cfg['end-box-class'] = 'documentation-metadata'

-- cfg['end-box-plainlinks']
-- Plainlinks
cfg['end-box-plainlinks'] = 'plainlinks'

-- cfg['toolbar-class']
-- Class added for toolbar links.
cfg['toolbar-class'] = 'documentation-toolbar'

-- cfg['clear']
-- Just used to clear things.
cfg['clear'] = 'documentation-clear'


----------------------------------------------------------------------------------------------------
-- Tracking category configuration
----------------------------------------------------------------------------------------------------

-- cfg['display-strange-usage-category']
-- Set to true to enable output of cfg['strange-usage-category'] if the module is used on a /doc subpage
-- or a /testcases subpage. This should be a boolean value (either true or false).
cfg['display-strange-usage-category'] = true

-- cfg['strange-usage-category']
-- Category to output if cfg['display-strange-usage-category'] is set to true and the module is used on a
-- /doc subpage or a /testcases subpage.
cfg['strange-usage-category'] = 'Wikipedia pages with strange ((documentation)) usage'

--[[
----------------------------------------------------------------------------------------------------
-- End configuration
--
-- Don't edit anything below this line.
----------------------------------------------------------------------------------------------------
--]]

return cfg</text>
      <sha1>a4mz1srhm8rh02cxt53a9azlcc4hx9f</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Documentation/styles.css</title>
    <ns>828</ns>
    <id>79</id>
    <revision>
      <id>146</id>
      <parentid>145</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>145</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1149" sha1="i8lops10ml7ifgplup23473ri87jccv" xml:space="preserve">/* {{pp|small=yes}} */
.documentation,
.documentation-metadata {
	border: 1px solid var( --border-color-base, #a2a9b1 );
	background-color: #ecfcf4;
	clear: both;
}

.documentation {
	margin: 1em 0 0 0;
	padding: 1em;
}

.documentation-metadata {
	margin: 0.2em 0; /* same margin left-right as .documentation */
    font-style: italic;
    padding: 0.4em 1em; /* same padding left-right as .documentation */
}

.documentation-startbox {
	padding-bottom: 3px;
	border-bottom: 1px solid var( --border-color-base, #a2a9b1 );
	margin-bottom: 1ex;
}

.documentation-heading {
	font-weight: bold;
	font-size: 125%;
}

.documentation-clear { /* Don't want things to stick out where they shouldn't. */
	clear: both;
}

.documentation-toolbar {
	font-style: normal;
	font-size: 85%;
}


@media screen {
    html.skin-theme-clientpref-night .documentation,
	html.skin-theme-clientpref-night .documentation-metadata {
	    background-color: #0b1e1c;
	}
}


@media screen and ( prefers-color-scheme: dark ) {
    html.skin-theme-clientpref-os .documentation,
    html.skin-theme-clientpref-os .documentation-metadata {
        background-color: #0b1e1c;
    }
}</text>
      <sha1>i8lops10ml7ifgplup23473ri87jccv</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Endplainlist</title>
    <ns>10</ns>
    <id>80</id>
    <revision>
      <id>148</id>
      <parentid>147</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>147</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="98" sha1="owuqpy73m48jricqo7bykll5w0j3c2o" xml:space="preserve">&lt;includeonly&gt;&lt;/div&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation|Template:Plainlist/doc}}
&lt;/noinclude&gt;</text>
      <sha1>owuqpy73m48jricqo7bykll5w0j3c2o</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Background color</title>
    <ns>10</ns>
    <id>81</id>
    <revision>
      <id>150</id>
      <parentid>149</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>149</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="567" sha1="6o18y3rxkphbai1bb0wwqd29gruxybv" xml:space="preserve">&lt;span style="background-color: {{{c|{{{1|}}}}}};color:black;"&gt;{{{t|{{{2|}}}}}}&lt;/span&gt;{{Main other|{{Ensure AAA contrast ratio|base={{{c|{{{1|}}}}}}|other={{{t|{{{2|}}}}}}|category=[[Category:Pages using Template:Background color with invalid color combination]]}}}}{{Template other|{{Ensure AAA contrast ratio|base={{{c|{{{1|}}}}}}|other={{{t|{{{2|}}}}}}|category=[[Category:Pages using Template:Background color with invalid color combination]]}}}}&lt;noinclude&gt;

{{Documentation}}
&lt;!-- PLEASE ADD THIS TEMPLATE'S CATEGORIES TO THE /doc SUBPAGE, THANKS --&gt;
&lt;/noinclude&gt;</text>
      <sha1>6o18y3rxkphbai1bb0wwqd29gruxybv</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Tnull</title>
    <ns>10</ns>
    <id>82</id>
    <redirect title="Template:Template link null" />
    <revision>
      <id>152</id>
      <parentid>151</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>151</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="88" sha1="kt9s20clzg7m0tnu0exwyoibis3zf5q" xml:space="preserve">#REDIRECT [[Template:Template link null]]

{{Redirect category shell|
{{R from move}}
}}</text>
      <sha1>kt9s20clzg7m0tnu0exwyoibis3zf5q</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Template link null</title>
    <ns>10</ns>
    <id>83</id>
    <revision>
      <id>154</id>
      <parentid>153</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>153</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="231" sha1="3wh5704zk7xm5kpqgoz7ybfwwx3479n" xml:space="preserve">&lt;includeonly&gt;{{#Invoke:Template link general|main|nolink=yes|code=yes}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation|1=Template:Tlg/doc
|content = {{tlg/doc|tnull}}
}}
&lt;!-- Add categories to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>3wh5704zk7xm5kpqgoz7ybfwwx3479n</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Dfn</title>
    <ns>10</ns>
    <id>84</id>
    <revision>
      <id>156</id>
      <parentid>155</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>155</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="404" sha1="luvqpiwetgllp79grmkxnuyoyftzgmm" xml:space="preserve">&lt;dfn {{#if:{{{id|}}}|id="{{{id}}}"}} {{#if:{{{title|}}}|title="{{{title}}}"}} {{#if:{{{2|}}}{{{class|}}}{{{title|}}}|class="{{#if:{{{2|}}}{{{title|}}}|explain}} {{#if:{{{class|}}}|{{{class}}}}}"}} {{#if:{{{style|}}}|style="{{{style}}}"}}&gt;{{#if:{{{2|}}}|&lt;span title="{{{2}}}"&gt;{{{1}}}&lt;/span&gt;|{{{1}}}}}&lt;/dfn&gt;&lt;noinclude&gt;
&lt;!--Categories and interwikis go in the /doc subpage.--&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>luvqpiwetgllp79grmkxnuyoyftzgmm</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Shortcut</title>
    <ns>828</ns>
    <id>85</id>
    <revision>
      <id>158</id>
      <parentid>157</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>157</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4336" sha1="0grxrt10usr45p0y9yes29aw6xnxg7j" xml:space="preserve">-- This module implements {{shortcut}}.

-- Set constants
local CONFIG_MODULE = 'Module:Shortcut/config'

-- Load required modules
local checkType = require('libraryUtil').checkType
local yesno = require('Module:Yesno')

local p = {}

local function message(msg, ...)
	return mw.message.newRawMessage(msg, ...):plain()
end

local function makeCategoryLink(cat)
	return string.format('[[%s:%s]]', mw.site.namespaces[14].name, cat)
end

function p._main(shortcuts, options, frame, cfg)
	checkType('_main', 1, shortcuts, 'table')
	checkType('_main', 2, options, 'table', true)
	options = options or {}
	frame = frame or mw.getCurrentFrame()
	cfg = cfg or mw.loadData(CONFIG_MODULE)
	local templateMode = options.template and yesno(options.template)
	local redirectMode = options.redirect and yesno(options.redirect)
	local isCategorized = not options.category or yesno(options.category) ~= false

	-- Validate shortcuts
	for i, shortcut in ipairs(shortcuts) do
		if type(shortcut) ~= 'string' or #shortcut &lt; 1 then
			error(message(cfg['invalid-shortcut-error'], i), 2)
		end
	end

	-- Make the list items. These are the shortcuts plus any extra lines such
	-- as options.msg.
	local listItems = {}
	for i, shortcut in ipairs(shortcuts) do
		local templatePath, prefix
		if templateMode then
			-- Namespace detection
			local titleObj = mw.title.new(shortcut, 10)
			if titleObj.namespace == 10 then
				templatePath = titleObj.fullText
			else
				templatePath = shortcut
			end
			prefix = options['pre' .. i] or options.pre or ''
		end
		if options.target and yesno(options.target) then
			listItems[i] = templateMode
				and string.format("&amp;#123;&amp;#123;%s[[%s|%s]]&amp;#125;&amp;#125;", prefix, templatePath, shortcut)
				or string.format("[[%s]]", shortcut)
		else
			listItems[i] = frame:expandTemplate{
				title = 'No redirect',
				args = templateMode and {templatePath, shortcut} or {shortcut, shortcut}
			}
			if templateMode then
				listItems[i] = string.format("&amp;#123;&amp;#123;%s%s&amp;#125;&amp;#125;", prefix, listItems[i])
			end
		end
	end
	table.insert(listItems, options.msg)

	-- Return an error if we have nothing to display
	if #listItems &lt; 1 then
		local msg = cfg['no-content-error']
		msg = string.format('&lt;strong class="error"&gt;%s&lt;/strong&gt;', msg)
		if isCategorized and cfg['no-content-error-category'] then
			msg = msg .. makeCategoryLink(cfg['no-content-error-category'])
		end
		return msg
	end

	local root = mw.html.create()
	root:wikitext(frame:extensionTag{ name = 'templatestyles', args = { src = 'Module:Shortcut/styles.css'} })
	-- Anchors
	local anchorDiv = root
		:tag('div')
			:addClass('module-shortcutanchordiv')
	for i, shortcut in ipairs(shortcuts) do
		local anchor = mw.uri.anchorEncode(shortcut)
		anchorDiv:tag('span'):attr('id', anchor)
	end

	-- Shortcut heading
	local shortcutHeading
	do
		local nShortcuts = #shortcuts
		if nShortcuts &gt; 0 then
			local headingMsg = options['shortcut-heading'] or
				redirectMode and cfg['redirect-heading'] or
				cfg['shortcut-heading']
			shortcutHeading = message(headingMsg, nShortcuts)
			shortcutHeading = frame:preprocess(shortcutHeading)
		end
	end

	-- Shortcut box
	local shortcutList = root
		:tag('div')
			:addClass('module-shortcutboxplain noprint')
			:attr('role', 'note')
	if options.float and options.float:lower() == 'left' then
		shortcutList:addClass('module-shortcutboxleft')
	end
	if options.clear and options.clear ~= '' then
		shortcutList:css('clear', options.clear)
	end
	if shortcutHeading then
		shortcutList
			:tag('div')
				:addClass('module-shortcutlist')
				:wikitext(shortcutHeading)
	end
	
	local ubl = require('Module:List').unbulleted(listItems)
	shortcutList:wikitext(ubl)
	return tostring(root)
end

function p.main(frame)
	local args = require('Module:Arguments').getArgs(frame)

	-- Separate shortcuts from options
	local shortcuts, options = {}, {}
	for k, v in pairs(args) do
		if type(k) == 'number' then
			shortcuts[k] = v
		else
			options[k] = v
		end
	end

	-- Compress the shortcut array, which may contain nils.
	local function compressArray(t)
		local nums, ret = {}, {}
		for k in pairs(t) do
			nums[#nums + 1] = k
		end
		table.sort(nums)
		for i, num in ipairs(nums) do
			ret[i] = t[num]
		end
		return ret
	end
	shortcuts = compressArray(shortcuts)

	return p._main(shortcuts, options, frame)
end

return p</text>
      <sha1>0grxrt10usr45p0y9yes29aw6xnxg7j</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Shortcut/config</title>
    <ns>828</ns>
    <id>86</id>
    <revision>
      <id>160</id>
      <parentid>159</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>159</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1240" sha1="t6jiszehpcz1mpvmzl8esji0vdvjr4p" xml:space="preserve">-- This module holds configuration data for [[Module:Shortcut]].

return {

-- The heading at the top of the shortcut box. It accepts the following parameter:
-- $1 - the total number of shortcuts. (required)
['shortcut-heading'] = '[[Wikipedia:Shortcut|{{PLURAL:$1|Shortcut|Shortcuts}}]]',

-- The heading when |redirect=yes is given. It accepts the following parameter:
-- $1 - the total number of shortcuts. (required)
['redirect-heading'] = '[[Wikipedia:Redirect|{{PLURAL:$1|Redirect|Redirects}}]]',

-- The error message to display when a shortcut is invalid (is not a string, or
-- is the blank string). It accepts the following parameter:
-- $1 - the number of the shortcut in the argument list. (required)
['invalid-shortcut-error'] = 'shortcut #$1 was invalid (shortcuts must be ' ..
	'strings of at least one character in length)',

-- The error message to display when no shortcuts or other displayable content
-- were specified. (required)
['no-content-error'] = 'Error: no shortcuts were specified and the ' ..
	mw.text.nowiki('|msg=') ..
	' parameter was not set.',

-- A category to add when the no-content-error message is displayed. (optional)
['no-content-error-category'] = 'Shortcut templates with missing parameters',
}</text>
      <sha1>t6jiszehpcz1mpvmzl8esji0vdvjr4p</sha1>
    </revision>
  </page>
  <page>
    <title>Template:High-use</title>
    <ns>10</ns>
    <id>87</id>
    <revision>
      <id>162</id>
      <parentid>161</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>161</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="270" sha1="j29sm6019piulvmp7rcudlkhl1yuxmv" xml:space="preserve">{{#invoke:High-use|main|1={{{1|}}}|2={{{2|}}}|info={{{info|}}}|demo={{{demo|}}}|form={{{form|}}}|expiry={{{expiry|}}}|system={{{system|}}}}}&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add categories to the /doc subpage; interwiki links go to Wikidata, thank you! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>j29sm6019piulvmp7rcudlkhl1yuxmv</sha1>
    </revision>
  </page>
  <page>
    <title>Module:High-use</title>
    <ns>828</ns>
    <id>88</id>
    <revision>
      <id>164</id>
      <parentid>163</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>163</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6937" sha1="7u5ehuisjaqc8500quv6bo138vry5dv" xml:space="preserve">local p = {}
local getArgs = require('Module:Arguments').getArgs

-- _fetch looks at the "demo" argument.
local _fetch = require('Module:Transclusion_count')._fetch
local yesno = require('Module:Yesno')

function p._num(args, count, no_percent)
	if count == nil then
		if yesno(args['fetch']) == false then
			if (args[1] or '') ~= '' then count = tonumber(args[1]) end
		else
			count = _fetch(args)
		end
	end
	
	-- Build output string
	local return_value = ""
	if count == nil then
		if args[1] == "risk" then
			return "a very large number of"
		else
			return "many"
		end
	else
		-- Use 2 significant figures for smaller numbers and 3 for larger ones
		local sigfig = 2
		if count &gt;= 100000 then
			sigfig = 3
		end
		
		-- Prepare to round to appropriate number of sigfigs
		local f = math.floor(math.log10(count)) - sigfig + 1
		
		-- Round and insert "approximately" or "+" when appropriate
		if (args[2] == "yes") or (type(args[1]) == 'string' and (mw.ustring.sub(args[1],-1) == "+")) then
			-- Round down
			return_value = string.format("%s+", mw.getContentLanguage():formatNum(math.floor( (count / 10^(f)) ) * (10^(f))) )
		else
			-- Round to nearest
			return_value = string.format("approximately&amp;#x20;%s", mw.getContentLanguage():formatNum(math.floor( (count / 10^(f)) + 0.5) * (10^(f))) )
		end

		-- Insert percentage of pages if that is likely to be &gt;= 1% and when |no-percent= not set to yes
		no_percent = no_percent or args['no-percent']
		if count and count &gt; 250000 and not yesno (no_percent) then
			local numpages = mw.getCurrentFrame():callParserFunction('NUMBEROFPAGES', 'R')
			local percent = math.floor( ( ( count/numpages ) * 100) + 0.5)
			if percent &gt;= 1 then
				return_value = string.format("%s&amp;#x20;pages, or roughly %s%% of all", return_value, percent)
			end
		end	
	end
	
	return return_value
end

function p.num(frame, count)
	return p._num(getArgs(frame), count)
end

-- Actions if there is a large (greater than or equal to 100,000) transclusion count
function p._risk(args)
	if args[1] == "risk" then
		return "risk"
	else
		local count = _fetch(args)
		if count and count &gt;= 100000 then
			return "risk"
		end
	end
	return ""
end

function p.risk(frame)
	return p._risk(getArgs(frame))
end

function p._text(args, count)
	-- Only show the information about how this template gets updated if someone
	-- is actually editing the page and maybe trying to update the count.
	local bot_text = (mw.getCurrentFrame():preprocess("{{REVISIONID}}") == "") and "\n\n----\n'''Preview message''': Transclusion count updated automatically ([[Template:High-use/doc#Technical details|see documentation]])." or ''
	
	if count == nil then
		if yesno(args['fetch']) == false then
			if (args[1] or '') ~= '' then count = tonumber(args[1]) end
		else
			count = _fetch(args)
		end
	end
	local title = mw.title.getCurrentTitle()
	if ( (args.demo or '' ~= '') and mw.title.new(args.demo, 10) ) then
		title = mw.title.new(args.demo, 10)
	end

	if title.subpageText == "doc" or title.subpageText == "sandbox" then
		title = title.basePageTitle
	end
	
	local systemMessages = (args['system'] or '') ~= ''
	
	-- This retrieves the project URL automatically to simplify localization.
	local templateCount = ('on [https://linkcount.toolforge.org/?project=%s&amp;page=%s#transclusions %s pages]'):format(
		title:fullUrl():gsub('//(.-)/.*', '%1'),
		mw.uri.encode(title.fullText), p._num(args, count))
	local used_on_text = "'''This " .. (title.namespace == 828 and "Lua module" or "template") .. ' is used ';
	if systemMessages then
		used_on_text = used_on_text .. args['system'] ..
			((count and count &gt; 2000) and ("''', and " .. templateCount) or ("'''"))
	else
		used_on_text = used_on_text .. templateCount .. "'''"
	end
	
	
	local sandbox_text =  ("%s's [[%s/sandbox|/sandbox]] or [[%s/testcases|/testcases]] subpages, or in your own [[%s]]. "):format(
		(title.namespace == 828 and "module" or "template"),
		title.fullText, title.fullText,
		title.namespace == 828 and "Module:Sandbox|module sandbox" or "Wikipedia:User pages#SUB|user subpage"
	)
	
	local infoArg = args["info"] ~= "" and args["info"]
	if (systemMessages or args[1] == "risk" or (count and count &gt;= 100000) ) then
		local info = systemMessages and '.&lt;br/&gt;Changes to it can cause immediate changes to the Wikipedia user interface.' or '.'
		if infoArg then
			info = info .. "&lt;br /&gt;" .. infoArg
		end
		sandbox_text = info .. '&lt;br /&gt; To avoid major disruption' ..
			(count and count &gt;= 100000 and ' and server load' or '') ..
			', any changes should be tested in the ' .. sandbox_text ..
			'The tested changes can be added to this page in a single edit. '
	else
		sandbox_text = (infoArg and ('.&lt;br /&gt;' .. infoArg .. ' C') or ' and c') ..
			'hanges may be widely noticed. Test changes in the ' .. sandbox_text
	end

	
	local discussion_text = systemMessages and 'Please discuss changes ' or 'Consider discussing changes '
	if args["2"] and args["2"] ~= "" and args["2"] ~= "yes" then
		discussion_text = string.format("%sat [[%s]]", discussion_text, args["2"])
	else
		discussion_text = string.format("%son the [[%s|talk page]]", discussion_text, title.talkPageTitle.fullText )
	end
	
	return used_on_text .. sandbox_text .. discussion_text .. " before implementing them." .. bot_text
end

function p.text(frame, count)
	return p._text(getArgs(frame), count)
end

function p._main(args, nocat)
	local count = nil
	if yesno(args['fetch']) == false then
		if (args[1] or '') ~= '' then count = tonumber(args[1]) end
	else
		count = _fetch(args)
	end
	local image = "[[File:Ambox warning yellow.svg|40px|alt=Warning|link=]]"
	local type_param = "style"
	local epilogue = ''
	if args['system'] and args['system'] ~= '' then
		image = "[[File:Ambox important.svg|40px|alt=Warning|link=]]"
		type_param = "content"
		nocat = nocat or args['nocat']
		local categorise = (nocat == '' or not yesno(nocat))
		if categorise and not mw.title.getCurrentTitle().isRedirect then
			epilogue = mw.getCurrentFrame():preprocess('{{Sandbox other||{{#switch:{{#invoke:Effective protection level|{{#switch:{{NAMESPACE}}|File=upload|#default=edit}}|{{FULLPAGENAME}}}}|sysop|templateeditor|interfaceadmin=|#default=[[Category:Pages used in system messages needing protection]]}}}}')
		end
	elseif (args[1] == "risk" or (count and count &gt;= 100000)) then
		image = "[[File:Ambox warning orange.svg|40px|alt=Warning|link=]]"
		type_param = "content"
	end
	
	if args["form"] == "editnotice" then
		return mw.getCurrentFrame():expandTemplate{
				title = 'editnotice',
				args = {
						["image"] = image,
						["text"] = p._text(args, count),
						["expiry"] = (args["expiry"] or "")
				}
		} .. epilogue
	else
		return require('Module:Message box').main('ombox', {
			type = type_param,
			image = image,
			text = p._text(args, count),
			expiry = (args["expiry"] or "")
		}) .. epilogue
	end
end

function p.main(frame)
	return p._main(getArgs(frame))
end
return p</text>
      <sha1>7u5ehuisjaqc8500quv6bo138vry5dv</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Transclusion count</title>
    <ns>828</ns>
    <id>89</id>
    <revision>
      <id>166</id>
      <parentid>165</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>165</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2330" sha1="cvwrrf1z7y5db6z5bajpjay525izf50" xml:space="preserve">local p = {}

function p._fetch(args)
	local template = nil
	local return_value = nil

	-- Use demo parameter if it exists, otherwise use current template name
	local namespace = mw.title.getCurrentTitle().namespace
	if args["demo"] and args["demo"] ~= "" then
		template = mw.ustring.gsub(args["demo"],"^[Tt]emplate:","")
	elseif namespace == 10 then -- Template namespace
		template = mw.title.getCurrentTitle().text
	elseif namespace == 828 then -- Module namespace
		template = (mw.site.namespaces[828].name .. ":" .. mw.title.getCurrentTitle().text)
	end

	-- If in template or module namespace, look up count in /data
	if template ~= nil then
		namespace = mw.title.new(template, "Template").namespace
		if namespace == 10 or namespace == 828 then
			template =  mw.ustring.gsub(template, "/doc$", "") -- strip /doc from end
			template =  mw.ustring.gsub(template, "/sandbox$", "") -- strip /sandbox from end
			local index = mw.ustring.sub(mw.title.new(template).text,1,1)
			local status, data = pcall(function ()
				return(mw.loadData('Module:Transclusion_count/data/' .. (mw.ustring.find(index, "%a") and index or "other")))
			end)
			if status then
				return_value = tonumber(data[mw.ustring.gsub(template, " ", "_")])
			end
		end
	end
	
	-- If database value doesn't exist, use value passed to template
	if return_value == nil and args[1] ~= nil then
		local arg1=mw.ustring.match(args[1], '[%d,]+')
		if arg1 and arg1 ~= '' then
			return_value = tonumber(mw.getCurrentFrame():callParserFunction('formatnum', arg1, 'R'))
		end
	end
	
	return return_value	
end

function p.fetch(frame)
	return p._fetch(frame.args)
end

-- Tabulate this data for [[Wikipedia:Database reports/Templates transcluded on the most pages]]
function p.tabulate()
	local list = {}
	for i = 65, 91 do
		local data = mw.loadData('Module:Transclusion count/data/' .. ((i == 91) and 'other' or string.char(i)))
		for name, count in pairs(data) do
			table.insert(list, {mw.title.new(name, "Template").fullText, count})	
		end
	end
	table.sort(list, function(a, b)
		return (a[2] == b[2]) and (a[1] &lt; b[1]) or (a[2] &gt; b[2])
	end)
	local lang = mw.getContentLanguage();
	for i = 1, #list do
		list[i] = ('|-\n| %d || [[%s]] || %s\n'):format(i, list[i][1]:gsub('_', ' '), lang:formatNum(list[i][2]))
	end
	return table.concat(list)
end

return p</text>
      <sha1>cvwrrf1z7y5db6z5bajpjay525izf50</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lua banner</title>
    <ns>828</ns>
    <id>90</id>
    <revision>
      <id>168</id>
      <parentid>167</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>167</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3908" sha1="dq7qzq2ns8wqfpy25uvhp3np9z9bde7" xml:space="preserve">-- This module implements the {{lua}} template.
local yesno = require('Module:Yesno')
local mList = require('Module:List')
local mTableTools = require('Module:TableTools')
local mMessageBox = require('Module:Message box')

local p = {}

function p.main(frame)
	local origArgs = frame:getParent().args
	local args = {}
	for k, v in pairs(origArgs) do
		v = v:match('^%s*(.-)%s*$')
		if v ~= '' then
			args[k] = v
		end
	end
	return p._main(args)
end

function p._main(args)
	local modules = mTableTools.compressSparseArray(args)
	local box = p.renderBox(modules)
	local trackingCategories = p.renderTrackingCategories(args, modules)
	return box .. trackingCategories
end

function p.renderBox(modules)
	local boxArgs = {}
	if #modules &lt; 1 then
		boxArgs.text = '&lt;strong class="error"&gt;Error: no modules specified&lt;/strong&gt;'
	else
		local moduleLinks = {}
		for i, module in ipairs(modules) do
			moduleLinks[i] = string.format('[[:%s]]', module)
			local maybeSandbox = mw.title.new(module .. '/sandbox')
			if maybeSandbox and maybeSandbox.exists then
				moduleLinks[i] = moduleLinks[i] .. string.format(' ([[:%s|sandbox]])', maybeSandbox.fullText)
			end
		end
		local moduleList = mList.makeList('bulleted', moduleLinks)
		local title = mw.title.getCurrentTitle()
		if title.subpageText == "doc" then
			title = title.basePageTitle
		end
		if title.contentModel == "Scribunto" then
			boxArgs.text = 'This module depends on the following other modules:' .. moduleList
		else
			boxArgs.text = 'This template  uses [[Wikipedia:Lua|Lua]]:\n' .. moduleList
		end
	end
	boxArgs.type = 'notice'
	boxArgs.small = true
	boxArgs.image = '[[File:Lua-Logo.svg|30px|alt=|link=]]'
	return mMessageBox.main('mbox', boxArgs)
end

function p.renderTrackingCategories(args, modules, titleObj)
	if yesno(args.nocat) then
		return ''
	end

	local cats = {}

	-- Error category
	if #modules &lt; 1 then
		cats[#cats + 1] = 'Lua templates with errors'
	end

	-- Lua templates category
	titleObj = titleObj or mw.title.getCurrentTitle()
	local subpageBlacklist = {
		doc = true,
		sandbox = true,
		sandbox2 = true,
		testcases = true
	}
	if not subpageBlacklist[titleObj.subpageText] then
		local protCatName
		if titleObj.namespace == 10 then
			local category = args.category
			if not category then
				local categories = {
					['Module:String'] = 'Templates based on the String Lua module',
					['Module:Math'] = 'Templates based on the Math Lua module',
					['Module:BaseConvert'] = 'Templates based on the BaseConvert Lua module',
					['Module:Citation/CS1'] = 'Templates based on the Citation/CS1 Lua module'
				}
				category = modules[1] and categories[modules[1]]
				category = category or 'Lua-based templates'
			end	
			cats[#cats + 1] = category
			protCatName = "Templates using under-protected Lua modules"
		elseif titleObj.namespace == 828 then
			protCatName = "Modules depending on under-protected modules"
		end
		if not args.noprotcat and protCatName then
			local protLevels = {
				autoconfirmed = 1,
				extendedconfirmed = 2,
				templateeditor = 3,
				sysop = 4
			}
			local currentProt
			if titleObj.id ~= 0 then
				-- id is 0 (page does not exist) if am previewing before creating a template.
				currentProt = titleObj.protectionLevels["edit"][1]
			end
			if currentProt == nil then currentProt = 0 else currentProt = protLevels[currentProt] end
			for i, module in ipairs(modules) do
				if module ~= "WP:libraryUtil" then
					local moduleTitle = mw.title.new(module)
					local moduleProt = moduleTitle and moduleTitle.protectionLevels["edit"][1]
					if moduleProt == nil then moduleProt = 0 else moduleProt = protLevels[moduleProt] end
					if moduleProt &lt; currentProt then
						cats[#cats + 1] = protCatName
						break
					end
				end
			end
		end
	end
	for i, cat in ipairs(cats) do
		cats[i] = string.format('[[Category:%s]]', cat)
	end
	return table.concat(cats)
end

return p</text>
      <sha1>dq7qzq2ns8wqfpy25uvhp3np9z9bde7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Lua</title>
    <ns>10</ns>
    <id>91</id>
    <revision>
      <id>170</id>
      <parentid>169</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>169</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="196" sha1="pnmjp3f3fl321yf2jpg5syebi412n7b" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Lua banner|main}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Lua|Module:Lua banner}}
{{documentation}}
&lt;!-- Categories go on the /doc subpage and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>pnmjp3f3fl321yf2jpg5syebi412n7b</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Module other</title>
    <ns>10</ns>
    <id>92</id>
    <revision>
      <id>172</id>
      <parentid>171</parentid>
      <timestamp>2025-07-09T04:31:21Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>171</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="439" sha1="i7wndwmrhldzbfap4eq8cegs6o7hwig" xml:space="preserve">{{#switch:
  &lt;!--If no or empty "demospace" parameter then detect namespace--&gt;
  {{#if:{{{demospace|}}}
  | {{lc: {{{demospace}}} }}    &lt;!--Use lower case "demospace"--&gt;
  | {{#ifeq:{{NAMESPACE}}|{{ns:Module}}
    | module
    | other
    }}
  }}
| module = {{{module|{{{1|}}}}}}
| other
| #default = {{{other|{{{2|}}}}}}
}}&lt;!--End switch--&gt;&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>i7wndwmrhldzbfap4eq8cegs6o7hwig</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Lua sidebar</title>
    <ns>10</ns>
    <id>93</id>
    <revision>
      <id>174</id>
      <parentid>173</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>173</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1380" sha1="n6lpw7jn0una7vh9rflo4cfu442hpi9" xml:space="preserve">{{Sidebar
| class = lua-sidebar
| templatestyles = Template:Lua sidebar/styles.css
| title = Related pages
| content1 = {{plainlist}}
* [[Template:{{{template|{{{title|{{BASEPAGENAME}}}}}}}}|Template]] {{#if:{{#invoke:redirect|isRedirect|Template talk:{{{template|{{{title|{{BASEPAGENAME}}}}}}}}}}||([[Template talk:{{{template|{{{title|{{BASEPAGENAME}}}}}}}}|talk]])}}
* [[Template:{{{template|{{{title|{{BASEPAGENAME}}}}}}}}/sandbox|Template sandbox]]
* [[Template:{{{template|{{{title|{{BASEPAGENAME}}}}}}}}/testcases|Template testcases]]
* [[Template:{{{template|{{{title|{{BASEPAGENAME}}}}}}}}/doc|Template doc]]
* [[Special:PrefixIndex/Template:{{{template|{{{title|{{BASEPAGENAME}}}}}}}}/|Template subpages]]
* [[Module:{{{module|{{{title|{{BASEPAGENAME}}}}}}}}|Module]] {{#if:{{#invoke:redirect|isRedirect|Module talk:{{{module|{{{title|{{BASEPAGENAME}}}}}}}}}}||([[Module talk:{{{module|{{{title|{{BASEPAGENAME}}}}}}}}|talk]])}}
* [[Module:{{{module|{{{title|{{BASEPAGENAME}}}}}}}}/sandbox|Module sandbox]]
* [[Module talk:{{{module|{{{title|{{BASEPAGENAME}}}}}}}}/testcases|Module testcases]]
* [[Module:{{{module|{{{title|{{BASEPAGENAME}}}}}}}}/doc|Module doc]]
* [[Special:PrefixIndex/Module:{{{module|{{{title|{{BASEPAGENAME}}}}}}}}/|Module subpages]]
{{endplainlist}}
| content2 = {{{1|}}}
}}[[Category:Lua-based templates]]&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>n6lpw7jn0una7vh9rflo4cfu442hpi9</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Lua sidebar/styles.css</title>
    <ns>10</ns>
    <id>94</id>
    <revision>
      <id>176</id>
      <parentid>175</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>175</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="48" sha1="hxkspvtmmhihekuzzwicqq4c1jd4hgr" xml:space="preserve">.lua-sidebar {
	width: auto;
	max-width: 22em;
}</text>
      <sha1>hxkspvtmmhihekuzzwicqq4c1jd4hgr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Template shortcut</title>
    <ns>10</ns>
    <id>95</id>
    <revision>
      <id>178</id>
      <parentid>177</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>177</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="105" sha1="me4jjte8wllgxkf22h7gbzu0e2tux3i" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Shortcut|main|template=yes}}&lt;/includeonly&gt;&lt;noinclude&gt;{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>me4jjte8wllgxkf22h7gbzu0e2tux3i</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Transclusion count/data/W</title>
    <ns>828</ns>
    <id>96</id>
    <revision>
      <id>180</id>
      <parentid>179</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>179</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="32983" sha1="qslusd9a1u1qobodqdi0j0jdadwarwh" xml:space="preserve">return {
["WAL"] = 2100,
["WDL"] = 7600,
["WDLtot"] = 6100,
["WP1"] = 5200,
["WPBS"] = 22000,
["WPB_Announcements"] = 19000,
["WPCC"] = 231000,
["WPEUR10k"] = 9400,
["WPEUR20k"] = 14000,
["WPLA10k"] = 2700,
["WPMILHIST_Infobox_style"] = 153000,
["WPOCEANIA10k"] = 3700,
["WPSS-cat"] = 20000,
["WPTC_track_map_key"] = 2100,
["WPUKIR10k"] = 9400,
["WPUKIR20k"] = 9700,
["WPUS"] = 3100,
["WPVG_announcements"] = 113000,
["WPVG_announcements/shell"] = 113000,
["WPVG_icon"] = 34000,
["WPVG_icon_direct"] = 150000,
["WPX_action_box"] = 2900,
["WPX_block"] = 2200,
["WPX_last_updated"] = 5100,
["WPX_list_end"] = 2200,
["WPX_list_start"] = 2200,
["WPX_subheader"] = 3000,
["WP_Architecture"] = 4000,
["WP_Athletics"] = 2100,
["WP_Crime"] = 2600,
["WP_Years"] = 5500,
["WPbox"] = 234000,
["WPbox/1"] = 234000,
["WRMS_source"] = 2700,
["WRMS_species"] = 14000,
["WTA"] = 3900,
["Warning"] = 56000,
["Watch"] = 28000,
["Wb"] = 2100,
["Wdib"] = 17000,
["Weather_box"] = 31000,
["Webarchive"] = 582000,
["Wednesday"] = 2700,
["Welcome_ISP"] = 4000,
["Welcome_graphical/links"] = 61000,
["Welcomeg/links"] = 61000,
["Western_name_order"] = 6700,
["What_links_here"] = 13000,
["When"] = 26000,
["Where"] = 2400,
["Which"] = 6400,
["Whisperback"] = 2700,
["White"] = 80000,
["Who"] = 11000,
["Who's_Who"] = 3200,
["Whois"] = 9500,
["Wide_image"] = 9400,
["WikiProjectBannerShell"] = 89000,
["WikiProjectCard"] = 3100,
["WikiProject_2010s"] = 3100,
["WikiProject_Academic_Journals"] = 35000,
["WikiProject_Afghanistan"] = 12000,
["WikiProject_Africa"] = 224000,
["WikiProject_African_diaspora"] = 24000,
["WikiProject_AfroCreatives"] = 9500,
["WikiProject_Agriculture"] = 13000,
["WikiProject_Alabama"] = 18000,
["WikiProject_Alaska"] = 12000,
["WikiProject_Albania"] = 16000,
["WikiProject_Albums"] = 396000,
["WikiProject_Algae"] = 4900,
["WikiProject_Algeria"] = 7500,
["WikiProject_Alternative_medicine"] = 2300,
["WikiProject_Alternative_music"] = 14000,
["WikiProject_Alternative_views"] = 2200,
["WikiProject_American_Open_Wheel_Racing"] = 3900,
["WikiProject_American_football"] = 11000,
["WikiProject_Amphibians_and_Reptiles"] = 34000,
["WikiProject_Amusement_Parks"] = 7000,
["WikiProject_Amusement_Parks/importance"] = 7000,
["WikiProject_Anarchism"] = 3700,
["WikiProject_Anarchism_cleanup_issue_count"] = 3800,
["WikiProject_Anatomy"] = 22000,
["WikiProject_Ancient_Egypt"] = 5800,
["WikiProject_Ancient_Near_East"] = 7200,
["WikiProject_Anglicanism"] = 12000,
["WikiProject_Anglo-Saxon_Kingdoms"] = 2300,
["WikiProject_Animal_rights"] = 2600,
["WikiProject_Animals"] = 33000,
["WikiProject_Animation"] = 40000,
["WikiProject_Animation/importance"] = 40000,
["WikiProject_Anime_and_manga"] = 42000,
["WikiProject_Anime_and_manga/checks"] = 42000,
["WikiProject_Anime_and_manga/type_check"] = 42000,
["WikiProject_Antarctica"] = 18000,
["WikiProject_Anthropology"] = 11000,
["WikiProject_Anthroponymy"] = 136000,
["WikiProject_Antigua_and_Barbuda"] = 2500,
["WikiProject_Apple_Inc."] = 3300,
["WikiProject_Apps"] = 2300,
["WikiProject_Arab_world"] = 6500,
["WikiProject_Archaeology"] = 23000,
["WikiProject_Architecture"] = 153000,
["WikiProject_Arctic"] = 3100,
["WikiProject_Arena_Football_League"] = 2800,
["WikiProject_Argentina"] = 30000,
["WikiProject_Arizona"] = 5400,
["WikiProject_Armenia"] = 13000,
["WikiProject_Arthropods"] = 28000,
["WikiProject_Articles_for_creation"] = 214000,
["WikiProject_Arts"] = 9900,
["WikiProject_Asia"] = 29000,
["WikiProject_Assyria"] = 5400,
["WikiProject_Astronomy"] = 81000,
["WikiProject_Astronomy/importance"] = 81000,
["WikiProject_Athletics"] = 83000,
["WikiProject_Auckland"] = 3100,
["WikiProject_Australia"] = 268000,
["WikiProject_Australia/ACR"] = 268000,
["WikiProject_Austria"] = 33000,
["WikiProject_Autism"] = 2300,
["WikiProject_Automobiles"] = 22000,
["WikiProject_Aviation"] = 80000,
["WikiProject_Awards"] = 40000,
["WikiProject_Azerbaijan"] = 16000,
["WikiProject_BBC"] = 9400,
["WikiProject_Badminton"] = 8300,
["WikiProject_Bahrain"] = 3500,
["WikiProject_Bangladesh"] = 29000,
["WikiProject_BannerShell"] = 2600,
["WikiProject_Banner_Shell"] = 8000,
["WikiProject_Baseball"] = 89000,
["WikiProject_Basketball"] = 65000,
["WikiProject_Basque"] = 2900,
["WikiProject_Bavaria"] = 5800,
["WikiProject_Beauty_Pageants"] = 8400,
["WikiProject_Beer"] = 4100,
["WikiProject_Beetles"] = 50000,
["WikiProject_Belarus"] = 11000,
["WikiProject_Belgium"] = 37000,
["WikiProject_Belize"] = 2600,
["WikiProject_Berkshire"] = 2300,
["WikiProject_Bhutan"] = 2800,
["WikiProject_Biathlon"] = 2900,
["WikiProject_Bible"] = 8200,
["WikiProject_Biography"] = 2740000,
["WikiProject_Biology"] = 9500,
["WikiProject_Birds"] = 32000,
["WikiProject_Bivalves"] = 3500,
["WikiProject_Board_and_table_games"] = 8600,
["WikiProject_Bolivia"] = 7600,
["WikiProject_Books"] = 78000,
["WikiProject_Bosnia_and_Herzegovina"] = 15000,
["WikiProject_Boxing"] = 19000,
["WikiProject_Brands"] = 23000,
["WikiProject_Brazil"] = 61000,
["WikiProject_Bridges_and_Tunnels"] = 13000,
["WikiProject_Bristol"] = 2500,
["WikiProject_British_Empire"] = 13000,
["WikiProject_British_Overseas_Territories"] = 21000,
["WikiProject_Buckinghamshire"] = 2200,
["WikiProject_Buddhism"] = 9100,
["WikiProject_Bulgaria"] = 24000,
["WikiProject_Buses"] = 6700,
["WikiProject_Business"] = 53000,
["WikiProject_COVID-19"] = 4800,
["WikiProject_California"] = 84000,
["WikiProject_Cambodia"] = 5700,
["WikiProject_Cambodia/to_do"] = 5700,
["WikiProject_Canada"] = 230000,
["WikiProject_Canada/TFtext"] = 230000,
["WikiProject_Canada_Roads"] = 2900,
["WikiProject_Canada_Roads/class"] = 2900,
["WikiProject_Canadian_football"] = 10000,
["WikiProject_Cannabis"] = 2500,
["WikiProject_Canoeing_and_Kayaking"] = 7500,
["WikiProject_Caribbean"] = 52000,
["WikiProject_Cartoon_Network"] = 3000,
["WikiProject_Catalan-speaking_countries"] = 4500,
["WikiProject_Categories"] = 6200,
["WikiProject_Catholicism"] = 60000,
["WikiProject_Caves"] = 2200,
["WikiProject_Celts"] = 2200,
["WikiProject_Cemeteries"] = 10000,
["WikiProject_Central_America"] = 9400,
["WikiProject_Central_Asia"] = 22000,
["WikiProject_Central_Asia/importance"] = 22000,
["WikiProject_Cephalopods"] = 4400,
["WikiProject_Chemicals"] = 28000,
["WikiProject_Chemistry"] = 18000,
["WikiProject_Cheshire"] = 4400,
["WikiProject_Chess"] = 8900,
["WikiProject_Chess/importance"] = 8900,
["WikiProject_Chicago"] = 41000,
["WikiProject_Children's_literature"] = 25000,
["WikiProject_Chile"] = 19000,
["WikiProject_China"] = 107000,
["WikiProject_Christian_music"] = 7600,
["WikiProject_Christianity"] = 86000,
["WikiProject_Cities"] = 409000,
["WikiProject_Civil_engineering"] = 22000,
["WikiProject_Classical_Greece_and_Rome"] = 31000,
["WikiProject_Classical_music"] = 34000,
["WikiProject_Cleveland"] = 2900,
["WikiProject_Climate_change"] = 4700,
["WikiProject_Climbing"] = 2800,
["WikiProject_Cold_War"] = 3100,
["WikiProject_College_Basketball"] = 38000,
["WikiProject_College_basketball"] = 60000,
["WikiProject_College_football"] = 162000,
["WikiProject_College_football/importance"] = 162000,
["WikiProject_Colombia"] = 18000,
["WikiProject_Comedy"] = 41000,
["WikiProject_Comics"] = 59000,
["WikiProject_Comics/importance"] = 59000,
["WikiProject_Companies"] = 109000,
["WikiProject_Composers"] = 18000,
["WikiProject_Computer_Security"] = 2500,
["WikiProject_Computer_science"] = 8500,
["WikiProject_Computer_security"] = 2700,
["WikiProject_Computing"] = 48000,
["WikiProject_Concerts"] = 6400,
["WikiProject_Connecticut"] = 17000,
["WikiProject_Conservatism"] = 11000,
["WikiProject_Cooperatives"] = 2400,
["WikiProject_Cornwall"] = 6200,
["WikiProject_Cornwall/guide"] = 6200,
["WikiProject_Correction_and_Detention_Facilities"] = 4900,
["WikiProject_Costa_Rica"] = 6200,
["WikiProject_Countries"] = 25000,
["WikiProject_Country_Music"] = 12000,
["WikiProject_Country_music"] = 15000,
["WikiProject_Cricket"] = 63000,
["WikiProject_Cricket/importance"] = 63000,
["WikiProject_Crime"] = 10000,
["WikiProject_Crime_and_Criminal_Biography"] = 68000,
["WikiProject_Croatia"] = 27000,
["WikiProject_Cuba"] = 8800,
["WikiProject_Cue_sports"] = 2200,
["WikiProject_Culture"] = 12000,
["WikiProject_Curling"] = 7300,
["WikiProject_Current_events"] = 8300,
["WikiProject_Cycling"] = 40000,
["WikiProject_Cyprus"] = 7000,
["WikiProject_Czech_Republic"] = 35000,
["WikiProject_Dallas-Fort_Worth"] = 3200,
["WikiProject_Dams"] = 7100,
["WikiProject_Dance"] = 17000,
["WikiProject_Darts"] = 2000,
["WikiProject_Deaf"] = 2200,
["WikiProject_Death"] = 52000,
["WikiProject_Denmark"] = 39000,
["WikiProject_Derbyshire"] = 3400,
["WikiProject_Devon"] = 5600,
["WikiProject_Dinosaurs"] = 5600,
["WikiProject_Diptera"] = 21000,
["WikiProject_Disability"] = 21000,
["WikiProject_Disambiguation"] = 342000,
["WikiProject_Disaster_management"] = 27000,
["WikiProject_Discographies"] = 7100,
["WikiProject_Discrimination"] = 7400,
["WikiProject_Disney"] = 10000,
["WikiProject_Doctor_Who"] = 4500,
["WikiProject_Dogs"] = 4000,
["WikiProject_Dorset"] = 3000,
["WikiProject_Dungeons_&amp;_Dragons"] = 6500,
["WikiProject_Dungeons_&amp;_Dragons/importance"] = 6500,
["WikiProject_Earthquakes"] = 3500,
["WikiProject_EastEnders"] = 2500,
["WikiProject_East_Anglia"] = 9100,
["WikiProject_East_Timor"] = 2100,
["WikiProject_Eastern_Orthodoxy"] = 3000,
["WikiProject_Ecology"] = 3800,
["WikiProject_Economics"] = 22000,
["WikiProject_Ecoregions"] = 2600,
["WikiProject_Ecuador"] = 9500,
["WikiProject_Edit_requests"] = 4200,
["WikiProject_Education"] = 40000,
["WikiProject_Egypt"] = 16000,
["WikiProject_El_Salvador"] = 4400,
["WikiProject_Elections_and_Referendums"] = 127000,
["WikiProject_Electrical_engineering"] = 4600,
["WikiProject_Electronic_music"] = 17000,
["WikiProject_Electronics"] = 6300,
["WikiProject_Elements"] = 10000,
["WikiProject_Energy"] = 28000,
["WikiProject_Engineering"] = 16000,
["WikiProject_England"] = 101000,
["WikiProject_Environment"] = 21000,
["WikiProject_Equine"] = 8300,
["WikiProject_Espionage"] = 3000,
["WikiProject_Essays"] = 2600,
["WikiProject_Estonia"] = 24000,
["WikiProject_Ethiopia"] = 6600,
["WikiProject_Ethnic_groups"] = 13000,
["WikiProject_Ethnic_groups_tasks"] = 13000,
["WikiProject_Europe"] = 27000,
["WikiProject_European_Microstates"] = 14000,
["WikiProject_European_Union"] = 9800,
["WikiProject_European_history"] = 15000,
["WikiProject_Eurovision"] = 5200,
["WikiProject_Event_Venues"] = 14000,
["WikiProject_Explosives"] = 2100,
["WikiProject_Faroe_Islands"] = 2700,
["WikiProject_Fashion"] = 13000,
["WikiProject_Feminism"] = 10000,
["WikiProject_Fencing"] = 8200,
["WikiProject_Festivals"] = 10000,
["WikiProject_Fictional_characters"] = 89000,
["WikiProject_Figure_Skating"] = 7600,
["WikiProject_Fiji"] = 5700,
["WikiProject_Film"] = 398000,
["WikiProject_Finance_&amp;_Investment"] = 22000,
["WikiProject_Finland"] = 38000,
["WikiProject_Firearms"] = 11000,
["WikiProject_Firefighting"] = 3900,
["WikiProject_Fisheries_and_Fishing"] = 3200,
["WikiProject_Fishes"] = 42000,
["WikiProject_Florida"] = 31000,
["WikiProject_Folklore"] = 3600,
["WikiProject_Food_and_drink"] = 64000,
["WikiProject_Football"] = 479000,
["WikiProject_Forestry"] = 3200,
["WikiProject_Former_countries"] = 36000,
["WikiProject_Formula_One"] = 8000,
["WikiProject_France"] = 184000,
["WikiProject_Fraternities_and_Sororities"] = 4000,
["WikiProject_Fungi"] = 28000,
["WikiProject_Futures_studies"] = 2100,
["WikiProject_Gaelic_games"] = 19000,
["WikiProject_Gambling"] = 5000,
["WikiProject_Gastropods"] = 47000,
["WikiProject_Gender_studies"] = 5400,
["WikiProject_Genealogy"] = 5500,
["WikiProject_Geography"] = 96000,
["WikiProject_Geology"] = 30000,
["WikiProject_Georgia_(U.S._state)"] = 24000,
["WikiProject_Georgia_(country)"] = 11000,
["WikiProject_Germany"] = 168000,
["WikiProject_Ghana"] = 7600,
["WikiProject_Ghost_towns"] = 2700,
["WikiProject_Gibraltar"] = 2500,
["WikiProject_Glaciers"] = 3900,
["WikiProject_Gloucestershire"] = 3100,
["WikiProject_Golf"] = 16000,
["WikiProject_Google"] = 2100,
["WikiProject_Greater_Manchester"] = 6800,
["WikiProject_Greece"] = 54000,
["WikiProject_Green_Bay_Packers"] = 3200,
["WikiProject_Greenland"] = 3000,
["WikiProject_Guatemala"] = 5100,
["WikiProject_Guild_of_Copy_Editors"] = 11000,
["WikiProject_Guitarists"] = 4400,
["WikiProject_Gymnastics"] = 12000,
["WikiProject_Haiti"] = 5800,
["WikiProject_Hampshire"] = 4500,
["WikiProject_Handball"] = 15000,
["WikiProject_Hawaii"] = 10000,
["WikiProject_Health_and_fitness"] = 6700,
["WikiProject_Heraldry"] = 3400,
["WikiProject_Heraldry_and_vexillology"] = 16000,
["WikiProject_Hertfordshire"] = 3500,
["WikiProject_Higher_education"] = 87000,
["WikiProject_Highways"] = 16000,
["WikiProject_Highways/class"] = 16000,
["WikiProject_Hinduism"] = 10000,
["WikiProject_Hip-hop"] = 26000,
["WikiProject_Hip_hop"] = 21000,
["WikiProject_Historic_sites"] = 25000,
["WikiProject_History"] = 73000,
["WikiProject_History_of_Science"] = 6000,
["WikiProject_Holidays"] = 5300,
["WikiProject_Home_Living"] = 3500,
["WikiProject_Honduras"] = 3400,
["WikiProject_Hong_Kong"] = 21000,
["WikiProject_Horror"] = 18000,
["WikiProject_Horse_racing"] = 15000,
["WikiProject_Horticulture_and_Gardening"] = 4800,
["WikiProject_Hospitals"] = 12000,
["WikiProject_Hotels"] = 5500,
["WikiProject_Houston"] = 4200,
["WikiProject_Human_rights"] = 16000,
["WikiProject_Hungary"] = 31000,
["WikiProject_Ice_Hockey"] = 64000,
["WikiProject_Iceland"] = 12000,
["WikiProject_Illinois"] = 40000,
["WikiProject_Indexes"] = 2500,
["WikiProject_India"] = 270000,
["WikiProject_Indiana"] = 3400,
["WikiProject_Indigenous_peoples_of_North_America"] = 19000,
["WikiProject_Indigenous_peoples_of_the_Americas"] = 5300,
["WikiProject_Indonesia"] = 35000,
["WikiProject_Industrial"] = 4500,
["WikiProject_Industrial_design"] = 3600,
["WikiProject_Industrial_tasks"] = 4500,
["WikiProject_Infoboxes"] = 2000,
["WikiProject_Insects"] = 107000,
["WikiProject_International_relations"] = 90000,
["WikiProject_Internet"] = 9900,
["WikiProject_Internet_culture"] = 9000,
["WikiProject_Intertranswiki/OKA"] = 4200,
["WikiProject_Iran"] = 93000,
["WikiProject_Iraq"] = 12000,
["WikiProject_Ireland"] = 102000,
["WikiProject_Islam"] = 23000,
["WikiProject_Islands"] = 17000,
["WikiProject_Isle_of_Man"] = 2800,
["WikiProject_Israel"] = 32000,
["WikiProject_Italy"] = 107000,
["WikiProject_Japan"] = 127000,
["WikiProject_Jazz"] = 36000,
["WikiProject_Jewish_Women"] = 3400,
["WikiProject_Jewish_culture"] = 2100,
["WikiProject_Jewish_history"] = 13000,
["WikiProject_Jordan"] = 4900,
["WikiProject_Journalism"] = 48000,
["WikiProject_Judaism"] = 24000,
["WikiProject_Kansas"] = 15000,
["WikiProject_Kent"] = 4900,
["WikiProject_Kingdom_of_Naples"] = 2300,
["WikiProject_Korea"] = 60000,
["WikiProject_Kosovo"] = 5400,
["WikiProject_Kurdistan"] = 6300,
["WikiProject_Kuwait"] = 2500,
["WikiProject_Kyrgyzstan"] = 3300,
["WikiProject_LGBTQ+_studies"] = 39000,
["WikiProject_LGBT_studies"] = 24000,
["WikiProject_Lacrosse"] = 3600,
["WikiProject_Lakes"] = 22000,
["WikiProject_Lancashire_and_Cumbria"] = 8700,
["WikiProject_Languages"] = 23000,
["WikiProject_Latin"] = 2000,
["WikiProject_Latin_America"] = 2900,
["WikiProject_Latin_music"] = 19000,
["WikiProject_Latino_and_Hispanic_heritage"] = 15000,
["WikiProject_Latter_Day_Saint_movement"] = 5200,
["WikiProject_Latvia"] = 14000,
["WikiProject_Law"] = 85000,
["WikiProject_Law_Enforcement"] = 16000,
["WikiProject_Leaders_by_year"] = 2600,
["WikiProject_Lebanon"] = 10000,
["WikiProject_Lepidoptera"] = 119000,
["WikiProject_Libraries"] = 12000,
["WikiProject_Library_of_Congress"] = 2300,
["WikiProject_Lighthouses"] = 4000,
["WikiProject_Lincolnshire"] = 5100,
["WikiProject_Linguistics"] = 16000,
["WikiProject_Lists"] = 178000,
["WikiProject_Lists/class"] = 178000,
["WikiProject_Literature"] = 39000,
["WikiProject_Lithuania"] = 17000,
["WikiProject_London"] = 38000,
["WikiProject_London_Transport"] = 3300,
["WikiProject_Lower_Saxony"] = 2100,
["WikiProject_Lutheranism"] = 3500,
["WikiProject_Luxembourg"] = 7000,
["WikiProject_Macau"] = 2300,
["WikiProject_Magazines"] = 22000,
["WikiProject_Maine"] = 11000,
["WikiProject_Malaysia"] = 29000,
["WikiProject_Maldives"] = 3000,
["WikiProject_Malta"] = 6100,
["WikiProject_Mammals"] = 19000,
["WikiProject_Maps"] = 11000,
["WikiProject_Marine_life"] = 15000,
["WikiProject_Marketing_&amp;_Advertising"] = 6600,
["WikiProject_Martial_arts"] = 32000,
["WikiProject_Maryland"] = 19000,
["WikiProject_Mathematics"] = 31000,
["WikiProject_Media"] = 23000,
["WikiProject_Media_franchises"] = 3200,
["WikiProject_Medicine"] = 76000,
["WikiProject_Melanesia"] = 9200,
["WikiProject_Merseyside"] = 4200,
["WikiProject_Mesoamerica"] = 3000,
["WikiProject_Metal"] = 24000,
["WikiProject_Metalworking"] = 2600,
["WikiProject_Mexico"] = 50000,
["WikiProject_Miami"] = 2600,
["WikiProject_Michigan"] = 31000,
["WikiProject_Microbiology"] = 20000,
["WikiProject_Micronesia"] = 9000,
["WikiProject_Microsoft"] = 2900,
["WikiProject_Microsoft_Windows"] = 2500,
["WikiProject_Middle_Ages"] = 31000,
["WikiProject_Military_history"] = 332000,
["WikiProject_Military_history/Checklist_categories"] = 170000,
["WikiProject_Military_history/Class"] = 332000,
["WikiProject_Military_history/Special_project_categories"] = 332000,
["WikiProject_Military_history/Special_project_phase"] = 332000,
["WikiProject_Military_history/Task_force_categories"] = 359000,
["WikiProject_Military_history/YesNo"] = 270000,
["WikiProject_Military_history/class"] = 332000,
["WikiProject_Mills"] = 2700,
["WikiProject_Mining"] = 8700,
["WikiProject_Minnesota"] = 24000,
["WikiProject_Missouri"] = 26000,
["WikiProject_Mixed_martial_arts"] = 6500,
["WikiProject_Moldova"] = 7200,
["WikiProject_Molecular_Biology"] = 39000,
["WikiProject_Mongols"] = 6200,
["WikiProject_Montana"] = 9800,
["WikiProject_Montenegro"] = 7100,
["WikiProject_Morocco"] = 10000,
["WikiProject_Motorcycle_racing"] = 5000,
["WikiProject_Motorcycling"] = 7900,
["WikiProject_Motorsport"] = 26000,
["WikiProject_Mountains"] = 38000,
["WikiProject_Multi-sport_events"] = 31000,
["WikiProject_Museums"] = 32000,
["WikiProject_Music/Music_genres_task_force"] = 5500,
["WikiProject_Music_theory"] = 2300,
["WikiProject_Musical_Instruments"] = 5500,
["WikiProject_Musical_Theatre"] = 7400,
["WikiProject_Myanmar"] = 12000,
["WikiProject_Mythology"] = 14000,
["WikiProject_NASCAR"] = 8100,
["WikiProject_National_Basketball_Association"] = 16000,
["WikiProject_National_Football_League"] = 53000,
["WikiProject_National_Register_of_Historic_Places"] = 94000,
["WikiProject_National_Register_of_Historic_Places/importance"] = 94000,
["WikiProject_Nepal"] = 21000,
["WikiProject_Netherlands"] = 56000,
["WikiProject_Neuroscience"] = 5200,
["WikiProject_Nevada"] = 9000,
["WikiProject_New_Jersey"] = 25000,
["WikiProject_New_York_(state)"] = 50000,
["WikiProject_New_York_City"] = 34000,
["WikiProject_New_Zealand"] = 81000,
["WikiProject_Newspapers"] = 17000,
["WikiProject_Nicaragua"] = 3200,
["WikiProject_Nigeria"] = 21000,
["WikiProject_Normandy"] = 4500,
["WikiProject_Norse_history_and_culture"] = 3700,
["WikiProject_North_America"] = 13000,
["WikiProject_North_America/importance"] = 13000,
["WikiProject_North_East_England"] = 5300,
["WikiProject_North_Macedonia"] = 7600,
["WikiProject_Northern_Ireland"] = 21000,
["WikiProject_Norway"] = 62000,
["WikiProject_Nottinghamshire"] = 2600,
["WikiProject_Novels"] = 90000,
["WikiProject_Numismatics"] = 7600,
["WikiProject_Nursing"] = 2200,
["WikiProject_Occult"] = 2600,
["WikiProject_Occupational_Safety_and_Health"] = 3300,
["WikiProject_Occupations"] = 5100,
["WikiProject_Oceania"] = 8000,
["WikiProject_Oceans"] = 3200,
["WikiProject_Ohio"] = 8400,
["WikiProject_Oklahoma"] = 15000,
["WikiProject_Olympics"] = 201000,
["WikiProject_Oman"] = 2200,
["WikiProject_Opera"] = 18000,
["WikiProject_Orders,_decorations,_and_medals"] = 6000,
["WikiProject_Oregon"] = 27000,
["WikiProject_Oregon/errors"] = 27000,
["WikiProject_Oregon_collab"] = 27000,
["WikiProject_Organizations"] = 58000,
["WikiProject_Organized_Labour"] = 13000,
["WikiProject_Overseas_France"] = 6100,
["WikiProject_Pakistan"] = 43000,
["WikiProject_Palaeontology"] = 34000,
["WikiProject_Palestine"] = 14000,
["WikiProject_Panama"] = 4600,
["WikiProject_Papua_New_Guinea"] = 5400,
["WikiProject_Paraguay"] = 4300,
["WikiProject_Paranormal"] = 2800,
["WikiProject_Pennsylvania"] = 50000,
["WikiProject_Peru"] = 17000,
["WikiProject_Pharmacology"] = 18000,
["WikiProject_Philadelphia"] = 11000,
["WikiProject_Philately"] = 4900,
["WikiProject_Philippines"] = 2300,
["WikiProject_Philosophy"] = 24000,
["WikiProject_Photography"] = 15000,
["WikiProject_Physics"] = 28000,
["WikiProject_Physiology"] = 4100,
["WikiProject_Pittsburgh"] = 6100,
["WikiProject_Plants"] = 149000,
["WikiProject_Podcasting"] = 2500,
["WikiProject_Poetry"] = 24000,
["WikiProject_Pokémon"] = 4100,
["WikiProject_Pokémon/class"] = 4100,
["WikiProject_Poland"] = 112000,
["WikiProject_Politics"] = 205000,
["WikiProject_Politics_of_the_United_Kingdom"] = 49000,
["WikiProject_Polynesia"] = 16000,
["WikiProject_Pop_music"] = 34000,
["WikiProject_Popular_Culture"] = 2100,
["WikiProject_Popular_culture"] = 3800,
["WikiProject_Pornography"] = 5000,
["WikiProject_Portals"] = 2800,
["WikiProject_Portals/class"] = 2800,
["WikiProject_Portals/importance"] = 2800,
["WikiProject_Portals/importancescale"] = 2800,
["WikiProject_Portals/qualityscale"] = 2800,
["WikiProject_Portugal"] = 30000,
["WikiProject_Post-hardcore"] = 4400,
["WikiProject_Primates"] = 2700,
["WikiProject_Pritzker-GLAM"] = 3000,
["WikiProject_Professional_sound_production"] = 2600,
["WikiProject_Professional_wrestling"] = 17000,
["WikiProject_Progressive_Rock"] = 4100,
["WikiProject_Protected_areas"] = 30000,
["WikiProject_Psychology"] = 20000,
["WikiProject_Puerto_Rico"] = 15000,
["WikiProject_Punk_music"] = 8400,
["WikiProject_Qatar"] = 4400,
["WikiProject_R&amp;B_and_Soul_Music"] = 18000,
["WikiProject_Radio"] = 16000,
["WikiProject_Radio_Stations"] = 41000,
["WikiProject_Record_Charts"] = 5000,
["WikiProject_Record_Labels"] = 10000,
["WikiProject_Record_Production"] = 7200,
["WikiProject_Redirect"] = 5100,
["WikiProject_Redirect/class"] = 5100,
["WikiProject_Referees"] = 4400,
["WikiProject_Reggae"] = 3300,
["WikiProject_Regional_and_national_music"] = 10000,
["WikiProject_Religion"] = 33000,
["WikiProject_Religious_texts"] = 2500,
["WikiProject_Retailing"] = 5700,
["WikiProject_Retailing/importance"] = 5700,
["WikiProject_Rivers"] = 57000,
["WikiProject_Robotics"] = 3300,
["WikiProject_Rock_music"] = 31000,
["WikiProject_Rocketry"] = 2500,
["WikiProject_Rocketry/importance"] = 2500,
["WikiProject_Rocks_and_minerals"] = 3100,
["WikiProject_Rodents"] = 5300,
["WikiProject_Role-playing_games"] = 5900,
["WikiProject_Romance"] = 3100,
["WikiProject_Romania"] = 41000,
["WikiProject_Rome"] = 3500,
["WikiProject_Roots_music"] = 5600,
["WikiProject_Rowing"] = 12000,
["WikiProject_Royalty_and_Nobility"] = 6200,
["WikiProject_Rugby_league"] = 20000,
["WikiProject_Rugby_union"] = 39000,
["WikiProject_Running"] = 26000,
["WikiProject_Russia"] = 125000,
["WikiProject_Sailing"] = 12000,
["WikiProject_Saints"] = 6400,
["WikiProject_San_Diego"] = 3100,
["WikiProject_Saudi_Arabia"] = 8600,
["WikiProject_Schools"] = 82000,
["WikiProject_Science"] = 20000,
["WikiProject_Science_Fiction"] = 20000,
["WikiProject_Science_fiction"] = 2300,
["WikiProject_Scotland"] = 57000,
["WikiProject_Scottish_Islands"] = 3300,
["WikiProject_Scouting"] = 7900,
["WikiProject_Screenwriters"] = 2600,
["WikiProject_Sculpture"] = 14000,
["WikiProject_Serbia"] = 29000,
["WikiProject_Sexology_and_sexuality"] = 9800,
["WikiProject_Shakespeare"] = 2100,
["WikiProject_Ships"] = 89000,
["WikiProject_Shipwrecks"] = 8000,
["WikiProject_Shopping_Centers"] = 5600,
["WikiProject_Sicily"] = 2500,
["WikiProject_Singapore"] = 15000,
["WikiProject_Skepticism"] = 6100,
["WikiProject_Skiing_and_Snowboarding"] = 17000,
["WikiProject_Skyscrapers"] = 5900,
["WikiProject_Slovakia"] = 18000,
["WikiProject_Slovenia"] = 22000,
["WikiProject_Snooker"] = 3200,
["WikiProject_Soap_Operas"] = 19000,
["WikiProject_Socialism"] = 24000,
["WikiProject_Sociology"] = 46000,
["WikiProject_Softball"] = 5100,
["WikiProject_Software"] = 14000,
["WikiProject_Somalia"] = 2900,
["WikiProject_Somerset"] = 4800,
["WikiProject_Song_Contests"] = 8800,
["WikiProject_Songs"] = 229000,
["WikiProject_South_Africa"] = 39000,
["WikiProject_South_America"] = 33000,
["WikiProject_South_Dakota"] = 8600,
["WikiProject_Southeast_Asia"] = 14000,
["WikiProject_Soviet_Union"] = 25000,
["WikiProject_Spaceflight"] = 14000,
["WikiProject_Spain"] = 85000,
["WikiProject_Speed_Skating"] = 5600,
["WikiProject_Spiders"] = 14000,
["WikiProject_Sports"] = 142000,
["WikiProject_Sports_Car_Racing"] = 4900,
["WikiProject_Squash"] = 2600,
["WikiProject_Sri_Lanka"] = 28000,
["WikiProject_St._Louis"] = 3000,
["WikiProject_Star_Trek"] = 4200,
["WikiProject_Star_Wars"] = 6000,
["WikiProject_Statistics"] = 7100,
["WikiProject_Stub_sorting"] = 63000,
["WikiProject_Stub_sorting_category"] = 20000,
["WikiProject_Stub_sorting_category/styles.css"] = 20000,
["WikiProject_Surrey"] = 2700,
["WikiProject_Sussex"] = 4300,
["WikiProject_Sweden"] = 69000,
["WikiProject_Swimming"] = 38000,
["WikiProject_Switzerland"] = 47000,
["WikiProject_Syria"] = 13000,
["WikiProject_Systems"] = 4800,
["WikiProject_Table_tennis"] = 3900,
["WikiProject_Taiwan"] = 20000,
["WikiProject_Tajikistan"] = 2600,
["WikiProject_Tambayan_Philippines"] = 51000,
["WikiProject_Taxation"] = 2200,
["WikiProject_Technology"] = 18000,
["WikiProject_Telecommunications"] = 10000,
["WikiProject_Television"] = 295000,
["WikiProject_Templates"] = 33000,
["WikiProject_Tennessee"] = 18000,
["WikiProject_Tennis"] = 59000,
["WikiProject_Textile_Arts"] = 2800,
["WikiProject_Textile_arts"] = 3500,
["WikiProject_Thailand"] = 25000,
["WikiProject_The_Beatles"] = 5000,
["WikiProject_The_Simpsons"] = 2200,
["WikiProject_Theatre"] = 38000,
["WikiProject_Theology"] = 2400,
["WikiProject_Tibet"] = 3900,
["WikiProject_Time"] = 18000,
["WikiProject_Timor-Leste"] = 2200,
["WikiProject_Toys"] = 3800,
["WikiProject_Trade"] = 2700,
["WikiProject_Trains"] = 149000,
["WikiProject_Trains/portalbox"] = 149000,
["WikiProject_Translation_studies"] = 2000,
["WikiProject_Transport"] = 31000,
["WikiProject_Travel_and_Tourism"] = 14000,
["WikiProject_Tree_of_Life"] = 7700,
["WikiProject_Trinidad_and_Tobago"] = 4900,
["WikiProject_Tunisia"] = 5200,
["WikiProject_Turkey"] = 60000,
["WikiProject_Turkmenistan"] = 2200,
["WikiProject_Turtles"] = 3700,
["WikiProject_Typography"] = 2900,
["WikiProject_U.S._Congress"] = 23000,
["WikiProject_U.S._Roads"] = 34000,
["WikiProject_U.S._Roads/StateName"] = 33000,
["WikiProject_U.S._Roads/articletest"] = 34000,
["WikiProject_U.S._Roads/cats"] = 34000,
["WikiProject_U.S._Roads/cats/core"] = 34000,
["WikiProject_U.S._Roads/cats/istemplate"] = 34000,
["WikiProject_U.S._Roads/class"] = 34000,
["WikiProject_U.S._Roads/overcat"] = 33000,
["WikiProject_U.S._Supreme_Court_cases"] = 5500,
["WikiProject_UK_Parliament_constituencies"] = 2300,
["WikiProject_UK_geography"] = 31000,
["WikiProject_Ukraine"] = 38000,
["WikiProject_Underwater_diving"] = 3700,
["WikiProject_United_Arab_Emirates"] = 7400,
["WikiProject_United_Kingdom"] = 81000,
["WikiProject_United_States"] = 775000,
["WikiProject_United_States_History"] = 5000,
["WikiProject_United_States_Territories"] = 6900,
["WikiProject_United_States_courts_and_judges"] = 12000,
["WikiProject_University_of_California"] = 3300,
["WikiProject_University_of_Cambridge"] = 2800,
["WikiProject_University_of_Florida"] = 2000,
["WikiProject_University_of_Oxford"] = 12000,
["WikiProject_University_of_Pennsylvania"] = 3100,
["WikiProject_Unreferenced_articles"] = 2900,
["WikiProject_Urban_studies_and_planning"] = 6400,
["WikiProject_Uruguay"] = 11000,
["WikiProject_Userboxes"] = 63000,
["WikiProject_Veganism_and_Vegetarianism"] = 3200,
["WikiProject_Venezuela"] = 12000,
["WikiProject_Veterinary_medicine"] = 2300,
["WikiProject_Video_games"] = 112000,
["WikiProject_Video_games/class"] = 112000,
["WikiProject_Video_games/importance"] = 112000,
["WikiProject_Vietnam"] = 18000,
["WikiProject_Villages"] = 12000,
["WikiProject_Virginia"] = 30000,
["WikiProject_Viruses"] = 7300,
["WikiProject_Visual_arts"] = 98000,
["WikiProject_Volcanoes"] = 7000,
["WikiProject_Volleyball"] = 18000,
["WikiProject_Wales"] = 32000,
["WikiProject_Warwickshire"] = 2600,
["WikiProject_Water"] = 2400,
["WikiProject_Water_sports"] = 15000,
["WikiProject_Weather"] = 16000,
["WikiProject_Websites"] = 5200,
["WikiProject_West_Midlands"] = 4300,
["WikiProject_Western_Asia"] = 11000,
["WikiProject_Westerns"] = 9600,
["WikiProject_Wiki_Loves_Women"] = 2000,
["WikiProject_Wikipedia_essays"] = 2700,
["WikiProject_Wikipedia_essays/importance"] = 2700,
["WikiProject_Wiltshire"] = 2800,
["WikiProject_Wisconsin"] = 31000,
["WikiProject_Women"] = 126000,
["WikiProject_Women's_Health"] = 3500,
["WikiProject_Women's_History"] = 71000,
["WikiProject_Women's_sport"] = 166000,
["WikiProject_Women_artists"] = 22000,
["WikiProject_Women_in_Business"] = 9200,
["WikiProject_Women_in_Music"] = 45000,
["WikiProject_Women_in_Red"] = 59000,
["WikiProject_Women_in_Religion"] = 8700,
["WikiProject_Women_scientists"] = 26000,
["WikiProject_Women_writers"] = 71000,
["WikiProject_World_Rally"] = 2300,
["WikiProject_Writing_systems"] = 4700,
["WikiProject_Years"] = 648000,
["WikiProject_Yemen"] = 6300,
["WikiProject_Yorkshire"] = 27000,
["WikiProject_YouTube"] = 2800,
["WikiProject_Yugoslavia"] = 7000,
["WikiProject_Zimbabwe"] = 5700,
["WikiProject_Zoo"] = 2900,
["WikiProject_banner_shell"] = 11300000,
["WikiProject_cleanup_list"] = 59000,
["WikiProject_cleanup_listing"] = 8900,
["WikiProject_cleanup_listing/styles.css"] = 8900,
["WikiProject_description_page"] = 2800,
["WikiProject_status"] = 2700,
["WikiProjectbasename"] = 2600,
["Wiki_Loves_Pride_talk"] = 3500,
["Wikibooks"] = 2600,
["Wikibreak"] = 2500,
["Wikicite"] = 2200,
["Wikidata"] = 502000,
["WikidataCheck"] = 490000,
["WikidataCoord"] = 14000,
["Wikidata_entity_link"] = 50000,
["Wikidata_image"] = 986000,
["Wikidata_list"] = 4000,
["Wikidata_list_end"] = 3800,
["Wikidata_location"] = 3400,
["Wikidata_property_link"] = 2500,
["Wikidata_sitelink"] = 89000,
["Wikidatacoord"] = 2600,
["Wikinews"] = 3500,
["Wikipedia's_sister_projects/styles.css"] = 6000,
["Wikipedia:Version_1.0_article_stats"] = 5200,
["Wikipedia_Embassy_link"] = 4400,
["Wikipedia_ads"] = 3700,
["Wikipedia_category"] = 17000,
["Wikipedia_help_pages"] = 2400,
["Wikipedia_languages/styles.css"] = 3800,
["Wikipedia_logs"] = 6500,
["Wikipedia_other"] = 13000,
["Wikipedia_policies_and_guidelines"] = 3700,
["Wikiquote"] = 42000,
["Wikiquote-inline"] = 3100,
["Wikisource"] = 20000,
["Wikisource-inline"] = 6300,
["Wikisource/Author"] = 5400,
["Wikisource/inner_core"] = 20000,
["Wikisource/outer_core"] = 20000,
["Wikisourcelang"] = 2200,
["Wikispecies"] = 36000,
["Wikispecies-inline"] = 13000,
["Wikivoyage"] = 12000,
["Wikivoyage-inline"] = 3200,
["Wikivoyage_inline"] = 5900,
["Wikt"] = 10000,
["Wikt-lang"] = 4000,
["Wiktionary"] = 79000,
["Wiktionary-inline"] = 3000,
["Wiktionary_redirect"] = 2000,
["Win_draw_lose"] = 7600,
["Win_draw_lose_totals"] = 6100,
["Wink"] = 4300,
["Winners"] = 5400,
["Winning_percentage"] = 40000,
["Winpct"] = 7700,
["Women's_Tennis_Association_link"] = 3900,
["Won"] = 48000,
["Workpage"] = 4700,
["Works_year_header"] = 4700,
["Works_year_header/helper"] = 4800,
["WorldFootball.net"] = 22000,
["World_Athletics"] = 14000,
["World_Rowing"] = 2600,
["World_Series_Year"] = 6700,
["Worldfootball.net"] = 4800,
["Wrap"] = 53000,
["Wraplink"] = 2800,
["Writer_icon"] = 6200,
["Writer_icon2"] = 6200,
["WritingCredits"] = 3800,
["Wsy"] = 6000,
["Module:WDL"] = 13000,
["Module:WLink"] = 73000,
["Module:WPMILHIST_Infobox_style"] = 243000,
["Module:WPSHIPS_utilities"] = 100000,
["Module:WPSHIPS_utilities/data"] = 100000,
["Module:Wd"] = 1780000,
["Module:Wd/i18n"] = 1780000,
["Module:Weather_box"] = 31000,
["Module:Weather_box/colors"] = 31000,
["Module:Weather_box/row"] = 31000,
["Module:Webarchive"] = 582000,
["Module:Webarchive/data"] = 582000,
["Module:Wide_image"] = 11000,
["Module:WikiProject_banner"] = 11300000,
["Module:WikiProject_banner/auxiliary"] = 4030000,
["Module:WikiProject_banner/config"] = 11300000,
["Module:WikiProject_banner/styles.css"] = 11300000,
["Module:Wikidata"] = 139000,
["Module:WikidataCheck"] = 506000,
["Module:WikidataCoord"] = 14000,
["Module:WikidataIB"] = 1780000,
["Module:WikidataIB/nolinks"] = 1780000,
["Module:WikidataIB/titleformats"] = 1780000,
["Module:WikidataIdentifiers"] = 2600,
["Module:Wikipedia_ads"] = 3700,
["Module:Wikipedia_ads/data"] = 4000,
["Module:Wikipedia_ads/list"] = 4000,
["Module:Wikitext_Parsing"] = 17900000,
["Module:Wikt-lang"] = 4000,
["Module:Wikt-lang/data"] = 4000,
["Module:Women_in_Red_event"] = 60000,
["Module:WritingCredits"] = 3800,
}</text>
      <sha1>qslusd9a1u1qobodqdi0j0jdadwarwh</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikidata property link</title>
    <ns>10</ns>
    <id>97</id>
    <revision>
      <id>182</id>
      <parentid>181</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>181</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1216" sha1="k8jv170qlggs0249fpe48ygwkpgfzbn" xml:space="preserve">&lt;includeonly&gt;{{#switch:{{str left|{{uc:{{{id|}}}}}|1}}
| N &lt;!--none--&gt; = {{#switch:{{str left|{{uc:{{{1|}}}}}|1}}
  | P = [[d:Special:EntityPage/{{uc:{{{1|}}}}}|{{wikidata|label|{{uc:{{{1|}}}}}}}]]
  | [[d:Special:EntityPage/P{{uc:{{{1|}}}}}|{{wikidata|label|P{{uc:{{{1|}}}}}}}]]
  }}
| O &lt;!--only--&gt; = {{#switch:{{str left|{{uc:{{{1|}}}}}|1}}
  | P = [[d:Special:EntityPage/{{uc:{{{1|}}}}}|{{uc:{{{1|}}}}}]]
  | [[d:Special:EntityPage/P{{uc:{{{1|}}}}}|P{{uc:{{{1|}}}}}]]
  }}
| F &lt;!--first--&gt; = {{#switch:{{str left|{{uc:{{{1|}}}}}|1}}
  | P = [[d:Special:EntityPage/{{uc:{{{1|}}}}}|{{uc:{{{1|}}}}}]]{{#if:{{wikidata|label|{{uc:{{{1|}}}}}}}|&amp;#58; &lt;small&gt;{{wikidata|label|{{uc:{{{1|}}}}}}}&lt;/small&gt;}}
  | [[d:Special:EntityPage/P{{uc:{{{1|}}}}}|P{{uc:{{{1|}}}}}]]{{#if:{{wikidata|label|P{{uc:{{{1|}}}}}}}|&amp;#58; &lt;small&gt;{{wikidata|label|P{{uc:{{{1|}}}}}}}&lt;/small&gt;}}
  }}
| #default = {{#switch:{{str left|{{uc:{{{1|}}}}}|1}}
  | P = [[d:Special:EntityPage/{{uc:{{{1|}}}}}|{{wikidata|label|{{uc:{{{1|}}}}}}} &lt;small&gt;({{uc:{{{1|}}}}})&lt;/small&gt;]]
  | [[d:Special:EntityPage/P{{uc:{{{1|}}}}}|{{wikidata|label|P{{uc:{{{1|}}}}}}} &lt;small&gt;(P{{uc:{{{1|}}}}})&lt;/small&gt;]]
  }}
}}&lt;/includeonly&gt;&lt;noinclude&gt;{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>k8jv170qlggs0249fpe48ygwkpgfzbn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Property</title>
    <ns>10</ns>
    <id>98</id>
    <redirect title="Template:Wikidata property link" />
    <revision>
      <id>184</id>
      <parentid>183</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>183</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="45" sha1="hnd6qym6gp623hmrowx5b3lbsghmzbj" xml:space="preserve">#REDIRECT [[Template:Wikidata property link]]</text>
      <sha1>hnd6qym6gp623hmrowx5b3lbsghmzbj</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Template rating</title>
    <ns>10</ns>
    <id>99</id>
    <revision>
      <id>186</id>
      <parentid>185</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>185</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5392" sha1="dimpd5efiyf50sppy8t23w8f4lgv82b" xml:space="preserve">{{Template other|{{ombox
 | type      = notice
 | image     = {{#switch: {{{1|&lt;noinclude&gt;g&lt;/noinclude&gt;}}}
   | pre-alpha | prealpha | pa = [[File:Ambox warning blue construction.svg|40x40px|link=]]
   | alpha | a                 = [[File:Greek lc alpha icon.svg|26x26px|link=]]
   | beta | b                  = [[File:Greek lc beta  icon.svg|40x40px|link=]]
   | mock-up | mockup | m      = [[File:Greek lc mu.svg|56x56px|link=]]
   | release | r | general | g = [[File:Green check.svg|40x40px|link=]]
   | protected | protect | p   = [[File:{{#switch:{{#invoke:Effective protection level|edit|{{#switch:{{SUBPAGENAME}}|doc|sandbox={{FULLBASEPAGENAME}}|{{FULLPAGENAME}}}}}}|autoconfirmed=Semi-protection-shackle|accountcreator|templateeditor=Template-protection-shackle|Full-protection-shackle}}.svg|40x40px|link=]]
  }}
 | style     = 
 | textstyle = 
 | text      = {{#switch: {{{1|&lt;noinclude&gt;g&lt;/noinclude&gt;}}}
   | pre-alpha | prealpha | pa = This template is rated as [[:Category:Templates in pre-alpha development|pre-alpha]]. It is unfinished, and may or may not be in active development. It should not be used in article namespace pages. Templates remain pre-alpha until the original editor (or someone who takes one over if it is abandoned for some time) is satisfied with the basic structure.&lt;!--
   --&gt;{{#switch: {{SUBPAGENAME}}|doc|sandbox=&lt;!-- No category for /doc or /sandbox subpages --&gt;
       | {{#ifeq: {{{nocat|}}} | true | &lt;!-- No category if user sets nocat=true --&gt; | [[Category:Templates in pre-alpha development|{{PAGENAME}}]] }}
      }}
   | alpha | a                 = This template is rated as [[:Category:Templates in alpha|alpha]]. It is ready for third party input, and may be used on a few pages to see if problems arise, but should be watched. Suggestions for new features or changes in their input and output mechanisms are welcome.&lt;!--
   --&gt;{{#switch: {{SUBPAGENAME}}|doc|sandbox=&lt;!-- No category for /doc or /sandbox subpages --&gt;
       | {{#ifeq: {{{nocat|}}} | true | &lt;!-- No category if user sets nocat=true --&gt; | [[Category:Templates in alpha|{{PAGENAME}}]] }}
      }}
   | beta | b                  = This template is rated as [[:Category:Templates in beta|beta]], and is ready for widespread use. It is still new and should be used with some caution to ensure the results are as expected.&lt;!--
   --&gt;{{#switch: {{SUBPAGENAME}}|doc|sandbox=&lt;!-- No category for /doc or /sandbox subpages --&gt;
       | {{#ifeq: {{{nocat|}}} | true | &lt;!-- No category if user sets nocat=true --&gt; | [[Category:Templates in beta|{{PAGENAME}}]] }}
      }}
   | mockup | mock-up | m      = This template is rated as [[:Category:Templates in mock-up|mock-up]]. The "mock-up" rating applies to templates that serve as a proof-of-concept demonstration for new functionality or features. These templates are designed to showcase potential new capabilities or design concepts, but they are not intended for long-term use in their current form. A mock-up template is typically a first step in the development process, allowing developers and users to explore the viability and utility of a new idea before it is fully implemented. Mock-ups should be monitored carefully, as they may undergo frequent updates or be retired altogether once the final design is ready for implementation in Lua. It is ready for third party input, and may be used on a few pages to see if problems arise. Users are encouraged to provide feedback on the mock-up's functionality on the Template talk page to aid in its development.&lt;!--
   --&gt;{{#switch: {{SUBPAGENAME}}|doc|sandbox=&lt;!-- No category for /doc or /sandbox subpages --&gt;
       | {{#ifeq: {{{nocat|}}} | true | &lt;!-- No category if user sets nocat=true --&gt; | [[Category:Templates in mockup |{{PAGENAME}}]] }}
      }}
   | release | r | general | g = This template is rated as ready for general use. It has reached a mature form and is thought to be bug-free and ready for use wherever appropriate. It is ready to mention on help pages and other Wikipedia resources as an option for new users to learn. To reduce server load and bad output, it should be improved by [[WP:TESTCASES|sandbox testing]] rather than repeated trial-and-error editing.&lt;!-- Category deleted per [[Wikipedia:Categories_for_discussion/Log/2021_October_17#Category%3ATemplates_for_general_use]] --&gt;
   | protected | protect | p   = This template is [[:Category:Wikipedia template-protected templates|subject to page protection]]. It is a [[Wikipedia:High-risk templates|highly visible template]] in use by a very large number of pages, or is [[WP:SUBST|substituted]] very frequently. Because vandalism or mistakes would affect many pages, and even trivial editing might cause substantial load on the servers, it is [[WP:PROTECT|protected]] from editing.&lt;!--
   --&gt;{{#switch: {{SUBPAGENAME}}|doc|sandbox=&lt;!-- No category for /doc or /sandbox subpages --&gt;
       | {{#ifeq: {{{nocat|}}} | true | &lt;!-- No category if user sets nocat=true --&gt; | [[Category:Wikipedia template-protected templates|{{PAGENAME}}]] }}
      }}
   | #default                  = {{error|Template rating is invalid or not specified.}}
  }}
}}|{{error|Error: {{tl|Template rating}} must be placed in the Template namespace.}}|demospace={{{demospace|&lt;noinclude&gt;template&lt;/noinclude&gt;}}}}}&lt;noinclude&gt;

{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go in Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>dimpd5efiyf50sppy8t23w8f4lgv82b</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Message box/ombox.css</title>
    <ns>828</ns>
    <id>100</id>
    <revision>
      <id>188</id>
      <parentid>187</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>187</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1852" sha1="aknh3fw7498ygg9b1o85bvfqn56r48n" xml:space="preserve">/* {{pp|small=y}} */
.ombox {
	margin: 4px 0;
	border-collapse: collapse;
	border: 1px solid #a2a9b1;    /* Default "notice" gray */
	background-color: var(--background-color-neutral-subtle, #f8f9fa);
	box-sizing: border-box;
    color: var(--color-base, #202122);
}

/* For the "small=yes" option. */
.ombox.mbox-small {
	font-size: 88%;
	line-height: 1.25em;
}

.ombox-speedy {
	border: 2px solid #b32424;    /* Red */
	background-color: #fee7e6;    /* Pink */
}

.ombox-delete {
	border: 2px solid #b32424;    /* Red */
}

.ombox-content {
	border: 1px solid #f28500;    /* Orange */
}

.ombox-style {
	border: 1px solid #fc3;       /* Yellow */
}

.ombox-move {
	border: 1px solid #9932cc;    /* Purple */
}

.ombox-protection {
	border: 2px solid #a2a9b1;    /* Gray-gold */
}

.ombox .mbox-text {
	border: none;
	/* @noflip */
	padding: 0.25em 0.9em;
	width: 100%;
}

.ombox .mbox-image {
	border: none;
	/* @noflip */
	padding: 2px 0 2px 0.9em;
	text-align: center;
}

.ombox .mbox-imageright {
	border: none;
	/* @noflip */
	padding: 2px 0.9em 2px 0;
	text-align: center;
}

/* An empty narrow cell */
.ombox .mbox-empty-cell {
	border: none;
	padding: 0;
	width: 1px;
}

.ombox .mbox-invalid-type {
	text-align: center;
}

@media (min-width: 720px) {
	.ombox {
		margin: 4px 10%;
	}
	
	.ombox.mbox-small {
		/* @noflip */
		clear: right;
		/* @noflip */
		float: right;
		/* @noflip */
		margin: 4px 0 4px 1em;
		width: 238px;
	}
}

/** T367463 */
body.skin--responsive table.ombox img {
	max-width: none !important;
}

@media screen {
	html.skin-theme-clientpref-night .ombox-speedy {
		background-color: #310402;    /* Dark red, same hue/saturation as light */
	}
}

@media screen and (prefers-color-scheme: dark) {
	html.skin-theme-clientpref-os .ombox-speedy {
		background-color: #310402; /* Dark red, same hue/saturation as light */
	}
}</text>
      <sha1>aknh3fw7498ygg9b1o85bvfqn56r48n</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wpl</title>
    <ns>10</ns>
    <id>101</id>
    <redirect title="Template:Wikidata property link" />
    <revision>
      <id>190</id>
      <parentid>189</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>189</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="45" sha1="hnd6qym6gp623hmrowx5b3lbsghmzbj" xml:space="preserve">#REDIRECT [[Template:Wikidata property link]]</text>
      <sha1>hnd6qym6gp623hmrowx5b3lbsghmzbj</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikidata/doc</title>
    <ns>10</ns>
    <id>102</id>
    <revision>
      <id>192</id>
      <parentid>191</parentid>
      <timestamp>2025-07-09T04:31:22Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>191</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="111256" sha1="1zfr3qni6ovld66kffh5dns8845glrp" xml:space="preserve">{{Hatnote|For the module that should be used in {{para|datax}} parameters of infobox templates instead of this {{lcfirst:{{NAMESPACE}}}}, see [[:Module:WikidataIB]].}}
{{Hatnote|For a version of this template with an opt-in toggle, see {{tl|WikidataOI}}.}}
&lt;noinclude&gt;{{Documentation subpage}}&lt;/noinclude&gt;
{{#ifeq:{{ROOTPAGENAME}}|Wikidata|{{Template shortcut|wd}}
{{Lua sidebar|template={{{template|Wikidata}}}|module=Wd}}
{{#ifeq:{{NAMESPACE}}:{{ROOTPAGENAME}}|Template:Wikidata|{{Template rating|protected}}
{{High-use|risk}}}}
{{#ifeq:{{NAMESPACENUMBER}}|10|{{Lua|Module:Wd}}}}}}
&lt;!-- Original documentation located at [[:en:Template:Wikidata/doc]]. --&gt;
This {{lcfirst:{{NAMESPACE}}}} is intended to fetch data from '''[[w:Wikidata|Wikidata]]''' with or without a link to the connected Wikipedia article and with many other features. {{{intro|}}}

== Usage ==
The general structure of a call to this {{lcfirst:{{NAMESPACE}}}} is as follows. Note that the basic structure consists of positional commands, flags and arguments, which all have a fixed position.

:{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}{{0|&amp;ensp;}}{{Background color|#cddae3|&lt;nowiki&gt;|command1|flag1a|flag1b|flag1c&lt;/nowiki&gt;}}{{0|&amp;ensp;}}{{Background color|#dce5ec|&lt;nowiki&gt;|command2|flag2a|flag2b|flag2c&lt;/nowiki&gt;}}{{0|&amp;ensp;}}{{Background color|#c1debf|&lt;nowiki&gt;|flag0a|flag0b|flag0c&lt;/nowiki&gt;}}{{0|&amp;ensp;}}{{Background color|#ffdfc4|&lt;nowiki&gt;|arg1|arg2|arg3&lt;/nowiki&gt;}}}}

Use different [[#Commands|{{Background color|#cddae3|commands}}]] to get different kinds of values from Wikidata. At least one command must be given and multiple commands can be combined into one call as shown above (in any order, more than two is also possible), but this only applies to commands from the [[#Claim class|claim class]]; calls containing a command from the [[#General class|general class]] cannot contain any other command. Each command can be followed by any number of [[#Command flags|{{Background color|#cddae3|command flags}}]], which are optional and can be used to tweak the output generated by that command.

The commands and their flags may be followed by any number of [[#Configuration flags|{{Background color|#c1debf|configuration flags}}]], which are also optional and affect the selection of data and the {{lcfirst:{{NAMESPACE}}}}'s behaviour in general. The call is closed with the [[#Positional arguments|{{Background color|#ffdfc4|positional arguments}}]], which may be required depending on the given command(s). Some [[#Named arguments|named arguments]] (i.e. name-value pairs) also exist, as well as a set of named flags for [[#Advanced usage|advanced usage]] that can be used to change the way the fetched values are merged together into the output.

This {{lcfirst:{{NAMESPACE}}}} was designed to provide the basic needs for fetching data from Wikidata, but a lot can be achieved through different combinations of calls. For convenience, such combinations could be wrapped into new templates that serve a specific need. See also the section on [[#Common use cases|common use cases]] below for some examples of useful "building blocks". Likewise, the functionality of this {{lcfirst:{{NAMESPACE}}}} can be extended by creating wrapper templates that use the [[Module:Wd#Main class|&lt;code&gt;main&lt;/code&gt; command]] provided by {{module other|this module|[[Module:Wd]] which is being used by this template}} (just like {{tl|WikidataOI}} does).

=== Common use cases ===
Below follows a list of common use cases. In the future, shortcut commands may be implemented that are equivalent to these calls for convenience.
{| class="wikitable"
|-
! Call
! Use case
|-
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|label|raw|{{{extraparams|}}}}}}}
| Returns the Q-identifier of the Wikidata item connected to the current page (e.g. "Q55").
|-
| {{nowrap|&lt;code&gt;&lt;nowiki&gt;{{#if:&lt;/nowiki&gt;{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|label|raw|{{{extraparams|}}}}}&lt;nowiki&gt;|...}}&lt;/nowiki&gt;&lt;/code&gt;}}
| Performs a check to determine if the current page has a Wikidata item.
Note that this statement relies on a returned value that is either empty or non-empty and that the &lt;code&gt;raw&lt;/code&gt; flag is important to include. Without this flag, an existing item's regular label would be returned which could be empty, giving an undesired result. If the flag is given on the other hand, then a non-empty Q-identifier is always returned if an item exists and an empty value if an item does not exist.
|}

== Commands ==
The commands (&lt;code&gt;{{Background color|#cddae3|command1}}&lt;/code&gt;, &lt;code&gt;{{Background color|#dce5ec|command2}}&lt;/code&gt;, ...) determine what kind of values are returned. One call can only contain commands from a single class.

=== Claim class ===
The claim class commands can be combined, meaning that multiple commands of different types from this class can be given at one time ([[#Usage|see above for usage]]).

Combine multiple commands into one call to this {{lcfirst:{{NAMESPACE}}}}, instead of making multiple calls to this {{lcfirst:{{NAMESPACE}}}} with one command each, to be sure that all the returned pieces of information belong to each other ([[#Examples|see also the examples below]]).
{| class="wikitable"
|-
! Type
! Command
! Returns
! Basic usage
! Description
|-
| rowspan="2" style="text-align:right;" | I
! style="text-align:left;" | &lt;code&gt;property&lt;/code&gt;
| {{smaller|first match{{efn|Returns only a single value instead of multiple (if multiple claims or statements match). The returned value is '''the first match found from the best-ranked''' claims.}}}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|property|P1|{{{extraparams|}}}}}}}
| rowspan="2" | Returns the requested property – or list of properties – from the current item-entity or from a given entity.
This command can be given only once in one call.
|-
! style="text-align:left;" | &lt;code&gt;properties&lt;/code&gt;
| {{smaller|all matches}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|properties|P1|{{{extraparams|}}}}}}}
|-
| colspan="5" |
|-
| rowspan="2" style="text-align:right;" | II
! style="text-align:left;" | &lt;code&gt;qualifier&lt;/code&gt;
| {{smaller|first match{{efn|Returns only a single value instead of multiple for each matching claim. To get at most one value in total in case the &lt;code&gt;property&lt;/code&gt; command is not also used, additionally use the [[#Configuration flags|&lt;code&gt;single&lt;/code&gt; configuration flag]].|name=fm}}}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|qualifier|P1|P2|{{{extraparams|}}}}}}}
| rowspan="2" | Returns the requested qualifier – or list of qualifiers – from the given property of the current item-entity or of a given entity.
Unlike the other claim class commands, this command can be given multiple times to retrieve different qualifiers in one call.
|-
! style="text-align:left;" | &lt;code&gt;qualifiers&lt;/code&gt;
| {{smaller|all matches}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|qualifiers|P1|P2|{{{extraparams|}}}}}}}
|-
| colspan="5" |
|-
| rowspan="2" style="text-align:right;" | III
! style="text-align:left;" | &lt;code&gt;reference&lt;/code&gt;
| {{smaller|first match{{efn|name=fm}}}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|reference|P1|{{{extraparams|}}}}}}}
| rowspan="2" | Returns a reference – or list of references – from the given property of the current item-entity or of a given entity.{{efn|See [[#References|the section on references]] for details.}}
This command can be given only once in one call.
|-
! style="text-align:left;" | &lt;code&gt;references&lt;/code&gt;
| {{smaller|all matches}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|references|P1|{{{extraparams|}}}}}}}
|-
| colspan="5" |
|-
| colspan="5" style="text-align:left;" | {{notelist}}
|}

=== General class ===
The general class commands cannot be combined.
{| class="wikitable"
|-
! Type
! Command
! Returns
! Basic usage
! Description
|-
| style="text-align:right;" | I
! style="text-align:left;" | &lt;code&gt;label&lt;/code&gt;
|
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|label|{{{extraparams|}}}}}}}
| Returns the label of the current item-entity or of a given entity if present.
|-
| colspan="5" |
|-
| style="text-align:right;" | II
! style="text-align:left;" | &lt;code&gt;title&lt;/code&gt;
|
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|title|{{{extraparams|}}}}}}}
| Returns the title of the page connected to the current item-entity or to a given item-entity if such page exists.
|-
| colspan="5" |
|-
| style="text-align:right;" | III
! style="text-align:left;" | &lt;code&gt;description&lt;/code&gt;
|
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|description|{{{extraparams|}}}}}}}
| Returns the description of the current item-entity or of a given entity if present.
|-
|-
| colspan="5" |
|-
| rowspan="2" style="text-align:right;" | IV
! style="text-align:left;" | &lt;code&gt;alias&lt;/code&gt;
| {{smaller|first match{{efn|Returns only a single value instead of multiple (if multiple values are present).|name=fmg}}}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|alias|{{{extraparams|}}}}}}}
| rowspan="2" | Returns an alias – or list of aliases – of the current item-entity or of a given entity if present.
|-
! style="text-align:left;" | &lt;code&gt;aliases&lt;/code&gt;
| {{smaller|all matches}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|aliases|{{{extraparams|}}}}}}}
|-
| colspan="5" |
|-
| rowspan="2" style="text-align:right;" | V
! style="text-align:left;" | &lt;code&gt;badge&lt;/code&gt;
| {{smaller|first match{{efn|name=fmg}}}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|badge|{{{extraparams|}}}}}}}
| rowspan="2" | Returns a badge – or list of badges – for the page connected to the current item-entity or to a given item-entity if such page exists.
|-
! style="text-align:left;" | &lt;code&gt;badges&lt;/code&gt;
| {{smaller|all matches}}
| {{nowrap|{{tnull|{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}|badges|{{{extraparams|}}}}}}}
|-
| colspan="5" |
|-
| colspan="5" style="text-align:left;" | {{notelist}}
|}

== Flags ==
The following (optional) flags are available which can be used to alter this {{lcfirst:{{NAMESPACE}}}}'s behaviour. They must be given after the (first) {{Background color|#cddae3|command}} and before the {{Background color|#ffdfc4|positional arguments}}. For convenience, empty flags (i.e. &lt;code&gt;||&lt;/code&gt;) are allowed and will simply be ignored.

=== Command flags ===
These flags (&lt;code&gt;{{Background color|#cddae3|flag1*}}&lt;/code&gt;, &lt;code&gt;{{Background color|#dce5ec|flag2*}}&lt;/code&gt;, ...) apply to the command that precedes them directly.
{| class="wikitable"
|-
! Flag
! Description
|-
! style="text-align:left;" | &lt;code&gt;raw&lt;/code&gt;
| Returns the raw value if applicable.

If this flag is used with item or property datatypes, then this will return the Q-identifier or P-identifier instead of the regular label.

For quantity datatypes, this flag will strip off any units of measurement, unless the &lt;code&gt;unit&lt;/code&gt; flag is also given in which case the raw unit of measurement (its Q-identifier) will be returned.

If this flag is used with time datatypes, then the returned date will be in the format of &lt;code&gt;yyyy-mm-dd&lt;/code&gt; (e.g. &lt;code&gt;1731-02-11&lt;/code&gt;), or &lt;code&gt;yyyy-mm&lt;/code&gt;, or &lt;code&gt;yyyy&lt;/code&gt; depending on the date's precision. Dates in the Julian calendar stored with a precision of days through millenniums will have &lt;code&gt;/Julian&lt;/code&gt; attached to the output (e.g. &lt;code&gt;1731-02-11/Julian&lt;/code&gt;, which may be split off using the [[mw:Help:Extension:ParserFunctions#.23titleparts|&lt;nowiki&gt;{{#titleparts}}&lt;/nowiki&gt; parser function]]).

If it is used with globe coordinate datatypes, then it replaces the various symbols with forward slashes in the returned value (e.g. &lt;code&gt;52/5/3/N/4/19/3/E&lt;/code&gt;, which may be split into parts using the [[mw:Help:Extension:ParserFunctions#.23titleparts|&lt;nowiki&gt;{{#titleparts}}&lt;/nowiki&gt; parser function]]).
|-
! style="text-align:left;" | &lt;code&gt;linked&lt;/code&gt;
| Creates a link to the Wikipedia article that is connected to the property or qualifier if it exists. Also links units of measurement that may be appended to values.

If this parameter is omitted, then the plain property or qualifier value will be returned.
|-
! style="text-align:left;" | &lt;code&gt;short&lt;/code&gt;
| '''&lt;code&gt;{{color|red|[EXPENSIVE]}}&lt;/code&gt;''' Returns the {{wpl|P1813}} of any entity returned if they have one attached. If that is not the case, then the default behaviour of returning the entity's label will occur.
|-
! style="text-align:left;" | &lt;code&gt;multilanguage&lt;/code&gt;
| Returns monolingual text values in any available language, not just the current wiki's language.
|-
! style="text-align:left;" | &lt;code&gt;unit&lt;/code&gt;
| Returns only the unit of measurement for quantity datatypes.
|}

=== Configuration flags ===
These flags (&lt;code&gt;{{Background color|#c1debf|flag0*}}&lt;/code&gt;) are general configuration flags and can be given anywhere after the first {{Background color|#cddae3|command}} (but before the {{Background color|#ffdfc4|positional arguments}}).
{| class="wikitable"
|-
!
! Flag
! Description
! Command class
|-
| rowspan="4" style="text-align:right;" | {{nowrap|Combination of:}}
! style="text-align:left;" | &lt;code&gt;preferred&lt;/code&gt;
| rowspan="4" | Sets a rank constraint for the selected claim(s).

The first three set the ranks for which claim(s) will be selected. They can optionally be followed by a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;-&lt;/code&gt;, e.g. &lt;code&gt;normal+&lt;/code&gt; or &lt;code&gt;preferred-&lt;/code&gt;, where the first selects claims with a 'normal' rank ''or higher'' and the second selects claims with a 'preferred' rank ''or lower''. To get claims of all ranks, use &lt;code&gt;preferred-&lt;/code&gt; or &lt;code&gt;deprecated+&lt;/code&gt;.

If the &lt;code&gt;best&lt;/code&gt; flag is given additionally, then only the claims that have the highest rank amongst the selected claims will be returned.

The default is &lt;code&gt;normal+|best&lt;/code&gt; (so by default claims with a 'deprecated' rank are never returned).

Output is always sorted from highest rank to lowest (regardless of any of these flags being set).
| rowspan="4" | [[#Claim class|claim]]
|-
! style="text-align:left;" | &lt;code&gt;normal&lt;/code&gt;
|-
! style="text-align:left;" | &lt;code&gt;deprecated&lt;/code&gt;
|-
! style="text-align:left;" | &lt;code&gt;best&lt;/code&gt;
|-
| rowspan="3" style="text-align:right;" | {{nowrap|Combination of:}}
! style="text-align:left;" | &lt;code&gt;future&lt;/code&gt;
| rowspan="3" | Sets a time constraint for the selected claim(s). Uses the claims' qualifiers of {{wpl|P580}} and {{wpl|P582}} to determine if the claim is valid for the selected time period(s).

The default is &lt;code&gt;future|current|former&lt;/code&gt; (so by default claims that are valid for any time period are returned), except when &lt;code&gt;date=&lt;/code&gt; is given ([[#Named arguments|see below]]) in which case the default is &lt;code&gt;current&lt;/code&gt;.
| rowspan="3" | claim
|-
! style="text-align:left;" | &lt;code&gt;current&lt;/code&gt;
|-
! style="text-align:left;" | &lt;code&gt;former&lt;/code&gt;
|-
|
! style="text-align:left;" | &lt;code&gt;mdy&lt;/code&gt;
| Returns date values in month-day-year order instead of day-month-year order.
| claim
|-
|
! style="text-align:left;" | &lt;code&gt;single&lt;/code&gt;
| Returns only a single claim instead of multiple (if multiple claims match). Has no effect if the &lt;code&gt;property&lt;/code&gt;/&lt;code&gt;properties&lt;/code&gt; command is given, in which case this flag would be redundant.
| claim
|-
|
! style="text-align:left;" | &lt;code&gt;sourced&lt;/code&gt;
| Only returns claims that have at least one non-empty reference. (References having only [[#Ignored parameters|ignored parameters]] are considered empty.)
| claim
|-
| rowspan="2" style="text-align:right;" | {{nowrap|One of:}}
! style="text-align:left;" | &lt;code&gt;edit&lt;/code&gt;
| rowspan="2" | Adds a clickable icon after the output that may be used by readers to edit the returned claim on Wikidata.

If &lt;code&gt;edit@end&lt;/code&gt; is used, then the icon will be placed at the end of the line for neat alignment in infoboxes.
| rowspan="2" | claim, [[#General class|general]]
|-
! style="text-align:left;" | &lt;code&gt;edit@end&lt;/code&gt;
|- style="display:none;"
| colspan="4" | &lt;!-- non-displayed row to avoid breaking table with sticky headers gadget --&gt;
|}

== Arguments ==
The arguments determine the sources from which all the returned values are fetched.

=== Positional arguments ===
The following table shows the available positional arguments (&lt;code&gt;{{Background color|#ffdfc4|arg*}}&lt;/code&gt;) in their fixed order. For each command, the applicable set of arguments is marked. If multiple commands are given, then the applicable set is the union of the individual sets. For instance, if the commands &lt;code&gt;properties&lt;/code&gt; and &lt;code&gt;qualifiers&lt;/code&gt; have been given, then at least both the arguments &lt;code&gt;property_id&lt;/code&gt; and &lt;code&gt;qualifier_id&lt;/code&gt; should be given as well.

More than one &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command can be given. The order in which these commands with their flags are given matches the order in which the respective &lt;code&gt;qualifier_id&lt;/code&gt; arguments are given.
{| class="wikitable" style="background:none;border:none;"
|- style="text-align:center;"
| rowspan="2" style="background:none;border:none;" |
| colspan="2" | {{smaller|''(required)''}}
| {{smaller|{{color|#777|''(optional)''}}}}
| {{smaller|{{color|#777|(optional)}}}}
| {{smaller|(required)}}
| {{smaller|{{color|#777|(optional)}}}}
| {{smaller|(required)}}
| {{smaller|(required)}}
| rowspan="2" style="background:none;border:none;" |
|-
| colspan="2" |
|
|
|
|
|
|
|-
| style="border-right:2px solid #000;" | ''&lt;code&gt;&lt;nowiki&gt;{{&lt;/nowiki&gt;{{{prename|}}}{{lcfirst:{{ROOTPAGENAME}}}}&lt;/code&gt;''
| colspan="2" style="border-right:2px solid #000;" | ''&lt;code&gt;commands&lt;/code&gt;''
| style="border-right:2px solid #000;" | ''&lt;code style="color:#777;"&gt;flags&lt;/code&gt;''
! style="border-right:2px solid #000;background-color:#ffdfc4;" | &lt;code style="color:#777;"&gt;entity_id&lt;/code&gt;
! style="border-right:2px solid #000;background-color:#ffdfc4;" | &lt;code&gt;property_id&lt;/code&gt;
! style="border-right:2px solid #000;background-color:#ffdfc4;" | &lt;code style="color:#777;"&gt;raw_value&lt;/code&gt;
! style="border-right:2px solid #000;background-color:#ffdfc4;" | &lt;code&gt;qualifier_id&lt;/code&gt;
! style="background-color:#ffdfc4;" | &lt;code&gt;qualifier_id&lt;/code&gt;
| ''&lt;code&gt;&lt;nowiki&gt;}}&lt;/nowiki&gt;&lt;/code&gt;''
|-
| rowspan="12" colspan="2" style="background:none;border:none;" |
| rowspan="2" colspan="2" style="border-style:dashed;border-left-color:blue;border-bottom-color:blue;" |
|
|
|
|
|
| rowspan="12" style="background:none;border:none;" |
|- style="text-align:center;"
| rowspan="2" | &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;,&lt;br /&gt;&lt;code&gt;description&lt;/code&gt;,&lt;br /&gt;&lt;code&gt;alias&lt;/code&gt;/&lt;code&gt;aliases&lt;/code&gt;,&lt;br /&gt;&lt;code&gt;badge&lt;/code&gt;/&lt;code&gt;badges&lt;/code&gt;
| rowspan="2" style="border-top:none;border-bottom:none;" |
| rowspan="2" style="border-top:none;border-bottom:none;" |
| rowspan="2" style="border-top:none;border-bottom:none;" |
| rowspan="2" style="border-top:none;border-bottom:none;" |
|-
| rowspan="2" colspan="2" style="border-style:dashed;border-left-color:blue;border-bottom-color:blue;" |
|- style="text-align:center;"
| rowspan="2" colspan="2" style="border-top:none;" | &lt;code&gt;property&lt;/code&gt;/&lt;code&gt;properties&lt;/code&gt;
| rowspan="2" style="border-top:none;border-bottom:none;" |
| rowspan="2" style="border-top:none;border-bottom:none;" |
| rowspan="2" style="border-top:none;border-bottom:none;" |
|-
| rowspan="2" colspan="2" style="border-style:dashed;border-left-color:blue;border-bottom-color:blue;" |
|- style="text-align:center;"
| rowspan="2" colspan="3" style="border-top:none;" | &lt;code&gt;reference&lt;/code&gt;/&lt;code&gt;references&lt;/code&gt;
| rowspan="2" style="border-top:none;border-bottom:none;" |
| rowspan="2" style="border-top:none;border-bottom:none;" |
|-
| rowspan="2" colspan="2" style="border-style:dashed;border-left-color:blue;border-bottom-color:blue;" |
|- style="text-align:center;"
| rowspan="2" colspan="4" style="border-top:none;" | &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt;
| rowspan="2" style="border-top:none;border-bottom:none;" |
|-
| rowspan="2" colspan="2" style="border-style:dashed;border-left-color:blue;border-bottom-color:blue;" |
|- style="text-align:center;"
| rowspan="2" colspan="5" style="border-top:none;" | &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; ''(optional 2&lt;sup&gt;nd&lt;/sup&gt;, 3&lt;sup&gt;rd&lt;/sup&gt;, etc.)''
|-
| rowspan="2" colspan="2" style="border:none;" |
|-
| colspan="5" style="border:none;" |
|}

Below follows a description of all positional arguments.

{| class="wikitable"
|-
! Argument
! Description
|-
! style="text-align:left;" | &lt;code style="color:#777;"&gt;entity_id&lt;/code&gt;

{{smaller|{{nobold|(optional)}}}}
| '''&lt;code&gt;{{color|red|[EXPENSIVE]}}&lt;/code&gt;''' '''Q-identifier''' of the item-entity to be accessed (e.g. &lt;code&gt;Q55&lt;/code&gt;), '''P-identifier''' (or an available '''[[#Property aliases|alias]]''') of the property-entity to be accessed preceded by the &lt;code&gt;Property:&lt;/code&gt; prefix (e.g. &lt;code&gt;Property:P38&lt;/code&gt;), or '''page title''' of the Wikipedia article whose connected item-entity is to be accessed preceded by &lt;code&gt;:&lt;/code&gt;, a prefixed colon (e.g. &lt;code&gt;:Netherlands&lt;/code&gt;).

In case of the [[#General class|general class commands]], the &lt;code&gt;Property:&lt;/code&gt; prefix may be omitted for P-identifiers (e.g. &lt;code&gt;P38&lt;/code&gt;).

If this parameter is omitted, then the item-entity connected to the current page will be used (except when &lt;code&gt;eid=&lt;/code&gt; or &lt;code&gt;page=&lt;/code&gt; is given, [[#Named arguments|see below]]). If this parameter is given, but empty (i.e. &lt;code&gt;&amp;#124;&amp;#124;&lt;/code&gt;), then due to its position it will be interpreted as an [[#Flags|empty flag]] and thus be ignored, giving the same result as if it were omitted. See also the [[#Named arguments|named arguments &lt;code&gt;eid=&lt;/code&gt; and &lt;code&gt;page=&lt;/code&gt;]] below that can be used to give an entity-ID or page title too, but without the item-entity connected to the current page being used as a default.
|-
! style="text-align:left;" | &lt;code&gt;property_id&lt;/code&gt;
| '''P-identifier''' (or an available '''[[#Property aliases|alias]]''') of the property within the entity to be accessed, without the &lt;code&gt;Property:&lt;/code&gt; prefix (e.g. &lt;code&gt;P35&lt;/code&gt;).
|-
! style="text-align:left;" | &lt;code style="color:#777;"&gt;raw_value&lt;/code&gt;

{{smaller|{{nobold|(optional)}}}}
| Either the '''Q-identifier''' equal to the property value (e.g. &lt;code&gt;Q29574&lt;/code&gt;) or a '''literal value''' (i.e. string or quantity etc., ''no entity label'') equal to the raw property value of the particular claim to be accessed.

Dates as literal values must be formatted &lt;code&gt;yyyy-mm-dd&lt;/code&gt; (e.g. &lt;code&gt;1731-02-11&lt;/code&gt;) for dates with a precision of days, &lt;code&gt;yyyy-mm&lt;/code&gt; (e.g. &lt;code&gt;1731-02&lt;/code&gt;) for dates with a precision of months, and &lt;code&gt;yyyy&lt;/code&gt; (e.g. &lt;code&gt;1731&lt;/code&gt;) for dates of lesser precision. Dates BCE require a minus sign in front of the year (e.g. &lt;code&gt;-2950-01-31&lt;/code&gt;). Dates stored in the Julian calendar must have &lt;code&gt;/Julian&lt;/code&gt; attached to the end (e.g. &lt;code&gt;1731-02-11/Julian&lt;/code&gt;). Decades like the 2010s must be given as &lt;code&gt;2010&lt;/code&gt; (but the 2010s BCE as &lt;code&gt;-2019&lt;/code&gt;), centuries like the 20th century as &lt;code&gt;1901&lt;/code&gt; (but the 20th century BCE as &lt;code&gt;-2000&lt;/code&gt;), and millenniums like the 3rd millennium as &lt;code&gt;2001&lt;/code&gt; (but the 3rd millennium BCE as &lt;code&gt;-3000&lt;/code&gt;).

Globe coordinates as literal values must be formatted with forward slashes (i.e. &lt;code&gt;/&lt;/code&gt;) between the parts and no symbols (e.g. &lt;code&gt;52/5/3/N/4/19/3/E&lt;/code&gt;) ''without any spaces or leading zeros''.

The special type &amp;#39;'''no value'''&amp;#39; can be given by entering the empty string (i.e. &lt;code&gt;&amp;#124;&amp;#124;&lt;/code&gt;) and the special type &amp;#39;'''unknown value'''&amp;#39; can be given by entering a single underscore (i.e. &lt;code&gt;&amp;#124;_&amp;#124;&lt;/code&gt;). To get a literal underscore, escape it by placing a backslash &lt;code&gt;\&lt;/code&gt; directly in front of it (i.e. &lt;code&gt;\_&lt;/code&gt;); the same holds for a literal backslash (i.e. &lt;code&gt;\\&lt;/code&gt;).

To get a literal vertical bar &lt;code&gt;|&lt;/code&gt;, use &lt;code&gt;{{tl|!}}&lt;/code&gt; or &lt;code&gt;&amp;amp;#124;&lt;/code&gt;.

If this parameter is omitted, then all claims (matching any other constraints) within the property will be accessed.
|-
! style="text-align:left;" | &lt;code&gt;qualifier_id&lt;/code&gt;
| '''P-identifier''' (or an available '''[[#Property aliases|alias]]''') of the qualifier within the entity to be accessed, without the &lt;code&gt;Property:&lt;/code&gt; prefix (e.g. &lt;code&gt;P580&lt;/code&gt;).
|}


=== Named arguments ===
Below follows a description of all named arguments, which are name-value pairs (i.e. &lt;code&gt;|name=value&lt;/code&gt;). These are all optional and can be given anywhere {{module other|after the first command|inside the call}}.

{| class="wikitable"
|-
! Argument
! Description
! Command class
|-
! style="text-align:right;" | &lt;code&gt;eid=&lt;/code&gt;
| '''&lt;code&gt;{{color|red|[EXPENSIVE]}}&lt;/code&gt;''' This argument can be used to give the '''Q-identifier''' (e.g. &lt;code&gt;&amp;#124;eid=Q55&lt;/code&gt;) or '''P-identifier''' (or an available '''[[#Property aliases|alias]]''') of the entity to be accessed. It offers the same functionality as the [[#Positional arguments|positional argument &lt;code&gt;entity_id&lt;/code&gt;]], with one difference: if the argument is given but its value is left empty (i.e. &lt;code&gt;&amp;#124;eid=&lt;/code&gt;), then no entity is accessed at all instead of the item-entity connected to the current page. This is useful in some cases where a variable entity-ID is expected, but where the item-entity connected to the current page should not be accessed as the default.

Also, the &lt;code&gt;Property:&lt;/code&gt; prefix may be omitted for P-identifiers (e.g. &lt;code&gt;&amp;#124;eid=P38&lt;/code&gt;) for all commands.

This argument only has effect if the positional argument &lt;code&gt;entity_id&lt;/code&gt; is omitted.
| [[#Claim class|claim]], [[#General class|general]]
|-
! style="text-align:right;" | &lt;code&gt;page=&lt;/code&gt;
| '''&lt;code&gt;{{color|red|[EXPENSIVE]}}&lt;/code&gt;''' This argument can be used to give the '''page title''' (e.g. &lt;code&gt;&amp;#124;page=Netherlands&lt;/code&gt;) of the Wikipedia article whose connected item-entity is to be accessed. It behaves similar to the named argument &lt;code&gt;eid=&lt;/code&gt; and can be used instead of the [[#Positional arguments|positional argument &lt;code&gt;entity_id&lt;/code&gt;]] (note that no prefixed colon, &lt;code&gt;:&lt;/code&gt;, is required). If the argument is given but its value is left empty (i.e. &lt;code&gt;&amp;#124;page=&lt;/code&gt;), then no entity is accessed at all instead of the item-entity connected to the current page.

This argument only has effect if the positional argument &lt;code&gt;entity_id&lt;/code&gt; and the named argument &lt;code&gt;eid=&lt;/code&gt; are omitted.
| claim, general
|-
! style="text-align:right;" | &lt;code&gt;date=&lt;/code&gt;
| This argument can be used to set a particular date (e.g. &lt;code&gt;&amp;#124;date=1731-02-11&lt;/code&gt;) relative to which claim matching using the [[#Configuration flags|&lt;code&gt;future&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt; and &lt;code&gt;former&lt;/code&gt; flags]] is done, instead of relative to today. It overrides the default of these flags to &lt;code&gt;current&lt;/code&gt; so that by default only claims that were valid at the given date are returned (based on the claims' qualifiers of {{wpl|P580}} and {{wpl|P582}}).

The date value must be formatted &lt;code&gt;yyyy-mm-dd&lt;/code&gt; (e.g. &lt;code&gt;1731-02-11&lt;/code&gt;), &lt;code&gt;yyyy-mm&lt;/code&gt; (e.g. &lt;code&gt;1731-02&lt;/code&gt;) or &lt;code&gt;yyyy&lt;/code&gt; (e.g. &lt;code&gt;1731&lt;/code&gt;).
| claim
|-
! style="text-align:right;" | &lt;code&gt;''&lt;qualifier&gt;''=&lt;/code&gt;
| The &lt;code&gt;''&lt;qualifier&gt;''&lt;/code&gt; is a placeholder for a set of arguments that determine which claims should be accessed based on qualifier value, analogous to the pair of [[#Positional arguments|positional arguments &lt;code&gt;property_id&lt;/code&gt; and &lt;code&gt;raw_value&lt;/code&gt;]] (that determine access based on property value).

As such, &lt;code&gt;''&lt;qualifier&gt;''&lt;/code&gt; is any qualifier's '''P-identifier''' (or an available '''[[#Property aliases|alias]]''') without the &lt;code&gt;Property:&lt;/code&gt; prefix (e.g. &lt;code&gt;P518&lt;/code&gt;). Its value is either the '''Q-identifier''' equal to one of the qualifier values (e.g. &lt;code&gt;Q27561&lt;/code&gt;) or a '''literal value''' (i.e. string or quantity etc., ''no entity label'') equal to one of the raw qualifier values of the particular claim to be accessed. The value format is the same as for the positional argument &lt;code&gt;raw_value&lt;/code&gt;. The special type &amp;#39;'''no value'''&amp;#39; given by the empty string also matches the total absence within the claim of the particular qualifier.

Example: &lt;code&gt;|P518=Q27561&lt;/code&gt;

Multiple arguments of this type can be given to match multiple qualifier values simultaneously for each claim.
| claim
|}

=== Property aliases ===
Property aliases are other names for P-identifiers that can be used instead. The following property aliases (which are [[Case sensitivity|case-sensitive]]) are currently available:

{| class="wikitable"
|-
! Alias
! &lt;sub&gt;translates&lt;br /&gt;&lt;/sub&gt;&lt;sup&gt;to&lt;/sup&gt;
! P-identifier
|- &lt;!-- property aliases purely for convenience --&gt;
| coord ||style="text-align: center;"| → || [[d:Property:P625|P625]]
|-
!colspan="3"|
|- &lt;!-- property aliases used by the module itself --&gt;
| image ||style="text-align: center;"| → || [[d:Property:P18|P18]]
|-
| author ||style="text-align: center;"| → || [[d:Property:P50|P50]]
|-
| authorNameString ||style="text-align: center;"| → || [[d:Property:P2093|P2093]]
|-
| publisher ||style="text-align: center;"| → || [[d:Property:P123|P123]]
|-
| importedFrom ||style="text-align: center;"| → || [[d:Property:P143|P143]]
|-
| wikimediaImportURL ||style="text-align: center;"| → || [[d:Property:P4656|P4656]]
|-
| statedIn ||style="text-align: center;"| → || [[d:Property:P248|P248]]
|-
| pages ||style="text-align: center;"| → || [[d:Property:P304|P304]]
|-
| language ||style="text-align: center;"| → || [[d:Property:P407|P407]]
|-
| hasPart ||style="text-align: center;"| → || [[d:Property:P527|P527]]
|-
| publicationDate ||style="text-align: center;"| → || [[d:Property:P577|P577]]
|-
| startTime ||style="text-align: center;"| → || [[d:Property:P580|P580]]
|-
| endTime ||style="text-align: center;"| → || [[d:Property:P582|P582]]
|-
| chapter ||style="text-align: center;"| → || [[d:Property:P792|P792]]
|-
| retrieved ||style="text-align: center;"| → || [[d:Property:P813|P813]]
|-
| referenceURL ||style="text-align: center;"| → || [[d:Property:P854|P854]]
|-
| sectionVerseOrParagraph ||style="text-align: center;"| → || [[d:Property:P958|P958]]
|-
| archiveURL ||style="text-align: center;"| → || [[d:Property:P1065|P1065]]
|-
| title ||style="text-align: center;"| → || [[d:Property:P1476|P1476]]
|-
| formatterURL ||style="text-align: center;"| → || [[d:Property:P1630|P1630]]
|-
| quote ||style="text-align: center;"| → || [[d:Property:P1683|P1683]]
|-
| shortName ||style="text-align: center;"| → || [[d:Property:P1813|P1813]]
|-
| definingFormula ||style="text-align: center;"| → || [[d:Property:P2534|P2534]]
|-
| archiveDate ||style="text-align: center;"| → || [[d:Property:P2960|P2960]]
|-
| inferredFrom ||style="text-align: center;"| → || [[d:Property:P3452|P3452]]
|-
| typeOfReference ||style="text-align: center;"| → || [[d:Property:P3865|P3865]]
|-
| column ||style="text-align: center;"| → || [[d:Property:P3903|P3903]]
|-
| subjectNamedAs ||style="text-align: center;"| → || [[d:Property:P1810|P1810]]
|-
| wikidataProperty ||style="text-align: center;"| → || [[d:Property:P1687|P1687]]
|}

== References ==
When either the &lt;code&gt;reference&lt;/code&gt; or the &lt;code&gt;references&lt;/code&gt; command is used and a reference is encountered (in Wikidata), the module checks if the reference contains an {{property|P143}}, {{property|P3452}} or {{property|P4656}} property. In the case one of these properties is present, the whole reference is ignored (i.e. it is treated as if it wasn't present).

Else, the module attempts to display the reference using the {{Tl|Cite web}} template. The reference has to have a {{property|P854}} property. The below table shows the mapping of Wikidata properties to parameters of Cite web.
&lt;!-- The information in the table is from Module:wd/i18n. --&gt;
{| class="wikitable"
|+
!Wikidata property
!Parameter of Cite web
!Notes
|-
|{{property|P2960}}
|archive-date
|
|-
|{{property|P1065}}
|archive-url
|
|-
|{{property|P50}}
| rowspan="2" |author/authorN
| rowspan="2" |N can be 1, 2, 3...
|-
|{{property|P2093}}
|-
|{{property|P407}}
|language
|Ignored when the same as the local language.
|-
|{{property|P304}}
|pages
|
|-
|{{property|P577}}
|date
|
|-
|{{property|P123}}
|publisher
|
|-
|{{property|P1683}}
|quote
|
|-
|{{property|P854}}
|url
|
|-
|{{property|P813}}
|access-date
|
|-
|{{property|P958}}
|at
|
|-
|{{property|P248}}
|website
|
|-
|{{property|P1810}}
|title
|Used only when {{property|P1476}} is not present, but a URL (either from {{property|P854}} or from an external identifier, as described below) is, otherwise ignored.
|-
|{{property|P1476}}
|title
|
|}
{{Anchor|Ignored parameters}}The following properties are ignored: {{property|P18}},  {{property|P3865}}.

If there is no {{property|P854}} property present in the reference, but a property of the "External identifier" [[d:Help:Data type|data type]] is present both in the reference and in the {{property|1687}} of the item in {{property|P248}}, a URL is generated from its content and is used in the same manner as a URL given in {{property|P854}}.

If there is no {{property|P854}} property, or the reference has unknown properties, the module attempts to display it using the {{Tl|Cite Q}} template. The {{property|P248}} property is mandatory. The below table shows the mapping of properties to Cite Q parameters.
{| class="wikitable"
|+
!Wikidata property
!Parameter of Cite Q 
!Notes
|-
|{{property|P248}}
|1
|Value supplied to the parameter is ''raw'', i.e. it is just the plain QID.
|-
|{{property|P792}}
|chapter
|
|-
|{{property|P3903}}
|at
|
|-
|{{property|P304}}
|pages
|
|-
|{{property|P577}}
|date
|
|-
|{{property|P813}}
|access-date
|
|-
|{{property|P958}}
|section
|
|-
|{{property|P1476}}
|title
|
|-
|any property of the "External identifier" data type
|id
|The label ("name") of the property is prepended before its content.
|}
The properties listed ''under'' the first table (in this section) are also ignored when using Cite Q.

A reference could be displayed using Cite Q only if the reference has a {{property|P248}} property and has only properties listed in the table above. If neither Cite web nor Cite Q could be used to display a reference, an error message with an explanation is returned.

To fix this error, check if the reference has the required properties and doesn't have any unknown properties, as described above. The [[d:Help:Sources|Wikidata help page on references]] can also be helpful when sourcing statements.

== Advanced usage ==
The layout of the output from (a combination of) commands that have both a singular and a plural form (e.g. &lt;code&gt;property&lt;/code&gt;/&lt;code&gt;properties&lt;/code&gt;) can be customized by using a number of named flags, which are name-value pairs (i.e. &lt;code&gt;|flag=value&lt;/code&gt;), that can be given anywhere {{module other|after the first command|inside the call}}. The table below shows the available named flags.

To insert a space at the beginning or end of a &lt;code&gt;value&lt;/code&gt;, use an underscore &lt;code&gt;_&lt;/code&gt;. To get a literal underscore, escape it by placing a backslash &lt;code&gt;\&lt;/code&gt; directly in front of it (i.e. &lt;code&gt;\_&lt;/code&gt;); the same holds for a literal backslash (i.e. &lt;code&gt;\\&lt;/code&gt;). To get a literal vertical bar &lt;code&gt;|&lt;/code&gt;, use &lt;code&gt;{{tl|!}}&lt;/code&gt; or &lt;code&gt;&amp;amp;#124;&lt;/code&gt;.

{| class="wikitable"
|-
! Named flag
! Default value
! Default condition
! Description
|-
! rowspan="6" style="text-align:right;" | &lt;code&gt;format=&lt;/code&gt;
| &lt;code&gt;%p[%s][%r]&lt;/code&gt;
| if the &lt;code&gt;property&lt;/code&gt;/&lt;code&gt;properties&lt;/code&gt; command '''was''' given and the &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command '''was not''' given
| rowspan="6" | The format of a single claim. The available parameters are as follows.

{| class="wikitable"
|-
! Parameter
! Description
|-
| &lt;code&gt;%p&lt;/code&gt;
| The claim's property value applied by the &lt;code&gt;property&lt;/code&gt;/&lt;code&gt;properties&lt;/code&gt; command.
|-
| &lt;code&gt;%q1&lt;/code&gt;, &lt;code&gt;%q2&lt;/code&gt;, &lt;code&gt;%q3&lt;/code&gt;, ...
| The claim's qualifier value or list of qualifier values applied by the corresponding &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command.
|-
| &lt;code&gt;%q&lt;/code&gt;
| The collection of the qualifier values applied by each &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command (i.e. &lt;code&gt;%q1&lt;/code&gt; + &lt;code&gt;%q2&lt;/code&gt; + &lt;code&gt;%q3&lt;/code&gt; + ...). If only one &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command was given, then this parameter is equivalent to &lt;code&gt;%q1&lt;/code&gt;.
|-
| &lt;code&gt;%r&lt;/code&gt;
| The claim's reference value or list of reference values applied by the &lt;code&gt;reference&lt;/code&gt;/&lt;code&gt;references&lt;/code&gt; command.
|-
| &lt;code&gt;%a&lt;/code&gt;
| The entity's alias applied by the &lt;code&gt;alias&lt;/code&gt;/&lt;code&gt;aliases&lt;/code&gt; command.
|-
| &lt;code&gt;%b&lt;/code&gt;
| The entity's page badge applied by the &lt;code&gt;badge&lt;/code&gt;/&lt;code&gt;badges&lt;/code&gt; command.
|-
| &lt;code&gt;%s&lt;/code&gt;
| The movable separator placeholder. This is a special parameter that is not applied by a command, but instead is filled automatically between each pair of claims, aliases or badges (if a list of claims, aliases or badges is returned). This is particularly handy in case a claim's reference is returned as well, since it allows the reference to be placed after the punctuation mark as prescribed by [[Wikipedia:Manual of Style#Punctuation and footnotes|Wikipedia's manual of style]]. The default value is a comma (&lt;code&gt;,&lt;/code&gt;) and can be overridden with the &lt;code&gt;sep%s&lt;/code&gt; flag (see below).
|}

Optional parameters can be given by encapsulating them between square brackets: &lt;code&gt;[...]&lt;/code&gt;. All content between the square brackets is only displayed if a value for each optional parameter that has been defined between the same brackets has been found. Optional content can also be nested.

To use two opening square brackets that directly follow each other (i.e. &lt;code&gt;{{!((}}&lt;/code&gt;), use &lt;code&gt;{{tl|!((}}&lt;/code&gt;.

At least one parameter must be given that is not optional, while the &lt;code&gt;%s&lt;/code&gt; parameter must always be defined as optional.

To get a literal &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;, escape the character by placing a backslash &lt;code&gt;\&lt;/code&gt; directly in front of it (e.g. &lt;code&gt;\%&lt;/code&gt;). See also the description directly above this table for more.
|-
| &lt;code&gt;%q[%s][%r]&lt;/code&gt;
| if the &lt;code&gt;property&lt;/code&gt;/&lt;code&gt;properties&lt;/code&gt; command '''was not''' given and the &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command '''was''' given
|-
| &lt;code&gt;%r&lt;/code&gt;
| if '''only''' the &lt;code&gt;reference&lt;/code&gt;/&lt;code&gt;references&lt;/code&gt; command was given
|-
| &lt;syntaxhighlight lang="wikitext"&gt;%p[ &lt;span style="font-size:85\%"&gt;(%q)&lt;/span&gt;][%s][%r]&lt;/syntaxhighlight&gt;
| if the &lt;code&gt;property&lt;/code&gt;/&lt;code&gt;properties&lt;/code&gt; command '''was''' given and the &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command '''was''' given
|-
| &lt;code&gt;%a[%s]&lt;/code&gt;
| if the &lt;code&gt;alias&lt;/code&gt;/&lt;code&gt;aliases&lt;/code&gt; command was given
|-
| &lt;code&gt;%b[%s]&lt;/code&gt;
| if the &lt;code&gt;badge&lt;/code&gt;/&lt;code&gt;badges&lt;/code&gt; command was given
|-
| colspan="4" |
|-
! rowspan="2" style="text-align:right;" | &lt;code&gt;sep=&lt;/code&gt;
| &lt;code&gt;{{dfn|_|title=space}}&lt;/code&gt;
| &lt;span style="color:#777;"&gt;''default''&lt;/span&gt;
| rowspan="2" | The fixed separator between each pair of claims, aliases or badges.
|-
| {{dfn|&lt;code&gt;{{0|&amp;ensp;}}&lt;/code&gt;|title=empty}}
| if '''only''' the &lt;code&gt;reference&lt;/code&gt;/&lt;code&gt;references&lt;/code&gt; command was given '''without''' the &lt;code&gt;raw&lt;/code&gt; flag
|-
| colspan="4" |
|-
! rowspan="2" style="text-align:right;" | &lt;code&gt;sep%s=&lt;/code&gt;
| &lt;code&gt;,&lt;/code&gt;
| &lt;span style="color:#777;"&gt;''default''&lt;/span&gt;
| rowspan="2" | The movable separator between each pair of claims, aliases or badges. This will be the value of the &lt;code&gt;%s&lt;/code&gt; parameter applied to all claims, aliases or badges, except for the last in the list (which can be set with the &lt;code&gt;punc&lt;/code&gt; flag).
|-
| &lt;code&gt;;&lt;/code&gt;
| if the &lt;code&gt;property&lt;/code&gt;/&lt;code&gt;properties&lt;/code&gt; command '''was not''' given and the &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command '''was''' given
|-
| colspan="4" |
|-
! style="text-align:right;" | &lt;code&gt;sep%q1=&lt;/code&gt;, &lt;code&gt;sep%q2=&lt;/code&gt;, &lt;code&gt;sep%q3=&lt;/code&gt;, ...
| &lt;code&gt;{{dfn|,_|title=comma space}}&lt;/code&gt;
| &lt;span style="color:#777;"&gt;''default''&lt;/span&gt;
| The separator between each pair of qualifiers of a single claim. These are the value separators for the &lt;code&gt;%q1&lt;/code&gt;, &lt;code&gt;%q2&lt;/code&gt;, &lt;code&gt;%q3&lt;/code&gt;, ... parameters.
If only one &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command was given, then the &lt;code&gt;sep%q1&lt;/code&gt; flag is equivalent to &lt;code&gt;sep%q&lt;/code&gt;.
|-
| colspan="4" |
|-
! rowspan="2" style="text-align:right;" | &lt;code&gt;sep%q=&lt;/code&gt;
| &lt;code&gt;{{dfn|,_|title=comma space}}&lt;/code&gt;
| if '''exactly one''' &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command was given
| rowspan="2" | The separator between each set of qualifiers of a single claim. This is the value separator for the &lt;code&gt;%q&lt;/code&gt; parameter.
If only one &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command was given, then this flag is equivalent to &lt;code&gt;sep%q1&lt;/code&gt;.
|-
| &lt;code&gt;{{dfn|{{;}}_|title=semicolon space}}&lt;/code&gt;
| if '''more than one''' &lt;code&gt;qualifier&lt;/code&gt;/&lt;code&gt;qualifiers&lt;/code&gt; command was given
|-
| colspan="4" |
|-
! rowspan="2" style="text-align:right;" | &lt;code&gt;sep%r=&lt;/code&gt;
| {{dfn|&lt;code&gt;{{0|&amp;ensp;}}&lt;/code&gt;|title=empty}}
| &lt;span style="color:#777;"&gt;''default''&lt;/span&gt;
| rowspan="2" | The separator between each pair of references of a single claim. This is the value separator for the &lt;code&gt;%r&lt;/code&gt; parameter.
|-
| &lt;code&gt;{{dfn|_|title=space}}&lt;/code&gt;
| if the &lt;code&gt;raw&lt;/code&gt; flag '''was''' given for the &lt;code&gt;reference&lt;/code&gt;/&lt;code&gt;references&lt;/code&gt; command
|-
| colspan="4" |
|-
! style="text-align:right;" | &lt;code&gt;punc=&lt;/code&gt;
| {{dfn|&lt;code&gt;{{0|&amp;ensp;}}&lt;/code&gt;|title=empty}}
| &lt;span style="color:#777;"&gt;''default''&lt;/span&gt;
| A punctuation mark placed at the end of the output. This will be placed on the &lt;code&gt;%s&lt;/code&gt; parameter applied to the last claim (or alias or badge) in the list.
This allows the last claim's references to be placed after the punctuation mark when the output is used as part of a sentence.
|}

== Examples ==
&lt;!--
TO UPDATE EXAMPLE RESULTS at [[Template:Wikidata/doc]], replace all the contents of the 'Examples' section with: {{subst:Template:Wikidata/doc/examples}}
(This makes the example results static for performance reasons.)

Changes to examples and additions of new examples should be made at [[Template:Wikidata/doc/examples]] after which the contents of the 'Examples' section at [[Template:Wikidata/doc]] should be substituted as described above.

The examples section is a bit bloated, though... For a bit of convenience, the following table row can be used as a basic template for any new example (note the 'xxx' that need to be replaced):

|-
| style="color:#777;font-size:small;" | Pxxx = "{{{{{|safesubst:}}}#invoke:wd|label|Pxxx}}"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|xxx}}]
| {{tnull|{{{{{|safesubst:}}}(((}}prename|{{{{{|safesubst:}}})))}}{{lcfirst:{{BASEPAGENAME}}}}|property|Pxxx|{{{{{|safesubst:}}}(((}}extraparams|{{{{{|safesubst:}}})))}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:{{{{{|safesubst:}}}#invoke:wd|property|Pxxx}}
| Description...

--&gt;
{| class="wikitable"
|-
! Parameters and output types
! Example
! style="width:20%"|Description
|-
| style="color:#777;font-size:small;" | [[d:Q55|Q55]] = "Netherlands", [[d:Property:P395|P395]] = "licence plate code"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|string}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|Q55|P395|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:NL
| Gets a literal string value.
|-
| style="color:#777;font-size:small;" | P395 = "licence plate code"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|string}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|P395|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:NL
| If the {{lcfirst:{{NAMESPACE}}}} is transcluded on the [[Netherlands]] page (which is linked to Q55), then the &lt;code&gt;Q55&lt;/code&gt; can be omitted.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P395 = "NL"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|string}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''eid{{=}}Q55'''|P395|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:NL
| An entity-ID can also be given using the &lt;code&gt;eid=&lt;/code&gt; argument.
|-
| style="color:#777;font-size:small;" | P395 = "NL"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|string}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''page{{=}}Netherlands'''|P395|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:NL
| A page title can be given instead of an entity-ID using the &lt;code&gt;page=&lt;/code&gt; argument.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P395 = "licence plate code"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|string}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''edit'''|Q55|P395|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:NL&amp;nbsp;[[File:OOjs UI icon edit-ltr-progressive.svg|frameless|text-top|10px|alt=Edit this on Wikidata|link=https://www.wikidata.org/wiki/Q55?uselang=en#P395|Edit this on Wikidata]]
| Adds a clickable icon that may be used to edit the returned value on Wikidata.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P395 = "licence plate code"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|string}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''edit@end'''|Q55|P395|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:NL&lt;span style="float:right"&gt;[[File:OOjs UI icon edit-ltr-progressive.svg|frameless|text-top|10px|alt=Edit this on Wikidata|link=https://www.wikidata.org/wiki/Q55?uselang=en#P395|Edit this on Wikidata]]&lt;/span&gt;
| Places the edit icon at the end of the line.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P1082|P1082]] = "population"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''property'''|'''normal+'''|Q55|P1082|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:17,590,672
| Gets a single property value from claims with a 'normal' rank or higher.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''properties'''|normal+|Q55|P1082|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:17,590,672, 10,026,773, 16,779,575, 16,829,289, 17,000,000, 17,081,507, 17,181,084, 17,282,163, 17,407,585
| Gets multiple property values from claims with a 'normal' rank or higher.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population", [[d:Property:P585|P585]] = "point in time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|'''qualifier'''|normal+|Q55|P1082|'''P585'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:17,590,672 &lt;span style="font-size:85%"&gt;(1 January 2022)&lt;/span&gt;, 10,026,773 &lt;span style="font-size:85%"&gt;(1950)&lt;/span&gt;, 16,779,575 &lt;span style="font-size:85%"&gt;(2013)&lt;/span&gt;, 16,829,289 &lt;span style="font-size:85%"&gt;(26 August 2014)&lt;/span&gt;, 17,000,000 &lt;span style="font-size:85%"&gt;(21 March 2016)&lt;/span&gt;, 17,081,507 &lt;span style="font-size:85%"&gt;(1 January 2017)&lt;/span&gt;, 17,181,084 &lt;span style="font-size:85%"&gt;(1 January 2018)&lt;/span&gt;, 17,282,163 &lt;span style="font-size:85%"&gt;(1 January 2019)&lt;/span&gt;, 17,407,585 &lt;span style="font-size:85%"&gt;(1 January 2020)&lt;/span&gt;
| Gets a single qualifier value for each claim, additional to the property value.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population", P585 = "point in time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|time}}], [{{smallcaps|reference}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifier|'''references'''|normal+|Q55|P1082|P585|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:17,590,672 &lt;span style="font-size:85%"&gt;(1 January 2022)&lt;/span&gt;,&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt; 10,026,773 &lt;span style="font-size:85%"&gt;(1950)&lt;/span&gt;,&lt;ref name="wikidata-cb4c9d92a7876cfdfafdaf4b92634cba9063dac1-v5"&gt;{{Cite web|publisher=Statistics Netherlands|title=CBS StatLine - Bevolking; kerncijfers|access-date=22 August 2015|url=http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T|archive-date=27 August 2015|archive-url=https://web.archive.org/web/20150827042738/http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T}}&lt;/ref&gt; 16,779,575 &lt;span style="font-size:85%"&gt;(2013)&lt;/span&gt;,&lt;ref name="wikidata-cb4c9d92a7876cfdfafdaf4b92634cba9063dac1-v5"&gt;{{Cite web|publisher=Statistics Netherlands|title=CBS StatLine - Bevolking; kerncijfers|access-date=22 August 2015|url=http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T|archive-date=27 August 2015|archive-url=https://web.archive.org/web/20150827042738/http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T}}&lt;/ref&gt; 16,829,289 &lt;span style="font-size:85%"&gt;(26 August 2014)&lt;/span&gt;,&lt;ref name="wikidata-475c2999c451e2e418b275ef9b087583a2db7228-v5"&gt;{{Cite web|title=CBS StatLine - Bevolking; kerncijfers|access-date=26 August 2014|url=http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;LA=NL|archive-url=https://web.archive.org/web/20140903082344/http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;LA=NL|archive-date=3 September 2014}}&lt;/ref&gt; 17,000,000 &lt;span style="font-size:85%"&gt;(21 March 2016)&lt;/span&gt;,&lt;ref name="wikidata-08fbc9797078849d8dc7b4754ad2109020d16f96-v5"&gt;{{Cite web|date=21 March 2016|url=http://www.cbs.nl/nl-NL/menu/themas/bevolking/publicaties/artikelen/archief/2016/nederland-telt-17-miljoen-inwoners.htm|title=Nederland telt 17 miljoen inwoners}}&lt;/ref&gt; 17,081,507 &lt;span style="font-size:85%"&gt;(1 January 2017)&lt;/span&gt;,&lt;ref name="wikidata-4f58fc69480f96aaec74e771792854a11428895e-v5"&gt;{{Cite web|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049|title=Bevolking; kerncijfers, 1950-2022|access-date=18 March 2023}}&lt;/ref&gt; 17,181,084 &lt;span style="font-size:85%"&gt;(1 January 2018)&lt;/span&gt;,&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt; 17,282,163 &lt;span style="font-size:85%"&gt;(1 January 2019)&lt;/span&gt;,&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt; 17,407,585 &lt;span style="font-size:85%"&gt;(1 January 2020)&lt;/span&gt;&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt;
| Gets references for each claim.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|reference}}]
| &lt;code&gt;A total of {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|references|Q55|P1082|{{{extraparams|}}}}} people live in the Netherlands.&lt;/code&gt;&lt;br /&gt;
:↓&lt;br /&gt;
:A total of 17,590,672&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt; people live in the Netherlands.
| Gets a property with its references.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|reference}}]
| &lt;code&gt;The Netherlands has a population of {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|references|Q55|P1082|'''punc{{=}}.'''|{{{extraparams|}}}}}&lt;/code&gt;
:↓&lt;br /&gt;
:The Netherlands has a population of 17,590,672.&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt;
| Adds a punctuation mark at the end of the output, in front of the references.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population", P585 = "point in time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|time}}], [{{smallcaps|reference}}]
| &lt;code&gt;'''&lt;nowiki&gt;&lt;ul&gt;&lt;/nowiki&gt;'''{{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifier|references|normal+|Q55|P1082|P585|'''&lt;nowiki&gt;format=&lt;li&gt;%p[%r][&lt;ul&gt;&lt;li&gt;%q&lt;/li&gt;&lt;/ul&gt;]&lt;/li&gt;&lt;/nowiki&gt;'''|{{{extraparams|}}}}}'''&lt;nowiki&gt;&lt;/ul&gt;&lt;/nowiki&gt;'''&lt;/code&gt;&lt;br /&gt;
:↓&lt;br /&gt;
&lt;ul&gt;&lt;li&gt;17,590,672&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;1 January 2022&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;10,026,773&lt;ref name="wikidata-cb4c9d92a7876cfdfafdaf4b92634cba9063dac1-v5"&gt;{{Cite web|publisher=Statistics Netherlands|title=CBS StatLine - Bevolking; kerncijfers|access-date=22 August 2015|url=http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T|archive-date=27 August 2015|archive-url=https://web.archive.org/web/20150827042738/http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;1950&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;16,779,575&lt;ref name="wikidata-cb4c9d92a7876cfdfafdaf4b92634cba9063dac1-v5"&gt;{{Cite web|publisher=Statistics Netherlands|title=CBS StatLine - Bevolking; kerncijfers|access-date=22 August 2015|url=http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T|archive-date=27 August 2015|archive-url=https://web.archive.org/web/20150827042738/http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;2013&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;16,829,289&lt;ref name="wikidata-475c2999c451e2e418b275ef9b087583a2db7228-v5"&gt;{{Cite web|title=CBS StatLine - Bevolking; kerncijfers|access-date=26 August 2014|url=http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;LA=NL|archive-url=https://web.archive.org/web/20140903082344/http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;LA=NL|archive-date=3 September 2014}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;26 August 2014&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;17,000,000&lt;ref name="wikidata-08fbc9797078849d8dc7b4754ad2109020d16f96-v5"&gt;{{Cite web|date=21 March 2016|url=http://www.cbs.nl/nl-NL/menu/themas/bevolking/publicaties/artikelen/archief/2016/nederland-telt-17-miljoen-inwoners.htm|title=Nederland telt 17 miljoen inwoners}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;21 March 2016&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;17,081,507&lt;ref name="wikidata-4f58fc69480f96aaec74e771792854a11428895e-v5"&gt;{{Cite web|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049|title=Bevolking; kerncijfers, 1950-2022|access-date=18 March 2023}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;1 January 2017&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;17,181,084&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;1 January 2018&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;17,282,163&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;1 January 2019&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;17,407,585&lt;ref name="wikidata-3abcb661cd2d0629bbc49088fa86f8b016fa3525-v5"&gt;{{Cite web|title=Bevolking; kerncijfers, 1950-2022|url=https://opendata.cbs.nl/statline/#/CBS/nl/dataset/37296ned/table?ts=1560596956049}}&lt;/ref&gt;&lt;ul&gt;&lt;li&gt;1 January 2020&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
| Returns the output in a custom format.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population", P585 = "point in time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''qualifier'''|normal+|Q55|P1082|P585|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:1 January 2022; 1950; 2013; 26 August 2014; 21 March 2016; 1 January 2017; 1 January 2018; 1 January 2019; 1 January 2020
| Gets a single qualifier per claim, by default for multiple matching claims.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population", P585 = "point in time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|qualifier|normal+|'''single'''|Q55|P1082|P585|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:1 January 2022
| To get a single qualifier for only a single claim, give the &lt;code&gt;single&lt;/code&gt; flag too so that only a single claim will be accessed.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population", P585 = "point in time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|qualifier|Q55|P1082|'''10026773'''|P585|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:1950
| Gets a qualifier from claims for which the (raw) property value matches a given literal value.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population", P585 = "point in time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|qualifier|'''mdy'''|Q55|P1082|10026773|P585|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:1950
| Gets dates in month-day-year order.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population", P585 = "point in time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|qualifier|'''raw'''|Q55|P1082|10026773|P585|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:1950
| Gets a raw date value.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|reference}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''references'''|Q55|P1082|'''10026773'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:&lt;ref name="wikidata-cb4c9d92a7876cfdfafdaf4b92634cba9063dac1-v5"&gt;{{Cite web|publisher=Statistics Netherlands|title=CBS StatLine - Bevolking; kerncijfers|access-date=22 August 2015|url=http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T|archive-date=27 August 2015|archive-url=https://web.archive.org/web/20150827042738/http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T}}&lt;/ref&gt;
| Gets the references from a particular claim.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1082 = "population"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|reference}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''references'''|'''raw'''|Q55|P1082|'''10026773'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:{{Cite web|publisher=Statistics Netherlands|title=CBS StatLine - Bevolking; kerncijfers|access-date=22 August 2015|url=http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T|archive-date=27 August 2015|archive-url=https://web.archive.org/web/20150827042738/http://statline.cbs.nl/StatWeb/publication/?VW=T&amp;DM=SLNL&amp;PA=37296ned&amp;D1=a&amp;D2=0,10,20,30,40,50,60,(l-1),l&amp;HD=130605-0924&amp;HDR=G1&amp;STB=T}}
| Gets references from a particular claim in their raw form.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P1081|P1081]] = "Human Development Index"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|reference}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|'''references'''|normal+|Q55|P1081|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:0.931,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.787, 0.799, 0.829,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt;&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.861,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.877,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.891,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.909,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.919,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.920,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.920,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.922,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.834,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.835,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.839,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.864,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.866,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.865,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.867,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.870,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.876,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.879,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.878,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.883,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.886,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.897,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.904,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.906,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.906,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.910,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.921,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.921,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.923,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.924,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.926,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.928&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt;
| Gets properties from each claim with any references they have.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1081 = "Human Development Index"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|reference}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|references|normal+|'''sourced'''|Q55|P1081|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:0.931,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.829,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt;&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.861,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.877,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.891,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.909,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.919,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.920,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.920,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.922,&lt;ref name="wikidata-9775e828e0f16e6a1b32ff4b6293321469548907-v5"&gt;{{Cite web|archive-url=https://web.archive.org/web/20170202193023/http://hdr.undp.org/en/countries/profiles/NLD|url=http://hdr.undp.org/en/countries/profiles/NLD|archive-date=2 February 2017|title=Netherlands}}&lt;/ref&gt; 0.834,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.835,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.839,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.864,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.866,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.865,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.867,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.870,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.876,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.879,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.878,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.883,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.886,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.897,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.904,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.906,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.906,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.910,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.921,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.921,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.923,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.924,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.926,&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt; 0.928&lt;ref name="wikidata-f5c4249c74a1deaf99aa1ce9def008283983d0a1-v5"&gt;{{Cite web|title=Human Development Data (1990-2017)|website=[[Human Development Report]]|url=http://hdr.undp.org/en/data|archive-date=30 December 2018|archive-url=https://web.archive.org/web/20181230181123/http://hdr.undp.org/en/data}}&lt;/ref&gt;
| Only gets properties from claims that have at least one reference.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P2855|P2855]] = "VAT rate", [[d:Property:P518|P518]] = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''qualifier'''|Q55|P2855|P518|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:food
| Gets a single qualifier value (for each matching claim).
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P2855 = "VAT rate", P518 = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''qualifiers'''|Q55|P2855|P518|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:food, medication, assistive technology, magazine, book, art, antique, hairdresser, hotel, campsite, recreation, sport, water
| Gets multiple qualifier values (for each matching claim).
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P2855 = "VAT rate", P518 = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''properties'''|qualifiers|Q55|P2855|P518|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:21%, 6% &lt;span style="font-size:85%"&gt;(food, medication, assistive technology, magazine, book, art, antique, hairdresser, hotel, campsite, recreation, sport, water)&lt;/span&gt;
| Gets multiple property values along with multiple qualifier values.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P2855 = "VAT rate", P518 = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}], [{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifiers|Q55|P2855|P518|'''sep{{=}}_+_'''|'''sep%s{{=}}'''|'''sep%q{{=}}_/_'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:21% + 6% &lt;span style="font-size:85%"&gt;(food / medication / assistive technology / magazine / book / art / antique / hairdresser / hotel / campsite / recreation / sport / water)&lt;/span&gt;
| Returns the output with custom separators.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P35|P35]] = "head of state", [[d:Property:P580|P580]] = "start time", [[d:Property:P582|P582]] = "end time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}], [{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|'''qualifier'''|'''qualifier'''|normal+|Q55|P35|'''P580'''|'''P582'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Willem-Alexander of the Netherlands &lt;span style="font-size:85%"&gt;(30 April 2013)&lt;/span&gt;, Beatrix of the Netherlands &lt;span style="font-size:85%"&gt;(30 April 1980; 30 April 2013)&lt;/span&gt;, Juliana of the Netherlands &lt;span style="font-size:85%"&gt;(4 September 1948; 30 April 1980)&lt;/span&gt;, Wilhelmina of the Netherlands &lt;span style="font-size:85%"&gt;(23 November 1890; 4 September 1948)&lt;/span&gt;, Willem III of the Netherlands &lt;span style="font-size:85%"&gt;(17 March 1849; 23 November 1890)&lt;/span&gt;, Willem II of the Netherlands &lt;span style="font-size:85%"&gt;(7 October 1840; 17 March 1849)&lt;/span&gt;, William I of the Netherlands &lt;span style="font-size:85%"&gt;(16 March 1815; 7 October 1840)&lt;/span&gt;
| Gets two different qualifier values for each claim.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P35 = "head of state", P580 = "start time", P582 = "end time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}], [{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifier|qualifier|normal+|Q55|P35|P580|P582|'''sep%q{{=}}_–_'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Willem-Alexander of the Netherlands &lt;span style="font-size:85%"&gt;(30 April 2013)&lt;/span&gt;, Beatrix of the Netherlands &lt;span style="font-size:85%"&gt;(30 April 1980 – 30 April 2013)&lt;/span&gt;, Juliana of the Netherlands &lt;span style="font-size:85%"&gt;(4 September 1948 – 30 April 1980)&lt;/span&gt;, Wilhelmina of the Netherlands &lt;span style="font-size:85%"&gt;(23 November 1890 – 4 September 1948)&lt;/span&gt;, Willem III of the Netherlands &lt;span style="font-size:85%"&gt;(17 March 1849 – 23 November 1890)&lt;/span&gt;, Willem II of the Netherlands &lt;span style="font-size:85%"&gt;(7 October 1840 – 17 March 1849)&lt;/span&gt;, William I of the Netherlands &lt;span style="font-size:85%"&gt;(16 March 1815 – 7 October 1840)&lt;/span&gt;
| Returns the output with a custom separator.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P35 = "head of state", P580 = "start time", P582 = "end time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}], [{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifier|qualifier|normal+|Q55|P35|P580|P582|'''&lt;nowiki&gt;format=%p[ &lt;span style="font-size:85\%"&gt;(%q1[ – %q2])&lt;/span&gt;][%s][%r]&lt;/nowiki&gt;'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Willem-Alexander of the Netherlands &lt;span style="font-size:85%"&gt;(30 April 2013)&lt;/span&gt;, Beatrix of the Netherlands &lt;span style="font-size:85%"&gt;(30 April 1980 – 30 April 2013)&lt;/span&gt;, Juliana of the Netherlands &lt;span style="font-size:85%"&gt;(4 September 1948 – 30 April 1980)&lt;/span&gt;, Wilhelmina of the Netherlands &lt;span style="font-size:85%"&gt;(23 November 1890 – 4 September 1948)&lt;/span&gt;, Willem III of the Netherlands &lt;span style="font-size:85%"&gt;(17 March 1849 – 23 November 1890)&lt;/span&gt;, Willem II of the Netherlands &lt;span style="font-size:85%"&gt;(7 October 1840 – 17 March 1849)&lt;/span&gt;, William I of the Netherlands &lt;span style="font-size:85%"&gt;(16 March 1815 – 7 October 1840)&lt;/span&gt;
| Returns the output in a custom format instead of with a custom separator.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P35 = "head of state", P580 = "start time", P582 = "end time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}], [{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifier|qualifier|normal+|Q55|P35|P580|P582|&lt;nowiki&gt;format=%p[ &lt;span style="font-size:85\%"&gt;(&lt;/nowiki&gt;'''&lt;nowiki&gt;[&lt;![]--%q2]since [%q2--[]&gt;]&lt;/nowiki&gt;'''&lt;nowiki&gt;%q1[ – %q2])&lt;/span&gt;][%s][%r]&lt;/nowiki&gt;|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Willem-Alexander of the Netherlands &lt;span style="font-size:85%"&gt;(since 30 April 2013)&lt;/span&gt;, Beatrix of the Netherlands &lt;span style="font-size:85%"&gt;(&lt;!--30 April 2013since 30 April 2013--&gt;30 April 1980 – 30 April 2013)&lt;/span&gt;, Juliana of the Netherlands &lt;span style="font-size:85%"&gt;(&lt;!--30 April 1980since 30 April 1980--&gt;4 September 1948 – 30 April 1980)&lt;/span&gt;, Wilhelmina of the Netherlands &lt;span style="font-size:85%"&gt;(&lt;!--4 September 1948since 4 September 1948--&gt;23 November 1890 – 4 September 1948)&lt;/span&gt;, Willem III of the Netherlands &lt;span style="font-size:85%"&gt;(&lt;!--23 November 1890since 23 November 1890--&gt;17 March 1849 – 23 November 1890)&lt;/span&gt;, Willem II of the Netherlands &lt;span style="font-size:85%"&gt;(&lt;!--17 March 1849since 17 March 1849--&gt;7 October 1840 – 17 March 1849)&lt;/span&gt;, William I of the Netherlands &lt;span style="font-size:85%"&gt;(&lt;!--7 October 1840since 7 October 1840--&gt;16 March 1815 – 7 October 1840)&lt;/span&gt;
| To add text only when a certain value is not present, like adding the word ''since'' if there is no end time, wrap it in between two optional blocks containing HTML comment tags and the relevant parameter (this also prevents the text from being added to the page source).
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P35 = "head of state", [[d:Q29574|Q29574]] = "Beatrix of the Netherlands", P580 = "start time", P582 = "end time"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}], [{{smallcaps|time}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifier|'''raw'''|qualifier|normal+|Q55|P35|'''Q29574'''|P580|P582|&lt;nowiki&gt;format=%p[ &lt;span style="font-size:85\%"&gt;(%q1[ – %q2])&lt;/span&gt;][%s][%r]&lt;/nowiki&gt;|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Beatrix of the Netherlands &lt;span style="font-size:85%"&gt;(1980-04-30 – 30 April 2013)&lt;/span&gt;
| Gets a property with qualifiers from claims for which the property matches a given Q-identifier, with one of the qualifier values in its raw form.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P38|P38]] = "currency", P518 = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifiers|normal+|'''current'''|Q55|P38|P518|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:euro &lt;span style="font-size:85%"&gt;(European Netherlands)&lt;/span&gt;, United States dollar &lt;span style="font-size:85%"&gt;(Caribbean Netherlands)&lt;/span&gt;
| Gets claims that are currently valid.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P38 = currency", P518 = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|'''linked'''|qualifiers|normal+|current|Q55|P38|P518|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[Euro|euro]] &lt;span style="font-size:85%"&gt;(European Netherlands)&lt;/span&gt;, [[United States dollar]] &lt;span style="font-size:85%"&gt;(Caribbean Netherlands)&lt;/span&gt;
| Gets claims with linked property values.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P38 = currency", P518 = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifiers|'''linked'''|normal+|current|Q55|P38|P518|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:euro &lt;span style="font-size:85%"&gt;(European Netherlands)&lt;/span&gt;, United States dollar &lt;span style="font-size:85%"&gt;([[Caribbean Netherlands]])&lt;/span&gt;
| Gets claims with linked qualifier values.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P38 = currency", P518 = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|'''linked'''|'''short'''|qualifiers|'''linked'''|normal+|current|Q55|P38|P518|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[Euro|euro]] &lt;span style="font-size:85%"&gt;(European Netherlands)&lt;/span&gt;, [[United States dollar|US dollar]] &lt;span style="font-size:85%"&gt;([[Caribbean Netherlands]])&lt;/span&gt;
| Gets claims with linked property and qualifier values, with short property values wherever available.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P38 = currency", [[d:Q4917|Q4917]] = "United States dollar", P518 = "applies to part"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|qualifiers|normal+|current|Q55|P38|'''Q4917'''|P518|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Caribbean Netherlands
| Gets qualifiers from claims for which the (raw) property value matches a given Q-identifier.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P38 = currency", P518 = "applies to part", [[d:Q27561|Q27561]] = "Caribbean Netherlands"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|normal+|current|Q55|P38|'''P518{{=}}Q27561'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:United States dollar
| Gets properties from claims for which a (raw) qualifier value matches a given Q-identifier.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P38 = currency"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|normal+|'''former'''|Q55|P38|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Dutch guilder
| Gets claims that were valid in the past.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P38 = currency"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|'''raw'''|normal+|former|Q55|P38|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Q788472
| Gets raw property values.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P38 = currency"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|raw|'''linked'''|normal+|former|Q55|P38|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[d:Special:EntityPage/Q788472|Q788472]]
| Gets raw property values that are linked to Wikidata.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P1549|P1549]] = "demonym"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|monolingual text}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|Q55|P1549|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Dutch
| Gets a monolingual text value in the current wiki's language.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P1549 = "demonym", [[d:Property:P407|P407]] = "language of work or name", [[d:Q36846|Q36846]] = "Toki Pona"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|monolingual text}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''multilanguage'''|Q55|P1549|P407{{=}}Q36846|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:
| Gets a monolingual text value in any available language.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P2884|P2884]] = "mains voltage"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|Q55|P2884|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:230 volt
| Gets a quantity value with its associated unit of measurement.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P2884 = "mains voltage"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''linked'''|Q55|P2884|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:230 [[Volt|volt]]
| Gets a quantity value with a linked unit of measurement.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P2884 = "mains voltage"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''raw'''|Q55|P2884|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:230
| Gets a raw quantity value.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P2884 = "mains voltage"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''unit'''|Q55|P2884|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:volt
| Gets only the unit of measurement.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P2884 = "mains voltage"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|quantity}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|unit|'''raw'''|Q55|P2884|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Q25250
| Gets the raw unit of measurement.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P625|P625]] = "coordinate location"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|globe coordinate}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|Q55|P625|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:52°19'N, 5°33'E
| Gets a globe coordinate value.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P625 = "coordinate location"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|globe coordinate}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''linked'''|Q55|P625|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[https://tools.wmflabs.org/geohack/geohack.php?language=en&amp;params=52_19_N_5_33_E_globe:earth 52°19'N, 5°33'E]
| Gets a linked globe coordinate value.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P625 = "coordinate location"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|globe coordinate}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''raw'''|Q55|P625|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:52/19/N/5/33/E
| Gets a raw globe coordinate value.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P625 = "coordinate location"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|globe coordinate}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|Q55|'''coord'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:52°19'N, 5°33'E
| A property alias can be used instead of the P-identifier.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", [[d:Property:P41|P41]] = "flag image"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|commons media}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''linked'''|Q55|P41|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[c:File:Flag of the Netherlands.svg|Flag of the Netherlands.svg]]
| Gets a media file name and links to it on Commons.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P41 = "flag image"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|commons media}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''raw'''|Q55|P41|'''&lt;nowiki&gt;format=\[\[File:%p {{!}} thumb {{!}} left\]\]&lt;/nowiki&gt;'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[File:Flag of the Netherlands.svg{{!}} thumb {{!}} left]]
| A Commons media file can be included on the page as-is by omitting the &lt;code&gt;linked&lt;/code&gt; and &lt;code&gt;raw&lt;/code&gt; flags, but by using the &lt;code&gt;raw&lt;/code&gt; flag it can be freely formatted.

|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P41 = "flag image"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|commons media}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|raw|'''date{{=}}1700-05-06'''|Q55|P41|&lt;nowiki&gt;format=\[\[File:%p {{!}} thumb {{!}} left\]\]&lt;/nowiki&gt;|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[File:Statenvlag.svg{{!}} thumb {{!}} left]]
| To get the value of a property that was valid at a given time, the &lt;code&gt;date=&lt;/code&gt; argument can be used.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands", P41 = "flag image"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|commons media}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|raw|date{{=}}1700-05-06|'''former'''|Q55|P41|&lt;nowiki&gt;format=\[\[File:%p {{!}} thumb {{!}} left\]\]&lt;/nowiki&gt;|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[File:Prinsenvlag.svg{{!}} thumb {{!}} left]]
| The time constraint flags work relatively to the date value given for the &lt;code&gt;date=&lt;/code&gt; argument.
|-
| style="color:#777;font-size:small;" | [[d:Q915684|Q915684]] = "Lorentz–Lorenz equation", [[d:Property:P2534|P2534]] = "defining formula"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|math}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|Q915684|P2534|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:&lt;math qid="Q915684"&gt;\frac{n^2 - 1}{n^2 + 2} = \frac{4 \pi}{3} N \alpha&lt;/math&gt;
| Gets a mathematical expression.
|-
| style="color:#777;font-size:small;" | Q915684 = "Lorentz–Lorenz equation", [[d:Property:P7235|P7235]] = "in defining formula", [[d:Property:P9758|P9758]] = "symbol represents"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}], [{{smallcaps|math}}]
| &lt;code&gt;&lt;nowiki&gt;&lt;ul&gt;&lt;/nowiki&gt;{{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|properties|qualifier|linked|Q915684|P7235|P9758|&lt;nowiki&gt;format=&lt;li&gt;%q[ (%p)]&lt;/li&gt;&lt;/nowiki&gt;|{{{extraparams|}}}}}&lt;nowiki&gt;&lt;/ul&gt;&lt;/nowiki&gt;&lt;/code&gt;&lt;br /&gt;
:↓&lt;br /&gt;
:&lt;ul&gt;&lt;li&gt;[[Refractive index|refractive index]] (&lt;math&gt;n&lt;/math&gt;)&lt;/li&gt; &lt;li&gt;[[Polarizability|polarizability]] (&lt;math&gt;\alpha&lt;/math&gt;)&lt;/li&gt; &lt;li&gt;[[Number density|volumetric number density]] (&lt;math&gt;N&lt;/math&gt;)&lt;/li&gt; &lt;li&gt;[[Pi|pi]] (&lt;math&gt;\pi&lt;/math&gt;)&lt;/li&gt;&lt;/ul&gt;
| Mathematical expressions can be combined with regular text as usual.
|-
| style="color:#777;font-size:small;" | [[d:Q6256|Q6256]] = "country", [[d:Property:P3896|P3896]] = "geoshape"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|geographic shape}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|'''linked'''|Q6256|P3896|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[c:Data:Naturalearthdata.com/admin-0-countries-no-antarctica.map|Data:Naturalearthdata.com/admin-0-countries-no-antarctica.map]]
| Gets a geographic shape data file name and links to it on Commons.
|-
| style="color:#777;font-size:small;" | Q4917 = "United States dollar"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''label'''|Q4917|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:United States dollar
| Gets an item's label.
|-
| style="color:#777;font-size:small;" | Q4917 = "United States dollar"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|label|'''short'''|'''linked'''|Q4917|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[United States dollar|US dollar]]
| Gets an item's short and linked label.
|-
| style="color:#777;font-size:small;" | P38 = currency"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|label|P38|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:currency
| Gets a property's label.
|-
| style="color:#777;font-size:small;" | P38 = currency"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|label|'''linked'''|P38|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[d:Special:EntityPage/P38|currency]]
| Gets a property's label that is linked to Wikidata.
|-
| style="color:#777;font-size:small;" | [[d:Q776|Q776]] = "Utrecht"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|label|Q776|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Utrecht
| Gets an item's label.
|-
| style="color:#777;font-size:small;" | Q776 = "Utrecht"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|label|'''linked'''|Q776|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[Utrecht (province)|Utrecht]]
| Gets an item's linked label.
|-
| style="color:#777;font-size:small;" | &lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|label|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Utrecht
| If the {{lcfirst:{{NAMESPACE}}}} is transcluded on the [[Utrecht (province)]] page (which is linked to Q776), then the &lt;code&gt;Q776&lt;/code&gt; can be omitted.
|-
| style="color:#777;font-size:small;" | &lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|label|'''raw'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Q776
| If just the &lt;code&gt;label&lt;/code&gt; command with the &lt;code&gt;raw&lt;/code&gt; flag is given, then the Q-identifier of the item connected to the current page is returned.
|-
| style="color:#777;font-size:small;" | &lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity label}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|label|raw|'''linked'''|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[d:Special:EntityPage/Q776|Q776]]
| If additionally the &lt;code&gt;linked&lt;/code&gt; flag is given, then the Q-identifier of the item connected to the current page is linked to Wikidata.
|-
| style="color:#777;font-size:small;" | Q776 = "Utrecht"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|page title}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''title'''|Q776|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Utrecht (province)
| Gets the title of the page on the current wiki that is linked to the given item.
|-
| style="color:#777;font-size:small;" | Q776 = "Utrecht"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|page title}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|title|'''linked'''|Q776|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[Utrecht (province)]]
| Gets the linked title of the page on the current wiki that is linked to the given item.
|-
| style="color:#777;font-size:small;" | &lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|page title}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|title|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Utrecht (province)
| If the {{lcfirst:{{NAMESPACE}}}} is transcluded on the [[Utrecht (province)]] page (which is linked to Q776), then the &lt;code&gt;Q776&lt;/code&gt; can be omitted.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity description}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''description'''|Q55|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:country in Northwestern Europe with territories in the Caribbean
| Gets an item's description.
|-
| style="color:#777;font-size:small;" | &lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity description}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|description|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:country in Northwestern Europe with territories in the Caribbean
| If the {{lcfirst:{{NAMESPACE}}}} is transcluded on the [[Netherlands]] page (which is linked to Q55), then the &lt;code&gt;Q55&lt;/code&gt; can be omitted.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity alias}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''alias'''|Q55|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Holland
| Gets one of an item's aliases.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity alias}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''aliases'''|Q55|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Holland, the Netherlands, NL, NED, Nederland, nl, 🇳🇱, Netherlands (after 1945)
| Gets all of an item's aliases.
|-
| style="color:#777;font-size:small;" | Q55 = "Netherlands"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity alias}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|alias|'''linked'''|Q55|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:[[Netherlands|Holland]]
| Gets a linked alias from an item.
|-
| style="color:#777;font-size:small;" | &lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|entity alias}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|alias|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Holland
| If the {{lcfirst:{{NAMESPACE}}}} is transcluded on the [[Netherlands]] page (which is linked to Q55), then the &lt;code&gt;Q55&lt;/code&gt; can be omitted.
|-
| style="color:#777;font-size:small;" | [[d:Q2|Q2]] = "Earth"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|page badge}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|'''badges'''|Q2|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:featured article badge
| Gets the badges for the page on the current wiki that is linked to the given item.
|-
| style="color:#777;font-size:small;" | Q2 = "Earth"&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|page badge}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|badges|'''raw'''|Q2|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:Q17437796
| Gets the raw badges for the page on the current wiki that is linked to the given item.
|-
| style="color:#777;font-size:small;" | &lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|page badge}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|badges|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:featured article badge
| If the {{lcfirst:{{NAMESPACE}}}} is transcluded on the [[Earth]] page (which is linked to Q2), then the &lt;code&gt;Q2&lt;/code&gt; can be omitted.
|-
| style="color:#777;font-size:small;" | [[d:Q28865|Q28865]] = "Python", [[d:P548|P548]] = "version type", [[d:P348|P348]] = "software version identifier",&lt;br /&gt;
:↓&lt;br /&gt;
[{{smallcaps|version}}], [{{smallcaps|reference}}]
| {{tnull|{{{prename|}}}{{lcfirst:{{BASEPAGENAME}}}}|property|reference|edit|Q28865|'''P548{{=}}Q2804309'''|P348|{{{extraparams|}}}}}&lt;br /&gt;
:↓&lt;br /&gt;
:3.11.3&lt;ref name="wikidata-47b0d8952e763dae8105c1e70220fc5d387af155-v5"&gt;{{Cite web|date=5 April 2023|url=https://blog.python.org/2023/04/its-time-for-another-set-of-python.html|title=It's time for another set of Python releases! Python 3.11.3, 3.10.11 and 3.12 alpha 7 are now available.|access-date=6 April 2023}}&lt;/ref&gt;&amp;nbsp;[[File:OOjs UI icon edit-ltr-progressive.svg|frameless|text-top|10px|alt=Edit this on Wikidata|link=https://www.wikidata.org/wiki/Q28865?uselang=en#P348|Edit this on Wikidata]]
| Get [[Python (programming language)|Python]]'s latest stable release version with its references. You may want to use '''P548{{=}}Q2122918''' to get the latest preview release version.
|}

=== Example references ===
{{Reflist}}

== TemplateData ==
&lt;templatedata&gt;
{
	"params": {},
	"description": "This template fetches data from the centralized knowledge base Wikidata. To edit the data, click on \"Wikidata item\" in the left sidebar."
}
&lt;/templatedata&gt;

== See also ==
{{module other|*{{tl|Wikidata}}, a user-friendly wrapper template for this module.
*{{tl|WikidataOI}}, a wrapper template for this module that adds an opt-in toggle.|{{{seealso|}}}
*{{tl|Sitelink}}, a template that can access other Wikipedia page titles
*[[Module:Wd]], the source module that is called by this template
*{{tl|Wdib}}, a wrapper template for the getValue call in [[Module:WikidataIB]]
*{{tl|Wikidata entity link}} or redirect {{tl|Q}}), to add a Wikidata entity link to a Wikipedia page
*{{tl|Wikidata property link}} or redirect {{tl|Property}}, to add a Wikidata property link to a Wikipedia page
*{{tl|Wikidata property}}, to add a Wikidata property {{tl|side box}} to a Wikipedia page or template documentation
*{{tl|Uses Wikidata}}, to add a Wikidata property box to the documentation of a template or module
*{{tl|Tracks Wikidata}}, to add a Wikidata property box to the documentation of a template, module, or category
*{{tl|Wikidata editnotice}}, an editnotice for articles that make extensive use of this template
}}
*{{tl|Pageid to title}}, to get a page title using its local page id, rather than Wikidata

&lt;includeonly&gt;&lt;!-- /doc page is transcluded on these two root pages: --&gt;{{#switch:{{NAMESPACE}}:{{PAGENAME}}
|Module:Wd = [[Category:Wikidata modules]][[Category:Modules using data from Wikidata]]
|Template:WikidataOI |Template:Wikidata = [[Category:Wikidata templates]]
}}&lt;/includeonly&gt;</text>
      <sha1>1zfr3qni6ovld66kffh5dns8845glrp</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Plainlist/styles.css</title>
    <ns>10</ns>
    <id>103</id>
    <revision>
      <id>194</id>
      <parentid>193</parentid>
      <timestamp>2025-07-09T04:31:23Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>193</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="218" sha1="9iguthb0t8w7c89r3am2dbgv55d4w1c" xml:space="preserve">/* {{pp-template|small=yes}} */
.plainlist ol,
.plainlist ul {
	line-height: inherit;
	list-style: none;
	margin: 0;
	padding: 0; /* Reset Minerva default */
}

.plainlist ol li,
.plainlist ul li {
	margin-bottom: 0;
}</text>
      <sha1>9iguthb0t8w7c89r3am2dbgv55d4w1c</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Shortcut/styles.css</title>
    <ns>828</ns>
    <id>104</id>
    <revision>
      <id>196</id>
      <parentid>195</parentid>
      <timestamp>2025-07-09T04:31:23Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>195</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="767" sha1="g02k2qd3gnpj5139dyiy8eo6xl650p8" xml:space="preserve">/* {{pp-template}} */
.module-shortcutboxplain {
	float: right;
	margin: 0 0 0 1em;
	border: 1px solid var(--border-color-base, #a2a9b1);
	background-color: var(--background-color-base, #fff);
	padding: 0.3em 0.6em 0.2em 0.6em;
	text-align: center;
	font-size: 85%;
}

.module-shortcutboxleft {
	float: left;
	margin: 0 1em 0 0;
}

.module-shortcutlist {
	display: inline-block;
	border-bottom: 1px solid var(--border-color-base, #a2a9b1);
	margin-bottom: 0.2em;
}

.module-shortcutboxplain ul {
	font-weight: bold;
}

.module-shortcutanchordiv {
	position: relative;
	top: -3em;
}

li .module-shortcutanchordiv {
	float: right; /* IE/Edge in list items */
}

.mbox-imageright .module-shortcutboxplain {
	padding: 0.4em 1em 0.4em 1em;
	line-height: 1.3;
	margin: 0;
}</text>
      <sha1>g02k2qd3gnpj5139dyiy8eo6xl650p8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Color/styles.css</title>
    <ns>10</ns>
    <id>105</id>
    <revision>
      <id>198</id>
      <parentid>197</parentid>
      <timestamp>2025-07-09T04:31:23Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>197</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="655" sha1="dl8bwbkew3oeno6jka06uesbas1lvul" xml:space="preserve">/* {{pp-template}} */
/* [[phab:T360683]]: This stylesheet removes the function of this template in
 * dark mode
 */

@media screen {
    html.skin-theme-clientpref-night div:not(.notheme) &gt; .tmp-color,
	html.skin-theme-clientpref-night p &gt; .tmp-color,
	html.skin-theme-clientpref-night table:not(.notheme) .tmp-color {
	   color: inherit !important;
	}
}

@media screen and ( prefers-color-scheme: dark) {
    /* automatic mode */
    html.skin-theme-clientpref-os div:not(.notheme) &gt; .tmp-color,
    html.skin-theme-clientpref-os p &gt; .tmp-color,
    html.skin-theme-clientpref-os table:not(.notheme) .tmp-color {
      color: inherit !important;
    }
}</text>
      <sha1>dl8bwbkew3oeno6jka06uesbas1lvul</sha1>
    </revision>
  </page>
  <page>
    <title>The Legend of Zelda: Skyward Sword</title>
    <ns>0</ns>
    <id>106</id>
    <revision>
      <id>463</id>
      <parentid>200</parentid>
      <timestamp>2025-07-09T04:37:16Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <comment>Replaced content with "{{Infobox video game | title = The Legend of Zelda: Skyward Sword | image = Legend of Zelda Skyward Sword boxart.png | alt = Packaging artwork of the ''Legend of Zelda'' 25th anniversary special edition, released worldwide | caption = European packaging artwork | developer = [[Nintendo EAD]]{{Efn|Additional development support by [[Monolith Soft]]&lt;ref name="MonolithGames"/&gt;}} | publisher = [[Nintendo]] | series = ''[[The Legend of Zelda]]'' | platforms = [[Wii]] | re..."</comment>
      <origin>463</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1127" sha1="g4t7hliqlu88pn4tdz0ervovmqat2l9" xml:space="preserve">{{Infobox video game
| title = The Legend of Zelda: Skyward Sword
| image = Legend of Zelda Skyward Sword boxart.png
| alt = Packaging artwork of the ''Legend of Zelda'' 25th anniversary special edition, released worldwide
| caption = European packaging artwork
| developer = [[Nintendo EAD]]{{Efn|Additional development support by [[Monolith Soft]]&lt;ref name="MonolithGames"/&gt;}}
| publisher = [[Nintendo]]
| series = ''[[The Legend of Zelda]]''
| platforms = [[Wii]]
| released = {{Video game release|EU|November 18, 2011|NA|November 20, 2011|JP|November 23, 2011|AU|November 24, 2011}}
| genre = [[Action-adventure game|Action-adventure]]
| modes = [[Single-player video game|Single-player]]
| director = [[Hidemaro Fujibayashi]]
| producer = [[Eiji Aonuma]]
| designer = Ryuji Kobayashi
| programmer = {{Unbulleted list|Toshio Iwawaki|Kazuaki Morita}}
| artist = Takumi Wada
| writer = {{Unbulleted list|Naoki Mori|Hidemaro Fujibayashi}}
| composer = {{Unbulleted list|Hajime Wakai|Shiho Fujii|[[Mahito Yokota]]|Takeshi Hama}}&lt;!--Lead composers only, per infobox documentation. Kondo's role is explained in prose below.--&gt;
}}</text>
      <sha1>g4t7hliqlu88pn4tdz0ervovmqat2l9</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang</title>
    <ns>828</ns>
    <id>107</id>
    <revision>
      <id>202</id>
      <parentid>201</parentid>
      <timestamp>2025-07-09T04:31:39Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>201</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="93521" sha1="ebtasdwni0hx25j8cjppzt39wan50qg" xml:space="preserve">--[=[

Lua support for the {{lang}}, {{langx}}, {{lang-??}}, and {{transliteration}} templates and replacement of various supporting templates. 

]=]

require('strict');

local getArgs = require ('Module:Arguments').getArgs;
local unicode = require ("Module:Unicode data");								-- for is_Latin() and is_rtl()
local yesno = require ('Module:Yesno');

local lang_data =  mw.loadData ('Module:Lang/data');							-- language name override and transliteration tool-tip tables
local lang_name_table = lang_data.lang_name_table;								-- language codes, names, regions, scripts, suppressed scripts
local lang_table = lang_data.lang_name_table.lang;
local lang_dep_table = lang_data.lang_name_table.lang_dep;
local script_table = lang_data.lang_name_table.script;
local region_table = lang_data.lang_name_table.region;
local variant_table = lang_data.lang_name_table.variant;
local suppressed_table = lang_data.lang_name_table.suppressed;
local override_table = lang_data.override;

local synonym_table = mw.loadData ('Module:Lang/ISO 639 synonyms');				-- ISO 639-2/639-2T code translation to 639-1 code

local cfg = mw.loadData ('Module:Lang/configuration' .. (mw.getCurrentFrame():getTitle():match ('/sandbox') or ''));	-- for internationalization

local is_latn_data = mw.loadData ('Module:Lang/data/is latn data');
local sizeof_ranges_t = is_latn_data.sizeof_ranges_t;

local namespace = mw.title.getCurrentTitle().namespace;							-- used for categorization

local content_lang = mw.language.getContentLanguage();
local this_wiki_lang_tag = content_lang.code;									-- get this wiki's language tag
local this_wiki_lang_dir = content_lang:getDir();								-- get this wiki's language direction

local initial_style_state;														-- set by lang_xx_normal() and lang_xx_italic()

local maint_cats = {};															-- maintenance categories go here
local maint_msgs = {};															-- and their messages go here


--[[--------------------------&lt; M A K E _ E R R O R _ S P A N &gt;--------------------------------------------------

]]

local function make_error_span (template, msg)
	return table.concat ({'&lt;span style="color:#d33"&gt;', cfg.misc_text_t.error, ': ', template, msg, '&lt;/span&gt;'})
end


--[[--------------------------&lt; S U B S T I T U T E &gt;----------------------------------------------------------

Substitutes $1, $2, etc in &lt;message&gt; with data from &lt;data_t&gt;. Returns plain-text substituted string when
&lt;data_t&gt; not nil; returns &lt;message&gt; else.

]]

local function substitute (message, data_t)
	return data_t and mw.message.newRawMessage (message, data_t):plain() or message;
end


--[[--------------------------&lt; M A K E _ E R R O R _ M S G &gt;--------------------------------------------------

Assembles an error message from template name, message text, help link, and error category.

]]

local function make_error_msg (msg, args_t, template)
	local category;
	local text;																	-- handle the oddity that is {{langx}}
	if cfg.templates_t.langxx == template then
		text = args_t.text or args_t[1];										-- for {{lang-xx}}
	else
		text = args_t.text or args_t[2];										-- for {{lang}}, {{langx}}, and {{transliteration}}
	end

	if cfg.templates_t.transliteration == template then
		category = cfg.make_error_msg_t.xlit_err_cat;
	else
		category = cfg.make_error_msg_t.lang_err_cat;
	end
	
	local category_link = ((0 == namespace or 10 == namespace) and not args_t.nocat) and substitute ('[[Category:$1]]', {category}) or '';
	return substitute ('[$1] &lt;span style="color:#d33"&gt;$2: &amp;#x7B;{$3}}: $4 ([[:Category:$5|$6]])&lt;/span&gt;$7',	-- &amp;#x7B; prevents template name from being treated as a template call in certain situations
		{
		text or cfg.make_error_msg_t.undefined,
		cfg.misc_text_t.error,
		template,
		msg,
		category,
		cfg.misc_text_t.help,
		category_link
		})
end
	

--[[--------------------------&lt; P A R A M E T E R _ V A L I D A T E &gt;------------------------------------------

]]

local function parameter_validate (args_t, template)
	local err_msg = cfg.parameter_validate_t.invalid_param;

	if cfg.templates_t.lang == template then									-- for {{lang}}
		for param, _ in pairs (args_t) do
			if not cfg.known_params_t.params_lang_t[param] and					-- unique {{lang}} parameters
				 not cfg.known_params_t.common_params_all_t[param] then			-- common to all
					return substitute (err_msg, {param});						-- &lt;param&gt; not found so abandon
			end
		end
	elseif cfg.templates_t.langx == template then								-- for {{langx}}
		for param, _ in pairs (args_t) do
			if not cfg.known_params_t.params_langx_t[param] and					-- unique {{langx}} parameters
				not cfg.known_params_t.params_x_t[param] and					-- common to {{langx}} and {{lang-xx}}
				not cfg.known_params_t.common_params_all_t[param] then			-- common to all
					return substitute (err_msg, {param});						-- &lt;param&gt; not found so abandon
			end
		end
	elseif cfg.templates_t.langxx == template then								-- for {{lang-xx}}
		for param, _ in pairs (args_t) do
			if not cfg.known_params_t.params_lang_xx_t[param] and				-- unique {{lang-xx}} parameters
				not cfg.known_params_t.params_x_t[param] and					-- common to {{langx}} and {{lang-xx}}
				not cfg.known_params_t.common_params_all_t[param] then			-- common to all
					return substitute (err_msg, {param});						-- &lt;param&gt; not found so abandon
			end
		end
	end		
end


--[[--------------------------&lt; I S _ S E T &gt;------------------------------------------------------------------

Returns true if argument is set; false otherwise. Argument is 'set' when it exists (not nil) or when it is not
an empty string.

]]

local function is_set (var)
	return not (var == nil or var == '');
end


--[[--------------------------&lt; I N V E R T  _ I T A L I C S &gt;-------------------------------------------------

This function attempts to invert the italic markup a args.text by adding/removing leading/trailing italic markup
in args.text.  Like |italic=unset, |italic=invert disables automatic italic markup.  Individual leading/trailing
apostrophes are converted to their HTML numeric entity equivalent so that the new italic markup doesn't become
bold markup inadvertently.

Leading and trailing wiki markup is extracted from args.text into separate table elements.  Addition, removal,
replacement of wiki markup is handled by a string.gsub() replacement table operating only on these separate elements.
In the string.gsub() matching pattern, '.*' matches empty string as well as the three expected wiki markup patterns.

This function expects that markup in args.text is complete and correct; if it is not, oddness may result.

]]

local function invert_italics (source)
	local invert_pattern_table = {												-- leading/trailing markup add/remove/replace patterns
		[""]="\'\'",															-- empty string becomes italic markup
		["\'\'"]="",															-- italic markup becomes empty string
		["\'\'\'"]="\'\'\'\'\'",												-- bold becomes bold italic
		["\'\'\'\'\'"]="\'\'\'",												-- bold italic become bold
		};
	local seg = {};

	source = source:gsub ("%f[\']\'%f[^\']", '&amp;#39;');							-- protect single quote marks from being interpreted as bold markup

	seg[1] = source:match ('^(\'\'+%f[^\']).+') or '';							-- get leading markup, if any; ignore single quote
	seg[3] = source:match ('.+(%f[\']\'\'+)$') or '';							-- get trailing markup, if any; ignore single quote

	if '' ~= seg[1] and '' ~= seg[3] then										-- extract the 'text' 
		seg[2] = source:match ('^\'\'+%f[^\'](.+)%f[\']\'\'+$')					-- from between leading and trailing markup
	elseif '' ~= seg[1] then
		seg[2] = source:match ('^\'\'+%f[^\'](.+)')								-- following leading markup
	elseif '' ~= seg[3] then
		seg[2] = source:match ('(.+)%f[\']\'\'+$')								-- preceding trailing markup
	else
		seg[2] = source															-- when there is no markup
	end

	seg[1] = invert_pattern_table[seg[1]] or seg[1];							-- replace leading markup according to pattern table
	seg[3] = invert_pattern_table[seg[3]] or seg[3];							-- replace leading markup according to pattern table

	return table.concat (seg);													-- put it all back together and done
end


--[[--------------------------&lt; V A L I D A T E _ I T A L I C &gt;------------------------------------------------

Validates |italic= or |italics= assigned values.

When |italic= is set and has an acceptable assigned value, return the matching CSS font-style property value or,
for the special case 'default', return nil.

When |italic= is not set, or has an unacceptable assigned value, return nil and a nil error message.

When both |italic= and |italics= are set, returns nil and a 'conflicting' error message.

The return value nil causes the calling lang, lang_xx, or xlit function to set args.italic according to the template's
defined default ('inherit' for {{lang}}, 'inherit' or 'italic' for {{lang-??}} depending on
the individual template's requirements, 'italic' for {{transliteration}}) or to the value appropriate to |script=, if set ({{lang}}
and {{lang-??}} only).

Accepted values and the values that this function returns are are:
	nil		-	when |italic= absent or not set; returns nil
	default	-	for completeness, should rarely if ever be used; returns nil
	yes		-	force args.text to be rendered in italic font; returns 'italic'
	no		-	force args.text to be rendered in normal font; returns 'normal'
	unset	-	disables font control so that font-style applied to text is dictated by markup inside or outside the template; returns 'inherit'
	invert	-	disables font control so that font-style applied to text is dictated by markup outside or inverted inside the template; returns 'invert'

]]

local function validate_italic (args)
	local properties = {[cfg.keywords_t.affirmative] = 'italic', [cfg.keywords_t.negative] = 'normal', [cfg.keywords_t.unset] = 'inherit', [cfg.keywords_t.invert] = 'invert', [cfg.keywords_t.default] = nil};
	
	local count = 0
	for _, arg in pairs {'italic', 'italics', 'i'} do
		if args[arg] then
			count = count + 1
		end
	end

	if count &gt; 1 then															-- return nil and an error message if more than one is set 
		return nil, cfg.validate_italic_t.multi_italic;
	end
	
	return properties[args.italic or args.italics or args.i], nil;				-- return an appropriate value and a nil error message
end


--[=[--------------------------&lt; V A L I D A T E _ C A T _ A R G S &gt;----------------------------------------------------------

Default behavior of the {{lang}} and {{lang-??}} templates is to add categorization when the templates are used in main space.
This default functionality may be suppressed by setting |nocat=yes or |cat=no.  This function selects one of these two parameters
to control categorization.

Because having two parameters with 'opposite' names and 'opposite' values is confusing, this function accepts only affirmative
values for |nocat= and only negative values for |cat=; in both cases the 'other' sense (and non-sense) is not accepted and the
parameter is treated as if it were not set in the template.

Sets args.nocat to true if categorization is to be turned off; to nil if the default behavior should apply.

Accepted values for |nocat= are the text strings:
	'yes', 'y', 'true', 't', on, '1'		-- [[Module:Yesno]] returns logical true for all of these; false or nil else
for |cat=
	'no', 'n', 'false', 'f', 'off', '0'		-- [[Module:Yesno]] returns logical false for all of these; true or nil else

]=]

local function validate_cat_args (args)
	if not (args.nocat or args.cat) then										-- both are nil, so categorize
		return;
	end
	
	if false == yesno (args.cat) or true == yesno (args.nocat) then
		args.nocat = true;														-- set to true when args.nocat is affirmative; nil else (as if the parameter were not set in the template)
	else																		-- args.nocat is the parameter actually used.
		args.nocat = nil;
	end
end


--[[--------------------------&lt; I N _ A R R A Y &gt;--------------------------------------------------------------

Whether needle is in haystack.

]]

local function in_array (needle, haystack)
	if needle == nil then
		return false;
	end
	for n,v in ipairs (haystack) do
		if v == needle then
			return n;
		end
	end
	return false;
end


--[[--------------------------&lt; F O R M A T _ I E T F _ T A G &gt;------------------------------------------------

Prettify IETF tags to use recommended subtag formats:
	code: lower case
	script: sentence case
	region: upper case
	variant: lower case
	private: lower case prefixed with -x-
	
]]

local function format_ietf_tag (code, script, region, variant, private)
	local out = {};

	if is_set (private) then
		return table.concat ({code:lower(), 'x', private:lower()}, '-');		-- if private, all other tags ignored
	end
	
	table.insert (out, code:lower());
	if is_set (script) then
		script = script:lower():gsub ('^%a', string.upper);
		table.insert (out, script);
	end

	if is_set (region) then
		table.insert (out, region:upper());
	end
	
	if is_set (variant) then
		table.insert (out, variant:lower());
	end
	
	return table.concat (out, '-');
end


--[[--------------------------&lt; G E T _ I E T F _ P A R T S &gt;--------------------------------------------------

Extracts and returns IETF language tag parts:
	primary language subtag (required) - 2 or 3 character IANA language code
	script subtag - four character IANA script code
	region subtag - two-letter or three digit IANA region code
	variant subtag - four digit or 5-8 alnum variant code; only one variant subtag supported
	private subtag - x- followed by 1-8 alnum private code; only supported with the primary language tag

in any one of these forms
	lang					lang-variant
	lang-script				lang-script-variant
	lang-region				lang-region-variant
	lang-script-region		lang-script-region-variant
	lang-x-private	
	
each of lang, script, region, variant, and private, when used, must be valid.

Languages with both two- and three-character code synonyms are promoted to the two-character synonym because
the IANA registry file omits the synonymous three-character code; we cannot depend on browsers understanding
the synonymous three-character codes in the lang= attribute.

For {{lang-??}} templates, the parameters |script=, |region=, and |variant= are supported (not supported in {{lang}}
because those parameters are superfluous to the IETF subtags in |code=).

Returns six  values; all lower case.  Valid parts are returned as themselves; omitted parts are returned as empty strings, invalid
parts are returned as nil; the sixth returned item is an error message (if an error detected) or nil.

See http://www.rfc-editor.org/rfc/bcp/bcp47.txt section 2.1.
	
]]

local function get_ietf_parts (source, args_script, args_region, args_variant)
	local code, script, region, variant, private;								-- IETF tag parts

	if not is_set (source) then
		return nil, nil, nil, nil, nil, cfg.get_ietf_parts_t.missing_lang_tag;
	end

	local pattern = {															-- table of tables holding acceptable IETF tag patterns and short names of the IETF part captured by the pattern
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%a%a)%-(%d%d%d%d)$', 's', 'r', 'v'}, 				-- 1 -  ll-Ssss-RR-variant (where variant is 4 digits)
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%d%d%d)%-(%d%d%d%d)$', 's', 'r', 'v'},				-- 2 -  ll-Ssss-DDD-variant (where region is 3 digits; variant is 4 digits)
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%a%a)%-(%w%w%w%w%w%w?%w?%w?)$', 's', 'r', 'v'},		-- 3 -  ll-Ssss-RR-variant (where variant is 5-8 alnum characters)
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%d%d%d)%-(%w%w%w%w%w%w?%w?%w?)$', 's', 'r', 'v'},	-- 4 -  ll-Ssss-DDD-variant (where region is 3 digits; variant is 5-8 alnum characters)
		
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%d%d%d%d)$', 's', 'v'},						-- 5 -  ll-Ssss-variant (where variant is 4 digits)
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%w%w%w%w%w%w?%w?%w?)$', 's', 'v'},			-- 6 -  ll-Ssss-variant (where variant is 5-8 alnum characters)
		
		{'^(%a%a%a?)%-(%a%a)%-(%d%d%d%d)$', 'r', 'v'},							-- 7 -  ll-RR-variant (where variant is 4 digits)
		{'^(%a%a%a?)%-(%d%d%d)%-(%d%d%d%d)$', 'r', 'v'},						-- 8 -  ll-DDD-variant (where region is 3 digits; variant is 4 digits)
		{'^(%a%a%a?)%-(%a%a)%-(%w%w%w%w%w%w?%w?%w?)$', 'r', 'v'},				-- 9 -  ll-RR-variant (where variant is 5-8 alnum characters)
		{'^(%a%a%a?)%-(%d%d%d)%-(%w%w%w%w%w%w?%w?%w?)$', 'r', 'v'},				-- 10 - ll-DDD-variant (where region is 3 digits; variant is 5-8 alnum characters)
		
		{'^(%a%a%a?)%-(%d%d%d%d)$', 'v'},										-- 11 - ll-variant (where variant is 4 digits)
		{'^(%a%a%a?)%-(%w%w%w%w%w%w?%w?%w?)$', 'v'},							-- 12 - ll-variant (where variant is 5-8 alnum characters)
		
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%a%a)$', 's', 'r'},							-- 13 - ll-Ssss-RR
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%d%d%d)$', 's', 'r'},						-- 14 - ll-Ssss-DDD (region is 3 digits)
		
		{'^(%a%a%a?)%-(%a%a%a%a)$', 's'},										-- 15 - ll-Ssss
		
		{'^(%a%a%a?)%-(%a%a)$', 'r'},											-- 16 - ll-RR
		{'^(%a%a%a?)%-(%d%d%d)$', 'r'},											-- 17 - ll-DDD (region is 3 digits)
		
		{'^(%a%a%a?)$'},														-- 18 - ll
		
		{'^(%a%a%a?)%-x%-(%w%w?%w?%w?%w?%w?%w?%w?)$', 'p'},						-- 19 - ll-x-pppppppp (private is 1-8 alnum characters)
		}

	local t = {};																-- table of captures; serves as a translator between captured IETF tag parts and named variables

	for i, v in ipairs (pattern) do												-- spin through the pattern table looking for a match
		local c1, c2, c3, c4;													-- captures in the 'pattern' from the pattern table go here
	
		c1, c2, c3, c4 = source:match (pattern[i][1]);							-- one or more captures set if source matches pattern[i])
			if c1 then															-- c1 always set on match
				code = c1;														-- first capture is always code
				t = {
					[pattern[i][2] or 'x'] = c2,								-- fill the table of captures with the rest of the captures
					[pattern[i][3] or 'x'] = c3,								-- take index names from pattern table and assign sequential captures
					[pattern[i][4] or 'x'] = c4,								-- index name may be nil in pattern[i] table so "or 'x'" spoofs a name for this index in this table
					};
				script = t.s or '';												-- translate table contents to named variables;
				region = t.r or '';												-- absent table entries are nil so set named IETF parts to empty string for concatenation
				variant= t.v or '';
				private = t.p or '';
				break;															-- and done
			end
	end

	if not code then
		return nil, nil, nil, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_tag, {source});	-- don't know what we got but it is malformed
	end

	code = code:lower();														-- ensure that we use and return lower case version of this
	
	if not (override_table[code] or lang_table[code] or synonym_table[code] or lang_dep_table[code]) then
		return nil, nil, nil, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_code, {code});		-- invalid language code, don't know about the others (don't care?)
	end

	if synonym_table[code] then													-- if 639-2/639-2T code has a 639-1 synonym
		table.insert (maint_cats, substitute (cfg.get_ietf_parts_t.maint_promo_cat, {code}));
		table.insert (maint_msgs, substitute (cfg.get_ietf_parts_t.maint_promo_msg, {code, synonym_table[code]}));
		code = synonym_table[code];												-- use the synonym
	end

	if is_set (script) then
		if is_set (args_script) then
			return code, nil, nil, nil, nil, cfg.get_ietf_parts_t.redundant_scr;	-- both code with script and |script= not allowed
		end
	else
		script = args_script or '';												-- use args.script if provided
	end 

	if is_set (script) then
		script = script:lower();												-- ensure that we use and return lower case version of this
		if not script_table[script] then
			return code, nil, nil, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_scr_code, {script, code});	-- language code OK, invalid script, don't know about the others (don't care?)
		end
	end
	if suppressed_table[script] then											-- ensure that code-script does not use a suppressed script
		if in_array (code, suppressed_table[script]) then
			return code, nil, nil, nil, nil, substitute (cfg.get_ietf_parts_t.script_code, {script, code});	-- language code OK, script is suppressed for this code
		end
	end

	if is_set (region) then
		if is_set (args_region) then
			return code, nil, nil, nil, nil, cfg.get_ietf_parts_t.redundant_reg;	-- both code with region and |region= not allowed
		end
	else
		region = args_region or '';												-- use args.region if provided
	end 

	if is_set (region) then
		region = region:lower();												-- ensure that we use and return lower case version of this
		if not region_table[region] then
			return code, script, nil, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_reg_code, {region, code});
		end
	end
	
	if is_set (variant) then
		if is_set (args_variant) then
			return code, nil, nil, nil, nil, cfg.get_ietf_parts_t.redundant_var;	-- both code with variant and |variant= not allowed
		end
	else
		variant = args_variant or '';											-- use args.variant if provided
	end 

	if is_set (variant) then
		variant = variant:lower();												-- ensure that we use and return lower case version of this
		if not variant_table[variant] then										-- make sure variant is valid
			return code, script, region, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_var, {variant});
		end																		-- does this duplicate/replace tests in lang() and lang_xx()?
		if is_set (script) then													-- if script set it must be part of the 'prefix'
			if not in_array (table.concat ({code, '-', script}), variant_table[variant]['prefixes']) then
				return code, script, region, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_var_code_scr, {variant, code, script});
			end
		elseif is_set (region) then												-- if region set, there are some prefixes that require lang code and region (en-CA-newfound)
			if not in_array (code, variant_table[variant]['prefixes']) then		-- first see if lang code is all that's required (en-oxendict though en-GB-oxendict is preferred)
				if not in_array (table.concat ({code, '-', region}), variant_table[variant]['prefixes']) then		-- now try for lang code and region (en-CA-newfound)
					return code, script, region, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_var_code_reg, {variant, code, region});
				end
			end
		else																	-- cheap way to determine if there are prefixes; fonipa and others don't have prefixes; # operator always returns 0
			if variant_table[variant]['prefixes'][1] and not in_array (code, variant_table[variant]['prefixes']) then
				return code, script, region, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_var_code, {variant, code});
			end
		end
	end

	if is_set (private) then
		private = private:lower();												-- ensure that we use and return lower case version of this
		if not override_table[table.concat ({code, '-x-', private})] then		-- make sure private tag is valid; note that index 
			return code, script, region, nil, nil, substitute (cfg.get_ietf_parts_t.unrecog_pri, {private});
		end
	end
	return code, script, region, variant, private, nil;							-- return the good bits; make sure that msg is nil
end


--[=[-------------------------&lt; M A K E _ W I K I L I N K &gt;----------------------------------------------------

Makes a wikilink; when both link and display text is provided, returns a wikilink in the form [[L|D]]; if only
link is provided, returns a wikilink in the form [[L]]; if neither are provided or link is omitted, returns an
empty string.

]=]

local function make_wikilink (link, display)
	if is_set (link) then
		if is_set (display) then
			return table.concat ({'[[', link, '|', display, ']]'});
		else
			return table.concat ({'[[', link, ']]'});
		end
	else
		return '';
	end
end


--[[--------------------------&lt; D I V _ M A R K U P _ A D D &gt;--------------------------------------------------

Adds &lt;i&gt; and &lt;/i&gt; tags to list-item text or to implied &lt;p&gt;..&lt;/p&gt; text. Mixed not supported.

]]

local function div_markup_add (text, style)
	if text:find ('^\n[%*:;#]') then											-- look for list markup; list markup must begin at start of text
		if 'italic' == style then
			return text:gsub ('(\n[%*:;#]+)([^\n]+)', '%1&lt;i&gt;%2&lt;/i&gt;');			-- insert italic markup at each list item
		else
			return text;
		end
	end

	if text:find ('\n+') then													-- look for any number of \n characters in text
		text = text:gsub ('([^\n])\n([^\n])', '%1 %2');							-- replace single newline characters with a space character which mimics MediaWiki

		if 'italic' == style then
			text = text:gsub('[^\n]+', '&lt;p&gt;&lt;i&gt;%1&lt;/i&gt;&lt;/p&gt;');						-- insert p and italic markup tags at each implied p (two or more consecutive '\n\n' sequences)
		else
			text = text:gsub ('[^\n]+', '&lt;p&gt;%1&lt;/p&gt;');							-- insert p markup at each implied p
			text = text:gsub ('\n', '');										-- strip newline characters
		end
	end

	return text;
end


--[[--------------------------&lt; T I T L E _ W R A P P E R _ M A K E &gt;------------------------------------------

Makes a &lt;span title="&lt;title text&gt;"&gt;&lt;content_text&gt;&lt;/span&gt; or &lt;div title="&lt;title text&gt;"&gt;&lt;content_text&gt;&lt;/div&gt; where
&lt;title text&gt; is in the tool-tip in the wiki's local language and &lt;content_text&gt; is non-local-language text in
HTML markup.  This because the lang= attribute applies to the content of its enclosing tag.

&lt;tag&gt; holds a string 'div' or 'span' used to choose the correct wrapping tag.

]]

local function title_wrapper_make (title_text, content_text, tag)
	local wrapper_t = {};
	
	table.insert (wrapper_t, table.concat ({'&lt;', tag}));						-- open opening wrapper tag
	table.insert (wrapper_t, ' title=\"');										-- begin title attribute
	table.insert (wrapper_t, title_text);										-- add &lt;title_text&gt;
	table.insert (wrapper_t, '\"&gt;');											-- end title attribute and close opening wrapper tag
	table.insert (wrapper_t, content_text);										-- add &lt;content_text&gt;
	table.insert (wrapper_t, table.concat ({'&lt;/', tag, '&gt;'}));					-- add closing wrapper tag

	return table.concat (wrapper_t);											-- make a big string and done
end


--[[--------------------------&lt; M A K E _ T E X T _ H T M L &gt;--------------------------------------------------

Add the HTML markup to text according to the type of content that it is: &lt;span&gt; or &lt;i&gt; tags for inline content or
&lt;div&gt; tags for block content

The lang= attribute also applies to the content of the tag where it is placed so this is wrong because 'Spanish
language text' is English:
	&lt;i lang="es" title="Spanish language text"&gt;casa&lt;/i&gt;
should be:
	&lt;span title="Spanish language text"&gt;&lt;i lang="es"&gt;casa&lt;/i&gt;&lt;/span&gt;
or for &lt;div&gt;...&lt;/div&gt;:
	&lt;div title="Spanish language text"&gt;&lt;div lang="es"&gt;&lt;spanish-language-text&gt;&lt;/div&gt;&lt;/div&gt;

]]

local function make_text_html (code, text, tag, rtl, style, size, language)
	local html_t = {};
	local style_added = '';
	local wrapper_tag = tag;													-- &lt;tag&gt; gets modified so save a copy for use when/if we create a wrapper span or div

	if text:match ('^%*') then
		table.insert (html_t, '&amp;#42;');											-- move proto language text prefix outside of italic markup if any; use numeric entity because plain splat confuses MediaWiki
		text = text:gsub ('^%*', '');											-- remove the splat from the text
	end

	if 'span' == tag then														-- default HTML tag for inline content
		if 'italic' == style then												-- but if italic
			tag = 'i';															-- change to &lt;i&gt; tags
		end
	else																		-- must be div so go
		text = div_markup_add (text, style);									-- handle implied &lt;p&gt;, implied &lt;p&gt; with &lt;i&gt;, and list markup (*;:#) with &lt;i&gt;
	end

	table.insert (html_t, table.concat ({'&lt;', tag}));							-- open the &lt;i&gt;, &lt;span&gt;, or &lt;div&gt; HTML tag
	code = code:gsub ('%-x%-.*', '');											-- strip private use subtag from code tag because meaningless outside of Wikipedia
	table.insert (html_t, table.concat ({' lang="', code, '\"'}));				-- add language attribute

	if (rtl or unicode.is_rtl(text)) and ('ltr' == this_wiki_lang_dir) then		-- text is right-to-left on a left-to-right wiki
		table.insert (html_t, ' dir="rtl"');									-- add direction attribute for right-to-left languages
	elseif not (rtl or unicode.is_rtl(text)) and ('rtl' == this_wiki_lang_dir) then	-- text is left-to-right on a right-to-left wiki
		table.insert (html_t, ' dir="ltr"');									-- add direction attribute for left-to-right languages
	end

	if 'normal' == style then													-- when |italic=no
		table.insert (html_t, ' style=\"font-style: normal;');					-- override external markup, if any
		style_added = '\"';														-- remember that style attribute added and is not yet closed
	end

	if is_set (size) then														-- when |size=&lt;something&gt;
		if is_set (style_added) then
			table.insert (html_t, table.concat ({' font-size: ', size, ';'}));	-- add when style attribute already inserted
		else
			table.insert (html_t, table.concat ({' style=\"font-size: ', size, ';'}));	-- create style attribute
			style_added = '\"';													-- remember that style attribute added and is not yet closed
		end
	end

	table.insert (html_t, table.concat ({style_added, '&gt;'}));					-- close the opening HTML tag
	table.insert (html_t, text);												-- insert the text

	table.insert (html_t, table.concat ({'&lt;/', tag, '&gt;'}));						-- close the 'text' &lt;i&gt;, &lt;span&gt;, or &lt;div&gt; HTML tag

	if is_set (language) then													-- create a &lt;title_text&gt; string for the title= attribute in a wrapper span or div
		local title_text;
			if 'zxx' == code then												-- special case for this tag 'no linguistic content'
				title_text = substitute ('$1 $2', {language, cfg.make_text_html_t.zxx});	-- not a language so don't use 'language' in title text
			elseif mw.ustring.find (language, 'languages', 1, true) then
				title_text = substitute ('$1 $2', {language, cfg.make_text_html_t.collective});	-- for collective languages
			else
				title_text = substitute ('$1-$2', {language, cfg.make_text_html_t.individual});	-- for individual languages
			end

		return title_wrapper_make (title_text, table.concat (html_t), wrapper_tag);
	else
		return table.concat (html_t);
	end
end


--[=[-------------------------&lt; M A K E _ C A T E G O R Y &gt;----------------------------------------------------

For individual language, &lt;language&gt;, returns:
	[[Category:Articles containing &lt;language&gt;-language text]]

For English:
	[[Category:Articles containing explicitly cited English-language text]]
	
For ISO 639-2 collective languages (and for 639-1 bh):
	[[Category:Articles with text in &lt;language&gt; languages]]

]=]

local function make_category (code, language_name, nocat, name_get)
	if ((0 ~= namespace) or nocat) and not name_get then						-- only categorize in article space
		return '';																-- return empty string for concatenation
	end

	if mw.ustring.find (language_name, 'languages', 1, true) then
		return substitute ('[[$1 $2]]', {cfg.make_category_t.collective_cat, language_name});
	end
		
	if this_wiki_lang_tag == code then
		return substitute ('[[$1 $2 $3-$4]]', {									-- unique category name for the local language
			cfg.make_category_t.cat_prefix,
			cfg.make_category_t.explicit_cat,
			language_name,
			cfg.make_category_t.cat_postfix,
			});
	else
		return substitute ('[[$1 $2-$3]]', {									-- category for individual languages
			cfg.make_category_t.cat_prefix,
			language_name,
			cfg.make_category_t.cat_postfix,
			});
	end
end


--[[--------------------------&lt; M A K E _ T R A N S L I T &gt;----------------------------------------------------

Return translit &lt;i lang=xx-Latn&gt;...&lt;/i&gt; where xx is the language code; else return empty string.

The value |script= is not used in {{transliteration}} for this purpose; instead it uses |code.  Because language scripts
are listed in the {{transliteration}} switches they are included in the data tables.  The script parameter is introduced
at {{Language with name and transliteration}}.  If |script= is set, this function uses it in preference to code.

To avoid confusion, in this module and the templates that use it, the transliteration script parameter is renamed
to be |translit-script= (in this function, tscript).

This function is used by both lang_xx() and xlit()
	lang_xx() always provides code, language_name, and translit; may provide tscript; never provides style
	xlit() always provides language_name, translit, and one of code or tscript, never both; always provides style

For {{transliteration}}, style only applies when a language code is provided.

]]

local function make_translit (code, language_name, translit, std, tscript, style, engvar)
	local title_t = lang_data.translit_title_table;								-- table of transliteration standards and the language codes and scripts that apply to those standards
	local title_text = '';														-- tool tip text for title= attribute
	
	std = std and std:lower();													-- lower case for table indexing
	
	if not is_set (std) and not is_set (tscript) then							-- when neither standard nor script specified
		title_text = language_name;												-- write a generic tool tip
		if not mw.ustring.find (language_name, 'languages', 1, true) then		-- collective language names (plural 'languages' is part of the name)
			title_text = substitute ('$1-$2', {title_text, cfg.misc_text_t.language});	-- skip this text (individual and macro languages only)
		end
		title_text = substitute ('$1 $2', {title_text, mw.ustring.lower (cfg.engvar_t[engvar]['romanisz_lc'])});	-- finish the tool tip; use romanization when neither script nor standard supplied

	elseif is_set (std) and is_set (tscript) then								-- when both are specified
		if title_t[std] then													-- and if standard is legitimate
			if title_t[std][tscript] then										-- and if script for that standard is legitimate
				if script_table[tscript] then
					title_text = substitute ('$1$2 ($3 $4) $5', {				-- add the appropriate text to the tool tip
						title_text,
						title_t[std][tscript:lower()],
						script_table[tscript],
						cfg.make_translit_t.script,
						cfg.make_translit_t.transliteration,
						});
				else
					title_text = title_text .. title_t[std]['default'];			-- use the default if script not in std table; TODO: maint cat? error message because script not found for this standard?
				end
			else
				title_text = title_text .. title_t[std]['default'];				-- use the default if script not in std table; TODO: maint cat? error message because script not found for this standard?
			end
		else
			return '';															-- invalid standard, setup for error message
		end

	elseif is_set (std) then													-- translit-script not set, use language code
		if not title_t[std] then return ''; end									-- invalid standard, setup for error message
		
		if title_t[std][code] then												-- if language code is in the table (xlit may not provide a language code)
			title_text = substitute ('$1$2 ($3 $4) $5', {						-- add the appropriate text to the tool tip
				title_text,
				title_t[std][code:lower()],
				language_name,
				cfg.misc_text_t.language,
				cfg.make_translit_t.transliteration,
				});
		else																	-- code doesn't match
			title_text = title_text .. title_t[std]['default'];					-- so use the standard's default
		end

	else																		-- here if translit-script set but translit-std not set
		if title_t['no_std'][tscript] then
			title_text = title_text .. title_t['no_std'][tscript];				-- use translit-script if set
		elseif title_t['no_std'][code] then
			title_text = title_text .. title_t['no_std'][code];					-- use language code
		else
			if is_set (tscript) then
				title_text = substitute ('$1$2-$3 $4', {						-- write a script tool tip
					title_text,
					language_name,
					cfg.make_translit_t.script,
					cfg.make_translit_t.transliteration,
					});

			elseif is_set (code) then
				if not mw.ustring.find (language_name, 'languages', 1, true) then	-- collective language names (plural 'languages' is part of the name)
					title_text = substitute ('$1-$2', {							-- skip this text (individual and macro languages only)
						title_text,
						cfg.misc_text_t.language,
						});
				end
					title_text = substitute ('$1 $2', {							-- finish the tool tip
						title_text,
						cfg.make_translit_t.transliteration,
						});
			else
					title_text = substitute ('$1 $2', {							-- generic tool tip (can we ever get here?)
						title_text,
						cfg.make_translit_t.transliteration,
						});
			end
		end
	end

	local tag
	if is_set (code) then														-- when a language code is provided (always with {{lang-??}} templates, not always with {{transliteration}})
		code = code:match ('^(%a%a%a?)');										-- strip all subtags leaving only the language subtag
		if not style then														-- nil for the default italic style
			tag = '&lt;i lang="%s-Latn"&gt;%s&lt;/i&gt;'
		else
			tag = '&lt;span style="font-style: %s" lang="%s-Latn"&gt;%s&lt;/span&gt;'		-- non-standard style, construct a span tag for it
			tag = string.format(tag, style, "%s", "%s")
		end
		tag = string.format(tag, code, "%s")
	else
		tag = '&lt;span&gt;%s&lt;/span&gt;'													-- when no language code: no lang= attribute, not italic ({{transliteration}} only)
	end
	
	tag = string.format(tag, translit)											-- add the translit text
	if '' == title_text then													-- when there is no need for a tool-tip
		return tag;																-- done
	else
		title_text = cfg.engvar_sel_t.gb == engvar and title_text:gsub ('([Rr]omani)z', '%1s') or title_text;	-- gb eng when engvar specifies gb eng; us eng else
		return title_wrapper_make (title_text, tag, 'span');					-- wrap with a tool-tip span and done
	end
end


--[[--------------------------&lt; V A L I D A T E _ T E X T &gt;----------------------------------------------------

This function checks the content of args.text and returns empty string if nothing is amiss else it returns an
error message. The tests are for empty or missing text and for improper or disallowed use of apostrophe markup.

Italic rendering is controlled by the |italic= template parameter so italic markup should never appear in args.text
either as ''itself'' or as '''''bold italic''''' unless |italic=unset or |italic=invert.

]]

local function validate_text (template, args)
	if not is_set (args.text) then
		return make_error_msg (cfg.validate_text_t.no_text, args, template);
	end

	if args.text:find ("%f[\']\'\'\'\'%f[^\']") or args.text:find ("\'\'\'\'\'[\']+") then	-- because we're looking, look for 4 appostrophes or 6+ appostrophes
		return make_error_msg (cfg.validate_text_t.malformed_markup, args, template);
	end

	local style = args.italic;

	if (cfg.keywords_t.unset ~= style) and (cfg.keywords_t.invert ~=style) then
		if args.text:find ("%f[\']\'\'%f[^\']") or args.text:find ("%f[\']\'\'\'\'\'%f[^\']") then	-- italic but not bold, or bold italic
			return make_error_msg (cfg.validate_text_t.italic_markup, args, template);
		end
	end
end


--[[--------------------------&lt; R E N D E R _ M A I N T &gt;------------------------------------------------------

Render mainenance messages and categories.

]]

local function render_maint (nocat)
	local maint = {};
	
	if 0 &lt; #maint_msgs then														-- when there are maintenance messages
		table.insert (maint, table.concat ({'&lt;span class="lang-comment" style="font-style: normal; display: none; color: #33aa33; margin-left: 0.3em;"&gt;'}));	-- opening &lt;span&gt; tag
		for _, msg in ipairs (maint_msgs) do
			table.insert (maint, table.concat ({msg, ' '}));					-- add message strings
		end
		table.insert (maint, '&lt;/span&gt;');										-- close the span
	end
	
	if (0 &lt; #maint_cats) and (0 == namespace) and not nocat then				-- when there are maintenance categories; article namespace only
		for _, cat in ipairs (maint_cats) do
			table.insert (maint, table.concat ({'[[Category:', cat, ']]'}));	-- format and add the categories
		end
	end
	
	return table.concat (maint);
end


--[[--------------------------&lt; P R O T O _ P R E F I X &gt;------------------------------------------------------

For proto languages, text is prefixed with a splat. We do that here as a flag for make_text_html() so that a splat
will be rendered outside of italic markup (if used). If the first character in text here is already a splat, we
do nothing.

proto_param is boolean or nil; true adds splat prefix regardless of language name; false removes and inhibits
regardless of language name; nil does nothing; presumes that the value in text is correct but removes extra splac.

]]

local function proto_prefix (text, language_name, proto_param)
	if false == proto_param then												-- when forced by |proto=no
		return text:gsub ('^%**', '');											-- return text without splat prefix regardless of language name or existing splat prefix in text
	elseif (language_name:find ('^Proto%-') or (true == proto_param)) then		-- language is a proto or forced by |proto=yes
		return text:gsub ('^%**', '*');											-- prefix proto-language text with a splat; also removes duplicate prefixing splats
	end
	
	return text:gsub ('^%*+', '*');												-- return text unmolested except multiple splats reduced to one splat
end


--[[--------------------------&lt; H A S _ P O E M _ T A G &gt;------------------------------------------------------

Looks for a poem strip marker in text; returns true when found; false else.

Auto-italic detection disabled when text has poem stripmarker because it is not possible for this code to know
the content that will replace the stripmarker.

]]

local function has_poem_tag (text)
	return text:find ('\127[^\127]*UNIQ%-%-poem%-[%a%d]+%-QINU[^\127]*\127') and true or false;
end


--[[--------------------------&lt; H T M L _ T A G _ S E L E C T &gt;------------------------------------------------

Inspects content of and selectively trims text.  Returns text and the name of an appropriate HTML tag for text.

If text contains:
	\n\n	text has implied &lt;p&gt;..&lt;/p&gt; tags - trim leading and trailing whitespace and return 
If text begins with list markup:
	\n*		unordered
	\n;		definition
	\n:		definition
	\n#		ordered
trim all leading whitespace except  \n and trim all trailing whitespace

If text contains &lt;poem&gt;...&lt;/poem&gt; stripmarker, return text unmodified and choose &lt;div&gt;..&lt;/div&gt; tags because 
the stripmarker is replaced with text wrapped in &lt;div&gt;..&lt;/div&gt; tags.

If the text contains any actual &lt;div&gt;...&lt;/div&gt; tags, then it's again returned unmodified and &lt;div&gt;...&lt;/div&gt;
tags are used to wrap it, to prevent div/span inversion.

]]

local function html_tag_select (text)
	local tag;
	
	if has_poem_tag (text) then													-- contains poem stripmarker (we can't know the content of that)
		tag = 'div';															-- poem replacement is in div tags so lang must use div tags
	elseif text:find ('&lt;div') then												-- reductive; if the text contains a div tag, we must use div tags
		tag = 'div';
	elseif mw.text.trim (text):find ('\n\n+') then								-- contains implied p tags
		text = mw.text.trim (text);												-- trim leading and trailing whitespace characters
		tag = 'div';															-- must be div because span may not contain p tags (added later by MediaWiki); poem replacement is in div tags
	elseif text:find ('\n[%*:;%#]') then										-- if text has list markup
		text = text:gsub ('^[\t\r\f ]*', ''):gsub ('%s*$', '');					-- trim all whitespace except leading newline character '\n'
		tag = 'div';															-- must be div because span may not contain ul, dd, dl, ol tags (added later by MediaWiki)
	else
		text = mw.text.trim (text);												-- plain text
		tag = 'span';															-- so span is fine
	end
	
	return text, tag;
end


--[[--------------------------&lt; V A L I D A T E _ P R O T O &gt;--------------------------------------------------

Validates value assigned to |proto=; permitted values are yes and no; yes returns as true, no returns as false,
empty string (or parameter omitted) returns as nil; any other value returns nil with &lt;proto_param&gt; as second
return value for use in error message.

]]

local function validate_proto (proto_param)
	if cfg.keywords_t.affirmative == proto_param then
		return true;
	elseif cfg.keywords_t.negative == proto_param then
		return false;
	elseif is_set (proto_param) then
		return nil, proto_param;												-- |proto= something other than 'yes' or 'no'
	else
		return nil;																-- missing or empty
	end
end


--[[--------------------------&lt; L A N G U A G E _ N A M E _ G E T &gt;--------------------------------------------

Common function to return language name from the data set according to IETF tag.

Returns language name if found in data tables; nil else.

]]

local function language_name_get (ietf, code, cat)
	ietf = ietf:lower();														-- ietf:lower() because format_ietf_tag() returns mixed case
	
	local name;																	-- remains nil if not found
	
	if override_table[ietf] then												-- look for whole IETF tag in override table
		name = override_table[ietf];
	elseif override_table[code] then											-- not there so try basic language tag
		name = override_table[code];
	elseif lang_table[code] then												-- shift to IANA active tag/name table
		name = lang_table[code];
	elseif lang_dep_table[code] then											-- try the IANA deprecated tag/name table
		name = lang_dep_table[code];
	end

	if lang_dep_table[code] and cat then										-- because deprecated code may have been overridden to en.wiki preferred name
		table.insert (maint_cats, substitute (cfg.language_name_get_t.deprecated_cat, {code}));
		table.insert (maint_msgs, substitute (cfg.language_name_get_t.deprecated_msg, {code}));
	end

	return name;																-- name from data tables or nil
end


--[[--------------------------&lt; T E X T _ S C R I P T _ M A T C H _ T E S T &gt;----------------------------------

IETF script subtag should match the script of the &lt;text&gt;.  This module does not attempt to know all scripts and
what they look like.  It does know what Latn script looks like so when &lt;text&gt; is written using other than the Latn
script, the IETF script subtag, if present, should not be Latn.

Conversely, when &lt;text&gt; is written using the Latn script, the IETF script subtag, if present, should be Latn.

For the purposes of this test, Latf (Fraktur) and Latg (Gaelic) are considered to be equivalent to Latn because
unicode treats these two scripts as font-specific variants of Latn.

Returns an error message when mismatch detected; nil else.

]]

local function text_script_match_test (script, is_latn_text, pos, char)
	local scripts_t = {['latf'] = true, ['latg'] = true, ['latn'] = true};		-- unicode 'latn' scripts; 'latf' and 'latg' are font variants so there are no Fraktur or Gaelic codepoints
	if is_set (script) then														-- don't bother with the rest of this if &lt;script&gt; is nil or empty string
		script = script:lower();												-- lower case to index into &lt;scripts_t&gt;
		if is_latn_text then													-- when text is wholly Latn script
			if not scripts_t[script] then										-- but a non-Latn script is specified
				return cfg.text_script_match_test_t.latn_txt_mismatch;			-- emit an error message
			end
		else																	-- when text is not wholly Latn script
			if scripts_t[script] then											-- but a Latn script is specified
				return substitute (cfg.text_script_match_test_t.latn_scr_mismatch, {pos, char});	-- emit an error message with position of first offending character
			end
		end
	end
end


--[[--------------------------&lt; B I N A R Y _ S E A R C H &gt;---------------------------------------------------

conducts a binary search of &lt;ranges_t&gt; for a sub-range that holds &lt;target&gt;.

returns boolean true if a sub-range holding &lt;target&gt; is found; boolean false else.

]]

local function binary_search (target, ranges_t)
	local idx_bot = 1;															-- initialize to index of first key
	local idx_top = sizeof_ranges_t;											-- initialize to index of last key (number of keys)

	if (target &lt; ranges_t[idx_bot][1]) or (target &gt; ranges_t[idx_top][2]) then	-- invalid; target out of range
		return;																	-- abandon
	end

	local idx_mid;																-- calculated index of range midway between top index and bottom index
	local flag = false;															-- flag to tell us when we've evaluated last (highest) range in &lt;ranges_t&gt;

	while 1 do
		idx_mid = math.ceil ((idx_bot + idx_top) / 2);							-- get the mid-point in the &lt;ranges_t&gt; sequence
		if (target &gt;= ranges_t[idx_mid][1]) and (target &lt;= ranges_t[idx_mid][2]) then		-- indexed range low value &lt;= target &lt;= indexed range high value
			return true;														-- we found the range that holds the &lt;target&gt; character; return true
		
		elseif (target &gt; ranges_t[idx_mid][2]) then								-- is &lt;target&gt; &gt; indexed range high value?
			idx_bot = idx_mid;													-- adjust &lt;idx_bot&gt; up

		else																	-- here when &lt;target&gt; less than indexed range low value
			idx_top = idx_mid - 1;												-- adjust &lt;idx_top&gt; down
		end

		if flag then
			break;																-- here when we just evaluated the last range and &lt;target&gt; not found
		end
	
		if not flag and (idx_bot == idx_top) then								-- set true just before we evaluate the last (highest) range in &lt;ranges_t&gt;
			flag = true;
		end
	end
end


--[[--------------------------&lt; I S _ L A T I N &gt;--------------------------------------------------------------

compare &lt;text&gt; as codepoints to lists of known codepoints accepted as Latn script

returns boolean true and modified &lt;text&gt; when &lt;text&gt; is wrapped in accept-as-written markup

returns boolean true and &lt;text&gt; when codepoint is known

returns boolean false, &lt;text&gt;, non-Latn codepoint position in &lt;text&gt; (left to right), and the codepoint character
	when codepoint is not known

TODO: when text has accept-as-written markup, return a non-boolean value to indicate that &lt;text&gt; is not wholly
	latn script?  Use that return value to create non-Latn HTML lang= attribute because &lt;text&gt; isn't really
	latn so lang=und (undetermined)? or instead, omit the -Latn subtag? (without -Latn need to force |italic=yes)

]]

local function is_latin (text, tag)
	local count;
	text, count = text:gsub ('^%(%((.+)%)%)$', '%1');							-- remove accept-as-written markup if present
	if 0 ~= count then
		return true, text;														-- markup present so assume that &lt;text&gt; is Latn-script
	end

	local pos = 0;																-- position counter for error messaging
	for codepoint in mw.ustring.gcodepoint (text) do							-- fetch each code point
		pos = pos + 1;															-- bump the position counter

		if not is_latn_data.singles_t[codepoint] and							-- codepoint not found in the singles list?
			not binary_search (codepoint, is_latn_data.ranges_t) and			-- codepoint not a member of a listed range?
			not (tag and is_latn_data.specials_t[codepoint] and is_latn_data.specials_t[codepoint][tag]) then	-- not a language-specific codepoint?
				return false, text, pos, mw.ustring.char (codepoint);			-- codepoint not known; return false with codepoint position and character representation
		end
	end
	return true, text;															-- is known; return &lt;text&gt;
end


--[[--------------------------&lt; _ L A N G &gt;--------------------------------------------------------------------

Entry point for {{lang}}.

There should be no reason to set parameters in the {{lang}} {{#invoke:}}
	&lt;includeonly&gt;{{#invoke:lang|lang}}&lt;/includeonly&gt;

Parameters are received from the template's frame (parent frame).

]]

local function _lang (args)
	local out = {};
	local language_name;														-- used to make category names
	local category_name;														-- same as language_name except that it retains any parenthetical disambiguators (if any) from the data set
	local subtags = {};															-- IETF subtags script, region, variant, and private
	local code;																	-- the language code
	local msg;																	-- for error messages
	local tag = 'span';															-- initial value for make_text_html()
	local template = args.template or cfg.templates_t.lang;

	maint_cats = {};															-- initialize because when this module required into another module, these only declared once so only initialzed once
	maint_msgs = {};
	
	validate_cat_args (args);													-- determine if categorization should be suppressed

	if args[1] and args.code then
		return make_error_msg (substitute (cfg.lang_t.conflict_n_param, {'1', cfg.lang_t.conflict_n_param_types.code}), args, template);
	else
		args.code = args[1] or args.code;										-- prefer args.code
	end

	if args[2] and args.text then
		return make_error_msg (substitute (cfg.lang_t.conflict_n_param, {'2', cfg.lang_t.conflict_n_param_types.text}), args, template);
	else
		args.text = args[2] or args.text;										-- prefer args.text
	end

	msg = validate_text (template, args);										-- ensure that |text= is set
	if is_set (msg) then														-- msg is an already-formatted error message
		return msg;
	end
	
	args.text, tag = html_tag_select (args.text);								-- inspects text; returns appropriate HTML tag with text trimmed accordingly

	args.rtl = args.rtl == cfg.keywords_t.affirmative;							-- convert to boolean: 'yes' -&gt; true, other values -&gt; false

	args.proto, msg = validate_proto (args.proto);								-- return boolean, or nil, or nil and error message flag
	if msg then
		return make_error_msg (substitute (cfg.lang_t.invalid_proto, {msg}), args, template);
	end

	code, subtags.script, subtags.region, subtags.variant, subtags.private, msg = get_ietf_parts (args.code);	-- |script=, |region=, |variant= not supported because they should be part of args.code ({{{1}}} in {{lang}})

	if msg then
		return make_error_msg (msg, args, template);
	end

	local is_latn_text, pos, char;
	is_latn_text, args.text, pos, char= is_latin (args.text, code);		-- make a boolean

	msg = text_script_match_test (subtags.script, is_latn_text, pos, char)
	if msg then																	-- if an error detected then there is an error message
		return make_error_msg (msg, args, template);
	end

	args.italic, msg = validate_italic (args);
	if msg then
		return make_error_msg (msg, args, template);
	end

	if nil == args.italic then													-- nil when |italic= absent or not set or |italic=default; args.italic controls
		if ('latn' == subtags.script) or								 		-- script is latn
			(this_wiki_lang_tag ~= code and not is_set (subtags.script) and not has_poem_tag (args.text) and is_latn_text) then -- text not this wiki's language, no script specified and not in poem markup but is wholly latn script (auto-italics)
				args.italic = 'italic';											-- DEFAULT for {{lang}} templates is upright; but if latn script set for font-style:italic
		else
			args.italic = 'inherit';											-- italic not set; script not latn; inherit current style
		end
	end
	
	if is_set (subtags.script) then												-- if script set, override rtl setting
		if in_array (subtags.script, lang_data.rtl_scripts) then
			args.rtl = true;													-- script is an rtl script
		else
			args.rtl = false;													-- script is not an rtl script
		end
	end

	args.code = format_ietf_tag (code, subtags.script, subtags.region, subtags.variant, subtags.private);	-- format to recommended subtag styles
	language_name = language_name_get (args.code, code, true);					-- get language name; try IETF tag first, then code w/o variant then code w/ variant

	if cfg.keywords_t.invert == args.italic and 'span' == tag then				-- invert only supported for in-line content
		args.text = invert_italics (args.text)
	end

	args.text = proto_prefix (args.text, language_name, args.proto);			-- prefix proto-language text with a splat

	table.insert (out, make_text_html (args.code, args.text, tag, args.rtl, args.italic, args.size, language_name));
	table.insert (out, make_category (code, language_name, args.nocat));
	table.insert (out, render_maint (args.nocat));								-- maintenance messages and categories

	return table.concat (out);													-- put it all together and done
end


--[[--------------------------&lt; L A N G &gt;----------------------------------------------------------------------

Entry point for {{lang}}.

There should be no reason to set parameters in the {{lang}} {{#invoke:}}
	&lt;includeonly&gt;{{#invoke:lang|lang}}&lt;/includeonly&gt;

Parameters are received from the template's frame (parent frame).

]]

local function lang (frame)
	local args_t = getArgs (frame, {											-- this code so that we can detect and handle wiki list markup in text
		valueFunc = function (key, value)
			if 2 == key or 'text' == key then									-- the 'text' parameter; do not trim wite space
				return value;													-- return untrimmed 'text'
			elseif value then													-- all other values: if the value is not nil
				value = mw.text.trim (value);									-- trim whitespace
				if '' ~= value then												-- empty string when value was only whitespace
					return value;
				end
			end
			return nil;															-- value was empty or contained only whitespace
		end																		-- end of valueFunc
		});

	args_t.fn = nil;															-- unset because not supported but this function might have been called by {{lang|fn=lang|...}}

	local msg = parameter_validate (args_t, cfg.templates_t.lang);				-- verify that all supplied parameters are supported by {{lang-??}}
	if msg then
		return make_error_msg (msg, args_t, cfg.templates_t.lang);				-- when template has unsupported params, abandon with error message
	end

	return _lang (args_t);
end


--[[--------------------------&lt; T R A N S L A T I O N _ M A K E &gt;----------------------------------------------

Stand-alone function to create literal translation of main text.

Also used by {{lang-x2}}.

]]

local function translation_make (args_t)
	local translation_t = {', '};												-- initialize output

	if 'none' ~= args_t.label then												-- if we want a label
		table.insert (translation_t, '&lt;small&gt;');								-- open the &lt;small&gt; HTML tag
		if cfg.keywords_t.negative == args_t.link then
			table.insert (translation_t, substitute ('&lt;abbr title="$1"&gt;$2&lt;/abbr&gt;', {cfg.translation_make_t.lit_xlation, cfg.translation_make_t.lit_abbr}));	-- unlinked form
		else
			table.insert (translation_t, make_wikilink (cfg.translation_make_t.lit_xlation, cfg.translation_make_t.lit_abbr));	-- linked form
		end
		table.insert (translation_t, "&amp;thinsp;&lt;/small&gt;");						-- close the &lt;small&gt; HTML tag
	end
	table.insert (translation_t, table.concat ({'&amp;#39;', args_t.translation, '&amp;#39;'}));	-- use HTML entities to avoid wiki markup confusion
	return table.concat (translation_t);										-- make a big string and done
end


--[[--------------------------&lt; _ L A N G _ X X &gt;--------------------------------------------------------------

For the {{lang-??}} templates, the only parameter required to be set in the template is the language code.  All
other parameters can, usually should, be written in the template call.  For {{lang-??}} templates for languages
that can have multiple writing systems, it may be appropriate to set |script= as well.

For each {{lang-??}} template choose the appropriate entry-point function so that this function knows the default
styling that should be applied to text.

For normal, upright style:
	&lt;includeonly&gt;{{#invoke:lang|lang_xx_inherit|code=xx}}&lt;/includeonly&gt;
For italic style:
	&lt;includeonly&gt;{{#invoke:lang|lang_xx_italic|code=xx}}&lt;/includeonly&gt;

All other parameters should be received from the template's frame (parent frame)

Supported parameters are:
	|code = (required) the IANA language code
	|script = IANA script code; especially for use with languages that use multiple writing systems
	|region = IANA region code
	|variant = IANA variant code
	|text = (required) the displayed text in language specified by code
	|link = boolean false ('no') does not link code-spcified language name to associated language article
	|rtl = boolean true ('yes') identifies the language specified by code as a right-to-left language
	|nocat = boolean true ('yes') inhibits normal categorization; error categories are not affected
	|cat = boolian false ('no') opposite form of |nocat=
	|italic = boolean true ('yes') renders displayed text in italic font; boolean false ('no') renders displayed text in normal font; not set renders according to initial_style_state
	|lit = text that is a literal translation of text
	|label = 'none' to suppress all labeling (language name, 'translit.', 'lit.')
				any other text replaces language-name label - automatic wikilinking disabled
	
	for those {{lang-??}} templates that support transliteration (those templates where |text= is not entirely latn script):
	|translit = text that is a transliteration of text
	|translit-std = the standard that applies to the transliteration
	|translit-script = ISO 15924 script name; falls back to code

For {{lang-??}}, the positional parameters are:
	{{{1}}}	text
	{{{2}}}	transliterated text
	{{{3}}}	literal translation text
no other positional parameters are allowed

]]

local function _lang_xx (args, base_template)									-- base_template will be either of 'langx' or 'lang-xx'
	local out = {};
	local language_name;														-- used to make display text, article links
	local category_name;														-- same as language_name except that it retains any parenthetical disambiguators (if any) from the data set
	local subtags = {};															-- IETF subtags script, region, and variant
	local code;																	-- the language code

	local translit_script_name;													-- name associated with IANA (ISO 15924) script code
	local translit;
	local msg;																	-- for error messages
	local tag = 'span';															-- initial value for make_text_html()
	local template = args.template or base_template;

	maint_cats = {};															-- initialize because when this module required into another module, these only declared once so only initialzed once
	maint_msgs = {};
	
	local text_idx = (cfg.templates_t.langx == base_template) and 2 or 1;		-- for {{langx}} 'text' positional parameter is '2'
	local translit_idx = (cfg.templates_t.langx == base_template) and 3 or 2;
	local xlate_idx = (cfg.templates_t.langx == base_template) and 4 or 3;

	if args[text_idx] and args.text then
		return make_error_msg (substitute (cfg.lang_t.conflict_n_param, {translit_idx, cfg.lang_t.conflict_n_param_types.text}), args, template);
	else
		args.text = args[text_idx] or args.text;								-- prefer positional 'text' parameter
	end

	msg = validate_text (template, args);										-- ensure that |text= is set, does not contain italic markup and is protected from improper bolding
	if is_set (msg) then
		return msg;
	end

	args.text, tag = html_tag_select (args.text);								-- inspects text; returns appropriate HTML tag with text trimmed accordingly

	if args[translit_idx] and args.translit then
		return make_error_msg (substitute (cfg.lang_t.conflict_n_param, {translit_idx, cfg.lang_t.conflict_n_param_types.translit}), args, template);

	else
		args.translit = args[translit_idx] or args.translit						-- prefer positional 'translit' parameter
	end

	args.engvar = cfg.engvar_sel_t[args.engvar] or cfg.default_engvar;			-- |engvar= when valid; cfg.default_engvar else

	if args[xlate_idx] and (args.translation or args.lit) then
		return make_error_msg (substitute (cfg.lang_xx_t.conflict_n_lit, {translit_idx}), args, template);
	elseif args.translation and args.lit then
		return make_error_msg (cfg.lang_xx_t.conflict_lit, args, template);
	else
		args.translation = args[xlate_idx] or args.translation or args.lit;		-- prefer positional 'translation' parameter
	end

	if args.links and args.link then
		return make_error_msg (cfg.lang_xx_t.conflict_link, args, template);
	else
		args.link = args.link or args.links;									-- prefer args.link
	end

	validate_cat_args (args);													-- determine if categorization should be suppressed

	args.rtl = args.rtl == cfg.keywords_t.affirmative;							-- convert to boolean: 'yes' -&gt; true, other values -&gt; false

	code, subtags.script, subtags.region, subtags.variant, subtags.private, msg = get_ietf_parts (args.code, args.script, args.region, args.variant);	-- private omitted because private

	if msg then																	-- if an error detected then there is an error message
		return make_error_msg (msg, args, template);
	end
	
	if args.translit then
		local latn, pos, char;
		latn, args.translit, pos, char = is_latin (args.translit, (('' ~= subtags.private) and (code .. '-x-' .. subtags.private)) or code);
		if not latn then
			return make_error_msg (substitute (cfg.lang_xx_t.translit_nonlatn, {pos, char}), args, template);
		end
	end

	local is_latn_text, text, pos, char = is_latin (args.text, code);			-- make a boolean
	args.text = text;															-- may have been modified (accept-as-written markup removed)

	msg = text_script_match_test (subtags.script, is_latn_text, pos, char)
	if msg then																	-- if an error detected then there is an error message
		return make_error_msg (msg, args, template);
	end

	args.italic, msg = validate_italic (args);
	if msg then
		return make_error_msg (msg, args, template);
	end
																				
	if cfg.templates_t.langx == base_template then								-- auto-italics  for {{langx}} templates; adapted from {{lang}} (no support for poem tag) 
		if nil == args.italic then												-- nil when |italic= absent or not set or |italic=default; args.italic controls
			if ('latn' == subtags.script) or								 	-- script is latn
				(this_wiki_lang_tag ~= code and not is_set (subtags.script) and is_latn_text) then -- text is not this wiki's language, no script specified and is wholly latn script (auto-italics)
					args.italic = 'italic';										-- set font-style:italic
			else
				args.italic = 'inherit';										-- italic not set; script not latn; inherit current style
			end
		end
	
	else																		-- {{lang-xx}} does not do auto italics; retained for those wikis that don't support {{langx}}
		if nil == args.italic then												-- args.italic controls
			if is_set (subtags.script) then
				if 'latn' == subtags.script then
					args.italic = 'italic';										-- |script=Latn; set for font-style:italic
				else
					args.italic = initial_style_state;							-- italic not set; script is not latn; set for font-style:&lt;initial_style_state&gt;
				end
			else
				args.italic = initial_style_state;								-- here when |italic= and |script= not set; set for font-style:&lt;initial_style_state&gt;
			end
		end
	end
	
	if is_set (subtags.script) then												-- if script set override rtl setting
		if in_array (subtags.script, lang_data.rtl_scripts) then
			args.rtl = true;													-- script is an rtl script
		else
			args.rtl = false;													-- script is not an rtl script
		end
	end

	args.proto, msg = validate_proto (args.proto);								-- return boolean, or nil, or nil and error message flag
	if msg then
		return make_error_msg (substitute (cfg.lang_t.invalid_proto, {args.proto}), args, template);
	end

	args.code = format_ietf_tag (code, subtags.script, subtags.region, subtags.variant, subtags.private);	-- format to recommended subtag styles
	language_name = language_name_get (args.code, code, true);					-- get language name; try IETF tag first, then code w/o variant then code w/ variant

	category_name = language_name;												-- category names retain IANA parenthetical diambiguators (if any)
	language_name = language_name:gsub ('%s+%b()', '');							-- remove IANA parenthetical disambiguators or qualifiers from names that have them

	if args.label then
		if 'none' ~= args.label then
			table.insert (out, table.concat ({args.label, ': '}));				-- custom label
		end
	else
		if cfg.keywords_t.negative == args.link then
			table.insert (out, language_name);									-- language name without wikilink
		else
			if mw.ustring.find (language_name, 'languages', 1, true) then
				table.insert (out, make_wikilink (language_name));				-- collective language name uses simple wikilink
			elseif lang_data.article_name[args.code:lower()] then				-- is IETF tag in article name over ride?
				table.insert (out, make_wikilink (lang_data.article_name[args.code:lower()], language_name));	-- language name with wikilink from override data
			elseif lang_data.article_name[code] then							-- is language tag in article override
				table.insert (out, make_wikilink (lang_data.article_name[code], language_name));	-- language name with wikilink from override data
			else
				table.insert (out, make_wikilink (substitute ('$1 $2', {language_name, cfg.misc_text_t.language}), language_name));	-- language name with wikilink
			end
		end
		table.insert (out, ': ');												-- separator
	end

	if cfg.keywords_t.invert == args.italic then
		args.text = invert_italics (args.text)
	end
	
	args.text = proto_prefix (args.text, language_name, args.proto);			-- prefix proto-language text with a splat

	table.insert (out, make_text_html (args.code, args.text, tag, args.rtl, args.italic, args.size, ('none' == args.label) and language_name or nil))

	if is_set (args.translit) and not is_latn_text then							-- transliteration; not supported when args.text is wholly latn text (this is an imperfect test)
		table.insert (out, ', ');												-- comma to separate text from translit
		if 'none' ~= args.label then
			table.insert (out, '&lt;small&gt;');
			if script_table[args['translit-script']] then						-- when |translit-script= is set, try to use the script's name
				translit_script_name = script_table[args['translit-script']];
			else
				translit_script_name = language_name;							-- fall back on language name
			end

			local translit_title_obj = mw.title.makeTitle (0, substitute ('$1 $2',{cfg.lang_xx_t.romanization, translit_script_name}));		-- make a title object; no engvar, article titles use US spelling
			if translit_title_obj.exists and (cfg.keywords_t.negative ~= args.link) then
				table.insert (out, make_wikilink (substitute ('$1 $2', {cfg.lang_xx_t.romanization, translit_script_name or language_name}),
					substitute ('$1', {cfg.engvar_t[args.engvar]['romanisz_pt']})) .. ':');	-- make a wikilink if there is an article to link to; engvar the display text

			else
				table.insert (out, substitute ('$1:', {cfg.engvar_t[args.engvar]['romanisz_pt']}));	-- else plain text per engvar

			end
			table.insert (out, '&amp;nbsp;&lt;/small&gt;');								-- close the small tag
		end
		
		translit = make_translit (args.code, language_name, args.translit, args['translit-std'], args['translit-script'], nil, args.engvar)
		if is_set (translit) then
			table.insert (out, translit);
		else
			return make_error_msg (substitute ('$1: $2', {cfg.lang_xx_t.invalid_xlit_std, args['translit-std'] or '[missing]'}), args, template);
		end
	
	elseif is_set (args.translit) and is_latn_text then							-- when creating a transliteration of Latn script &lt;text&gt;
		return make_error_msg (cfg.lang_xx_t.xlit_of_latn, args, template);		-- emit error message and abandon
	end

	if is_set (args.translation) then											-- translation (not supported in {{lang}})
		table.insert (out, translation_make (args));
	end
	
	table.insert (out, make_category (code, category_name, args.nocat));
	table.insert (out, render_maint(args.nocat));								-- maintenance messages and categories

	return table.concat (out);													-- put it all together and done
end


--[[--------------------------&lt; L A N G _ X X _ A R G S _ G E T &gt;----------------------------------------------

Common function to get args table from {{lang-??}} templates.

Returns table of args.

Text positional parameters are not trimmed here but are selectively trimmed at html_tag_select().

]]

local function lang_xx_args_get (frame, base_template)
	local args_t = getArgs(frame,
		{
		parentFirst= true,														-- parameters in the template override parameters set in the {{#invoke:}}
		valueFunc = function (key, value)
			if ((cfg.templates_t.langx == base_template) and 2 or 1) == key then	-- the 'text' positional parameter; 1 for {{lang-??}}, 2 for {{langx}}; do not trim wite space
				return value;													-- return untrimmed 'text' positional parameter
			elseif value then													-- all other values: if the value is not nil
				value = mw.text.trim (value);									-- trim whitespace
				if '' ~= value then												-- empty string when value was only whitespace
					return value;
				end
			end
			return nil;															-- value was empty or contained only whitespace
		end																		-- end of valueFunc
	});

	return args_t;
end


--[[--------------------------&lt; L A N G _ X X _ I T A L I C &gt;--------------------------------------------------

Entry point for those {{lang-??}} templates that call lang_xx_italic(). Sets the initial style state to italic.

]]

local function lang_xx_italic (frame)
	local args = lang_xx_args_get (frame, cfg.templates_t.langxx);
	args.fn = nil;																-- unset because not supported but this function might have been called by {{lang|fn=lang_xx_italic|...}}
	
	local msg = parameter_validate (args, cfg.templates_t.langxx);				-- verify that all supplied parameters are supported by {{lang-??}}
	if msg then
		return make_error_msg (msg, args, cfg.templates_t.langxx);				-- when template has unsupported params, abandon with error message
	end

	initial_style_state = 'italic';
	return _lang_xx (args, cfg.templates_t.langxx) .. '[[Category:Pages using Lang-xx templates]]';	-- temporary category
end


--[[--------------------------&lt; _ L A N G _ X X _ I T A L I C &gt;------------------------------------------------

Entry point from another module. Sets the initial style state to italic.

]]

local function _lang_xx_italic (args)
	initial_style_state = 'italic';
	return _lang_xx (args, cfg.templates_t.langxx);
end


--[[--------------------------&lt; L A N G _ X X _ I N H E R I T &gt;------------------------------------------------

Entry point for those {{lang-??}} templates that call lang_xx_inherit(). Sets the initial style state to inherit.

]]

local function lang_xx_inherit (frame)
	local args = lang_xx_args_get (frame, cfg.templates_t.langxx);
	args.fn = nil;																-- unset because not supported but this function might have been called by {{lang|fn=lang_xx_inherit|...}}

	local msg = parameter_validate (args, cfg.templates_t.langxx);				-- verify that all supplied parameters are supported by {{lang-??}}
	if msg then
		return make_error_msg (msg, args, cfg.templates_t.langxx);				-- when template has unsupported params, abandon with error message
	end

	initial_style_state = 'inherit';
	return _lang_xx (args, cfg.templates_t.langxx) .. '[[Category:Pages using Lang-xx templates]]';	-- temporary category
end


--[[--------------------------&lt; _ L A N G _ X X _ I N H E R I T &gt;----------------------------------------------

Entry point from another module. Sets the initial style state to inherit.

]]

local function _lang_xx_inherit (args)
	initial_style_state = 'inherit';
	return _lang_xx (args, cfg.templates_t.langxx);
end


--[[--------------------------&lt; _ L A N G X &gt;------------------------------------------------------------------

Entry point from another module.

]]

local function _langx (args_t)
	local langx_data = mw.loadData ('Module:Lang/langx');						-- get necessary data 
	local rtl_t = langx_data.rtl_t;												-- get list of language tags for languages that are rendered right-to-left
	local link_t = langx_data.link_t;											-- get list of language tags for {{lang-??}} templates that set |link=&lt;something&gt;
	local size_t = langx_data.size_t;											-- get list of language tags for {{lang-??}} templates that set |size=&lt;something&gt;

	local msg = parameter_validate (args_t, cfg.templates_t.langx);
	if msg then
		return make_error_msg (msg, args_t, cfg.templates_t.langx);
	end

	args_t.code = args_t[1] or args_t.code;										-- get the language tag; must be {{{1}}} or |code=
	if not args_t.code then
		return make_error_msg (cfg.get_ietf_parts_t.missing_lang_tag, args_t, cfg.templates_t.langx);
	end
	
	args_t.rtl = args_t.rtl or (rtl_t[args_t.code] and cfg.keywords_t.affirmative);	-- prefer |rtl= in template call, use rtl_t else
	args_t.link = args_t.link or link_t[args_t.code];							-- prefer |link= in template call, use link_t felse
	args_t.size = args_t.size or size_t[args_t.code];							-- prefer |size= in template call, use size_t else
	
	args_t[1] = nil;															-- unset to mimic {{lang-??}} templates which set |code=xx

	local lang_subtag = args_t.code;											-- use only the base language subtag for unsupported tag test; some args_t.code are modified by |script= etc
	return _lang_xx (args_t, cfg.templates_t.langx);
end


--[[--------------------------&lt; L A N G X &gt;--------------------------------------------------------------------

Entry point for {{langx}}.

this function calls _lang_xx() to render non-English text. The {{lang-??}} templates have three positional paramters
but {{langx}} has four:

				|  1	|  2		|  3		|  4	
	{{lang-xx	|&lt;text&gt;	|&lt;xlit&gt;		|&lt;xlat&gt;		}}
	{{langx		|&lt;tag&gt;	|&lt;text&gt;		|&lt;xlit&gt;		|&lt;xlat&gt;		}}

The calls to lang_xx_args_get() and _lang_xx() use 'langx' as a flag for those functions to select the proper
positional parameters.

{{lang-??}} depends on the calling template to select 'inherit' or 'italic' to establish the default rendering.

{{langx}} can't do that.  The initial version of {{langx}} relied on a list of language tags (inherit_t in ~/langx)
scraped from those {{lang-??}} templates that call lang_xx_inherit() to render text in upright font. langx() now
uses auto-italics code adapted from {{lang}} (doesn't support poem tags).

]]

local function langx (frame)
	local args_t = lang_xx_args_get (frame, cfg.templates_t.langx);				-- get the arguments; 'langx' is the &lt;base_template&gt; used to decide which positional param is 'text', 'translit', 'lit'
	
	return _langx (args_t);
end


--[[--------------------------&lt; _ I S _ I E T F _ T A G &gt;------------------------------------------------------

Returns true when a language name associated with IETF language tag exists; nil else.  IETF language tag must be valid.

All code combinations supported by {{lang}} and the {{lang-??}} templates are supported by this function.

Module entry point from another module.

]]

local function _is_ietf_tag (tag)												-- entry point when this module is require()d into another
	local c, s, r, v, p, err;													-- code, script, region, variant, private, error message
	c, s, r, v, p, err = get_ietf_parts (tag);									-- disassemble tag into constituent part and validate

	return ((c and not err) and true) or nil;									-- return true when code portion has a value without error message; nil else
end


--[[--------------------------&lt; I S _ I E T F _ T A G &gt;--------------------------------------------------------

Module entry point from an {{#invoke:}}.

]]

local function is_ietf_tag (frame)
	return _is_ietf_tag (getArgs (frame)[1]);									-- args[1] is the IETF language tag to be tested; also get parent frame
end


--[[--------------------------&lt; I S _ I E T F _ T A G _ F R A M E &gt;--------------------------------------------

Module entry point from an {{#invoke:}}; same as is_ietf_tag() except does not get parameters from the parent
(template) frame.  This function not useful when called by {{lang|fn=is_ietf_tag_frame|&lt;tag&gt;}} because &lt;tag&gt;
is in the parent frame.

]]

local function is_ietf_tag_frame (frame)
	return _is_ietf_tag (getArgs (frame, {frameOnly = true,})[1]);				-- args[1] is the IETF language tag to be tested; do not get parent frame
end


--[[--------------------------&lt; _ N A M E _ F R O M _ T A G &gt;--------------------------------------------------

Returns language name associated with IETF language tag if valid; error message else.

All code combinations supported by {{lang}} and the {{lang-??}} templates are supported by this function.

Set invoke's |link= parameter to yes to get wikilinked version of the language name.

Module entry point from another module.

]]

local function _name_from_tag (args)
	local subtags = {};															-- IETF subtags script, region, variant, and private
	local raw_code = args[1];													-- save a copy of the input IETF subtag
	local link = cfg.keywords_t.affirmative == args['link'];					-- make a boolean
	local label = args.label;
	local code;																	-- the language code
	local msg;																	-- gets an error message if IETF language tag is malformed or invalid
	local language_name = '';
	
	code, subtags.script, subtags.region, subtags.variant, subtags.private, msg = get_ietf_parts (raw_code);
	if msg then
		local template = (args['template'] and table.concat ({'{{', args['template'], '}}: '})) or '';	-- make template name (if provided by the template)
		return make_error_span (template, msg);
	end

	raw_code = format_ietf_tag (code, subtags.script, subtags.region, subtags.variant, subtags.private);	-- format to recommended subtag styles; private omitted because private
	language_name = language_name_get (raw_code, code);							-- get language name; try IETF tag first, then code w/o variant then code w/ variant

	if 'yes' ~= args.raw then
		language_name = language_name:gsub ('%s+%b()', '');						-- remove IANA parenthetical disambiguators or qualifiers from names that have them
	end

	if link then																-- when |link=yes, wikilink the language name
		if mw.ustring.find (language_name, 'languages', 1, true) then
			language_name = make_wikilink (language_name, label);				-- collective language name uses simple wikilink
		elseif lang_data.article_name[raw_code:lower()] then					-- is IETF tag in article name override?
			language_name = make_wikilink (lang_data.article_name[raw_code:lower()], label or language_name);	-- language name with wikilink from override data
		elseif lang_data.article_name[code] then								-- is language tag in article name override?
			language_name = make_wikilink (lang_data.article_name[code], label or language_name);	-- language name with wikilink from override data
		else
			language_name = make_wikilink (substitute ('$1 $2', {language_name, cfg.misc_text_t.language}), label or language_name);	-- language name with wikilink
		end
	end

	return language_name;
end


--[[--------------------------&lt; N A M E _ F R O M _ T A G &gt;----------------------------------------------------

Module entry point from an {{#invoke:}}.

]]

local function name_from_tag (frame)											-- entry point from an {{#invoke:lang|name_from_tag|&lt;IETF tag&gt;|link=&lt;yes&gt;|template=&lt;template name&gt;}}
	return _name_from_tag (getArgs(frame))										-- pass-on the args table, nothing else; getArgs() so we also get parent frame
end


--[[--------------------------&lt; _ T A G _ F R O M _ N A M E &gt;--------------------------------------------------

Returns the IETF language tag associated with the language name.  Spelling of language name must be correct
according to the spelling in the source tables.  When a standard language name has a parenthetical disambiguator,
that disambiguator must be omitted (they are not present in the data name-to-tag tables).

Module entry point from another module.

]]

local function _tag_from_name (args)											-- entry point from another module
	local msg;

	if args[1] and '' ~= args[1] then
		local data = mw.loadData ('Module:Lang/tag from name');					-- get the reversed data tables TODO: change when going live
		local lang = args[1]:lower();											-- allow any-case for the language name (speeling must till be correct)
		local tag = data.rev_override_table[lang] or data.rev_lang_table[lang] or data.rev_lang_dep_table[lang];	-- get the code; look first in the override then in the standard

		if tag then
			return tag, true;													-- language name found so return tag and done; second return used by is_lang_name()
		else
			msg = substitute (cfg.tag_from_name_t.lang_not_found, {args[1]});	-- language name not found, error message
		end
	else
		msg = cfg.tag_from_name_t.missing_lang_name;							-- language name not found, error message
	end

	local template = '';
	if args.template and '' ~= args.template then
		template = table.concat ({'{{', args['template'], '}}: '});				-- make template name (if provided by the template)
	end
	return make_error_span (template, msg);

end


--[[--------------------------&lt; T A G _ F R O M _ N A M E &gt;----------------------------------------------------

Module entry point from an {{#invoke:}}.

]]

local function tag_from_name (frame)											-- entry point from an {{#invoke:lang|tag_from_name|&lt;language name&gt;|link=&lt;yes&gt;|template=&lt;template name&gt;}}
	local result, _ = _tag_from_name (getArgs(frame))							-- pass-on the args table, nothing else; getArgs() so we also get parent frame; supress second return used by is_lang_name()
	return result;		
end


--[[--------------------------&lt; I S _ L A N G _ N A M E &gt;------------------------------------------------------

Module entry point from an {{#invoke:}}.

]]

local function is_lang_name (frame)
	local _, result = _tag_from_name (getArgs(frame))							-- pass-on the args table, nothing else; getArgs() so we also get parent frame; supress second return used by tag_from_name()
	return result and true or nil;		
end


--[[--------------------------&lt; _ X L I T &gt;--------------------------------------------------------------------

Module entry point from another module.

]]

local function _xlit (args)
	local title_table = lang_data.translit_title_table;							-- table of transliteration standards and the language codes and scripts that apply to those standards
	local language_name;														-- language name that matches language code; used for tool tip
	local translit;																-- transliterated text to display
	local script;																-- IANA script
	local msg;																	-- for when called functions return an error message
	local template = args.template or cfg.templates_t.transliteration;

	maint_cats = {};															-- initialize because when this module required into another module, these only declared once so only initialzed once
	maint_msgs = {};
	
	if is_set (args[3]) then													-- [3] set when {{transliteration|code|standard|text}}
		args.text = args[3];													-- get the transliterated text
		args.translit_std = args[2] and args[2]:lower();						-- get the standard; lower case for table indexing

		if not title_table[args.translit_std] then
			return make_error_msg (substitute (cfg.transl_t.unrecog_xlit_std, {args.translit_std}), args, template);
		end
	else
		if is_set (args[2]) then												-- [2] set when {{transliteration|code|text}}
			args.text = args[2];												-- get the transliterated text
		else
			if args[1] and (args[1]:match ('^%a%a%a?%a?$') or					-- args[2] missing; is args[1] a language or script tag or is it the transliterated text?
				args[1]:match ('^%a%a%a?%-x%-')) then							-- or is args[1] a private-use tag
					return make_error_msg (cfg.transl_t.no_text, args, template);	-- args[1] is a code so we're missing text
			else
				args.text = args[1];											-- args[1] is not a code so we're missing that; assign args.text for error message
				return make_error_msg (cfg.transl_t.missing_lang_scr, args, template);
			end
		end
	end

	if is_set (args[1]) then													-- IANA language code used for HTML lang= attribute; or ISO 15924 script code
		if args[1]:match ('^%a%a%a?%a?$') or args[1]:match ('^%a%a%a?%-x%-') then	-- args[1] has correct form?
			args.code = args[1]:lower();										-- use the language/script code; only (2, 3, or 4 alpha characters) or private-use; lower case because table indexes are lower case
		else
			return make_error_msg (substitute (cfg.transl_t.unrecog_lang_scr, {args[1]}), args, template);	-- invalid language / script code
		end
	else
		return make_error_msg (cfg.transl_t.missing_lang_scr, args, template);	-- missing language / script code so quit
	end

	local is_latn_text, pos, char;
	is_latn_text, args.text, pos, char= is_latin (args.text, args.code);		-- is latn text? strip accept-as-written markup
	if not is_latn_text then													-- when text is not latn
		return make_error_msg (substitute (cfg.lang_xx_t.translit_nonlatn, {pos, char}), args, template);	-- abandon with error message
	end


	args.italic, msg = validate_italic (args);
	if msg then
		return make_error_msg (msg, args, template);
	end
	
	if 'italic' == args.italic then												-- 'italic' when |italic=yes; because that is same as absent or not set and |italic=default
		args.italic = nil;														-- set to nil; 
	end

	args.engvar = cfg.engvar_sel_t[args.engvar] or cfg.default_engvar;			-- |engvar= when valid; cfg.default_engvar else

	if override_table[args.code] then											-- is code a language code defined in the override table?
		language_name = override_table[args.code];
		args.code = args.code:match ('^%a%a%a?');								-- if private use, strip all but language subtag
	elseif lang_table[args.code] then											-- is code a language code defined in the standard language code tables?
		language_name = lang_table[args.code];
	elseif lang_dep_table[args.code] then										-- is code a language code defined in the deprecated language code tables?
		language_name = lang_dep_table[args.code];
	elseif script_table[args.code] then											-- if here, code is not a language code; is it a script code?
		language_name = script_table[args.code];
		script = args.code;														-- code was an ISO 15924 script so use that instead
		args.code = '';															-- unset because not a language code
	else
		return make_error_msg (substitute (cfg.transl_t.unrecog_lang_scr, {args.code}), args, template);	-- invalid language / script code
	end
																				-- here only when all parameters passed to make_translit() are valid
	return make_translit (args.code, language_name, args.text, args.translit_std, script, args.italic, args.engvar);
end


--[[--------------------------&lt; X L I T &gt;----------------------------------------------------------------------

Module entry point from an {{#invoke:}}.

]]

local function xlit (frame)
	return _xlit (getArgs(frame));
end


--[[--------------------------&lt; C A T E G O R Y _ F R O M _ T A G &gt;--------------------------------------------

Returns category name associated with IETF language tag if valid; error message else.

All code combinations supported by {{lang}} and the {{lang-??}} templates are supported by this function.

Module entry point from another module.

]]

local function _category_from_tag (args_t)
	local subtags = {};															-- IETF subtags script, region, variant, and private
	local raw_code = args_t[1];													-- save a copy of the input IETF subtag
	local link = cfg.keywords_t.affirmative == args_t.link;						-- make a boolean
	local label = args_t.label;
	local code;																	-- the language code
	local msg;																	-- gets an error message if IETF language tag is malformed or invalid
	local category_name = '';
	
	code, subtags.script, subtags.region, subtags.variant, subtags.private, msg = get_ietf_parts (raw_code);
	if msg then
		local template = (args_t.template and table.concat ({'{{', args_t.template, '}}: '})) or '';	-- make template name (if provided by the template)
		return make_error_span (template, msg);
	end

	raw_code = format_ietf_tag (code, subtags.script, subtags.region, subtags.variant, subtags.private);	-- format to recommended subtag styles; private omitted because private
	category_name = language_name_get (raw_code, code);							-- get language name; try IETF tag first, then code w/o variant then code w/ variant
	category_name = make_category (code, category_name, nil, true):gsub ('[%[%]]', '');

	if link then
		return table.concat ({'[[:', category_name, ']]'});
	else
		return category_name;
	end
end


--[[--------------------------&lt; C A T E G O R Y _ F R O M _ T A G &gt;--------------------------------------------

Module entry point from an {{#invoke:}}.

]]

local function category_from_tag (frame)										-- entry point from an {{#invoke:lang|category_from_tag|&lt;IETF tag&gt;|template=&lt;template name&gt;}}
	return _category_from_tag (getArgs (frame));								-- pass-on the args table, nothing else; getArgs() so we also get parent frame
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	category_from_tag = category_from_tag,										-- frame entry points when this module is #invoke:ed into templates/wikitext
	lang = lang,																-- entry point for {{lang}}
	langx = langx,																-- entry point for {{langx}}
	lang_xx_inherit = lang_xx_inherit,											-- entry points for {{lang-??}}
	lang_xx_italic = lang_xx_italic,
	is_ietf_tag = is_ietf_tag,
	is_ietf_tag_frame = is_ietf_tag_frame,
	is_lang_name = is_lang_name,
	tag_from_name = tag_from_name,												-- returns IETF tag associated with language name
	name_from_tag = name_from_tag,												-- used for template documentation; possible use in ISO 639 name from code templates
	xlit = xlit,																-- entry point for {{transliteration}}
	
	_category_from_tag = _category_from_tag,									-- API entry points when this module is require()d into other modules
	_lang = _lang,
	_langx = _langx,
	_lang_xx_inherit = _lang_xx_inherit,
	_lang_xx_italic = _lang_xx_italic,
	_is_ietf_tag = _is_ietf_tag,
	get_ietf_parts = get_ietf_parts,
	_tag_from_name = _tag_from_name, 
	_name_from_tag = _name_from_tag,
	_xlit = _xlit,
	_translation_make = translation_make,
	};</text>
      <sha1>ebtasdwni0hx25j8cjppzt39wan50qg</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Unicode data</title>
    <ns>828</ns>
    <id>108</id>
    <revision>
      <id>204</id>
      <parentid>203</parentid>
      <timestamp>2025-07-09T04:31:39Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>203</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="17447" sha1="6p4mgnjz169i7z6oswqh9nvzd3szcwu" xml:space="preserve">local p = {}

local floor = math.floor

local function errorf(level, ...)
	if type(level) == "number" then
		return error(string.format(...), level + 1)
	else -- level is actually the format string.
		return error(string.format(level, ...), 2)
	end
end

local function binary_range_search(codepoint, ranges)
	local low, mid, high
	low, high = 1, ranges.length or require "Module:TableTools".length(ranges)
	while low &lt;= high do
		mid = floor((low + high) / 2)
		local range = ranges[mid]
		if codepoint &lt; range[1] then
			high = mid - 1
		elseif codepoint &lt;= range[2] then
			return range, mid
		else
			low = mid + 1
		end
	end
	return nil, mid
end
p.binary_range_search = binary_range_search

--[[
local function linear_range_search(codepoint, ranges)
	for i, range in ipairs(ranges) do
		if range[1] &lt;= codepoint and codepoint &lt;= range[2] then
			return range
		end
	end
end
--]]

-- Load a module by indexing "loader" with the name of the module minus the
-- "Module:Unicode data/" part. For instance, loader.blocks returns
-- [[Module:Unicode data/blocks]]. If a module cannot be loaded, false will be
-- returned.
local loader = setmetatable({}, {
	__index = function (self, key)
		local success, data = pcall(mw.loadData, "Module:Unicode data/" .. key)
		if not success then
			data = false
		end
		self[key] = data
		return data
	end
})

-- For the algorithm used to generate Hangul Syllable names,
-- see "Hangul Syllable Name Generation" in section 3.12 of the
-- Unicode Specification:
-- https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf
-- binary_range_search assumes these are ordered by codepoint. Do not place them in a random order!
local name_hooks = {
	{     0x00,     0x1F, "&lt;control-%04X&gt;" }, -- C0 control characters
	{     0x7F,     0x9F, "&lt;control-%04X&gt;" }, -- DEL and C1 control characters
	{   0x3400,   0x4DBF, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension A
	{   0x4E00,   0x9FFF, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph
	{   0xAC00,   0xD7A3, function (codepoint) -- Hangul Syllables
		local Hangul_data = loader.Hangul
		local syllable_index = codepoint - 0xAC00

		return ("HANGUL SYLLABLE %s%s%s"):format(
			Hangul_data.leads[floor(syllable_index / Hangul_data.final_count)],
			Hangul_data.vowels[floor((syllable_index % Hangul_data.final_count)
				/ Hangul_data.trail_count)],
			Hangul_data.trails[syllable_index % Hangul_data.trail_count]
		)
	end },
	-- High Surrogates, High Private Use Surrogates, Low Surrogates
	{   0xD800,   0xDFFF, "&lt;surrogate-%04X&gt;" },
	{   0xE000,   0xF8FF, "&lt;private-use-%04X&gt;" }, -- Private Use
	-- CJK Compatibility Ideographs
	{   0xF900,   0xFA6D, "CJK COMPATIBILITY IDEOGRAPH-%04X" },
	{   0xFA70,   0xFAD9, "CJK COMPATIBILITY IDEOGRAPH-%04X" },
	{  0x17000,  0x187F7, "TANGUT IDEOGRAPH-%04X" }, -- Tangut Ideograph
	{  0x18800,  0x18AFF, function (codepoint)
		return ("TANGUT COMPONENT-%03d"):format(codepoint - 0x187FF)
	end },
	{  0x18D00,  0x18D08, "TANGUT IDEOGRAPH-%04X" }, -- Tangut Ideograph Supplement
	{  0x1B170,  0x1B2FB, "NUSHU CHARACTER-%04X" }, -- Nushu
	{  0x20000,  0x2A6DF, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension B
	{  0x2A700,  0x2B739, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension C
	{  0x2B740,  0x2B81D, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension D
	{  0x2B820,  0x2CEA1, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension E
	{  0x2CEB0,  0x2EBE0, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension F
	{  0x2EBF0,  0x2EE5D, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension I
	{  0x2F800,  0x2FA1D, "CJK COMPATIBILITY IDEOGRAPH-%04X" }, -- CJK Compatibility Ideographs Supplement (Supplementary Ideographic Plane)
	{  0x30000,  0x3134A, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension G
	{  0x31350,  0x323AF, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension H
	{  0xE0100,  0xE01EF, function (codepoint) -- Variation Selectors Supplement
		return ("VARIATION SELECTOR-%d"):format(codepoint - 0xE0100 + 17)
	end},
	{  0xF0000,  0xFFFFD, "&lt;private-use-%04X&gt;" }, -- Plane 15 Private Use
	{ 0x100000, 0x10FFFD, "&lt;private-use-%04X&gt;" }  -- Plane 16 Private Use
}
name_hooks.length = #name_hooks

local name_range_cache

local function generate_name(data, codepoint)
	if type(data) == "string" then
		return data:format(codepoint)
	else
		return data(codepoint)
	end
end

--[[
-- Checks that the code point is a number and in range.
-- Does not check whether code point is an integer.
-- Not used
local function check_codepoint(funcName, argIdx, val)
	require 'libraryUtil'.checkType(funcName, argIdx, val, 'number')
	if codepoint &lt; 0 or 0x10FFFF &lt; codepoint then
		errorf("Codepoint %04X out of range", codepoint)
	end
end
--]]

function p.is_noncharacter(codepoint)
	-- U+FDD0-U+FDEF and all code points ending in FFFE or FFFF are Unassigned
	-- (Cn) and specifically noncharacters:

	-- https://www.unicode.org/faq/private_use.html#nonchar4
	return 0xFDD0 &lt;= codepoint and (codepoint &lt;= 0xFDEF
			or floor(codepoint % 0x10000) &gt;= 0xFFFE)
end

-- https://www.unicode.org/versions/Unicode11.0.0/ch04.pdf, section 4.8
function p.lookup_name(codepoint)
	if p.is_noncharacter(codepoint) then
		return ("&lt;noncharacter-%04X&gt;"):format(codepoint)
	end

	if name_range_cache -- Check if previously used "name hook" applies to this code point.
			and codepoint &gt;= name_range_cache[1]
			and codepoint &lt;= name_range_cache[2] then
		return generate_name(name_range_cache[3], codepoint)
	end
	
	local range = binary_range_search(codepoint, name_hooks)
	if range then
		name_range_cache = range
		return generate_name(range[3], codepoint)
	end

	local data = loader[('names/%03X'):format(codepoint / 0x1000)]
	
	if data and data[codepoint] then
		return data[codepoint]
	
	-- Unassigned (Cn) consists of noncharacters and reserved characters.
	-- The character has been established not to be a noncharacter,
	-- and if it were assigned, its name would already been retrieved,
	-- so it must be reserved.
	else
		return ("&lt;reserved-%04X&gt;"):format(codepoint)
	end
end

function p.lookup_image(codepoint)
	local data = loader[('images/%03X'):format(codepoint / 0x1000)]
	
	if data then
		return data[codepoint]
	end
end

local planes = {
	[ 0] = "Basic Multilingual Plane";
	[ 1] = "Supplementary Multilingual Plane";
	[ 2] = "Supplementary Ideographic Plane";
	[ 3] = "Tertiary Ideographic Plane";
	[14] = "Supplementary Special-purpose Plane";
	[15] = "Supplementary Private Use Area-A";
	[16] = "Supplementary Private Use Area-B";
}

-- Load [[Module:Unicode data/blocks]] if needed and assign it to this variable.
local blocks

local function block_iter(blocks, i)
	i = i + 1
	local data = blocks[i]
	if data then
		 -- Unpack doesn't work on tables loaded with mw.loadData.
		return i, data[1], data[2], data[3]
	end
end

-- An ipairs-type iterator generator for the list of blocks.
function p.enum_blocks()
	local blocks = loader.blocks
	return block_iter, blocks, 0
end

function p.lookup_plane(codepoint)
	local i = floor(codepoint / 0x10000)
	return planes[i] or ("Plane %u"):format(i)
end

function p.lookup_block(codepoint)
	local blocks = loader.blocks
	local range = binary_range_search(codepoint, blocks)
	if range then
		return range[3]
	else
		return "No Block"
	end
end

function p.get_block_info(name)
	for i, block in ipairs(loader.blocks) do
		if block[3] == name then
			return block
		end
	end
end

function p.is_valid_pagename(pagename)
	local has_nonws = false

	for cp in mw.ustring.gcodepoint(pagename) do
		if (cp == 0x0023) -- #
		or (cp == 0x005B) -- [
		or (cp == 0x005D) -- ]
		or (cp == 0x007B) -- {
		or (cp == 0x007C) -- |
		or (cp == 0x007D) -- }
		or (cp == 0x180E) -- MONGOLIAN VOWEL SEPARATOR
		or ((cp &gt;= 0x2000) and (cp &lt;= 0x200A)) -- spaces in General Punctuation block
		or (cp == 0xFFFD) -- REPLACEMENT CHARACTER
		then
			return false
		end

		local printable, result = p.is_printable(cp)
		if not printable then
			return false
		end

		if result ~= "space-separator" then
			has_nonws = true
		end
	end

	return has_nonws
end

local function manual_unpack(what, from)
	if what[from + 1] == nil then
		return what[from]
	end
	
	local result = {}
	from = from or 1
	for i, item in ipairs(what) do
		if i &gt;= from then
			table.insert(result, item)
		end
	end
	return unpack(result)
end

local function compare_ranges(range1, range2)
	return range1[1] &lt; range2[1]
end

-- Creates a function to look up data in a module that contains "singles" (a
-- code point-to-data map) and "ranges" (an array containing arrays that contain
-- the low and high code points of a range and the data associated with that
-- range).
-- "loader" loads and returns the "singles" and "ranges" tables.
-- "match_func" is passed the code point and either the data or the "dots", and
-- generates the final result of the function.
-- The varargs ("dots") describes the default data to be returned if there wasn't
-- a match.
-- In case the function is used more than once, "cache" saves ranges that have
-- already been found to match, or a range whose data is the default if there
-- was no match.
local function memo_lookup(data_module_subpage, match_func, ...)
	local dots = { ... }
	local cache = {}
	local singles, ranges

	return function (codepoint)
		if not singles then
			local data_module = loader[data_module_subpage]
			singles, ranges = data_module.singles, data_module.ranges
		end

		if singles[codepoint] then
			return match_func(codepoint, singles[codepoint])
		end

		local range = binary_range_search(codepoint, cache)
		if range then
			return match_func(codepoint, manual_unpack(range, 3))
		end
		
		local range, index = binary_range_search(codepoint, ranges)
		if range then
			table.insert(cache, range)
			table.sort(cache, compare_ranges)
			return match_func(codepoint, manual_unpack(range, 3))
		end
		
		if ranges[index] then
			local dots_range
			if codepoint &gt; ranges[index][2] then
				dots_range = {
					ranges[index][2] + 1,
					ranges[index + 1] and ranges[index + 1][1] - 1 or 0x10FFFF,
					unpack(dots)
				}
			else -- codepoint &lt; range[index][1]
				dots_range = {
					ranges[index - 1] and ranges[index - 1][2] + 1 or 0,
					ranges[index][1] - 1,
					unpack(dots)
				}
			end
			table.sort(cache, compare_ranges)
		end
		
		return match_func(codepoint)
	end
end

-- Get a code point's combining class value in [[Module:Unicode data/combining]],
-- and return whether this value is not zero. Zero is assigned as the default
-- if the combining class value is not found in this data module.
-- That is, return true if character is combining, or false if it is not.
-- See https://www.unicode.org/reports/tr44/#Canonical_Combining_Class_Values for
-- more information.
p.is_combining = memo_lookup(
	"combining",
	function (codepoint, combining_class)
		return combining_class and combining_class ~= 0 or false
	end,
	0)

function p.add_dotted_circle(str)
	return (mw.ustring.gsub(str, ".",
		function(char)
			if p.is_combining(mw.ustring.codepoint(char)) then
				return '◌' .. char
			end
		end))
end

local lookup_control = memo_lookup(
	"control",
	function (codepoint, ccc)
		return ccc or "assigned"
	end,
	"assigned")
p.lookup_control = lookup_control

function p.is_assigned(codepoint)
	return lookup_control(codepoint) ~= "unassigned"
end

function p.is_printable(codepoint)
	local result = lookup_control(codepoint)
	return (result == "assigned") or (result == "space-separator"), result
end

function p.is_whitespace(codepoint)
	local result = lookup_control(codepoint)
	return (result == "space-separator"), result
end

p.lookup_category = memo_lookup(
	"category",
	function (codepoint, category)
		return category
	end,
	"Cn")

local lookup_script = memo_lookup(
	"scripts",
	function (codepoint, script_code)
		return script_code or 'Zzzz'
	end,
	"Zzzz")
p.lookup_script = lookup_script

function p.get_best_script(str)
	-- Check type of argument, because mw.text.decode coerces numbers to strings!
	require "libraryUtil".checkType("get_best_script", 1, str, "string")
	
	-- Convert HTML character references (including named character references,
	-- or character entities) to characters.
	str = mw.text.decode(str, true)
	
	local scripts = {}
	for codepoint in mw.ustring.gcodepoint(str) do
		local script = lookup_script(codepoint)
		
		-- Ignore "Inherited", "Undetermined", or "Uncoded" scripts.
		if not (script == "Zyyy" or script == "Zinh" or script == "Zzzz") then
			scripts[script] = true
		end
	end
	
	-- If scripts does not contain two or more keys,
	-- return first and only key (script code) in table.
	if not next(scripts, next(scripts)) then
		return next(scripts)
	end -- else return majority script, or else "Zzzz"?
end

function p.is_Latin(str)
	require "libraryUtil".checkType("get_best_script", 1, str, "string")
	str = mw.text.decode(str, true)
	
	-- Search for the leading bytes that introduce the UTF-8 encoding of the
	-- code points U+0340-U+10FFFF. If they are not found and there is at least
	-- one Latin-script character, the string counts as Latin, because the rest
	-- of the characters can only be Zyyy, Zinh, and Zzzz.
	-- The only scripts found below U+0370 (the first code point of the Greek
	-- and Coptic block) are Latn, Zyyy, Zinh, and Zzzz.
	-- See the codepage in the [[UTF-8]] article.
	if not str:find "[\205-\244]" then
		for codepoint in mw.ustring.gcodepoint(str) do
			if lookup_script(codepoint) == "Latn" then
				return true
			end
		end
	end
	
	local Latn = false
	local i = 0;																-- indexer for use in error messages
	
	for codepoint in mw.ustring.gcodepoint(str) do
		i = i + 1;																-- bump the indexer
		local script = lookup_script(codepoint)
		
		if script == "Latn" then
			Latn = true
		elseif not (script == "Zyyy" or script == "Zinh"
				or script == "Zzzz") then
			return false, i														-- abandon as not Latn; identify the offending character's position
		end
	end
	
	return Latn, (not Latn and i) or nil										-- when &lt;Latn&gt; false, return offending charactor's position as second return value; nil else
end

-- Checks that a string contains only characters belonging to right-to-left
-- scripts, or characters of ignorable scripts.
function p.is_rtl(str)
	require "libraryUtil".checkType("get_best_script", 1, str, "string")
	str = mw.text.decode(str, true)
	
	-- Search for the leading bytes that introduce the UTF-8 encoding of the
	-- code points U+0580-U+10FFFF. If they are not found, the string can only
	-- have characters from a left-to-right script, because the first code point
	-- in a right-to-left script is U+0591, in the Hebrew block.
	if not str:find "[\214-\244]" then
		return false
	end
	
	local result = false
	local rtl = loader.scripts.rtl
	for codepoint in mw.ustring.gcodepoint(str) do
		local script = lookup_script(codepoint)
		
		if rtl[script] then
			result = true
		elseif not (script == "Zyyy" or script == "Zinh"
				or script == "Zzzz") then
			return false
		end
	end
	
	return result
end


--[[--------------------------&lt; I S _ R T L _ F R A M E &gt;------------------------------------------------------

external entry from an {{#invoke:}} to determine if a string of text is rtl.  Strips html and html-like tags so
that those tags don't corrupt the is-rtl-is-not-rtl determination; this added for the cases where the rtl text
has &lt;br /&gt; tags.

]]

function p.is_rtl_frame (frame)
	local str = frame.args[1];													-- get the string from the {{#invoke:}} frame
	str = str:gsub ('%b&lt;&gt;', '');												-- strip any html and html-like tags
	return p.is_rtl (str);														-- return if whatever remains rtl; false else
end


local function get_codepoint(args, arg)
	local codepoint_string = args[arg]
		or errorf(2, "Parameter %s is required", tostring(arg))
	local codepoint = tonumber(codepoint_string, 16)
		or errorf(2, "Parameter %s is not a code point in hexadecimal base",
			tostring(arg))
	if not (0 &lt;= codepoint and codepoint &lt;= 0x10FFFF) then
		errorf(2, "code point in parameter %s out of range", tostring(arg))
	end
	return codepoint
end

local function get_func(args, arg, prefix)
	local suffix = args[arg]
		or errorf(2, "Parameter %s is required", tostring(arg))
	suffix = mw.text.trim(suffix)
	local func_name = prefix .. suffix
	local func = p[func_name]
		or errorf(2, "There is no function '%s'", func_name)
	return func
end

-- This function allows any of the "lookup" functions to be invoked. The first
-- parameter is the word after "lookup_"; the second parameter is the code point
-- in hexadecimal base.
function p.lookup(frame)
	local func = get_func(frame.args, 1, "lookup_")
	local codepoint = get_codepoint(frame.args, 2)
	local result = func(codepoint)
	if func == p.lookup_name then
		-- Prevent code point labels such as &lt;control-0000&gt; from being
		-- interpreted as HTML tags.
		result = result:gsub("&lt;", "&amp;lt;")
	end
	return result
end

function p.is(frame)
	local func = get_func(frame.args, 1, "is_")
	
	-- is_Latin and is_valid_pagename take strings.
	if func == p.is_Latin or func == p.is_valid_pagename or func == p.is_rtl then
		return (func(frame.args[2]))
	else -- The rest take code points.
		local codepoint = get_codepoint(frame.args, 2)
		return (func(codepoint)) -- Adjust to one result.
	end
end

function p.lookup_kCantonese(codepoint)
	local data = loader[('Unihan/kCantonese/%02X'):format(floor(codepoint / 0x1000))]
	if data then
		return data[codepoint]
	end
end

return p</text>
      <sha1>6p4mgnjz169i7z6oswqh9nvzd3szcwu</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/data</title>
    <ns>828</ns>
    <id>109</id>
    <revision>
      <id>206</id>
      <parentid>205</parentid>
      <timestamp>2025-07-09T04:31:39Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>205</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="32126" sha1="9fxpox2gqkq2cenl59r8fw3p30srqlt" xml:space="preserve">local lang_obj = mw.language.getContentLanguage();
local this_wiki_lang_tag = lang_obj.code;										-- get this wiki's language tag


--[[--------------------------&lt; L A N G _ N A M E _ T A B L E &gt;------------------------------------------------

primary table of tables that decode:
	lang -&gt; language tags and names
	script -&gt; ISO 15924 script tags
	region -&gt; ISO 3166 region tags
	variant -&gt; IANA registered variant tags
	suppressed -&gt; map of scripts tags and their associated language tags
	
all of these data come from separate modules that are derived from the IANA language-subtag-registry file

key_to_lower() avoids the metatable trap and sets all keys in the subtables to lowercase. Many language codes
have multiple associated names; Module:lang is only concerned with the first name so key_to_lower() only fetches
the first name.

]]

local function key_to_lower (module, src_type)
	local out = {};
	local source_t = (('var_sup' == src_type) and require (module)) or mw.loadData (module);		-- fetch data from this module; require() avoids metatable trap for variant data

	if 'var_sup' == src_type then
		for k, v in pairs (source_t) do
			out[k:lower()] = v;													-- for variant and suppressed everything is needed
		end

	elseif 'lang' == src_type and source_t.active then							-- for ~/iana_languages (active)
		for k, v in pairs (source_t.active) do
			out[k:lower()] = v[1];												-- ignore multiple names; take first name only
		end

	elseif 'lang_dep' == src_type and source_t.deprecated then					-- for ~/iana_languages (deprecated)
		for k, v in pairs (source_t.deprecated) do
			out[k:lower()] = v[1];												-- ignore multiple names; take first name only
		end

	else																		-- here for all other sources
		for k, v in pairs (source_t) do
			out[k:lower()] = v[1];												-- ignore multiple names; take first name only
		end
	end
	return out;
end

local lang_name_table_t = {
	lang = key_to_lower ('Module:Lang/data/iana languages', 'lang'),
	lang_dep = key_to_lower ('Module:Lang/data/iana languages', 'lang_dep'),
	script = key_to_lower ('Module:Lang/data/iana scripts'),					-- script keys are capitalized; set to lower
	region = key_to_lower ('Module:Lang/data/iana regions'),					-- region keys are uppercase; set to lower
	variant = key_to_lower ('Module:Lang/data/iana variants', 'var_sup'),
	suppressed = key_to_lower ('Module:Lang/data/iana suppressed scripts', 'var_sup'),	-- script keys are capitalized; set to lower
	}


--[[--------------------------&lt; I 1 8 N   M E D I A W I K I   O V E R R I D E &gt;--------------------------------

For internationalization; not used at en.wiki

The language names taken from the IANA language-subtag-registry file are given in English. That may not be ideal.
Translating ~8,000 language names is also not ideal.  MediaWiki maintains (much) shorter lists of language names
in most languages for which there is a Wikipedia edition.  When desired, Module:Lang can use the MediaWiki 
language list for the local language.

Caveat lector: the list of MediaWiki language names for your language may not be complete or may not exist at all.
When incomplete, MediaWiki's list will 'fall back' to another language (typically English).  When that happens
add an appropriate entry to the override table below.

Caveat lector: the list of MediaWiki language names for your language may not be correct.  At en.wiki, the
MediaWiki language names do not agree with the IANA language names for these ISO 639-1 tags.  Often it is simply
spelling differences:
	bh: IANA: Bihari languages MW: Bhojpuri – the ISO 639-3 tag for Bhojpuri is bho
	bn: IANA: Bengali MW: Bangla – Bengali is the exonym, Bangla is the endonym
	dv: IANA: Dhivehi MW: Divehi
	el: IANA: Modern Greek MW: Greek
	ht: IANA: Haitian MW: Haitian Creole
	ky: IANA: Kirghiz MW: Kyrgyz
	li: IANA: Limburgan MW: Limburgish
	or: IANA: Oriya MW: Odia
	os: IANA: Ossetian MW: Ossetic
	"pa: IANA: Panjabi MW: Punjabi
	"ps: IANA: Pushto MW: Pashto
	"to: IANA: Tonga MW: Tongan
	"ug: IANA: Uighur MW: Uyghur
use the override table to override language names that are incorrect for your project

To see the list of names that MediaWiki has for your language, enter this in the Debug console:
	=mw.dumpObject (mw.language.fetchLanguageNames ('&lt;tag&gt;', 'all'))
(replacing &lt;tag&gt; with the language tag for your language)

Use of the MediaWiki language names lists is enabled when media_wiki_override_enable is set to boolean true.
	
]]

local media_wiki_override_enable = false;										-- set to true to override IANA names with MediaWiki names; always false at en.wiki
																				-- caveat lector: the list of MediaWiki language names for your language may not be complete or may not exist at all
	if true == media_wiki_override_enable then
		local mw_languages_by_tag_t = mw.language.fetchLanguageNames (this_wiki_lang_tag, 'all');	-- get a table of language tag/name pairs known to MediaWiki
		for tag, name in pairs (mw_languages_by_tag_t) do						-- loop through each tag/name pair in the MediaWiki list
			if lang_name_table_t.lang[tag] then									-- if the tag is in the main list
				lang_name_table_t.lang[tag] = name;								-- overwrite existing name with the name from MediaWiki
			end
		end
	end


--[[--------------------------&lt; O V E R R I D E &gt;--------------------------------------------------------------

Language codes and names in this table override the BCP47 names in lang_name_table.

indexes in this table shall always be lower case

]]

local override = {
------------------------------&lt; I S O _ 6 3 9 - 1 &gt;------------------------------------------------------------

	["ab"] = "Abkhaz",                                                          -- to match en.wiki article name
	["ca-valencia"] = "Valencian",
	["cu"] = "Church Slavonic",													-- 2nd IANA name;
	["de-at"] = "Austrian German",												-- these code-region and code-variant tags to match en.wiki article names
	["de-ch"] = "Swiss Standard German",
	["en-au"] = "Australian English",
	["en-ca"] = "Canadian English",
	["en-emodeng"] = "Early Modern English",
	["en-gb"] = "British English",
	["en-ie"] = "Irish English",
	["en-in"] = "Indian English",
	["en-nz"] = "New Zealand English",
	["en-us"] = "American English",
	["en-za"] = "South African English",
	["fr-ca"] = "Canadian French",
	["fr-gallo"] = "Gallo",
	["fy"] = "West Frisian",													-- Western Frisian
	["mo"] = "Moldovan",														-- Moldavian (deprecated code); to match en.wiki article title
	["nl-be"] = "Flemish",														-- match MediaWiki
	["oc-gascon"] = "Gascon",
	["oc-provenc"] = "Provençal",
	["ps"] = "Pashto",															-- Pushto
	["pt-br"] = "Brazilian Portuguese",											-- match MediaWiki
	["ro-md"] = "Moldovan",														-- 'not deprecated' form
	["ro-cyrl-md"] = "Moldovan",												-- 'not deprecated' form
	["tw-asante"] = "Asante Twi",
	["ug"] = "Uyghur",															-- 2nd IANA name; to match en.wiki article name

-- these ISO 639-1 language-name overrides imported from Module:Language/data/wp_languages (since deleted)
--&lt;begin do-not-edit except to comment out&gt;--
		["av"] = "Avar",														-- Avaric
		["bo"] = "Standard Tibetan",											-- Tibetan
		["el"] = "Greek",														-- Modern Greek
--		["en-SA"] = "South African English",									-- English; no; SA is not South Africa it Saudi Arabia; ZA is South Africa
		["ff"] = "Fula",														-- Fulah
		["ht"] = "Haitian Creole",												-- Haitian
		["hz"] = "Otjiherero",													-- Herero
		["ii"] = "Yi",															-- Sichuan Yi
		["ki"] = "Gikuyu",														-- Kikuyu
		["kl"] = "Greenlandic",													-- Kalaallisut
		["ky"] = "Kyrgyz",														-- Kirghiz
		["lg"] = "Luganda",														-- Ganda
		["li"] = "Limburgish",													-- Limburgan
		["mi"] = "Māori",														-- Maori
		["na"] = "Nauruan",														-- Nauru
		["nb"] = "Bokmål",														-- Norwegian Bokmål
		["nd"] = "Northern Ndebele",											-- North Ndebele
		["nn"] = "Nynorsk",														-- Norwegian Nynorsk
		["nr"] = "Southern Ndebele",											-- South Ndebele
		["ny"] = "Chichewa",													-- Nyanja
		["oj"] = "Ojibwe",														-- Ojibwa
		["or"] = "Odia",														-- Oriya
		["pa"] = "Punjabi",														-- Panjabi
		["rn"] = "Kirundi",														-- Rundi
		["sl"] = "Slovene",														-- Slovenian
		["ss"] = "Swazi",														-- Swati
		["st"] = "Sotho",														-- Southern Sotho
		["to"] = "Tongan",														-- Tonga
--&lt;end do-not-edit except to comment out&gt;--


------------------------------&lt; I S O _ 6 3 9 - 2,   - 3,   - 5 &gt;----------------------------------------------

	["alv"] = "Atlantic–Congo languages",										-- to match en.wiki article title (endash)
	["arc"] = "Imperial Aramaic (700-300 BCE)",									-- Official Aramaic (700-300 BCE), Imperial Aramaic (700-300 BCE); to match en.wiki article title uses ISO639-2 'preferred' name
	["art"] = "constructed",													-- to match en.wiki article; lowercase for category name
	["ast-es"] = "Leonese",														-- ast in IANA is Asturian; Leonese is a dialect
	["bea"] = "Dane-zaa",														-- Beaver; to match en.wiki article title
	["bha"] = "Bhariati",														-- Bharia; to match en.wiki article title
	["bhd"] = "Bhadarwahi",														-- Bhadrawahi; to match en.wiki article title
	["bla"] = "Blackfoot",														-- Siksika; to match en.wiki article title
	["blc"] = "Nuxalk",															-- Bella Coola; to match en.wiki article title
	["bua"] = "Buryat",															-- Buriat; this is a macro language; these four use wp preferred transliteration;
	["bxm"] = "Mongolian Buryat",												-- Mongolia Buriat; these three all redirect to Buryat
	["bxr"] = "Russian Buryat",													-- Russia Buriat;
	["bxu"] = "Chinese Buryat",													-- China Buriat;
	["byr"] = "Yipma",															-- Baruya, Yipma
	["clm"] = "Klallam",														-- Clallam; to match en.wiki article title
	["egy"] = "Ancient Egyptian",												-- Egyptian (Ancient); distinguish from contemporary arz: Egyptian Arabic 
	["ems"] = "Alutiiq",														-- Pacific Gulf Yupik; to match en.wiki article title
	["esx"] = "Eskimo–Aleut languages",											-- to match en.wiki article title (endash)
	["frr"] = "North Frisian",													-- Northern Frisian
	["frs"] = "East Frisian Low Saxon",											-- Eastern Frisian
	["gsw-fr"] = "Alsatian",													-- match MediaWiki
	["haa"] = "Hän",															-- Han; to match en.wiki article title
	["hei"] = "Heiltsuk–Oowekyala",												-- Heiltsuk; to match en.wiki article title
	["hmx"] = "Hmong–Mien languages",											-- to match en.wiki article title (endash)
	["ilo"] = "Ilocano",														-- Iloko; to match en.wiki article title
	["jam"] = "Jamaican Patois",												-- Jamaican Creole English
	["lij-mc"] = "Monégasque",													-- Ligurian as spoken in Monaco; this one for proper tool tip; also in &lt;article_name&gt; table
	["luo"] = "Dholuo",															-- IANA (primary) /ISO 639-3: Luo (Kenya and Tanzania); IANA (secondary): Dholuo
	["mhr"] = "Meadow Mari",													-- Eastern Mari
	["mid"] = "Modern Mandaic",													-- Mandaic
	['mis'] = "uncoded",														-- Uncoded languages; capitalization; special scope, not collective scope;
	["mkh"] = "Mon–Khmer languages",											-- to match en.wiki article title (endash)
	["mla"] = "Tamambo",														-- Malo
	['mte'] = "Mono-Alu",														-- Mono (Solomon Islands)
	['mul'] = "multiple",														-- Multiple languages; capitalization; special scope, not collective scope;
	["nan-tw"] = "Taiwanese Hokkien",											-- make room for IANA / 639-3 nan Min Nan Chinese; match en.wiki article title
	["new"] = "Newar",															-- Newari, Nepal Bhasa; to match en,wiki article title
	["ngf"] = "Trans–New Guinea languages",										-- to match en.wiki article title (endash)
	["nic"] = "Niger–Congo languages",											-- Niger-Kordofanian languages; to match en,wiki article title
	["nrf"] = "Norman",															-- not quite a collective - IANA name: Jèrriais + Guernésiais; categorizes to Norman-language text
	["nrf-gg"] = "Guernésiais",													-- match MediaWiki
	["nrf-je"] = "Jèrriais",													-- match MediaWiki
	["nzi"] = "Nzema",															-- Nzima; to match en.wiki article title
	["oma"] = "Omaha–Ponca",													-- to match en.wiki article title (endash)
	["orv"] = "Old East Slavic",												-- Old Russian
	["pfl"] = "Palatine German",												-- Pfaelzisch; to match en.wiki article
	["pie"] = "Piro Pueblo",													-- Piro; to match en.wiki article
	["pms"] = "Piedmontese",													-- Piemontese; to match en.wiki article title
	["pnb"] = "Punjabi (Western)",												-- Western Panjabi; dab added to override import from ~/wp languages and distinguish pnb from pa in reverse look up tag_from_name()
	['qwm'] = "Cuman",															-- Kuman (Russia); to match en.wiki article name
	["rop"] = "Australian Kriol",												-- Kriol; en.wiki article is a dab; point to correct en.wiki article
	["rsk"] = "Pannonian Rusyn",												-- Ruthenian; en.wiki preferred name
	["sco-ulster"] = "Ulster Scots",
	["sdo"] = "Bukar–Sadong",													-- Bukar-Sadung Bidayuh; to match en.wiki article title
	["smp"] = "Samaritan Hebrew",												-- to match en.wiki article title
	["stq"] = "Saterland Frisian",												-- Saterfriesisch
	["und"] = "undetermined",													-- capitalization to match existing category
	["wrg"] = "Warrongo",														-- Warungu
	["xal-ru"] = "Kalmyk",														-- to match en.wiki article title
	["xgf"] = "Tongva",															-- ISO 639-3 is Gabrielino-Fernandeño
	["yuf"] = "Havasupai–Hualapai",												-- Havasupai-Walapai-Yavapai; to match en.wiki article title
	["zkt"] = "Khitan",															-- Kitan; to match en.wiki article title
	["zxx"] = "no linguistic content",											-- capitalization

-- these ISO 639-2, -3 language-name overrides imported from Module:Language/data/wp_languages (since deleted)
--&lt;begin do-not-edit except to comment out&gt;--
		["ace"] = "Acehnese",													-- Achinese
		["aec"] = "Sa'idi Arabic",												-- Saidi Arabic
		["akl"] = "Aklan",														-- Aklanon
		["alt"] = "Altay",														-- Southern Altai
		["apm"] = "Mescalero-Chiricahua",										-- Mescalero-Chiricahua Apache
		["bal"] = "Balochi",													-- Baluchi
--		["bcl"] = "Central Bicolano",											-- Central Bikol
		["bin"] = "Edo",														-- Bini
		["bpy"] = "Bishnupriya Manipuri",										-- Bishnupriya
		["chg"] = "Chagatay",													-- Chagatai
		["ckb"] = "Sorani Kurdish",												-- Central Kurdish
		["cnu"] = "Shenwa",														-- Chenoua
		["coc"] = "Cocopah",													-- Cocopa
		["diq"] = "Zazaki",														-- Dimli
		["fit"] = "Meänkieli",													-- Tornedalen Finnish
		["fkv"] = "Kven",														-- Kven Finnish
		["frk"] = "Old Frankish",												-- Frankish
		["gez"] = "Ge'ez",														-- Geez
		["gju"] = "Gujari",														-- Gujari
		["gsw"] = "Alemannic German",											-- Swiss German
		["gul"] = "Gullah",														-- Sea Island Creole English
		["hak"] = "Hakka",														-- Hakka Chinese
		["hbo"] = "Biblical Hebrew",											-- Ancient Hebrew
		["hnd"] = "Hindko",														-- Southern Hindko
--		["ikt"] = "Inuvialuk",													-- Inuinnaqtun
		["kaa"] = "Karakalpak",													-- Kara-Kalpak
		["khb"] = "Tai Lü",														-- Lü
		["kmr"] = "Kurmanji Kurdish",											-- Northern Kurdish
		["kpo"] = "Kposo",														-- Ikposo
		["krj"] = "Kinaray-a",													-- Kinaray-A
--		["ktz"] = "Juǀ'hoan",													-- Juǀʼhoan
		["lez"] = "Lezgian",													-- Lezghian
		["liv"] = "Livonian",													-- Liv
		["lng"] = "Lombardic",													-- Langobardic
		["mia"] = "Miami-Illinois",												-- Miami
		["miq"] = "Miskito",													-- Mískito
		["mix"] = "Mixtec",														-- Mixtepec Mixtec
		["mni"] = "Meitei",														-- Manipuri
		["mrj"] = "Hill Mari",													-- Western Mari
		["mww"] = "White Hmong",												-- Hmong Daw
		["nds-nl"] = "Dutch Low Saxon",											-- Low German
--		["new"] = "Nepal Bhasa",												-- Newari
		["nso"] = "Northern Sotho",												-- Pedi
--		["nwc"] = "Classical Nepal Bhasa",										-- Classical Newari, Classical Nepal Bhasa, Old Newari
		["ood"] = "O'odham",													-- Tohono O'odham
		["otk"] = "Old Turkic",													-- Old Turkish
		["pal"] = "Middle Persian",												-- Pahlavi
		["pam"] = "Kapampangan",												-- Pampanga
		["phr"] = "Potwari",													-- Pahari-Potwari
		["pka"] = "Jain Prakrit",												-- Ardhamāgadhī Prākrit
--		["pnb"] = "Punjabi",													-- Western Panjabi
		["psu"] = "Shauraseni",													-- Sauraseni Prākrit
		["rap"] = "Rapa Nui",													-- Rapanui
		["rar"] = "Cook Islands Māori",											-- Rarotongan
		["rmu"] = "Scandoromani",												-- Tavringer Romani
		["rom"] = "Romani",														-- Romany
		["rup"] = "Aromanian",													-- Macedo-Romanian
		["ryu"] = "Okinawan",													-- Central Okinawan
		["sdc"] = "Sassarese",													-- Sassarese Sardinian
		["sdn"] = "Gallurese",													-- Gallurese Sardinian
		["shp"] = "Shipibo",													-- Shipibo-Conibo
		["src"] = "Logudorese",													-- Logudorese Sardinian
		["sro"] = "Campidanese",												-- Campidanese Sardinian
		["tkl"] = "Tokelauan",													-- Tokelau
		["tvl"] = "Tuvaluan",													-- Tuvalu
		["tyv"] = "Tuvan",														-- Tuvinian
		["vls"] = "West Flemish",												-- Vlaams
		["wep"] = "Westphalian",												-- Westphalien
		["xal"] = "Oirat",														-- Kalmyk
		["xcl"] = "Old Armenian",												-- Classical Armenian
		["yua"] = "Yucatec Maya",												-- Yucateco
--&lt;end do-not-edit except to comment out&gt;--


------------------------------&lt; P R I V A T E _ U S E _ T A G S &gt;----------------------------------------------

	["akk-x-latbabyl"] = "Late Babylonian Akkadian",
	["akk-x-midassyr"] = "Middle Assyrian Akkadian",
	["akk-x-midbabyl"] = "Middle Babylonian Akkadian",
	["akk-x-neoassyr"] = "Neo-Assyrian Akkadian",
	["akk-x-neobabyl"] = "Neo-Babylonian Akkadian",
	["akk-x-old"] = "Old Akkadian",
	["akk-x-oldassyr"] = "Old Assyrian Akkadian",
	["akk-x-oldbabyl"] = "Old Babylonian Akkadian",
	["alg-x-proto"] = "Proto-Algonquian",										-- alg in IANA is Algonquian languages
	["art-x-uropi"] = "Uropi",													-- art in IANA is Artificial languages
	["ast-x-west"] = "Western Asturian",
	["ca-x-old"] = "Old Catalan",
	["cel-x-combrit"] = "Common Brittonic",										-- cel in IANA is Celtic languages
	["cel-x-proto"] = "Proto-Celtic",
	["ccs-x-proto"] = "Proto-Kartvelian",										-- ccs in IANA is Kartvelian languages
	["egy-x-demotic"] = "Demotic Egyptian",
	["egy-x-late"] = "Late Egyptian",
	["egy-x-middle"] = "Middle Egyptian",
	["egy-x-old"] = "Old Egyptian",
	["et-x-seto"] = "Seto",														-- to replace {{Lang-est-sea}}
	["fiu-x-proto"] = "Proto-Finno-Ugric",										-- fiu in IANA is Finno-Ugric languages
	["fr-x-frainc"] = "Franc-Comtois",											-- to replace {{Lang-fra-frc}}
	["fr-x-quebec"] = "Quebec French",
	["gem-x-proto"] = "Proto-Germanic",											-- gem in IANA is Germanic languages
	["gmw-x-ecg"] = "East Central German",
	["grc-x-aeolic"] = "Aeolic Greek",											-- these grc-x-... codes are preferred alternates to the non-standard catchall code grc-gre
	["grc-x-arcadcyp"] = "Arcadocypriot Greek",
	["grc-x-attic"] = "Attic Greek",
	["grc-x-biblical"] = "Biblical Greek",
	["grc-x-byzant"] = "Byzantine Greek",
	["grc-x-classic"] = "Classical Greek",
	["grc-x-doric"] = "Doric Greek",
	["grc-x-hellen"] = "Hellenistic Greek",
	["grc-x-ionic"] = "Ionic Greek",
	["grc-x-koine"] = "Koinē Greek",
	["grc-x-medieval"] = "Medieval Greek",
	["grc-x-patris"] = "Patristic Greek",
	["grk-x-proto"] = "Proto-Greek",											-- grk in IANA is Greek languages
	["iir-x-proto"] = "Proto-Indo-Iranian",										-- iir in IANA is Indo-Iranian Languages
	["inc-x-mitanni"] = "Mitanni-Aryan",										-- inc in IANA is Indic languages
	["inc-x-proto"] = "Proto-Indo-Aryan",
	["ine-x-anatolia"] = "Anatolian languages",
	["ine-x-proto"] = "Proto-Indo-European",
	["ira-x-proto"] = "Proto-Iranian",											-- ira in IANA is Iranian languages
	["itc-x-proto"] = "Proto-Italic",											-- itc in IANA is Italic languages
	["ksh-x-colog"] = "Colognian",												-- en.wiki article is Colognian; ksh (Kölsch) redirects there
	["la-x-medieval"] = "Medieval Latin",
	["la-x-new"] = "New Latin",
	["lmo-x-berg"] = "Bergamasque",												-- lmo in IANA is Lombard; Bergamasque is a dialect
	["lmo-x-cremish"] = "Cremish",												-- lmo in IANA is Lombard; Cremish is a dialect
	["lmo-x-milanese"] = "Milanese",											-- lmo in IANA is Lombard; Milanese is a dialect
	["mis-x-ripuar"] = "Ripuarian",												-- replaces improper use of ksh in wp_languages
	["prg-x-old"] = "Old Prussian",
	["sem-x-ammonite"] = "Ammonite",
	["sem-x-aramaic"] = "Aramaic",
	["sem-x-canaan"] = "Canaanite languages",
	["sem-x-dumaitic"] = "Dumaitic",
	["sem-x-egurage"] = "Eastern Gurage",
	["sem-x-hatran"] = "Hatran Aramaic",
	["sem-x-oldsoara"] = "Old South Arabian",
	["sem-x-palmyren"] = "Palmyrene Aramaic",
	["sem-x-proto"] = "Proto-Semitic",
	["sem-x-taymanit"] = "Taymanitic",
	["smi-x-proto"] = "Proto-Samic",											-- smi in IANA is Samic languages
	["sla-x-proto"] = "Proto-Slavic",											-- sla in IANA is Slavic languages
	["sq-x-proto"] = "Proto-Albanian",
	["trk-x-oldanat"] = "Old Anatolian Turkish",								-- to replace {{Lang-1ca}}
	["urj-x-proto"] = "Proto-Uralic",											-- urj in IANA is Uralic languages
	["yuf-x-hav"] = "Havasupai",												-- IANA name for these three is Havasupai-Walapai-Yavapai
	["yuf-x-wal"] = "Walapai",
	["yuf-x-yav"] = "Yavapai",
	["xsc-x-pontic"] = "Pontic Scythian",										-- xsc in IANA is Scythian
	["xsc-x-saka"] = "Saka",
	["xsc-x-sarmat"] = "Sarmatian",
	["zle-x-ruthenia"] = "Ruthenian",											-- zle in IANA is East Slavic languages collective; moved to allow rsk for Pannonian Rusyn
	}


--[[--------------------------&lt; A R T I C L E _ L I N K &gt;------------------------------------------------------

for those rare occasions when article titles don't fit with the normal '&lt;language name&gt; language', this table
maps language code to article title. Use of this table should be avoided and the use of redirects preferred as
that is the long-standing method of handling article names that don't fit with the normal pattern

]]

local article_name = {
	['kue'] = "Kuman language (New Guinea)",									-- Kuman (Papua New Guinea); to avoid Kuman dab page
	["lij-mc"] = "Monégasque dialect",											-- Ligurian as spoken in Monaco
	['mbo'] = "Mbo language (Cameroon)",										-- Mbo (Cameroon)
	['mnh'] = "Mono language (Congo)",											-- Mono (Democratic Republic of Congo); see Template_talk:Lang#Mono_languages
	['mnr'] = "Mono language (California)",										-- Mono (USA)
	['mru'] = "Mono language (Cameroon)",										-- Mono (Cameroon)
	["snq"] = "Sangu language (Gabon)",											-- Sangu (Gabon)
	["toi"] = "Tonga language (Zambia and Zimbabwe)",                           -- Tonga (Zambia and Zimbabwe); to avoid Tonga language dab page
	["vwa"] = "Awa language (China)",											-- Awa (China); to avoid Awa dab page
	["xlg"] = "Ligurian language (ancient)",									-- see Template_talk:Lang#Ligurian_dab
	["zmw"] = "Mbo language (Congo)",											-- Mbo (Democratic Republic of Congo)
	}


--[=[-------------------------&lt; R T L _ S C R I P T S &gt;--------------------------------------------------------

ISO 15924 scripts that are written right-to-left. Data in this table taken from [[ISO 15924#List of codes]]

last update to this list: 2017-12-24

]=]

local rtl_scripts = {
	'adlm', 'arab', 'aran', 'armi', 'avst', 'cprt', 'egyd', 'egyh', 'hatr', 'hebr',
	'hung', 'inds', 'khar', 'lydi', 'mand', 'mani', 'mend', 'merc', 'mero', 'narb',
	'nbat', 'nkoo', 'orkh', 'palm', 'phli', 'phlp', 'phlv', 'phnx', 'prti', 'rohg',
	'samr', 'sarb', 'sogd', 'sogo', 'syrc', 'syre', 'syrj', 'syrn', 'thaa', 'wole',
	};


--[[--------------------------&lt; T R A N S L I T _ T I T L E S &gt;------------------------------------------------

This is a table of tables of transliteration standards and the language codes or language scripts that apply to
those standards. This table is used to create the tool-tip text associated with the transliterated text displayed
by some of the {{lang-??}} templates.

These tables are more-or-less copied directly from {{special|PermaLink/680078354}}. The standard 'NO_STD' is a construct to allow for
the cases when no |std= parameter value is provided.

]]

local translit_title_table = {
	['ahl'] = {
		['default'] = 'Academy of the Hebrew Language transliteration',
		},

	['ala'] = {
		['default'] = 'American Library Association – Library of Congress transliteration',
		},

	['ala-lc'] = {
		['default'] = 'American Library Association – Library of Congress transliteration',
		},

	['batr'] = {
		['default'] = 'Bikdash Arabic Transliteration Rules',
		},

	['bgn/pcgn'] = {
		['default'] = 'Board on Geographic Names / Permanent Committee on Geographical Names transliteration',
		},

	['din'] = {
		['ar'] = 'DIN 31635 Arabic',
		['fa'] = 'DIN 31635 Arabic',
		['ku'] = 'DIN 31635 Arabic',
		['ps'] = 'DIN 31635 Arabic',
		['tg'] = 'DIN 31635 Arabic',
		['ug'] = 'DIN 31635 Arabic',
		['ur'] = 'DIN 31635 Arabic',
		['arab'] = 'DIN 31635 Arabic',

		['default'] = 'DIN transliteration',
		},

	['eae'] = {
		['default'] = 'Encyclopaedia Aethiopica transliteration',
		},

	['hepburn'] = {
		['default'] = 'Hepburn transliteration',
		},

	['hunterian'] = {
		['default'] = 'Hunterian transliteration',
		},

	['iast'] = {
		['default'] = 'International Alphabet of Sanskrit transliteration',
		},

	['iso'] = {																	-- when a transliteration standard is supplied
		['ab'] = 'ISO 9 Cyrillic',
		['ba'] = 'ISO 9 Cyrillic',
		['be'] = 'ISO 9 Cyrillic',
		['bg'] = 'ISO 9 Cyrillic',
		['kk'] = 'ISO 9 Cyrillic',
		['ky'] = 'ISO 9 Cyrillic',
		['mn'] = 'ISO 9 Cyrillic',
		['ru'] = 'ISO 9 Cyrillic',
		['tg'] = 'ISO 9 Cyrillic',
		['uk'] = 'ISO 9 Cyrillic',
		['bua'] = 'ISO 9 Cyrillic',
		['sah'] = 'ISO 9 Cyrillic',
		['tut'] = 'ISO 9 Cyrillic',
		['xal'] = 'ISO 9 Cyrillic',
		['cyrl'] = 'ISO 9 Cyrillic',
		['cyrs'] = 'ISO 9 Cyrillic',

		['ar'] = 'ISO 233 Arabic',
		['ku'] = 'ISO 233 Arabic',
		['ps'] = 'ISO 233 Arabic',
		['ug'] = 'ISO 233 Arabic',
		['ur'] = 'ISO 233 Arabic',
		['arab'] = 'ISO 233 Arabic',

		['he'] = 'ISO 259 Hebrew',
		['yi'] = 'ISO 259 Hebrew',
		['hebr'] = 'ISO 259 Hebrew',

		['el'] = 'ISO 843 Greek',
		['grc'] = 'ISO 843 Greek',

		['ja'] = 'ISO 3602 Japanese',
		['hira'] = 'ISO 3602 Japanese',
		['hrkt'] = 'ISO 3602 Japanese',
		['jpan'] = 'ISO 3602 Japanese',
		['kana'] = 'ISO 3602 Japanese',

		['zh'] = 'ISO 7098 Chinese',
		['chi'] = 'ISO 7098 Chinese',
		['cmn'] = 'ISO 7098 Chinese',
		['zho'] = 'ISO 7098 Chinese',
--		['han'] = 'ISO 7098 Chinese',											-- unicode alias of Hani? doesn't belong here? should be Hani?
		['hans'] = 'ISO 7098 Chinese',
		['hant'] = 'ISO 7098 Chinese',

		['ka'] = 'ISO 9984 Georgian',
		['kat'] = 'ISO 9984 Georgian',

		['arm'] = 'ISO 9985 Armenian',
		['hy'] = 'ISO 9985 Armenian',

		['th'] = 'ISO 11940 Thai',
		['tha'] = 'ISO 11940 Thai',

		['ko'] = 'ISO 11941 Korean',
		['kor'] = 'ISO 11941 Korean',

		['awa'] = 'ISO 15919 Indic',
		['bho'] = 'ISO 15919 Indic',
		['bn'] = 'ISO 15919 Indic',
		['bra'] = 'ISO 15919 Indic',
		['doi'] = 'ISO 15919 Indic',
		['dra'] = 'ISO 15919 Indic',
		['gon'] = 'ISO 15919 Indic',
		['gu'] = 'ISO 15919 Indic',
		['hi'] = 'ISO 15919 Indic',
		['hno'] = 'ISO 15919 Indic',
		['inc'] = 'ISO 15919 Indic',
		['kn'] = 'ISO 15919 Indic',
		['kok'] = 'ISO 15919 Indic',
		['ks'] = 'ISO 15919 Indic',
		['mag'] = 'ISO 15919 Indic',
		['mai'] = 'ISO 15919 Indic',
		['ml'] = 'ISO 15919 Indic',
		['mr'] = 'ISO 15919 Indic',
		['ne'] = 'ISO 15919 Indic',
		['new'] = 'ISO 15919 Indic',
		['or'] = 'ISO 15919 Indic',
		['pa'] = 'ISO 15919 Indic',
		['pnb'] = 'ISO 15919 Indic',
		['raj'] = 'ISO 15919 Indic',
		['sa'] = 'ISO 15919 Indic',
		['sat'] = 'ISO 15919 Indic',
		['sd'] = 'ISO 15919 Indic',
		['si'] = 'ISO 15919 Indic',
		['skr'] = 'ISO 15919 Indic',
		['ta'] = 'ISO 15919 Indic',
		['tcy'] = 'ISO 15919 Indic',
		['te'] = 'ISO 15919 Indic',
		['beng'] = 'ISO 15919 Indic',
		['brah'] = 'ISO 15919 Indic',
		['deva'] = 'ISO 15919 Indic',
		['gujr'] = 'ISO 15919 Indic',
		['guru'] = 'ISO 15919 Indic',
		['knda'] = 'ISO 15919 Indic',
		['mlym'] = 'ISO 15919 Indic',
		['orya'] = 'ISO 15919 Indic',
		['sinh'] = 'ISO 15919 Indic',
		['taml'] = 'ISO 15919 Indic',
		['telu'] = 'ISO 15919 Indic',

		['default'] = 'ISO transliteration',
		},

	['jyutping'] = {
		['default'] = 'Jyutping transliteration',
		},

	['mlcts'] = {
		['default'] = 'Myanmar Language Commission Transcription System',
		},

	['mr'] = {
		['default'] = 'McCune–Reischauer transliteration',
		},

	['nihon-shiki'] = {
		['default'] = 'Nihon-shiki transliteration',
		},

	['no_std'] = {																-- when no transliteration standard is supplied
		['akk'] = 'Semitic transliteration',
		['sem'] = 'Semitic transliteration',
		['phnx'] = 'Semitic transliteration',
		['xsux'] = 'Cuneiform transliteration',
		},

	['pinyin'] = {
		['default'] = 'Pinyin transliteration',
		},

	['rr'] = {
		['default'] = 'Revised Romanization of Korean transliteration',
		},

	['rtgs'] = {
		['default'] = 'Royal Thai General System of Transcription',
		},
	
	['satts'] = {
		['default'] = 'Standard Arabic Technical Transliteration System transliteration',
		},

	['scientific'] = {
		['default'] = 'scientific transliteration',
		},

	['ukrainian'] = {
		['default'] = 'Ukrainian National system of romanization',
		},

	['ungegn'] = {
		['default'] = 'United Nations Group of Experts on Geographical Names transliteration',
		},

	['wadegile'] = {
		['default'] = 'Wade–Giles transliteration',
		},

	['wehr'] = {
		['default'] = 'Hans Wehr transliteration',
		},
	['yaleko'] = {
		['default'] = 'Yale romanization of Korean',
	}
};


--[[--------------------------&lt; E N G _ V A R &gt;----------------------------------------------------------------

Used at en.wiki so that spelling of 'romanized' (US, default) can be changed to 'romanised' to match the envar
specified by a {{Use xxx English}}.

This is accomplished by setting |engvar=gb; can, should be omitted in articles that use American English; no
need for the clutter.

]]

local engvar_sel_t = {															-- select either UK English or US English
	['au'] = 'gb_t',															-- these match IANA region codes (except in lower case)
	['ca'] = 'us_t',
	['gb'] = 'gb_t',
	['ie'] = 'gb_t',
	['in'] = 'gb_t',
	['nz'] = 'gb_t',
	['us'] = 'us_t',															-- default engvar
	['za'] = 'gb_t'
	};

local engvar_t = {
	['gb_t'] = {
		['romanisz_lc'] = 'romanisation',										-- lower case
		['romanisz_uc'] = 'Romanisation',										-- upper case
		['romanisz_pt'] = 'romanised',											-- past tense
		},
	['us_t'] = {																-- default engvar
		['romanisz_lc'] = 'romanization',										-- lower case
		['romanisz_uc'] = 'Romanization',										-- upper case
		['romanisz_pt'] = 'romanized',											-- past tense
		}
	}


--[[--------------------------&lt; E X P O R T S &gt;----------------------------------------------------------------
]]

return
	{
	this_wiki_lang_tag = this_wiki_lang_tag,
	this_wiki_lang_dir = lang_obj:getDir(),										-- wiki's language direction
	
	article_name = article_name,
	engvar_t = engvar_t,
	engvar_sel_t = engvar_sel_t,
	lang_name_table = lang_name_table_t,
	override = override,
	rtl_scripts = rtl_scripts,
	special_tags_table = special_tags_table,
	translit_title_table = translit_title_table,
	};</text>
      <sha1>9fxpox2gqkq2cenl59r8fw3p30srqlt</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/ISO 639 synonyms</title>
    <ns>828</ns>
    <id>110</id>
    <revision>
      <id>208</id>
      <parentid>207</parentid>
      <timestamp>2025-07-09T04:31:39Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>207</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3163" sha1="shzq5qyzo42nqfska6amwdq4g8lois9" xml:space="preserve">-- File-Date: 2013-01-11
return {
	["aar"] = "aa",
	["abk"] = "ab",
	["afr"] = "af",
	["aka"] = "ak",
	["amh"] = "am",
	["ara"] = "ar",
	["arg"] = "an",
	["asm"] = "as",
	["ava"] = "av",
	["ave"] = "ae",
	["aym"] = "ay",
	["aze"] = "az",
	["bak"] = "ba",
	["bam"] = "bm",
	["bel"] = "be",
	["ben"] = "bn",
	["bih"] = "bh",
	["bis"] = "bi",
	["bod"] = "bo",
	["bos"] = "bs",
	["bre"] = "br",
	["bul"] = "bg",
	["cat"] = "ca",
	["ces"] = "cs",
	["cha"] = "ch",
	["che"] = "ce",
	["chu"] = "cu",
	["chv"] = "cv",
	["cor"] = "kw",
	["cos"] = "co",
	["cre"] = "cr",
	["cym"] = "cy",
	["dan"] = "da",
	["deu"] = "de",
	["div"] = "dv",
	["dzo"] = "dz",
	["ell"] = "el",
	["eng"] = "en",
	["epo"] = "eo",
	["est"] = "et",
	["eus"] = "eu",
	["ewe"] = "ee",
	["fao"] = "fo",
	["fas"] = "fa",
	["fij"] = "fj",
	["fin"] = "fi",
	["fra"] = "fr",
	["fry"] = "fy",
	["ful"] = "ff",
	["gla"] = "gd",
	["gle"] = "ga",
	["glg"] = "gl",
	["glv"] = "gv",
	["grn"] = "gn",
	["guj"] = "gu",
	["hat"] = "ht",
	["hau"] = "ha",
	["heb"] = "he",
	["her"] = "hz",
	["hin"] = "hi",
	["hmo"] = "ho",
	["hrv"] = "hr",
	["hun"] = "hu",
	["hye"] = "hy",
	["ibo"] = "ig",
	["ido"] = "io",
	["iii"] = "ii",
	["iku"] = "iu",
	["ile"] = "ie",
	["ina"] = "ia",
	["ind"] = "id",
	["ipk"] = "ik",
	["isl"] = "is",
	["ita"] = "it",
	["jav"] = "jv",
	["jpn"] = "ja",
	["kal"] = "kl",
	["kan"] = "kn",
	["kas"] = "ks",
	["kat"] = "ka",
	["kau"] = "kr",
	["kaz"] = "kk",
	["khm"] = "km",
	["kik"] = "ki",
	["kin"] = "rw",
	["kir"] = "ky",
	["kom"] = "kv",
	["kon"] = "kg",
	["kor"] = "ko",
	["kua"] = "kj",
	["kur"] = "ku",
	["lao"] = "lo",
	["lat"] = "la",
	["lav"] = "lv",
	["lim"] = "li",
	["lin"] = "ln",
	["lit"] = "lt",
	["ltz"] = "lb",
	["lub"] = "lu",
	["lug"] = "lg",
	["mah"] = "mh",
	["mal"] = "ml",
	["mar"] = "mr",
	["mkd"] = "mk",
	["mlg"] = "mg",
	["mlt"] = "mt",
	["mon"] = "mn",
	["mri"] = "mi",
	["msa"] = "ms",
	["mya"] = "my",
	["nau"] = "na",
	["nav"] = "nv",
	["nbl"] = "nr",
	["nde"] = "nd",
	["ndo"] = "ng",
	["nep"] = "ne",
	["nld"] = "nl",
	["nno"] = "nn",
	["nob"] = "nb",
	["nor"] = "no",
	["nya"] = "ny",
	["oci"] = "oc",
	["oji"] = "oj",
	["ori"] = "or",
	["orm"] = "om",
	["oss"] = "os",
	["pan"] = "pa",
	["pli"] = "pi",
	["pol"] = "pl",
	["por"] = "pt",
	["pus"] = "ps",
	["que"] = "qu",
	["roh"] = "rm",
	["ron"] = "ro",
	["run"] = "rn",
	["rus"] = "ru",
	["sag"] = "sg",
	["san"] = "sa",
	["sin"] = "si",
	["slk"] = "sk",
	["slv"] = "sl",
	["sme"] = "se",
	["smo"] = "sm",
	["sna"] = "sn",
	["snd"] = "sd",
	["som"] = "so",
	["sot"] = "st",
	["spa"] = "es",
	["sqi"] = "sq",
	["srd"] = "sc",
	["srp"] = "sr",
	["ssw"] = "ss",
	["sun"] = "su",
	["swa"] = "sw",
	["swe"] = "sv",
	["tah"] = "ty",
	["tam"] = "ta",
	["tat"] = "tt",
	["tel"] = "te",
	["tgk"] = "tg",
	["tgl"] = "tl",
	["tha"] = "th",
	["tir"] = "ti",
	["ton"] = "to",
	["tsn"] = "tn",
	["tso"] = "ts",
	["tuk"] = "tk",
	["tur"] = "tr",
	["twi"] = "tw",
	["uig"] = "ug",
	["ukr"] = "uk",
	["urd"] = "ur",
	["uzb"] = "uz",
	["ven"] = "ve",
	["vie"] = "vi",
	["vol"] = "vo",
	["wln"] = "wa",
	["wol"] = "wo",
	["xho"] = "xh",
	["yid"] = "yi",
	["yor"] = "yo",
	["zha"] = "za",
	["zho"] = "zh",
	["zul"] = "zu"
	}</text>
      <sha1>shzq5qyzo42nqfska6amwdq4g8lois9</sha1>
    </revision>
  </page>
  <page>
    <title>Template:'s</title>
    <ns>10</ns>
    <id>111</id>
    <revision>
      <id>210</id>
      <parentid>209</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>209</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="178" sha1="chfodpjwfrvut1ze57xqs15szk36xbn" xml:space="preserve">&lt;span class="nowrap" style="padding-left:0.1em;"&gt;&amp;#39;s&lt;/span&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>chfodpjwfrvut1ze57xqs15szk36xbn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite journal</title>
    <ns>10</ns>
    <id>112</id>
    <revision>
      <id>212</id>
      <parentid>211</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>211</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="126" sha1="9fcytsszanq7xbwi3p28zsneear9938" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Citation/CS1|citation
|CitationClass=journal
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>9fcytsszanq7xbwi3p28zsneear9938</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Yesno</title>
    <ns>10</ns>
    <id>113</id>
    <revision>
      <id>214</id>
      <parentid>213</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>213</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="374" sha1="bioaq6x8oitfnx7oqmfhviol4hbp1nd" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#switch: {{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;lc: {{{1|¬}}} }}
 |no
 |n
 |f
 |false
 |off
 |0        = {{{no|&lt;!-- null --&gt;}}}
 |         = {{{blank|{{{no|&lt;!-- null --&gt;}}}}}}
 |¬        = {{{¬|}}}
 |yes
 |y
 |t
 |true
 |on
 |1        = {{{yes|yes}}}
 |#default = {{{def|{{{yes|yes}}}}}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>bioaq6x8oitfnx7oqmfhviol4hbp1nd</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pagetype</title>
    <ns>10</ns>
    <id>114</id>
    <revision>
      <id>216</id>
      <parentid>215</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>215</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="179" sha1="lljnsh3xa96oyrio8us1qbonct9sq7b" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:pagetype|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>lljnsh3xa96oyrio8us1qbonct9sq7b</sha1>
    </revision>
  </page>
  <page>
    <title>Template:If both</title>
    <ns>10</ns>
    <id>115</id>
    <revision>
      <id>218</id>
      <parentid>217</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>217</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="204" sha1="0ai65pdgkgn12lzic912cra70w3l8d7" xml:space="preserve">{{{{{|safesubst:}}}#if:{{{1|}}}| {{{{{|safesubst:}}}#if:{{{2|}}}|{{{3|}}}|{{{4|}}}}} |{{{4|}}} }}&lt;noinclude&gt;
{{Documentation}}
&lt;!--
   PLEASE ADD CATEGORIES
   TO THE /doc SUBPAGE, THANKS
--&gt;
&lt;/noinclude&gt;</text>
      <sha1>0ai65pdgkgn12lzic912cra70w3l8d7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Yesno-yes</title>
    <ns>10</ns>
    <id>116</id>
    <revision>
      <id>220</id>
      <parentid>219</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>219</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="272" sha1="2ln5m2kzkd3wxvm1r25pwd6kj6j77we" xml:space="preserve">{{SAFESUBST:&lt;noinclude /&gt;yesno|{{{1}}}|yes={{{yes|yes}}}|no={{{no|no}}}|blank={{{blank|yes}}}|¬={{{¬|yes}}}|def={{{def|yes}}}}}&lt;noinclude&gt;
{{Documentation|Template:Yesno/doc}}
&lt;!--Categories go in the doc page referenced above; interwikis go in Wikidata.--&gt;
&lt;/noinclude&gt;</text>
      <sha1>2ln5m2kzkd3wxvm1r25pwd6kj6j77we</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype</title>
    <ns>828</ns>
    <id>117</id>
    <revision>
      <id>222</id>
      <parentid>221</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>221</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="8227" sha1="nqu0kvn2uc9jqptetkmoluzmahcxzzp" xml:space="preserve">--------------------------------------------------------------------------------
--                                                                            --
--      This meta-module which automatically detects namespaces, and allows   --
--      for a great deal of customisation. It can easily be ported to other   --
--      wikis by changing the values in the [[Module:Pagetype/config]].       --
--                                                                            --
--------------------------------------------------------------------------------
-- Load config.
local cfg = mw.loadData('Module:Pagetype/config')

-- Load required modules.
local yesno = require('Module:Yesno')
local p = {}

-- Look up a namespace argument in the args table.
local function lookUpNamespaceArg(args, key)
	local arg = args[key]
	-- Convert "yes", "1" etc. to true, "no", "0" etc. to false, and leave
	-- other values the same.
	return yesno(arg, arg)
end

-- Append multiple values to an array
local function appendMultiple(target, source)
	for _, value in ipairs(source) do
		table.insert(target, value)
	end
end

-- Get argument keys for a title's namespace
local function getNamespaceArgKeys(title)
	local nsInfo = mw.site.namespaces[title.namespace]
	local customAliases = cfg.customNamespaceAliases[title.namespace] or {}
	local keys = {}
	if nsInfo.name ~= '' then
		table.insert(keys, nsInfo.name)
	end
	if nsInfo.canonicalName ~= nsInfo.name and nsInfo.canonicalName ~= '' then
		table.insert(keys, nsInfo.canonicalName)
	end
	appendMultiple(keys, nsInfo.aliases)
	appendMultiple(keys, customAliases)
	return keys
end

-- Get the argument for a title's namespace, if it was specified in the args table.
local function getNamespaceArg(title, args)
	if title.isTalkPage then
		return lookUpNamespaceArg(args, cfg.talk)
	end
	for _, key in ipairs(getNamespaceArgKeys(title)) do
		local arg = lookUpNamespaceArg(args, mw.ustring.lower(key))
		if arg ~= nil then
			return arg
		end
	end
	return nil
end

-- Look up a page type specific to the title's namespace
local function getExplicitPageType(title)
	if title.isTalkPage then
		return cfg.talkDefault
	else
		return cfg.pagetypes[title.namespace]
	end
end

-- Get a default page type that is not specific to the title's namespace
local function getDefaultPageType(args)
	local other = lookUpNamespaceArg(args, cfg.other)
	if type(other) == 'string' then
		return other
	else
		return cfg.otherDefault
	end
end

local function detectRedirects(title, args)
	local redirect = lookUpNamespaceArg(args, cfg.redirect)
	if redirect == false then
		-- Don't detect redirects if they have been specifically disallowed.
		return nil
	end

	-- Allow custom values for redirects.
	if not title.isRedirect then
		return nil
	elseif type(redirect) == 'string' then
		return redirect
	else
		return cfg.redirectDefault
	end
end

local function capitalize(pageType)
	local first = mw.ustring.sub(pageType, 1, 1)
	local rest = mw.ustring.sub(pageType, 2)
	return mw.ustring.upper(first) .. rest
end

local function pluralize(pageType)
	if cfg.irregularPlurals[pageType] then
		return cfg.irregularPlurals[pageType]
	else
		return pageType .. cfg.plural -- often 's'
	end
end

local function parseContent(title, args, optionsList)
	if title.namespace==828 and title.subpageText~='doc' -- don't detect modules
		or not title.exists -- can't check unless page exists
	then
		return nil
	end
	local content = title:getContent()
	if content == nil then
		return nil
	end
	local templates -- lazily evaluated
	for _, options in next, optionsList do
		local list, parameter, default, articleOnly = unpack(options, 1, 4)
		if not articleOnly or title.namespace==0 then -- only check for templates if we should...
			local out = lookUpNamespaceArg(args, parameter)
			if type(out) == "string" or (out ~= false and default) then -- ...and if we actually have anything to say about them
				if not templates then
					templates = {} -- do our delayed evaluation now that we are required to
					content = require('Module:Wikitext Parsing').PrepareText(content) -- disregard templates which do not have any affect
					for template in string.gmatch(content, "{{%s*([^|}]-)%s*[|}]") do
						templates[#templates+1] = capitalize(template)
					end
				end
				local wantedTemplates = mw.loadData('Module:Pagetype/' .. list)
				local templateFound = false
				for _, template in next, templates do
					if wantedTemplates[template] then
						templateFound = true
						break
					end
				end
				if templateFound then
					if type(out)=='string' then
						return out
					elseif out ~= false and default then
						return default
					end
				end
			end
		end
	end
end

-- Find pages which do not exist
local function nonExistent(title, args)
	local arg = lookUpNamespaceArg(args, cfg.ne)
	if arg == false then
		return nil
	end
	local exists = false
	if title.exists then -- not an article if it does not exist
		exists = true
	elseif title.namespace==8 and mw.message.new(title.text):exists() then
		exists = true
	elseif title.namespace==6 and title.fileExists then
		exists = true
	end
	if not exists then
		if type(arg) == 'string' then
			return arg
		else
			return cfg.naDefault
		end
	end
end

-- Get page types for mainspaces pages with an explicit class specified
local function getMainNamespaceClassPageType(title, args)
	local class = args[1]
	if type(class) == 'string' then	-- Put in lower case so e.g. "na" and "NA" will both match
		class = mw.ustring.lower(class)
	end
	local arg = lookUpNamespaceArg(args, cfg.na)
	if arg == false then -- don't check for this class if it is specifically disallowed
		return nil
	end
	if cfg.naAliases[class] then
		if type(arg) == 'string' then
			return arg
		else
			return cfg.naDefault
		end
	else
		return nil
	end
end

-- Get page type specified by an explicit namespace argument.
local function getNamespaceArgPageType(title, args)
	local namespaceArg = getNamespaceArg(title, args)
	if namespaceArg == true then
		-- Namespace has been explicitly enabled, so return the default for
		-- this namespace
		return getExplicitPageType(title)
	elseif namespaceArg == false then
		-- Namespace has been explicitly disabled
		return getDefaultPageType(args)
	elseif namespaceArg then
		-- This namespaces uses custom text
		return namespaceArg
	else
		return nil
	end
end


-- Get page type not specified or detected by other means
local function getOtherPageType(title, args)
-- Whether the title is in the set of default active namespaces which are looked up in cfg.pagetypes.
	local isInDefaultActiveNamespace = false
	local defaultNamespacesKey = args[cfg.defaultns]
	if defaultNamespacesKey == cfg.defaultnsAll then
		isInDefaultActiveNamespace = true
	else
		local defaultNamespaces
		if defaultNamespacesKey == cfg.defaultnsExtended then
			defaultNamespaces = cfg.extendedNamespaces
		elseif defaultNamespacesKey == cfg.defaultnsNone then
			defaultNamespaces = {}
		else
			defaultNamespaces = cfg.defaultNamespaces
		end
		isInDefaultActiveNamespace = defaultNamespaces[title.namespace]
	end
	if isInDefaultActiveNamespace then
		return getExplicitPageType(title)
	else
		return getDefaultPageType(args)
	end
end

function p._main(args)
	local title
	if args.page then
		title = mw.title.new(args.page)
	else
		title = mw.title.getCurrentTitle()
	end
	if title and not yesno(args.talk, true) and args[cfg.defaultns] ~= cfg.defaultnsAll then
		title = title.subjectPageTitle
	end
	local pageType = detectRedirects(title, args)
		or nonExistent(title, args)
		or parseContent(title, args, {
			{'softredirect', cfg.softRedirect, cfg.softRedirectDefault},
			{'setindex', cfg.sia, cfg.siaDefault, true},
			{'disambiguation', cfg.dab, cfg.dabDefault, true},
			{'rfd', cfg.rfd, cfg.rfdDefault},
		})
		or (title.namespace == 0 and getMainNamespaceClassPageType(title, args))
		or getNamespaceArgPageType(title, args)
		or getOtherPageType(title, args)
	if yesno(args.plural, false) then
		pageType = pluralize(pageType)
	end
	if yesno(args.caps, false) then
		pageType = capitalize(pageType)
	end
	return pageType
end

function p.main(frame)
	local args = require('Module:Arguments').getArgs(frame)
	return p._main(args)
end

return p</text>
      <sha1>nqu0kvn2uc9jqptetkmoluzmahcxzzp</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype/config</title>
    <ns>828</ns>
    <id>118</id>
    <revision>
      <id>224</id>
      <parentid>223</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>223</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4216" sha1="61h7tsfs7sjoixfi1zfjharglkpqbji" xml:space="preserve">--------------------------------------------------------------------------------
--                  Module:Pagetype configuration data                        --
-- This page holds localisation and configuration data for Module:Pagetype.   --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                        Start configuration data                            --
--------------------------------------------------------------------------------

-- This table holds the default page types for each namespace. Keys to this
-- table should be integers that can be used as keys to mw.site.namespaces.
cfg.pagetypes = {
	[0]    = 'article', -- Main namespace
	[2]    = 'user page',
	[4]    = 'project page',
	[6]    = 'file',
	[8]    = 'interface page', -- MediaWiki namespace
	[10]   = 'template',
	[12]   = 'help page',
	[14]   = 'category',
	[100]  = 'portal',
	[118]  = 'draft',
	[710]  = 'Timed Text page',
	[828]  = 'module',
	[2300] = 'gadget',
	[2302] = 'gadget definition',
	[-1]   = 'special page',
	[-2]   = 'file', -- Media namespace
}

-- This table holds the namespaces to be looked up from cfg.pagetypes by
-- default.
cfg.defaultNamespaces = {
	[0] = true,   -- main
	[6] = true,   -- file
	[10] = true,  -- template
	[14] = true,  -- category
	[828] = true, -- module
}

-- This table holds the namespaces to be looked up from cfg.pagetypes if
-- cfg.defaultnsExtended is set.
cfg.extendedNamespaces = {
	[0] = true,   -- main
	[2] = true,   -- user
	[4] = true,   -- project
	[6] = true,   -- file
	[8] = true,   -- mediawiki
	[10] = true,  -- template
	[12] = true,  -- help
	[14] = true,  -- category
	[100] = true, -- portal
	[118] = true, -- draft
	[828] = true, -- module
}

-- This table holds custom aliases for each namespace.
cfg.customNamespaceAliases = {
	[0] = {'main'},
}

-- The parameter name to set which default namespace values to be looked up from
-- cfg.pagetypes.
cfg.defaultns = 'defaultns'

-- The value of cfg.defaultns to set all namespaces, including talk.
cfg.defaultnsAll = 'all'

-- The value of cfg.defaultns to set the namespaces listed in
-- cfg.extendedNamespaces
cfg.defaultnsExtended = 'extended'

-- The value of cfg.defaultns to set no default namespaces.
cfg.defaultnsNone = 'none'

-- The parameter name to use for talk pages.
cfg.talk = 'talk'

-- The default value for talk pages.
cfg.talkDefault = 'talk page'

-- The parameter name to use for disambiguation pages page.
cfg.dab = 'dab'

-- The parameter name to use for non-existent pages.
cfg.ne = 'nonexistent'
cfg.neDefault = 'page'

cfg.softRedirect = 'soft_redirect'
cfg.softRedirectDefault = 'redirect'

cfg.sia = 'sia'
cfg.siaDefault = 'article'

cfg.rfd = 'redirect'
cfg.rfdDefault = 'redirect'

-- This table holds the different possible aliases for disambiguation-class
-- pages. These should be lower-case.
cfg.dabAliases = {
	['disambiguation'] = true,
	['disambig'] = true,
	['disamb'] = true,
	['dab'] = true,
}

-- The default value for disambiguation pages.
cfg.dabDefault = 'page'

-- The parameter name to use for N/A-class page.
cfg.na = 'na'

-- This table holds the different possible aliases for N/A-class pages. These
-- should be lower-case.
cfg.naAliases = {
	['na'] = true,
	['n/a'] = true,
}

-- The default value for N/A-class pages.
cfg.naDefault = 'page'

-- The parameter name to use for redirects.
cfg.redirect = 'redirect'

-- The default value to use for redirects.
cfg.redirectDefault = 'redirect'

-- The parameter name for undefined namespaces.
cfg.other = 'other'

-- The value used if the module detects an undefined namespace.
cfg.otherDefault = 'page'

-- The usual suffix denoting a plural.
cfg.plural = 's'

-- This table holds plurals not formed by a simple suffix.
cfg.irregularPlurals = {
	["category"] = "categories"
}

--------------------------------------------------------------------------------
--                        End configuration data                              --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line</text>
      <sha1>61h7tsfs7sjoixfi1zfjharglkpqbji</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect/data</title>
    <ns>828</ns>
    <id>119</id>
    <revision>
      <id>226</id>
      <parentid>225</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>225</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2569" sha1="ojp6d3pc8mql5nufaqdg576c9so3479" xml:space="preserve">--------------------------------------------------------------------------------
--                          Namespace detect data                             --
-- This module holds data for [[Module:Namespace detect]] to be loaded per    --
-- page, rather than per #invoke, for performance reasons.                    --
--------------------------------------------------------------------------------

local cfg = require('Module:Namespace detect/config')

local function addKey(t, key, defaultKey)
	if key ~= defaultKey then
		t[#t + 1] = key
	end
end

-- Get a table of parameters to query for each default parameter name.
-- This allows wikis to customise parameter names in the cfg table while
-- ensuring that default parameter names will always work. The cfg table
-- values can be added as a string, or as an array of strings.

local defaultKeys = {
	'main',
	'talk',
	'other',
	'subjectns',
	'demospace',
	'demopage'
}

local argKeys = {}
for i, defaultKey in ipairs(defaultKeys) do
	argKeys[defaultKey] = {defaultKey}
end

for defaultKey, t in pairs(argKeys) do
	local cfgValue = cfg[defaultKey]
	local cfgValueType = type(cfgValue)
	if cfgValueType == 'string' then
		addKey(t, cfgValue, defaultKey)
	elseif cfgValueType == 'table' then
		for i, key in ipairs(cfgValue) do
			addKey(t, key, defaultKey)
		end
	end
	cfg[defaultKey] = nil -- Free the cfg value as we don't need it any more.
end

local function getParamMappings()
	--[[
	-- Returns a table of how parameter names map to namespace names. The keys
	-- are the actual namespace names, in lower case, and the values are the
	-- possible parameter names for that namespace, also in lower case. The
	-- table entries are structured like this:
	-- {
	--   [''] = {'main'},
	--   ['wikipedia'] = {'wikipedia', 'project', 'wp'},
	--   ...
	-- }
	--]]
	local mappings = {}
	local mainNsName = mw.site.subjectNamespaces[0].name
	mainNsName = mw.ustring.lower(mainNsName)
	mappings[mainNsName] = mw.clone(argKeys.main)
	mappings['talk'] = mw.clone(argKeys.talk)
	for nsid, ns in pairs(mw.site.subjectNamespaces) do
		if nsid ~= 0 then -- Exclude main namespace.
			local nsname = mw.ustring.lower(ns.name)
			local canonicalName = mw.ustring.lower(ns.canonicalName)
			mappings[nsname] = {nsname}
			if canonicalName ~= nsname then
				table.insert(mappings[nsname], canonicalName)
			end
			for _, alias in ipairs(ns.aliases) do
				table.insert(mappings[nsname], mw.ustring.lower(alias))
			end
		end
	end
	return mappings
end

return {
	argKeys = argKeys,
	cfg = cfg,
	mappings = getParamMappings()
}</text>
      <sha1>ojp6d3pc8mql5nufaqdg576c9so3479</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect/config</title>
    <ns>828</ns>
    <id>120</id>
    <revision>
      <id>228</id>
      <parentid>227</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>227</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3545" sha1="1o6ozz56i8q0xgyl6xa41n2v7kelhli" xml:space="preserve">--------------------------------------------------------------------------------
--                    Namespace detect configuration data                     --
--                                                                            --
-- This module stores configuration data for Module:Namespace detect. Here    --
-- you can localise the module to your wiki's language.                       --
--                                                                            --
-- To activate a configuration item, you need to uncomment it. This means     --
-- that you need to remove the text "-- " at the start of the line.           --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                              Parameter names                               --
-- These configuration items specify custom parameter names. Values added     --
-- here will work in addition to the default English parameter names.         --
-- To add one extra name, you can use this format:                            --
--                                                                            --
-- cfg.foo = 'parameter name'                                                 --
--                                                                            --
-- To add multiple names, you can use this format:                            --
--                                                                            --
-- cfg.foo = {'parameter name 1', 'parameter name 2', 'parameter name 3'}     --
--------------------------------------------------------------------------------

---- This parameter displays content for the main namespace:
-- cfg.main = 'main'

---- This parameter displays in talk namespaces:
-- cfg.talk = 'talk'

---- This parameter displays content for "other" namespaces (namespaces for which
---- parameters have not been specified):
-- cfg.other = 'other'

---- This parameter makes talk pages behave as though they are the corresponding
---- subject namespace. Note that this parameter is used with [[Module:Yesno]].
---- Edit that module to change the default values of "yes", "no", etc.
-- cfg.subjectns = 'subjectns'

---- This parameter sets a demonstration namespace:
-- cfg.demospace = 'demospace'

---- This parameter sets a specific page to compare:
cfg.demopage = 'page'

--------------------------------------------------------------------------------
--                           Table configuration                              --
-- These configuration items allow customisation of the "table" function,     --
-- used to generate a table of possible parameters in the module              --
-- documentation.                                                             --
--------------------------------------------------------------------------------

---- The header for the namespace column in the wikitable containing the list of
---- possible subject-space parameters.
-- cfg.wikitableNamespaceHeader = 'Namespace'

---- The header for the wikitable containing the list of possible subject-space
---- parameters.
-- cfg.wikitableAliasesHeader = 'Aliases'

--------------------------------------------------------------------------------
--                        End of configuration data                           --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line.</text>
      <sha1>1o6ozz56i8q0xgyl6xa41n2v7kelhli</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal</title>
    <ns>828</ns>
    <id>121</id>
    <revision>
      <id>230</id>
      <parentid>229</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>229</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="17104" sha1="17la7cpkbw894t9i08xfqc16pd5ncik" xml:space="preserve">--[==[ This module is a Lua implementation of the old {{Portal}} template. As of February 2019 it is used on nearly 7,900,000 articles.
-- Please take care when updating it! It outputs two functions: p.portal, which generates a list of portals, and p.image, which
-- produces the image name for an individual portal.

-- The portal image data is kept in submodules of [[Module:Portal/images]], listed below:
-- [[Module:Portal/images/a]]		- for portal names beginning with "A".
-- [[Module:Portal/images/b]]		- for portal names beginning with "B".
-- [[Module:Portal/images/c]]		- for portal names beginning with "C".
-- [[Module:Portal/images/d]]		- for portal names beginning with "D".
-- [[Module:Portal/images/e]]		- for portal names beginning with "E".
-- [[Module:Portal/images/f]]		- for portal names beginning with "F".
-- [[Module:Portal/images/g]]		- for portal names beginning with "G".
-- [[Module:Portal/images/h]]		- for portal names beginning with "H".
-- [[Module:Portal/images/i]]		- for portal names beginning with "I".
-- [[Module:Portal/images/j]]		- for portal names beginning with "J".
-- [[Module:Portal/images/k]]		- for portal names beginning with "K".
-- [[Module:Portal/images/l]]		- for portal names beginning with "L".
-- [[Module:Portal/images/m]]		- for portal names beginning with "M".
-- [[Module:Portal/images/n]]		- for portal names beginning with "N".
-- [[Module:Portal/images/o]]		- for portal names beginning with "O".
-- [[Module:Portal/images/p]]		- for portal names beginning with "P".
-- [[Module:Portal/images/q]]		- for portal names beginning with "Q".
-- [[Module:Portal/images/r]]		- for portal names beginning with "R".
-- [[Module:Portal/images/s]]		- for portal names beginning with "S".
-- [[Module:Portal/images/t]]		- for portal names beginning with "T".
-- [[Module:Portal/images/u]]		- for portal names beginning with "U".
-- [[Module:Portal/images/v]]		- for portal names beginning with "V".
-- [[Module:Portal/images/w]]		- for portal names beginning with "W".
-- [[Module:Portal/images/x]]		- for portal names beginning with "X".
-- [[Module:Portal/images/y]]		- for portal names beginning with "Y".
-- [[Module:Portal/images/z]]		- for portal names beginning with "Z".
-- [[Module:Portal/images/other]]	- for portal names beginning with any other letters. This includes numbers,
-- 									  letters with diacritics, and letters in non-Latin alphabets.
-- [[Module:Portal/images/aliases]]	- for adding aliases for existing portal names. Use this page for variations
-- 									  in spelling and diacritics, etc., no matter what letter the portal begins with.
--
-- The images data pages are separated by the first letter to reduce server load when images are added, changed, or removed.
-- Previously all the images were on one data page at [[Module:Portal/images]], but this had the disadvantage that all
-- 5,000,000 pages using this module needed to be refreshed every time an image was added or removed.
]==]

local p = {}

-- determine whether we're being called from a sandbox
local isSandbox = mw.getCurrentFrame():getTitle():find('sandbox', 1, true)
local sandbox = isSandbox and '/sandbox' or ''

local function sandboxVersion(s)
	return isSandbox and s..'-sand' or s
end

local templatestyles = 'Module:Portal'..sandbox..'/styles.css'

local getArgs = require('Module:Arguments').getArgs
local yesno = require('Module:Yesno')

-- List of non-talk namespaces which should not be tracked (Talk pages are never tracked)
local badNamespaces = {'user','template','draft','wikipedia'}

-- Check whether to do tracking in this namespace
-- Returns true unless the page is one of the banned namespaces
local function checkTracking(title)
	local thisPage = title or mw.title.getCurrentTitle()
	if thisPage.isTalkPage then
		return false
	end
	local ns = thisPage.nsText:lower()
	for _, v in ipairs(badNamespaces) do
		if ns == v then
			return false
		end
	end
	return true
end

local function matchImagePage(s)
	-- Finds the appropriate image subpage given a lower-case
	-- portal name plus the first letter of that portal name.
	if type(s) ~= 'string' or #s &lt; 1 then return end
	local firstLetter = mw.ustring.sub(s, 1, 1)
	local imagePage
	if mw.ustring.find(firstLetter, '^[a-z]') then
		imagePage = 'Module:Portal/images/' .. firstLetter .. sandbox
	else
		imagePage = 'Module:Portal/images/other' .. sandbox
	end
	return mw.loadData(imagePage)[s]
end

local function getAlias(s)
	-- Gets an alias from the image alias data page.
	local aliasData = mw.loadData('Module:Portal/images/aliases'..sandbox)
	for portal, aliases in pairs(aliasData) do
		for _, alias in ipairs(aliases) do
			if alias == s then
				return portal
			end
		end
	end
end

local defaultImage = 'Portal-puzzle.svg|link=|alt='

local function getImageName(s)
	-- Gets the image name for a given string.
	if type(s) ~= 'string' or #s &lt; 1 then
		return defaultImage
	end
	s = mw.ustring.lower(s)
	local image = matchImagePage(s) or matchImagePage(getAlias(s)) or defaultImage
	image = mw.ustring.gsub(image,'^File:','') --- strip mistaken leading File: or Image:
	image = mw.ustring.gsub(image,'^Image:','')
	return image
end

local function exists(title) 
	local success, exists = pcall(function() return title.exists end)
	-- If success = false, then we're out of expensive parser function calls and can't check whether it exists
	-- in that case, don't throw a Lua error
	return not success or exists
end

 -- Function to check argument portals for errors, generate tracking categories if needed
 --     Function first checks for too few/many portals provided
 --     Then checks the portal list to purge any portals that don't exist
 -- Arguments:
 --   portals: raw list of portals
 --   args.tracking: is tracking requested? (will not track on bad titles or namespaces)
 --   args.redlinks: should redlinks be displayed?
 --   args.minPortals: minimum number of portal arguments
 --   args.maxPortals: maximum number of portal arguments
 -- Returns:
 --   portals = list of portals, with redlinks purged (if args.redlinks=false)
 --   trackingCat = possible tracking category
 --   errorMsg = error message
function p._checkPortals(portals, args)
	local trackingCat = ''
	local errMsg = nil
	
	-- Tracking is on by default.
	-- It is disabled if any of the following is true
	-- 1/ the parameter "tracking" is set to 'no, 'n', or 'false'
	-- 2/ the current page fails the namespace or pagename tests 
	local trackingEnabled = args.tracking and checkTracking()
	
	args.minPortals = args.minPortals or 1
	args.maxPortals = args.maxPortals or -1
	-- check for too few portals
	if #portals &lt; args.minPortals then
		errMsg = 'please specify at least '..args.minPortals..' portal'..(args.minPortals &gt; 1 and 's' or '')
		trackingCat = (trackingEnabled and '[[Category:Portal templates with too few portals]]' or '')
		return portals, trackingCat, errMsg
	end
	-- check for too many portals
	if args.maxPortals &gt;= 0 and #portals &gt; args.maxPortals then
		errMsg = 'too many portals (maximum = '..args.maxPortals..')'
		trackingCat = (trackingEnabled and '[[Category:Portal templates with too many portals]]' or '')
		return portals, trackingCat, errMsg
	end
	if not args.redlinks or trackingEnabled then
		-- make new list of portals that exist
		local existingPortals = {}
		for _, portal in ipairs(portals) do
			local portalTitle = mw.title.new(portal,"Portal")
			-- if portal exists, put it into list
			if portalTitle and exists(portalTitle) then
				table.insert(existingPortals,portal)
			-- otherwise set tracking cat
			elseif trackingEnabled then
				trackingCat = "[[Category:Portal templates with redlinked portals]]"
			end
		end
		-- If redlinks is off, use portal list purged of redlinks
		portals = args.redlinks and portals or existingPortals
		-- if nothing left after purge, set tracking cat
		if #portals == 0 and trackingEnabled then
			trackingCat = trackingCat.."[[Category:Pages with empty portal template]]" 
		end
	end
	return portals, trackingCat, errMsg
end

local function portalBox(args)
	return mw.html.create('ul')
		:attr('role', 'navigation')
		:attr('aria-label', 'Portals')
		:addClass('noprint')
		:addClass(args.error and '' or sandboxVersion('portalbox'))
		:addClass(args.border and sandboxVersion('portalborder') or '')
		:addClass(sandboxVersion(args.left and 'portalleft' or 'portalright'))
		:css('margin', args.margin or nil)
		:newline()
end

local function fillBox(root, contents)
	for _, item in ipairs(contents) do
		local entry = root:tag('li')
		entry:addClass(sandboxVersion('portalbox-entry'))
		local image = entry:tag('span')
		image:addClass(sandboxVersion('portalbox-image'))
		image:wikitext(item[1])
		local link = entry:tag('span')
		link:addClass(sandboxVersion('portalbox-link'))
		link:wikitext(item[2])
	end
	return root
end

local function noviewer(portalImage)
    -- Function to add noviewer class to filespec for portalImage
    local portalImage, hasClass = mw.ustring.gsub(portalImage, "class%s*=[^%|]+", "%0 noviewer")
    if hasClass == 0 then
        portalImage = portalImage.."|class=noviewer"
    end
    return portalImage
end

function p._portal(portals, args)
	-- This function builds the portal box used by the {{portal}} template.
	
	-- Normalize all arguments
	if args.redlinks == 'include' then args.redlinks = true end
	args.addBreak = args['break']
	for key, default in pairs({left=false,tracking=true,nominimum=false,
		                       redlinks=false,addBreak=false,border=true}) do
		if args[key] == nil then args[key] = default end
		args[key] = yesno(args[key], default)
	end

	local root = portalBox(args)

	local trackingCat = ''
	local errMsg = nil
	args.minPortals = args.nominimum and 0 or 1
	args.maxPortals = -1
	portals, trackingCat, errMsg = p._checkPortals(portals, args)
	root:wikitext(trackingCat)
	-- if error message, put it in the box and return
	if errMsg then
		if args.border then -- suppress error message when border=no
			args.error = true  -- recreate box without fancy formatting
			root = portalBox(args)
			root:wikitext(trackingCat)
			local errTag = root:tag('strong')
			errTag:addClass('error')
			errTag:css('padding','0.2em')
			errTag:wikitext('Error: '..errMsg)
		end
		return tostring(root)
	end
	-- if no portals (and no error), just return tracking category
	if #portals == 0 then
		return trackingCat
	end

	local contents = {}
	-- Display the portals specified in the positional arguments.
	local defaultUsed = nil
	for _, portal in ipairs(portals) do
		local portalImage = getImageName(portal)
		if portalImage == defaultImage then
			defaultUsed = portal
        else
            portalImage = noviewer(portalImage)
		end
		local image = string.format('[[File:%s|32x28px]]',
			portalImage)
		local link = string.format('[[Portal:%s|%s%sportal]]',
			portal, portal, args.addBreak and '&lt;br /&gt;' or ' ')
		table.insert(contents, {image, link})
	end
	if defaultUsed and args.tracking and checkTracking() then
		local cat = string.format('[[Category:Portal templates with default image|%s]]',
			                      defaultUsed)
		root:wikitext(cat)
	end
	return tostring(fillBox(root, contents))
end

function p._demo(imageList, args)
	for key, default in pairs({left=false,border=true}) do
		if args[key] == nil then args[key] = default end
		args[key] = yesno(args[key], default)
	end
	
	local root = portalBox(args)

	local contents = {}
	-- Display the portals specified in the positional arguments.
	for _, fn in ipairs(imageList) do
		local image = string.format('[[File:%s|32x28px]]',noviewer(fn))
		local link = string.format('[[:File:%s|%s]]',fn,fn)
		table.insert(contents,{image,link})
	end

	return tostring(fillBox(root,contents))
end

function p._image(portal,keep)
	-- Wrapper function to allow getImageName() to be accessed through #invoke.
	-- backward compatibility: if table passed, take first element
	if type(portal) == 'table' then
		portal = portal[1]
	end
	local name = getImageName(portal)
	-- If keep is yes (or equivalent), then allow all metadata (like image borders) to be returned
    -- also, add "noviewer" class to metadata
	local keepargs = yesno(keep)
    if keepargs then
        return noviewer(name)
    end
    -- otherwise, just keep filename, plus optional category
	local args = mw.text.split(name, "|", true)
	local result = {args[1]}  -- the filename always comes first
	local category = ''
	-- parse name, looking for category arguments
	for i = 2,#args do
		local m = mw.ustring.match(args[i],  "^%s*category%s*=")
		if m then
			table.insert(result, args[i])
		end
	end
	-- reassemble arguments
	return table.concat(result,"|")
end


local function getAllImageTable()
	-- Returns an array containing all image subpages (minus aliases) as loaded by mw.loadData.
	local images = {}
	for i, subpage in ipairs{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'other'} do
		local imageTable = mw.loadData('Module:Portal/images/' .. subpage .. sandbox)
		for portal, image in pairs(imageTable) do
			local args = mw.text.split(image,"|")
			images[portal] = args[1] -- just use image filename
		end
	end
	return images
end

function p._displayAll(portals, args)
	-- This function displays all portals that have portal images. This function is for maintenance purposes and should not be used in
	-- articles, for two reasons: 1) there are over 1500 portals with portal images, and 2) the module doesn't record how the portal
	-- names are capitalized, so the portal links may be broken.
	local lang = mw.language.getContentLanguage()
	portals = portals or {}
	for portal in pairs(getAllImageTable()) do
		table.insert(portals,lang:ucfirst(portal))
	end
	table.sort(portals)
	args.redlinks = args.redlinks or "yes"
	return p._portal(portals, args)
end

function p._imageDupes()
	-- This function searches the image subpages to find duplicate images. If duplicate images exist, it is not necessarily a bad thing,
	-- as different portals might just happen to choose the same image. However, this function is helpful in identifying images that
	-- should be moved to a portal alias for ease of maintenance.
	local exists, dupes = {}, {}
	for portal, image in pairs(getAllImageTable()) do
		if not exists[image] then
			exists[image] = portal
		else
			table.insert(dupes, string.format('The image "[[:File:%s|%s]]" is used for both portals "%s" and "%s".', image, image, exists[image], portal))
		end
	end
	if #dupes &lt; 1 then
		return 'No duplicate images found.'
	else
		return 'The following duplicate images were found:\n* ' .. table.concat(dupes, '\n* ')
	end
end

local function processPortalArgs(args)
	-- This function processes a table of arguments and returns two tables: an array of portal names for processing by ipairs, and a table of
	-- the named arguments that specify style options, etc. We need to use ipairs because we want to list all the portals in the order
	-- they were passed to the template, but we also want to be able to deal with positional arguments passed explicitly, for example
	-- {{portal|2=Politics}}. The behaviour of ipairs is undefined if nil values are present, so we need to make sure they are all removed.
	args = type(args) == 'table' and args or {}
	local portals = {}
	local namedArgs = {}
	for k, v in pairs(args) do
		if type(k) == 'number' and type(v) == 'string' then -- Make sure we have no non-string portal names.
			table.insert(portals, k)
		elseif type(k) ~= 'number' then
			namedArgs[k] = v
		end
	end
	table.sort(portals)
	for i, v in ipairs(portals) do
		portals[i] = args[v]
	end
	return portals, namedArgs
end

-- Entry point for sorting portals from other named arguments
function p._processPortalArgs(args)
	return processPortalArgs(args)
end

function p.image(frame)
	local origArgs = getArgs(frame)
	local portals, args = processPortalArgs(origArgs)
	return p._image(portals[1],args.border)
end

function p.demo(frame)
	local args = getArgs(frame)
	local styles = frame:extensionTag{ name = 'templatestyles', args = { src = templatestyles} }
	return styles..p._demo(args,args)
end

local function makeWrapper(funcName)
	-- Processes external arguments and sends them to the other functions.
	return function (frame)
		-- If called via #invoke, use the args passed into the invoking
		-- template, or the args passed to #invoke if any exist. Otherwise
		-- assume args are being passed directly in from the debug console
		-- or from another Lua module. 
		-- Also: trim whitespace and remove blank arguments
		local origArgs = getArgs(frame)
		-- create two tables to pass to func: an array of portal names, and a table of named arguments.
		local portals, args = processPortalArgs(origArgs)
		local results = ''
		if funcName == '_portal' or funcName == '_displayAll' then
			results = frame:extensionTag{ name = 'templatestyles', args = { src = templatestyles} }
		end
		return results .. p[funcName](portals, args) 
	end
end

for _, funcName in ipairs{'portal', 'imageDupes', 'displayAll'} do
	p[funcName] = makeWrapper('_' .. funcName)
end

return p</text>
      <sha1>17la7cpkbw894t9i08xfqc16pd5ncik</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Short description</title>
    <ns>10</ns>
    <id>122</id>
    <revision>
      <id>232</id>
      <parentid>231</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>231</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1362" sha1="nc8snfbgla6s5ax6jm572afbuuzotb3" xml:space="preserve">{{#ifeq:{{lc:{{{1|}}}}}|none|{{SHORTDESC:}}&lt;nowiki/&gt;&lt;!--Prevents whitespace issues when used with adjacent newlines--&gt;|&lt;div class="shortdescription nomobile noexcerpt noprint searchaux" style="display:none"&gt;{{{1|}}}{{SHORTDESC:{{{1|}}}|{{{2|}}}}}&lt;/div&gt;}}&lt;includeonly&gt;{{#ifeq:{{{pagetype}}}|Disambiguation pages||{{#ifeq:{{pagetype |defaultns = all |user=exclude}}|exclude||{{#ifeq:{{#switch: {{NAMESPACENUMBER}} | 2 | 3 | 4 | 5 | 6 | 7 | 10 | 11 | 12 | 13 | 14 | 15 | 100 | 101 | 118 | 119 | 828 | 829 | = exclude|#default=}}|exclude||[[Category:{{{pagetype|{{pagetype |defaultns = extended |plural=y}}}}} with short description]]}}}}}}&lt;/includeonly&gt;&lt;!-- Start tracking
--&gt;{{#invoke:Check for unknown parameters|check|unknown={{Main other|[[Category:Pages using short description with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Short description]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | 2 | pagetype | bot |plural }}&lt;!--
--&gt;{{#ifexpr: {{#invoke:String|len|{{{1|}}}}}&gt;100 | [[Category:{{{pagetype|{{pagetype |defaultns = extended |plural=y}}}}} with long short description]]}}&lt;!--
--&gt;&lt;includeonly&gt;{{#if:{{{1|}}}||[[Category:Pages with empty short description]]}}&lt;/includeonly&gt;&lt;!--
--&gt;{{Short description/lowercasecheck|{{{1|}}}}}&lt;!-- 
--&gt;{{Main other |{{SDcat |sd={{{1|}}} }} }}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>nc8snfbgla6s5ax6jm572afbuuzotb3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Short description/lowercasecheck</title>
    <ns>10</ns>
    <id>123</id>
    <revision>
      <id>234</id>
      <parentid>233</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>233</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="827" sha1="i1e9w8d3rdcgxtws9nvbvfopq7y0nnk" xml:space="preserve">{{#ifeq:&lt;!--test first character for lower-case letter--&gt;{{#invoke:string|find|1={{{1|}}}|2=^%l|plain=false}}|1
|&lt;!-- first character is a lower case letter; test against whitelist
--&gt;{{#switch: {{First word|{{{1|}}}}}&lt;!--begin whitelist--&gt;
|c. &lt;!--for circa--&gt;
|gTLD
|iMac
|iOS
|iOS,
|iPad
|iPhone
|iTunes
|macOS
|none
|pH
|pH-dependent=&lt;!-- end whitelist; short description starts with an allowed lower-case string; whitelist matched; do nothing --&gt; 
|#default=&lt;!-- apply category to track lower-case short descriptions --&gt;{{main other|[[Category:Pages with lower-case short description|{{trim|{{{1|}}}}}]]}}{{Testcases other|{{red|CATEGORY APPLIED}}}}&lt;!-- end whitelist test --&gt;}}
|&lt;!-- short description does not start with lower-case letter; do nothing; end lower-case test --&gt;
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>i1e9w8d3rdcgxtws9nvbvfopq7y0nnk</sha1>
    </revision>
  </page>
  <page>
    <title>Template:SDcat</title>
    <ns>10</ns>
    <id>124</id>
    <revision>
      <id>236</id>
      <parentid>235</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>235</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="94" sha1="gejktck2ca8vfelabmrprhfecoxzlpi" xml:space="preserve">&lt;includeonly&gt;{{#invoke:SDcat |setCat}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gejktck2ca8vfelabmrprhfecoxzlpi</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Unbulleted list</title>
    <ns>10</ns>
    <id>125</id>
    <revision>
      <id>238</id>
      <parentid>237</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>237</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="181" sha1="g28jpumica8ycuimxbfi2qlrcbowsb3" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:list|unbulleted}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>g28jpumica8ycuimxbfi2qlrcbowsb3</sha1>
    </revision>
  </page>
  <page>
    <title>Module:String</title>
    <ns>828</ns>
    <id>126</id>
    <revision>
      <id>240</id>
      <parentid>239</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>239</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="18028" sha1="j5gx8uvupr1pa2fyqbe6td6jr0hxq00" xml:space="preserve">--[[

This module is intended to provide access to basic string functions.

Most of the functions provided here can be invoked with named parameters,
unnamed parameters, or a mixture.  If named parameters are used, Mediawiki will
automatically remove any leading or trailing whitespace from the parameter.
Depending on the intended use, it may be advantageous to either preserve or
remove such whitespace.

Global options
    ignore_errors: If set to 'true' or 1, any error condition will result in
        an empty string being returned rather than an error message.

    error_category: If an error occurs, specifies the name of a category to
        include with the error message.  The default category is
        [Category:Errors reported by Module String].

    no_category: If set to 'true' or 1, no category will be added if an error
        is generated.

Unit tests for this module are available at Module:String/tests.
]]

local str = {}

--[[
len

This function returns the length of the target string.

Usage:
{{#invoke:String|len|target_string|}}
OR
{{#invoke:String|len|s=target_string}}

Parameters
    s: The string whose length to report

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.
]]
function str.len( frame )
	local new_args = str._getParameters( frame.args, {'s'} )
	local s = new_args['s'] or ''
	return mw.ustring.len( s )
end

--[[
sub

This function returns a substring of the target string at specified indices.

Usage:
{{#invoke:String|sub|target_string|start_index|end_index}}
OR
{{#invoke:String|sub|s=target_string|i=start_index|j=end_index}}

Parameters
    s: The string to return a subset of
    i: The first index of the substring to return, defaults to 1.
    j: The last index of the string to return, defaults to the last character.

The first character of the string is assigned an index of 1.  If either i or j
is a negative value, it is interpreted the same as selecting a character by
counting from the end of the string.  Hence, a value of -1 is the same as
selecting the last character of the string.

If the requested indices are out of range for the given string, an error is
reported.
]]
function str.sub( frame )
	local new_args = str._getParameters( frame.args, { 's', 'i', 'j' } )
	local s = new_args['s'] or ''
	local i = tonumber( new_args['i'] ) or 1
	local j = tonumber( new_args['j'] ) or -1

	local len = mw.ustring.len( s )

	-- Convert negatives for range checking
	if i &lt; 0 then
		i = len + i + 1
	end
	if j &lt; 0 then
		j = len + j + 1
	end

	if i &gt; len or j &gt; len or i &lt; 1 or j &lt; 1 then
		return str._error( 'String subset index out of range' )
	end
	if j &lt; i then
		return str._error( 'String subset indices out of order' )
	end

	return mw.ustring.sub( s, i, j )
end

--[[
This function implements that features of {{str sub old}} and is kept in order
to maintain these older templates.
]]
function str.sublength( frame )
	local i = tonumber( frame.args.i ) or 0
	local len = tonumber( frame.args.len )
	return mw.ustring.sub( frame.args.s, i + 1, len and ( i + len ) )
end

--[[
_match

This function returns a substring from the source string that matches a
specified pattern. It is exported for use in other modules

Usage:
strmatch = require("Module:String")._match
sresult = strmatch( s, pattern, start, match, plain, nomatch )

Parameters
    s: The string to search
    pattern: The pattern or string to find within the string
    start: The index within the source string to start the search.  The first
        character of the string has index 1.  Defaults to 1.
    match: In some cases it may be possible to make multiple matches on a single
        string.  This specifies which match to return, where the first match is
        match= 1.  If a negative number is specified then a match is returned
        counting from the last match.  Hence match = -1 is the same as requesting
        the last match.  Defaults to 1.
    plain: A flag indicating that the pattern should be understood as plain
        text.  Defaults to false.
    nomatch: If no match is found, output the "nomatch" value rather than an error.

For information on constructing Lua patterns, a form of [regular expression], see:

* http://www.lua.org/manual/5.1/manual.html#5.4.1
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Ustring_patterns

]]
-- This sub-routine is exported for use in other modules
function str._match( s, pattern, start, match_index, plain_flag, nomatch )
	if s == '' then
		return str._error( 'Target string is empty' )
	end
	if pattern == '' then
		return str._error( 'Pattern string is empty' )
	end
	start = tonumber(start) or 1
	if math.abs(start) &lt; 1 or math.abs(start) &gt; mw.ustring.len( s ) then
		return str._error( 'Requested start is out of range' )
	end
	if match_index == 0 then
		return str._error( 'Match index is out of range' )
	end
	if plain_flag then
		pattern = str._escapePattern( pattern )
	end

	local result
	if match_index == 1 then
		-- Find first match is simple case
		result = mw.ustring.match( s, pattern, start )
	else
		if start &gt; 1 then
			s = mw.ustring.sub( s, start )
		end

		local iterator = mw.ustring.gmatch(s, pattern)
		if match_index &gt; 0 then
			-- Forward search
			for w in iterator do
				match_index = match_index - 1
				if match_index == 0 then
					result = w
					break
				end
			end
		else
			-- Reverse search
			local result_table = {}
			local count = 1
			for w in iterator do
				result_table[count] = w
				count = count + 1
			end

			result = result_table[ count + match_index ]
		end
	end

	if result == nil then
		if nomatch == nil then
			return str._error( 'Match not found' )
		else
			return nomatch
		end
	else
		return result
	end
end

--[[
match

This function returns a substring from the source string that matches a
specified pattern.

Usage:
{{#invoke:String|match|source_string|pattern_string|start_index|match_number|plain_flag|nomatch_output}}
OR
{{#invoke:String|match|s=source_string|pattern=pattern_string|start=start_index
    |match=match_number|plain=plain_flag|nomatch=nomatch_output}}

Parameters
    s: The string to search
    pattern: The pattern or string to find within the string
    start: The index within the source string to start the search.  The first
        character of the string has index 1.  Defaults to 1.
    match: In some cases it may be possible to make multiple matches on a single
        string.  This specifies which match to return, where the first match is
        match= 1.  If a negative number is specified then a match is returned
        counting from the last match.  Hence match = -1 is the same as requesting
        the last match.  Defaults to 1.
    plain: A flag indicating that the pattern should be understood as plain
        text.  Defaults to false.
    nomatch: If no match is found, output the "nomatch" value rather than an error.

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from each string.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

If the match_number or start_index are out of range for the string being queried, then
this function generates an error.  An error is also generated if no match is found.
If one adds the parameter ignore_errors=true, then the error will be suppressed and
an empty string will be returned on any failure.

For information on constructing Lua patterns, a form of [regular expression], see:

* http://www.lua.org/manual/5.1/manual.html#5.4.1
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Ustring_patterns

]]
-- This is the entry point for #invoke:String|match
function str.match( frame )
	local new_args = str._getParameters( frame.args, {'s', 'pattern', 'start', 'match', 'plain', 'nomatch'} )
	local s = new_args['s'] or ''
	local start = tonumber( new_args['start'] ) or 1
	local plain_flag = str._getBoolean( new_args['plain'] or false )
	local pattern = new_args['pattern'] or ''
	local match_index = math.floor( tonumber(new_args['match']) or 1 )
	local nomatch = new_args['nomatch']

	return str._match( s, pattern, start, match_index, plain_flag, nomatch )
end

--[[
pos

This function returns a single character from the target string at position pos.

Usage:
{{#invoke:String|pos|target_string|index_value}}
OR
{{#invoke:String|pos|target=target_string|pos=index_value}}

Parameters
    target: The string to search
    pos: The index for the character to return

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

The first character has an index value of 1.

If one requests a negative value, this function will select a character by counting backwards
from the end of the string.  In other words pos = -1 is the same as asking for the last character.

A requested value of zero, or a value greater than the length of the string returns an error.
]]
function str.pos( frame )
	local new_args = str._getParameters( frame.args, {'target', 'pos'} )
	local target_str = new_args['target'] or ''
	local pos = tonumber( new_args['pos'] ) or 0

	if pos == 0 or math.abs(pos) &gt; mw.ustring.len( target_str ) then
		return str._error( 'String index out of range' )
	end

	return mw.ustring.sub( target_str, pos, pos )
end

--[[
str_find

This function duplicates the behavior of {{str_find}}, including all of its quirks.
This is provided in order to support existing templates, but is NOT RECOMMENDED for
new code and templates.  New code is recommended to use the "find" function instead.

Returns the first index in "source" that is a match to "target".  Indexing is 1-based,
and the function returns -1 if the "target" string is not present in "source".

Important Note: If the "target" string is empty / missing, this function returns a
value of "1", which is generally unexpected behavior, and must be accounted for
separatetly.
]]
function str.str_find( frame )
	local new_args = str._getParameters( frame.args, {'source', 'target'} )
	local source_str = new_args['source'] or ''
	local target_str = new_args['target'] or ''

	if target_str == '' then
		return 1
	end

	local start = mw.ustring.find( source_str, target_str, 1, true )
	if start == nil then
		start = -1
	end

	return start
end

--[[
find

This function allows one to search for a target string or pattern within another
string.

Usage:
{{#invoke:String|find|source_str|target_string|start_index|plain_flag}}
OR
{{#invoke:String|find|source=source_str|target=target_str|start=start_index|plain=plain_flag}}

Parameters
    source: The string to search
    target: The string or pattern to find within source
    start: The index within the source string to start the search, defaults to 1
    plain: Boolean flag indicating that target should be understood as plain
        text and not as a Lua style regular expression, defaults to true

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the parameter.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

This function returns the first index &gt;= "start" where "target" can be found
within "source".  Indices are 1-based.  If "target" is not found, then this
function returns 0.  If either "source" or "target" are missing / empty, this
function also returns 0.

This function should be safe for UTF-8 strings.
]]
function str.find( frame )
	local new_args = str._getParameters( frame.args, {'source', 'target', 'start', 'plain' } )
	local source_str = new_args['source'] or ''
	local pattern = new_args['target'] or ''
	local start_pos = tonumber(new_args['start']) or 1
	local plain = new_args['plain'] or true

	if source_str == '' or pattern == '' then
		return 0
	end

	plain = str._getBoolean( plain )

	local start = mw.ustring.find( source_str, pattern, start_pos, plain )
	if start == nil then
		start = 0
	end

	return start
end

--[[
replace

This function allows one to replace a target string or pattern within another
string.

Usage:
{{#invoke:String|replace|source_str|pattern_string|replace_string|replacement_count|plain_flag}}
OR
{{#invoke:String|replace|source=source_string|pattern=pattern_string|replace=replace_string|
   count=replacement_count|plain=plain_flag}}

Parameters
    source: The string to search
    pattern: The string or pattern to find within source
    replace: The replacement text
    count: The number of occurences to replace, defaults to all.
    plain: Boolean flag indicating that pattern should be understood as plain
        text and not as a Lua style regular expression, defaults to true
]]
function str.replace( frame )
	local new_args = str._getParameters( frame.args, {'source', 'pattern', 'replace', 'count', 'plain' } )
	local source_str = new_args['source'] or ''
	local pattern = new_args['pattern'] or ''
	local replace = new_args['replace'] or ''
	local count = tonumber( new_args['count'] )
	local plain = new_args['plain'] or true

	if source_str == '' or pattern == '' then
		return source_str
	end
	plain = str._getBoolean( plain )

	if plain then
		pattern = str._escapePattern( pattern )
		replace = string.gsub( replace, "%%", "%%%%" ) --Only need to escape replacement sequences.
	end

	local result

	if count ~= nil then
		result = mw.ustring.gsub( source_str, pattern, replace, count )
	else
		result = mw.ustring.gsub( source_str, pattern, replace )
	end

	return result
end

--[[
    simple function to pipe string.rep to templates.
]]
function str.rep( frame )
	local repetitions = tonumber( frame.args[2] )
	if not repetitions then
		return str._error( 'function rep expects a number as second parameter, received "' .. ( frame.args[2] or '' ) .. '"' )
	end
	return string.rep( frame.args[1] or '', repetitions )
end

--[[
escapePattern

This function escapes special characters from a Lua string pattern. See [1]
for details on how patterns work.

[1] https://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns

Usage:
{{#invoke:String|escapePattern|pattern_string}}

Parameters
    pattern_string: The pattern string to escape.
]]
function str.escapePattern( frame )
	local pattern_str = frame.args[1]
	if not pattern_str then
		return str._error( 'No pattern string specified' )
	end
	local result = str._escapePattern( pattern_str )
	return result
end

--[[
count
This function counts the number of occurrences of one string in another.
]]
function str.count(frame)
	local args = str._getParameters(frame.args, {'source', 'pattern', 'plain'})
	local source = args.source or ''
	local pattern = args.pattern or ''
	local plain = str._getBoolean(args.plain or true)
	if plain then
		pattern = str._escapePattern(pattern)
	end
	local _, count = mw.ustring.gsub(source, pattern, '')
	return count
end

--[[
endswith
This function determines whether a string ends with another string.
]]
function str.endswith(frame)
	local args = str._getParameters(frame.args, {'source', 'pattern'})
	local source = args.source or ''
	local pattern = args.pattern or ''
	if pattern == '' then
		-- All strings end with the empty string.
		return "yes"
	end
	if mw.ustring.sub(source, -mw.ustring.len(pattern), -1) == pattern then
		return "yes"
	else
		return ""
	end
end

--[[
join

Join all non empty arguments together; the first argument is the separator.
Usage:
{{#invoke:String|join|sep|one|two|three}}
]]
function str.join(frame)
	local args = {}
	local sep
	for _, v in ipairs( frame.args ) do
		if sep then
			if v ~= '' then
				table.insert(args, v)
			end
		else
			sep = v
		end
	end
	return table.concat( args, sep or '' )
end

--[[
Helper function that populates the argument list given that user may need to use a mix of
named and unnamed parameters.  This is relevant because named parameters are not
identical to unnamed parameters due to string trimming, and when dealing with strings
we sometimes want to either preserve or remove that whitespace depending on the application.
]]
function str._getParameters( frame_args, arg_list )
	local new_args = {}
	local index = 1
	local value

	for _, arg in ipairs( arg_list ) do
		value = frame_args[arg]
		if value == nil then
			value = frame_args[index]
			index = index + 1
		end
		new_args[arg] = value
	end

	return new_args
end

--[[
Helper function to handle error messages.
]]
function str._error( error_str )
	local frame = mw.getCurrentFrame()
	local error_category = frame.args.error_category or 'Errors reported by Module String'
	local ignore_errors = frame.args.ignore_errors or false
	local no_category = frame.args.no_category or false

	if str._getBoolean(ignore_errors) then
		return ''
	end

	local error_str = '&lt;strong class="error"&gt;String Module Error: ' .. error_str .. '&lt;/strong&gt;'
	if error_category ~= '' and not str._getBoolean( no_category ) then
		error_str = '[[Category:' .. error_category .. ']]' .. error_str
	end

	return error_str
end

--[[
Helper Function to interpret boolean strings
]]
function str._getBoolean( boolean_str )
	local boolean_value

	if type( boolean_str ) == 'string' then
		boolean_str = boolean_str:lower()
		if boolean_str == 'false' or boolean_str == 'no' or boolean_str == '0'
				or boolean_str == '' then
			boolean_value = false
		else
			boolean_value = true
		end
	elseif type( boolean_str ) == 'boolean' then
		boolean_value = boolean_str
	else
		error( 'No boolean value found' )
	end
	return boolean_value
end

--[[
Helper function that escapes all pattern characters so that they will be treated
as plain text.
]]
function str._escapePattern( pattern_str )
	return ( string.gsub( pattern_str, "[%(%)%.%%%+%-%*%?%[%^%$%]]", "%%%0" ) )
end

return str</text>
      <sha1>j5gx8uvupr1pa2fyqbe6td6jr0hxq00</sha1>
    </revision>
  </page>
  <page>
    <title>Module:SDcat</title>
    <ns>828</ns>
    <id>127</id>
    <revision>
      <id>242</id>
      <parentid>241</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>241</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1851" sha1="cml06m2kvz7og9bi5f1xe6ylhi3d9a0" xml:space="preserve">--[[
SDcat
Module to check whether local short description matches that on Wikidata
--]]

local p = {}

-------------------------------------------------------------------------------
--[[
setCat has the qid of a Wikidata entity passed as |qid=
(it defaults to the associated qid of the current article if omitted)
and the local short description passed as |sd=
It returns a category if there is an associated Wikidata entity.
It returns one of the following tracking categories, as appropriate:
* Category:Short description matches Wikidata (case-insensitive)
* Category:Short description is different from Wikidata
* Category:Short description with empty Wikidata description
For testing purposes, a link prefix |lp= may be set to ":" to make the categories visible.
--]]

-- function exported for use in other modules
-- (local short description, Wikidata entity-ID, link prefix)
p._setCat = function(sdesc, itemID, lp)
	if not mw.wikibase then return nil end
	if itemID == "" then itemID = nil end
	-- Wikidata description field
	local wdesc = (mw.wikibase.getDescription(itemID) or ""):lower()
	if wdesc == "" then
		return "[[" .. lp .. "Category:Short description with empty Wikidata description]]"
	elseif wdesc == sdesc then
		return "[[" .. lp .. "Category:Short description matches Wikidata]]"
	else
		return "[[" .. lp .. "Category:Short description is different from Wikidata]]"
	end
end

-- function exported for call from #invoke
p.setCat = function(frame)
	local args
	if frame.args.sd then
		args = frame.args
	else
		args = frame:getParent().args
	end
	-- local short description
	local sdesc = mw.text.trim(args.sd or ""):lower()
	-- Wikidata entity-ID
	local itemID = mw.text.trim(args.qid or "")
	-- link prefix, strip quotes
	local lp = mw.text.trim(args.lp or ""):gsub('"', '')
	return p._setCat(sdesc, itemID, lp)
end

return p</text>
      <sha1>cml06m2kvz7og9bi5f1xe6ylhi3d9a0</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Infobox</title>
    <ns>828</ns>
    <id>128</id>
    <revision>
      <id>244</id>
      <parentid>243</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>243</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="20533" sha1="1m9tzydwofr8cj9bzzm2am6moool42y" xml:space="preserve">local p = {}
local args = {}
local origArgs = {}
local root
local empty_row_categories = {}
local category_in_empty_row_pattern = '%[%[%s*[Cc][Aa][Tt][Ee][Gg][Oo][Rr][Yy]%s*:[^]]*]]'
local has_rows = false
local lists = {
	plainlist_t = {
		patterns = {
			'^plainlist$',
			'%splainlist$',
			'^plainlist%s',
			'%splainlist%s'
		},
		found = false,
		styles = 'Plainlist/styles.css'
	},
	hlist_t = {
		patterns = {
			'^hlist$',
			'%shlist$',
			'^hlist%s',
			'%shlist%s'
		},
		found = false,
		styles = 'Hlist/styles.css'
	}
}

local function has_list_class(args_to_check)
	for _, list in pairs(lists) do
		if not list.found then
			for _, arg in pairs(args_to_check) do
				for _, pattern in ipairs(list.patterns) do
					if mw.ustring.find(arg or '', pattern) then
						list.found = true
						break
					end
				end
				if list.found then break end
			end
		end
	end
end

local function fixChildBoxes(sval, tt)
	local function notempty( s ) return s and s:match( '%S' ) end
	
	if notempty(sval) then
		local marker = '&lt;span class=special_infobox_marker&gt;'
		local s = sval
		-- start moving templatestyles and categories inside of table rows
		local slast = ''
		while slast ~= s do
			slast = s
			s = mw.ustring.gsub(s, '(&lt;/[Tt][Rr]%s*&gt;%s*)(%[%[%s*[Cc][Aa][Tt][Ee][Gg][Oo][Rr][Yy]%s*:[^]]*%]%])', '%2%1')
			s = mw.ustring.gsub(s, '(&lt;/[Tt][Rr]%s*&gt;%s*)(\127[^\127]*UNIQ%-%-templatestyles%-%x+%-QINU[^\127]*\127)', '%2%1')
		end
		-- end moving templatestyles and categories inside of table rows
		s = mw.ustring.gsub(s, '(&lt;%s*[Tt][Rr])', marker .. '%1')
		s = mw.ustring.gsub(s, '(&lt;/[Tt][Rr]%s*&gt;)', '%1' .. marker)
		if s:match(marker) then
			s = mw.ustring.gsub(s, marker .. '%s*' .. marker, '')
			s = mw.ustring.gsub(s, '([\r\n]|-[^\r\n]*[\r\n])%s*' .. marker, '%1')
			s = mw.ustring.gsub(s, marker .. '%s*([\r\n]|-)', '%1')
			s = mw.ustring.gsub(s, '(&lt;/[Cc][Aa][Pp][Tt][Ii][Oo][Nn]%s*&gt;%s*)' .. marker, '%1')
			s = mw.ustring.gsub(s, '(&lt;%s*[Tt][Aa][Bb][Ll][Ee][^&lt;&gt;]*&gt;%s*)' .. marker, '%1')
			s = mw.ustring.gsub(s, '^(%{|[^\r\n]*[\r\n]%s*)' .. marker, '%1')
			s = mw.ustring.gsub(s, '([\r\n]%{|[^\r\n]*[\r\n]%s*)' .. marker, '%1')
			s = mw.ustring.gsub(s, marker .. '(%s*&lt;/[Tt][Aa][Bb][Ll][Ee]%s*&gt;)', '%1')
			s = mw.ustring.gsub(s, marker .. '(%s*\n|%})', '%1')
		end
		if s:match(marker) then
			local subcells = mw.text.split(s, marker)
			s = ''
			for k = 1, #subcells do
				if k == 1 then
					s = s .. subcells[k] .. '&lt;/' .. tt .. '&gt;&lt;/tr&gt;'
				elseif k == #subcells then
					local rowstyle = ' style="display:none"'
					if notempty(subcells[k]) then rowstyle = ''	end
					s = s .. '&lt;tr' .. rowstyle ..'&gt;&lt;' .. tt .. ' colspan=2&gt;\n' ..
						subcells[k]
				elseif notempty(subcells[k]) then
					if (k % 2) == 0 then
						s = s .. subcells[k]
					else
						s = s .. '&lt;tr&gt;&lt;' .. tt .. ' colspan=2&gt;\n' ..
							subcells[k] .. '&lt;/' .. tt .. '&gt;&lt;/tr&gt;'
					end
				end
			end
		end
		-- the next two lines add a newline at the end of lists for the PHP parser
		-- [[Special:Diff/849054481]]
		-- remove when [[:phab:T191516]] is fixed or OBE
		s = mw.ustring.gsub(s, '([\r\n][%*#;:][^\r\n]*)$', '%1\n')
		s = mw.ustring.gsub(s, '^([%*#;:][^\r\n]*)$', '%1\n')
		s = mw.ustring.gsub(s, '^([%*#;:])', '\n%1')
		s = mw.ustring.gsub(s, '^(%{%|)', '\n%1')
		return s
	else
		return sval
	end
end

-- Cleans empty tables
local function cleanInfobox()
	root = tostring(root)
	if has_rows == false then
		root = mw.ustring.gsub(root, '&lt;table[^&lt;&gt;]*&gt;%s*&lt;/table&gt;', '')
	end
end

-- Returns the union of the values of two tables, as a sequence.
local function union(t1, t2)

	local vals = {}
	for k, v in pairs(t1) do
		vals[v] = true
	end
	for k, v in pairs(t2) do
		vals[v] = true
	end
	local ret = {}
	for k, v in pairs(vals) do
		table.insert(ret, k)
	end
	return ret
end

-- Returns a table containing the numbers of the arguments that exist
-- for the specified prefix. For example, if the prefix was 'data', and
-- 'data1', 'data2', and 'data5' exist, it would return {1, 2, 5}.
local function getArgNums(prefix)
	local nums = {}
	for k, v in pairs(args) do
		local num = tostring(k):match('^' .. prefix .. '([1-9]%d*)$')
		if num then table.insert(nums, tonumber(num)) end
	end
	table.sort(nums)
	return nums
end

-- Adds a row to the infobox, with either a header cell
-- or a label/data cell combination.
local function addRow(rowArgs)
	
	if rowArgs.header and rowArgs.header ~= '_BLANK_' then
		has_rows = true
		has_list_class({ rowArgs.rowclass, rowArgs.class, args.headerclass })
		
		root
			:tag('tr')
				:addClass(rowArgs.rowclass)
				:cssText(rowArgs.rowstyle)
				:tag('th')
					:attr('colspan', '2')
					:addClass('infobox-header')
					:addClass(rowArgs.class)
					:addClass(args.headerclass)
					-- @deprecated next; target .infobox-&lt;name&gt; .infobox-header
					:cssText(args.headerstyle)
					:cssText(rowArgs.rowcellstyle)
					:wikitext(fixChildBoxes(rowArgs.header, 'th'))
		if rowArgs.data then
			root:wikitext(
				'[[Category:Pages using infobox templates with ignored data cells]]'
			)
		end
	elseif rowArgs.data and rowArgs.data:gsub(category_in_empty_row_pattern, ''):match('^%S') then
		has_rows = true
		has_list_class({ rowArgs.rowclass, rowArgs.class })
		
		local row = root:tag('tr')
		row:addClass(rowArgs.rowclass)
		row:cssText(rowArgs.rowstyle)
		if rowArgs.label then
			row
				:tag('th')
					:attr('scope', 'row')
					:addClass('infobox-label')
					-- @deprecated next; target .infobox-&lt;name&gt; .infobox-label
					:cssText(args.labelstyle)
					:cssText(rowArgs.rowcellstyle)
					:wikitext(rowArgs.label)
					:done()
		end

		local dataCell = row:tag('td')
		dataCell
			:attr('colspan', not rowArgs.label and '2' or nil)
			:addClass(not rowArgs.label and 'infobox-full-data' or 'infobox-data')
			:addClass(rowArgs.class)
			-- @deprecated next; target .infobox-&lt;name&gt; .infobox(-full)-data
			:cssText(rowArgs.datastyle)
			:cssText(rowArgs.rowcellstyle)
			:wikitext(fixChildBoxes(rowArgs.data, 'td'))
	else
		table.insert(empty_row_categories, rowArgs.data or '')
	end
end

local function renderTitle()
	if not args.title then return end

	has_rows = true
	has_list_class({args.titleclass})
	
	root
		:tag('caption')
			:addClass('infobox-title')
			:addClass(args.titleclass)
			-- @deprecated next; target .infobox-&lt;name&gt; .infobox-title
			:cssText(args.titlestyle)
			:wikitext(args.title)
	
end

local function renderAboveRow()
	if not args.above then return end

	has_rows = true
	has_list_class({ args.aboveclass })
	
	root
		:tag('tr')
			:tag('th')
				:attr('colspan', '2')
				:addClass('infobox-above')
				:addClass(args.aboveclass)
				-- @deprecated next; target .infobox-&lt;name&gt; .infobox-above
				:cssText(args.abovestyle)
				:wikitext(fixChildBoxes(args.above,'th'))
end

local function renderBelowRow()
	if not args.below then return end

	has_rows = true
	has_list_class({ args.belowclass })
	
	root
		:tag('tr')
			:tag('td')
				:attr('colspan', '2')
				:addClass('infobox-below')
				:addClass(args.belowclass)
				-- @deprecated next; target .infobox-&lt;name&gt; .infobox-below
				:cssText(args.belowstyle)
				:wikitext(fixChildBoxes(args.below,'td'))
end

local function addSubheaderRow(subheaderArgs)
	if subheaderArgs.data and
		subheaderArgs.data:gsub(category_in_empty_row_pattern, ''):match('^%S') then
		has_rows = true
		has_list_class({ subheaderArgs.rowclass, subheaderArgs.class })
		
		local row = root:tag('tr')
		row:addClass(subheaderArgs.rowclass)

		local dataCell = row:tag('td')
		dataCell
			:attr('colspan', '2')
			:addClass('infobox-subheader')
			:addClass(subheaderArgs.class)
			:cssText(subheaderArgs.datastyle)
			:cssText(subheaderArgs.rowcellstyle)
			:wikitext(fixChildBoxes(subheaderArgs.data, 'td'))
	else
		table.insert(empty_row_categories, subheaderArgs.data or '')
	end
end

local function renderSubheaders()
	if args.subheader then
		args.subheader1 = args.subheader
	end
	if args.subheaderrowclass then
		args.subheaderrowclass1 = args.subheaderrowclass
	end
	local subheadernums = getArgNums('subheader')
	for k, num in ipairs(subheadernums) do
		addSubheaderRow({
			data = args['subheader' .. tostring(num)],
			-- @deprecated next; target .infobox-&lt;name&gt; .infobox-subheader
			datastyle = args.subheaderstyle,
			rowcellstyle = args['subheaderstyle' .. tostring(num)],
			class = args.subheaderclass,
			rowclass = args['subheaderrowclass' .. tostring(num)]
		})
	end
end

local function addImageRow(imageArgs)

	if imageArgs.data and
		imageArgs.data:gsub(category_in_empty_row_pattern, ''):match('^%S') then

		has_rows = true
		has_list_class({ imageArgs.rowclass, imageArgs.class })
		
		local row = root:tag('tr')
		row:addClass(imageArgs.rowclass)

		local dataCell = row:tag('td')
		dataCell
			:attr('colspan', '2')
			:addClass('infobox-image')
			:addClass(imageArgs.class)
			:cssText(imageArgs.datastyle)
			:wikitext(fixChildBoxes(imageArgs.data, 'td'))
	else
		table.insert(empty_row_categories, imageArgs.data or '')
	end
end

local function renderImages()
	if args.image then
		args.image1 = args.image
	end
	if args.caption then
		args.caption1 = args.caption
	end
	local imagenums = getArgNums('image')
	for k, num in ipairs(imagenums) do
		local caption = args['caption' .. tostring(num)]
		local data = mw.html.create():wikitext(args['image' .. tostring(num)])
		if caption then
			data
				:tag('div')
					:addClass('infobox-caption')
					-- @deprecated next; target .infobox-&lt;name&gt; .infobox-caption
					:cssText(args.captionstyle)
					:wikitext(caption)
		end
		addImageRow({
			data = tostring(data),
			-- @deprecated next; target .infobox-&lt;name&gt; .infobox-image
			datastyle = args.imagestyle,
			class = args.imageclass,
			rowclass = args['imagerowclass' .. tostring(num)]
		})
	end
end

-- When autoheaders are turned on, preprocesses the rows
local function preprocessRows()
	if not args.autoheaders then return end
	
	local rownums = union(getArgNums('header'), getArgNums('data'))
	table.sort(rownums)
	local lastheader
	for k, num in ipairs(rownums) do
		if args['header' .. tostring(num)] then
			if lastheader then
				args['header' .. tostring(lastheader)] = nil
			end
			lastheader = num
		elseif args['data' .. tostring(num)] and
			args['data' .. tostring(num)]:gsub(
				category_in_empty_row_pattern, ''
			):match('^%S') then
			local data = args['data' .. tostring(num)]
			if data:gsub(category_in_empty_row_pattern, ''):match('%S') then
				lastheader = nil
			end
		end
	end
	if lastheader then
		args['header' .. tostring(lastheader)] = nil
	end
end

-- Gets the union of the header and data argument numbers,
-- and renders them all in order
local function renderRows()

	local rownums = union(getArgNums('header'), getArgNums('data'))
	table.sort(rownums)
	for k, num in ipairs(rownums) do
		addRow({
			header = args['header' .. tostring(num)],
			label = args['label' .. tostring(num)],
			data = args['data' .. tostring(num)],
			datastyle = args.datastyle,
			class = args['class' .. tostring(num)],
			rowclass = args['rowclass' .. tostring(num)],
			-- @deprecated next; target .infobox-&lt;name&gt; rowclass
			rowstyle = args['rowstyle' .. tostring(num)],
			rowcellstyle = args['rowcellstyle' .. tostring(num)]
		})
	end
end

local function renderNavBar()
	if not args.name then return end

	has_rows = true
	root
		:tag('tr')
			:tag('td')
				:attr('colspan', '2')
				:addClass('infobox-navbar')
				:wikitext(require('Module:Navbar')._navbar{
					args.name,
					mini = 1,
				})
end

local function renderItalicTitle()
	local italicTitle = args['italic title'] and mw.ustring.lower(args['italic title'])
	if italicTitle == '' or italicTitle == 'force' or italicTitle == 'yes' then
		root:wikitext(require('Module:Italic title')._main({}))
	end
end

-- Categories in otherwise empty rows are collected in empty_row_categories.
-- This function adds them to the module output. It is not affected by
-- args.decat because this module should not prevent module-external categories
-- from rendering.
local function renderEmptyRowCategories()
	for _, s in ipairs(empty_row_categories) do
		root:wikitext(s)
	end
end

-- Render tracking categories. args.decat == turns off tracking categories.
local function renderTrackingCategories()
	if args.decat == 'yes' then return end
	if args.child == 'yes' then
		if args.title then
			root:wikitext(
				'[[Category:Pages using embedded infobox templates with the title parameter]]'
			)
		end
	elseif #(getArgNums('data')) == 0 and mw.title.getCurrentTitle().namespace == 0 then
		root:wikitext('[[Category:Articles using infobox templates with no data rows]]')
	end
end

--[=[
Loads the templatestyles for the infobox.

TODO: FINISH loading base templatestyles here rather than in
MediaWiki:Common.css. There are 4-5000 pages with 'raw' infobox tables.
See [[Mediawiki_talk:Common.css/to_do#Infobox]] and/or come help :).
When we do this we should clean up the inline CSS below too.
Will have to do some bizarre conversion category like with sidebar.

]=]
local function loadTemplateStyles()
	local frame = mw.getCurrentFrame()
	
	local hlist_templatestyles = ''
	if lists.hlist_t.found then
		hlist_templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = lists.hlist_t.styles }
		}
	end
	
	local plainlist_templatestyles = ''
	if lists.plainlist_t.found then
		plainlist_templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = lists.plainlist_t.styles }
		}
	end
	
	-- See function description
	local base_templatestyles = frame:extensionTag{
		name = 'templatestyles', args = { src = 'Module:Infobox/styles.css' }
	}

	local templatestyles = ''
	if args['templatestyles'] then
		templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['templatestyles'] }
		}
	end
	
	local child_templatestyles = ''
	if args['child templatestyles'] then
		child_templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['child templatestyles'] }
		}
	end
	
	local grandchild_templatestyles = ''
	if args['grandchild templatestyles'] then
		grandchild_templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['grandchild templatestyles'] }
		}
	end
	
	return table.concat({
		-- hlist -&gt; plainlist -&gt; base is best-effort to preserve old Common.css ordering.
		-- this ordering is not a guarantee because the rows of interest invoking
		-- each class may not be on a specific page
		hlist_templatestyles,
		plainlist_templatestyles,
		base_templatestyles,
		templatestyles,
		child_templatestyles,
		grandchild_templatestyles
	})
end

-- common functions between the child and non child cases
local function structure_infobox_common()
	renderSubheaders()
	renderImages()
	preprocessRows()
	renderRows()
	renderBelowRow()
	renderNavBar()
	renderItalicTitle()
	renderEmptyRowCategories()
	renderTrackingCategories()
	cleanInfobox()
end

-- Specify the overall layout of the infobox, with special settings if the
-- infobox is used as a 'child' inside another infobox.
local function _infobox()
	if args.child ~= 'yes' then
		root = mw.html.create('table')

		root
			:addClass(args.subbox == 'yes' and 'infobox-subbox' or 'infobox')
			:addClass(args.bodyclass)
			-- @deprecated next; target .infobox-&lt;name&gt;
			:cssText(args.bodystyle)
		
		has_list_class({ args.bodyclass })

		renderTitle()
		renderAboveRow()
	else
		root = mw.html.create()

		root
			:wikitext(args.title)
	end
	structure_infobox_common()
	
	return loadTemplateStyles() .. root
end

-- If the argument exists and isn't blank, add it to the argument table.
-- Blank arguments are treated as nil to match the behaviour of ParserFunctions.
local function preprocessSingleArg(argName)
	if origArgs[argName] and origArgs[argName] ~= '' then
		args[argName] = origArgs[argName]
	end
end

-- Assign the parameters with the given prefixes to the args table, in order, in
-- batches of the step size specified. This is to prevent references etc. from
-- appearing in the wrong order. The prefixTable should be an array containing
-- tables, each of which has two possible fields, a "prefix" string and a
-- "depend" table. The function always parses parameters containing the "prefix"
-- string, but only parses parameters in the "depend" table if the prefix
-- parameter is present and non-blank.
local function preprocessArgs(prefixTable, step)
	if type(prefixTable) ~= 'table' then
		error("Non-table value detected for the prefix table", 2)
	end
	if type(step) ~= 'number' then
		error("Invalid step value detected", 2)
	end

	-- Get arguments without a number suffix, and check for bad input.
	for i,v in ipairs(prefixTable) do
		if type(v) ~= 'table' or type(v.prefix) ~= "string" or
			(v.depend and type(v.depend) ~= 'table') then
			error('Invalid input detected to preprocessArgs prefix table', 2)
		end
		preprocessSingleArg(v.prefix)
		-- Only parse the depend parameter if the prefix parameter is present
		-- and not blank.
		if args[v.prefix] and v.depend then
			for j, dependValue in ipairs(v.depend) do
				if type(dependValue) ~= 'string' then
					error('Invalid "depend" parameter value detected in preprocessArgs')
				end
				preprocessSingleArg(dependValue)
			end
		end
	end

	-- Get arguments with number suffixes.
	local a = 1 -- Counter variable.
	local moreArgumentsExist = true
	while moreArgumentsExist == true do
		moreArgumentsExist = false
		for i = a, a + step - 1 do
			for j,v in ipairs(prefixTable) do
				local prefixArgName = v.prefix .. tostring(i)
				if origArgs[prefixArgName] then
					-- Do another loop if any arguments are found, even blank ones.
					moreArgumentsExist = true
					preprocessSingleArg(prefixArgName)
				end
				-- Process the depend table if the prefix argument is present
				-- and not blank, or we are processing "prefix1" and "prefix" is
				-- present and not blank, and if the depend table is present.
				if v.depend and (args[prefixArgName] or (i == 1 and args[v.prefix])) then
					for j,dependValue in ipairs(v.depend) do
						local dependArgName = dependValue .. tostring(i)
						preprocessSingleArg(dependArgName)
					end
				end
			end
		end
		a = a + step
	end
end

-- Parse the data parameters in the same order that the old {{infobox}} did, so
-- that references etc. will display in the expected places. Parameters that
-- depend on another parameter are only processed if that parameter is present,
-- to avoid phantom references appearing in article reference lists.
local function parseDataParameters()

	preprocessSingleArg('autoheaders')
	preprocessSingleArg('child')
	preprocessSingleArg('bodyclass')
	preprocessSingleArg('subbox')
	preprocessSingleArg('bodystyle')
	preprocessSingleArg('title')
	preprocessSingleArg('titleclass')
	preprocessSingleArg('titlestyle')
	preprocessSingleArg('above')
	preprocessSingleArg('aboveclass')
	preprocessSingleArg('abovestyle')
	preprocessArgs({
		{prefix = 'subheader', depend = {'subheaderstyle', 'subheaderrowclass'}}
	}, 10)
	preprocessSingleArg('subheaderstyle')
	preprocessSingleArg('subheaderclass')
	preprocessArgs({
		{prefix = 'image', depend = {'caption', 'imagerowclass'}}
	}, 10)
	preprocessSingleArg('captionstyle')
	preprocessSingleArg('imagestyle')
	preprocessSingleArg('imageclass')
	preprocessArgs({
		{prefix = 'header'},
		{prefix = 'data', depend = {'label'}},
		{prefix = 'rowclass'},
		{prefix = 'rowstyle'},
		{prefix = 'rowcellstyle'},
		{prefix = 'class'}
	}, 50)
	preprocessSingleArg('headerclass')
	preprocessSingleArg('headerstyle')
	preprocessSingleArg('labelstyle')
	preprocessSingleArg('datastyle')
	preprocessSingleArg('below')
	preprocessSingleArg('belowclass')
	preprocessSingleArg('belowstyle')
	preprocessSingleArg('name')
	-- different behaviour for italics if blank or absent
	args['italic title'] = origArgs['italic title']
	preprocessSingleArg('decat')
	preprocessSingleArg('templatestyles')
	preprocessSingleArg('child templatestyles')
	preprocessSingleArg('grandchild templatestyles')
end

-- If called via #invoke, use the args passed into the invoking template.
-- Otherwise, for testing purposes, assume args are being passed directly in.
function p.infobox(frame)
	if frame == mw.getCurrentFrame() then
		origArgs = frame:getParent().args
	else
		origArgs = frame
	end
	
	parseDataParameters()
	
	return _infobox()
end

-- For calling via #invoke within a template
function p.infoboxTemplate(frame)
	origArgs = {}
	for k,v in pairs(frame.args) do origArgs[k] = mw.text.trim(v) end
	
	parseDataParameters()
	
	return _infobox()
end
return p</text>
      <sha1>1m9tzydwofr8cj9bzzm2am6moool42y</sha1>
    </revision>
  </page>
  <page>
    <title>Module:InfoboxImage</title>
    <ns>828</ns>
    <id>129</id>
    <revision>
      <id>246</id>
      <parentid>245</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>245</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="9894" sha1="2ohqqedq1scfevaci8ml267ehill79u" xml:space="preserve">-- Inputs:
--    image - Can either be a bare filename (with or without the File:/Image: prefix) or a fully formatted image link
--    page - page to display for multipage images (DjVu)
--    size - size to display the image
--    maxsize - maximum size for image
--    sizedefault - default size to display the image if size param is blank
--    alt - alt text for image
--    title - title text for image
--    border - set to yes if border
--    center - set to yes, if the image has to be centered
--    upright - upright image param
--    suppressplaceholder - if yes then checks to see if image is a placeholder and suppresses it
--    link - page to visit when clicking on image
--    class - HTML classes to add to the image
-- Outputs:
--    Formatted image.
-- More details available at the "Module:InfoboxImage/doc" page

local i = {};

local placeholder_image = {
    "Blue - Replace this image female.svg",
    "Blue - Replace this image male.svg",
    "Flag of None (square).svg",
    "Flag of None.svg",
    "Flag of.svg",
    "Green - Replace this image female.svg",
    "Green - Replace this image male.svg",
    "Image is needed female.svg",
    "Image is needed male.svg",
    "Location map of None.svg",
    "Male no free image yet.png",
    "Missing flag.png",
    "No flag.svg",
    "No free portrait.svg",
    "No portrait (female).svg",
    "No portrait (male).svg",
    "Red - Replace this image female.svg",
    "Red - Replace this image male.svg",
    "Replace this image female.svg",
    "Replace this image male (blue).svg",
    "Replace this image male.svg",
    "Silver - Replace this image female.svg",
    "Silver - Replace this image male.svg",
    "Replace this image.svg",
	"Cricket no pic.png",
	"CarersLogo.gif",
	"Diagram Needed.svg",
	"Example.jpg",
	"Image placeholder.png",
	"No male portrait.svg",
	"Nocover-upload.png",
	"NoDVDcover copy.png",
	"Noribbon.svg",
	"No portrait-BFD-test.svg",
	"Placeholder barnstar ribbon.png",
	"Project Trains no image.png",
	"Image-request.png",
	"Sin bandera.svg",
	"Sin escudo.svg",
	"Replace this image - temple.png",
	"Replace this image butterfly.png",
	"Replace this image.svg",
	"Replace this image1.svg",
	"Resolution angle.png",
	"Image-No portrait-text-BFD-test.svg",
	"Insert image here.svg",
	"No image available.png",
	"NO IMAGE YET square.png",
	"NO IMAGE YET.png",
	"No Photo Available.svg",
	"No Screenshot.svg",
	"No-image-available.jpg",
	"Null.png",
	"PictureNeeded.gif",
	"Place holder.jpg",
	"Unbenannt.JPG",
	"UploadACopyrightFreeImage.svg",
	"UploadAnImage.gif",
	"UploadAnImage.svg",
	"UploadAnImageShort.svg",
	"CarersLogo.gif",
	"Diagram Needed.svg",
	"No male portrait.svg",
	"NoDVDcover copy.png",
	"Placeholder barnstar ribbon.png",
	"Project Trains no image.png",
	"Image-request.png",
	"Noimage.gif",
}

local categories = {
	url_image_links = "[[Category:Pages using infoboxes with URL in image parameter]]",
	thumbnail_images = "[[Category:Pages using infoboxes with thumbnail images]]",
}

local function trackable()
	local ns = mw.title.getCurrentTitle().nsText:lower()
	return not (ns == 'user' or ns == 'user talk')
end

function i.IsPlaceholder(image)
    -- change underscores to spaces
    image = mw.ustring.gsub(image, "_", " ");
    assert(image ~= nil, 'mw.ustring.gsub(image, "_", " ") must not return nil')
    -- if image starts with [[ then remove that and anything after |
    if mw.ustring.sub(image,1,2) == "[[" then
        image = mw.ustring.sub(image,3);
        image = mw.ustring.gsub(image, "([^|]*)|.*", "%1");
        assert(image ~= nil, 'mw.ustring.gsub(image, "([^|]*)|.*", "%1") must not return nil')
    end
    -- Trim spaces
    image = mw.ustring.gsub(image, '^[ ]*(.-)[ ]*$', '%1');
    assert(image ~= nil, "mw.ustring.gsub(image, '^[ ]*(.-)[ ]*$', '%1') must not return nil")
    -- remove prefix if exists
    local allNames = mw.site.namespaces[6].aliases
    allNames[#allNames + 1] = mw.site.namespaces[6].name
    allNames[#allNames + 1] = mw.site.namespaces[6].canonicalName
    for i, name in ipairs(allNames) do
        if mw.ustring.lower(mw.ustring.sub(image, 1, mw.ustring.len(name) + 1)) == mw.ustring.lower(name .. ":") then
            image = mw.ustring.sub(image, mw.ustring.len(name) + 2);
            break
        end
    end
    -- Trim spaces
    image = mw.ustring.gsub(image, '^[ ]*(.-)[ ]*$', '%1');
    -- capitalise first letter
    image = mw.ustring.upper(mw.ustring.sub(image,1,1)) .. mw.ustring.sub(image,2);

    for i,j in pairs(placeholder_image) do
        if image == j then
            return true
        end
    end
    return false
end

function i.InfoboxImage(frame)
    local image = frame.args["image"];
    
    if image == "" or image == nil then
        return "";
    end
    if image == "&amp;nbsp;" then
        return image;
    end
    if frame.args["suppressplaceholder"] ~= "no" then
        if i.IsPlaceholder(image) == true then
            return "";
        end
    end
    
    if string.find(image, "^%[*https?:") then
		-- Error category.
		return trackable() and categories.url_image_links or ""
	end

    if mw.ustring.sub(image,1,2) == "[[" then
        -- search for thumbnail images and add to tracking cat if found
        local cat = "";
        if mw.title.getCurrentTitle().namespace == 0 and (mw.ustring.find(image, "|%s*thumb%s*[|%]]") or mw.ustring.find(image, "|%s*thumbnail%s*[|%]]")) then
            cat = trackable() and categories.thumbnail_images or ""
        end
        return image .. cat;
    elseif mw.ustring.sub(image,1,2) == "{{" and mw.ustring.sub(image,1,3) ~= "{{{" then
        return image;
    elseif mw.ustring.sub(image,1,1) == "&lt;" then
        return image;
    elseif mw.ustring.sub(image,1,8) == mw.ustring.char(127).."'\"`UNIQ" then
        -- Found strip marker at begining, so pass don't process at all
        return image;
    else
        local result = "";
        local page = frame.args["page"];
        local size = frame.args["size"];
        local maxsize = frame.args["maxsize"];
        local sizedefault = frame.args["sizedefault"];
        local alt = frame.args["alt"];
        local link = frame.args["link"];
        local title = frame.args["title"];
        local border = frame.args["border"];
        local upright = frame.args["upright"] or "";
        local thumbtime = frame.args["thumbtime"] or "";
        local center = frame.args["center"];
        local class = frame.args["class"];
        
        -- remove prefix if exists
        local allNames = mw.site.namespaces[6].aliases
        allNames[#allNames + 1] = mw.site.namespaces[6].name
        allNames[#allNames + 1] = mw.site.namespaces[6].canonicalName
        for i, name in ipairs(allNames) do
            if mw.ustring.lower(mw.ustring.sub(image, 1, mw.ustring.len(name) + 1)) == mw.ustring.lower(name .. ":") then
                image = mw.ustring.sub(image, mw.ustring.len(name) + 2);
                break
            end
        end
        
        if maxsize ~= "" and maxsize ~= nil then
            -- if no sizedefault then set to maxsize
            if sizedefault == "" or sizedefault == nil then
                sizedefault = maxsize
            end
            -- check to see if size bigger than maxsize
            if size ~= "" and size ~= nil then
                local sizenumber = tonumber(mw.ustring.match(size,"%d*")) or 0;
                local maxsizenumber = tonumber(mw.ustring.match(maxsize,"%d*")) or 0;
                if sizenumber&gt;maxsizenumber and maxsizenumber&gt;0 then
                    size = maxsize;
                end
            end
        end
        -- add px to size if just a number
        if (tonumber(size) or 0) &gt; 0 then
            size = size .. "px";
        end
        -- add px to sizedefault if just a number
        if (tonumber(sizedefault) or 0) &gt; 0 then
            sizedefault = sizedefault .. "px";
        end
        
        result = "[[File:" .. image;
        if page ~= "" and page ~= nil then
            result = result .. "|page=" .. page;
        end
        if size ~= "" and size ~= nil then
            result = result .. "|" .. size;
        elseif sizedefault ~= "" and sizedefault ~= nil then
            result = result .. "|" .. sizedefault;
        else
            result = result .. "|frameless";
        end
        if center == "yes" then
            result = result .. "|center"
        end
        if alt ~= "" and alt ~= nil then
            result = result .. "|alt=" .. alt;
        end
        if link ~= "" and link ~= nil then
            result = result .. "|link=" .. link;
        end
        if border == "yes" then
            result = result .. "|border";
        end
        if upright == "yes" then
            result = result .. "|upright";
        elseif upright ~= "" then
            result = result .. "|upright=" .. upright;
        end
        if thumbtime ~= "" then
            result = result .. "|thumbtime=" .. thumbtime;
        end
        if class ~= nil and class ~= "" then
            result = result .. "|class=" .. class;
        end
        -- if alt value is a keyword then do not use as a description
        if alt == "thumbnail" or alt == "thumb" or alt == "frameless" or alt == "left" or alt == "center" or alt == "right" or alt == "upright" or alt == "border" or mw.ustring.match(alt or "", '^[0-9]*px$', 1) ~= nil then
            alt = nil;
        end
        if title ~= "" and title ~= nil then
            -- does title param contain any templatestyles? If yes then set to blank.
            if mw.ustring.match(frame:preprocess(title), 'UNIQ%-%-templatestyles', 1) ~= nil then
                title = nil;
            end
        end
        if title ~= "" and title ~= nil then
            result = result .. "|" .. title;
        end
        result = result .. "]]";
        
        return result;
    end
end

return i;</text>
      <sha1>2ohqqedq1scfevaci8ml267ehill79u</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Infobox/styles.css</title>
    <ns>828</ns>
    <id>130</id>
    <revision>
      <id>248</id>
      <parentid>247</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>247</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="2112" sha1="ed9hwgdet8h6h2bc3c9iiv47kgu74p6" xml:space="preserve">/* {{pp|small=y}} */
/*
 * This TemplateStyles sheet deliberately does NOT include the full set of
 * infobox styles. We are still working to migrate all of the manual
 * infoboxes. See [[MediaWiki talk:Common.css/to do#Infobox]]
 * DO NOT ADD THEM HERE
 */
/*
 * not strictly certain these styles are necessary since the modules now
 * exclusively output infobox-subbox or infobox, not both
 * just replicating the module faithfully
 */
.infobox-subbox {
	padding: 0;
	border: none;
	margin: -3px;
	width: auto;
	min-width: 100%;
	font-size: 100%;
	clear: none;
	float: none;
	background-color: transparent;
}

.infobox-3cols-child {
	margin: auto;
}

.infobox .navbar {
	font-size: 100%;
}

/* Dark theme: [[William_Wragg]], [[Coral_Castle]] */

@media screen {
    html.skin-theme-clientpref-night .infobox-full-data:not(.notheme) &gt; div:not(.notheme)[style] {
	    background: #1f1f23 !important;
	      /* switch with var( --color-base ) when supported. */
	      color: #f8f9fa;
	}
}


@media screen and ( prefers-color-scheme: dark) {
    html.skin-theme-clientpref-os .infobox-full-data:not(.notheme) &gt; div:not(.notheme)[style] {
      background: #1f1f23 !important;
      /* switch with var( --color-base ) when supported. */
      color: #f8f9fa;
    }
}


/* Since infobox is a table, many infobox templates take advantage of this to
 * add columns and rows to the infobox itself rather than as part of a new table
 * inside them. This class should be discouraged and removed on the long term,
 * but allows us to at least identify these tables going forward
 * Currently in use on: [[Module:Infobox3cols]]
 * Fixes issue described in [[phab:F55300125]] on Vector 2022.
*/
@media (min-width: 640px) {
  body.skin--responsive .infobox-table {
    display: table !important;
  }
  body.skin--responsive .infobox-table &gt; caption {
    display: table-caption !important;
  }
  body.skin--responsive .infobox-table &gt; tbody {
    display: table-row-group;
  }
  body.skin--responsive .infobox-table th,
  body.skin--responsive .infobox-table td {
    padding-left: inherit;
    padding-right: inherit;
  }
}</text>
      <sha1>ed9hwgdet8h6h2bc3c9iiv47kgu74p6</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Category handler</title>
    <ns>10</ns>
    <id>131</id>
    <revision>
      <id>250</id>
      <parentid>249</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>249</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="148" sha1="og6fhyj2ssd4fmzpqzuodk12q3cms0z" xml:space="preserve">{{#invoke:Category handler|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories to the /doc subpage, and interwikis to Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>og6fhyj2ssd4fmzpqzuodk12q3cms0z</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler</title>
    <ns>828</ns>
    <id>132</id>
    <revision>
      <id>252</id>
      <parentid>251</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>251</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7871" sha1="letwavu3yvlayfzew66uuwixmwebq5b" xml:space="preserve">--------------------------------------------------------------------------------
--                                                                            --
--                              CATEGORY HANDLER                              --
--                                                                            --
--      This module implements the {{category handler}} template in Lua,      --
--      with a few improvements: all namespaces and all namespace aliases     --
--      are supported, and namespace names are detected automatically for     --
--      the local wiki. This module requires [[Module:Namespace detect]]      --
--      and [[Module:Yesno]] to be available on the local wiki. It can be     --
--      configured for different wikis by altering the values in              --
--      [[Module:Category handler/config]], and pages can be blacklisted      --
--      from categorisation by using [[Module:Category handler/blacklist]].   --
--                                                                            --
--------------------------------------------------------------------------------

-- Load required modules
local yesno = require('Module:Yesno')

-- Lazily load things we don't always need
local mShared, mappings

local p = {}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function trimWhitespace(s, removeBlanks)
	if type(s) ~= 'string' then
		return s
	end
	s = s:match('^%s*(.-)%s*$')
	if removeBlanks then
		if s ~= '' then
			return s
		else
			return nil
		end
	else
		return s
	end
end

--------------------------------------------------------------------------------
-- CategoryHandler class
--------------------------------------------------------------------------------

local CategoryHandler = {}
CategoryHandler.__index = CategoryHandler

function CategoryHandler.new(data, args)
	local obj = setmetatable({ _data = data, _args = args }, CategoryHandler)
	
	-- Set the title object
	do
		local pagename = obj:parameter('demopage')
		local success, titleObj
		if pagename then
			success, titleObj = pcall(mw.title.new, pagename)
		end
		if success and titleObj then
			obj.title = titleObj
			if titleObj == mw.title.getCurrentTitle() then
				obj._usesCurrentTitle = true
			end
		else
			obj.title = mw.title.getCurrentTitle()
			obj._usesCurrentTitle = true
		end
	end

	-- Set suppression parameter values
	for _, key in ipairs{'nocat', 'categories'} do
		local value = obj:parameter(key)
		value = trimWhitespace(value, true)
		obj['_' .. key] = yesno(value)
	end
	do
		local subpage = obj:parameter('subpage')
		local category2 = obj:parameter('category2')
		if type(subpage) == 'string' then
			subpage = mw.ustring.lower(subpage)
		end
		if type(category2) == 'string' then
			subpage = mw.ustring.lower(category2)
		end
		obj._subpage = trimWhitespace(subpage, true)
		obj._category2 = trimWhitespace(category2) -- don't remove blank values
	end
	return obj
end

function CategoryHandler:parameter(key)
	local parameterNames = self._data.parameters[key]
	local pntype = type(parameterNames)
	if pntype == 'string' or pntype == 'number' then
		return self._args[parameterNames]
	elseif pntype == 'table' then
		for _, name in ipairs(parameterNames) do
			local value = self._args[name]
			if value ~= nil then
				return value
			end
		end
		return nil
	else
		error(string.format(
			'invalid config key "%s"',
			tostring(key)
		), 2)
	end
end

function CategoryHandler:isSuppressedByArguments()
	return
		-- See if a category suppression argument has been set.
		self._nocat == true
		or self._categories == false
		or (
			self._category2
			and self._category2 ~= self._data.category2Yes
			and self._category2 ~= self._data.category2Negative
		)

		-- Check whether we are on a subpage, and see if categories are
		-- suppressed based on our subpage status.
		or self._subpage == self._data.subpageNo and self.title.isSubpage
		or self._subpage == self._data.subpageOnly and not self.title.isSubpage
end

function CategoryHandler:shouldSkipBlacklistCheck()
	-- Check whether the category suppression arguments indicate we
	-- should skip the blacklist check.
	return self._nocat == false
		or self._categories == true
		or self._category2 == self._data.category2Yes
end

function CategoryHandler:matchesBlacklist()
	if self._usesCurrentTitle then
		return self._data.currentTitleMatchesBlacklist
	else
		mShared = mShared or require('Module:Category handler/shared')
		return mShared.matchesBlacklist(
			self.title.prefixedText,
			mw.loadData('Module:Category handler/blacklist')
		)
	end
end

function CategoryHandler:isSuppressed()
	-- Find if categories are suppressed by either the arguments or by
	-- matching the blacklist.
	return self:isSuppressedByArguments()
		or not self:shouldSkipBlacklistCheck() and self:matchesBlacklist()
end

function CategoryHandler:getNamespaceParameters()
	if self._usesCurrentTitle then
		return self._data.currentTitleNamespaceParameters
	else
		if not mappings then
			mShared = mShared or require('Module:Category handler/shared')
			mappings = mShared.getParamMappings(true) -- gets mappings with mw.loadData
		end
		return mShared.getNamespaceParameters(
			self.title,
			mappings
		)
	end
end

function CategoryHandler:namespaceParametersExist()
	-- Find whether any namespace parameters have been specified.
	-- We use the order "all" --&gt; namespace params --&gt; "other" as this is what
	-- the old template did.
	if self:parameter('all') then
		return true
	end
	if not mappings then
		mShared = mShared or require('Module:Category handler/shared')
		mappings = mShared.getParamMappings(true) -- gets mappings with mw.loadData
	end
	for ns, params in pairs(mappings) do
		for i, param in ipairs(params) do
			if self._args[param] then
				return true
			end
		end
	end
	if self:parameter('other') then
		return true
	end
	return false
end

function CategoryHandler:getCategories()
	local params = self:getNamespaceParameters()
	local nsCategory
	for i, param in ipairs(params) do
		local value = self._args[param]
		if value ~= nil then
			nsCategory = value
			break
		end
	end
	if nsCategory ~= nil or self:namespaceParametersExist() then
		-- Namespace parameters exist - advanced usage.
		if nsCategory == nil then
			nsCategory = self:parameter('other')
		end
		local ret = {self:parameter('all')}
		local numParam = tonumber(nsCategory)
		if numParam and numParam &gt;= 1 and math.floor(numParam) == numParam then
			-- nsCategory is an integer
			ret[#ret + 1] = self._args[numParam]
		else
			ret[#ret + 1] = nsCategory
		end
		if #ret &lt; 1 then
			return nil
		else
			return table.concat(ret)
		end
	elseif self._data.defaultNamespaces[self.title.namespace] then
		-- Namespace parameters don't exist, simple usage.
		return self._args[1]
	end
	return nil
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p = {}

function p._exportClasses()
	-- Used for testing purposes.
	return {
		CategoryHandler = CategoryHandler
	}
end

function p._main(args, data)
	data = data or mw.loadData('Module:Category handler/data')
	local handler = CategoryHandler.new(data, args)
	if handler:isSuppressed() then
		return nil
	end
	return handler:getCategories()
end

function p.main(frame, data)
	data = data or mw.loadData('Module:Category handler/data')
	local args = require('Module:Arguments').getArgs(frame, {
		wrappers = data.wrappers,
		valueFunc = function (k, v)
			v = trimWhitespace(v)
			if type(k) == 'number' then
				if v ~= '' then
					return v
				else
					return nil
				end
			else
				return v
			end
		end
	})
	return p._main(args, data)
end

return p</text>
      <sha1>letwavu3yvlayfzew66uuwixmwebq5b</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/data</title>
    <ns>828</ns>
    <id>133</id>
    <revision>
      <id>254</id>
      <parentid>253</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>253</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="631" sha1="k26mwixuaeijisfddb0sxkg82iux8v4" xml:space="preserve">-- This module assembles data to be passed to [[Module:Category handler]] using
-- mw.loadData. This includes the configuration data and whether the current
-- page matches the title blacklist.

local data = require('Module:Category handler/config')
local mShared = require('Module:Category handler/shared')
local blacklist = require('Module:Category handler/blacklist')
local title = mw.title.getCurrentTitle()

data.currentTitleMatchesBlacklist = mShared.matchesBlacklist(
	title.prefixedText,
	blacklist
)

data.currentTitleNamespaceParameters = mShared.getNamespaceParameters(
	title,
	mShared.getParamMappings()
)

return data</text>
      <sha1>k26mwixuaeijisfddb0sxkg82iux8v4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/config</title>
    <ns>828</ns>
    <id>134</id>
    <revision>
      <id>256</id>
      <parentid>255</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>255</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5755" sha1="6ga9hbq2pdwalsvx68i53dmbr421rq5" xml:space="preserve">--------------------------------------------------------------------------------
--            [[Module:Category handler]] configuration data                  --
--       Language-specific parameter names and values can be set here.        --
--       For blacklist config, see [[Module:Category handler/blacklist]].     --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                       Start configuration data                             --
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--                              Parameter names                               --
-- These configuration items specify custom parameter names.                  --
-- To add one extra name, you can use this format:                            --
--                                                                            --
-- foo = 'parameter name',                                                    --
--                                                                            --
-- To add multiple names, you can use this format:                            --
--                                                                            --
-- foo = {'parameter name 1', 'parameter name 2', 'parameter name 3'},        --
--------------------------------------------------------------------------------

cfg.parameters = {
	
	-- The nocat and categories parameter suppress
	-- categorisation. They are used with Module:Yesno, and work as follows:
	--
	-- cfg.nocat:
	-- Result of yesno()                        Effect
	-- true                                     Categorisation is suppressed
	-- false                                    Categorisation is allowed, and
	--                                          the blacklist check is skipped
	-- nil                                      Categorisation is allowed
	--
	-- cfg.categories:
	-- Result of yesno()                        Effect
	-- true                                     Categorisation is allowed, and
	--                                          the blacklist check is skipped
	-- false                                    Categorisation is suppressed
	-- nil                                      Categorisation is allowed
	nocat = 'nocat',
	categories = 'categories',
	
	-- The parameter name for the legacy "category2" parameter. This skips the
	-- blacklist if set to the cfg.category2Yes value, and suppresses
	-- categorisation if present but equal to anything other than
	-- cfg.category2Yes or cfg.category2Negative.
	category2 = 'category2',
	
	-- cfg.subpage is the parameter name to specify how to behave on subpages.
	subpage = 'subpage',
	
	-- The parameter for data to return in all namespaces.
	all = 'all',
	
	-- The parameter name for data to return if no data is specified for the
	-- namespace that is detected.
	other = 'other',
	
	-- The parameter name used to specify a page other than the current page;
	-- used for testing and demonstration.
	demopage = 'page',
}

--------------------------------------------------------------------------------
--                              Parameter values                              --
-- These are set values that can be used with certain parameters. Only one    --
-- value can be specified, like this:                                         --
--                                                                            --
-- cfg.foo = 'value name'                                                     --                                               --
--------------------------------------------------------------------------------

-- The following settings are used with the cfg.category2 parameter. Setting
-- cfg.category2 to cfg.category2Yes skips the blacklist, and if cfg.category2
-- is present but equal to anything other than cfg.category2Yes or
-- cfg.category2Negative then it supresses cateogrisation.
cfg.category2Yes = 'yes'
cfg.category2Negative = '¬'

-- The following settings are used with the cfg.subpage parameter.
-- cfg.subpageNo is the value to specify to not categorise on subpages;
-- cfg.subpageOnly is the value to specify to only categorise on subpages.
cfg.subpageNo = 'no'
cfg.subpageOnly = 'only'

--------------------------------------------------------------------------------
--                           Default namespaces                               --
-- This is a table of namespaces to categorise by default. The keys are the   --
-- namespace numbers.                                                         --
--------------------------------------------------------------------------------

cfg.defaultNamespaces = {
	[  0] = true, -- main
	[  6] = true, -- file
	[ 12] = true, -- help
	[ 14] = true, -- category
	[100] = true, -- portal
	[108] = true, -- book
}

--------------------------------------------------------------------------------
--                                Wrappers                                    --
-- This is a wrapper template or a list of wrapper templates to be passed to  --
-- [[Module:Arguments]].                                                      --
--------------------------------------------------------------------------------

cfg.wrappers = 'Template:Category handler'

--------------------------------------------------------------------------------
--                           End configuration data                           --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line.</text>
      <sha1>6ga9hbq2pdwalsvx68i53dmbr421rq5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/shared</title>
    <ns>828</ns>
    <id>135</id>
    <revision>
      <id>258</id>
      <parentid>257</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>257</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="888" sha1="omlsnhudxz6juptvtxz7ns97jutbzc5" xml:space="preserve">-- This module contains shared functions used by [[Module:Category handler]]
-- and its submodules.

local p = {}

function p.matchesBlacklist(page, blacklist)
	for i, pattern in ipairs(blacklist) do
		local match = mw.ustring.match(page, pattern)
		if match then
			return true
		end
	end
	return false
end

function p.getParamMappings(useLoadData)
	local dataPage = 'Module:Namespace detect/data'
	if useLoadData then
		return mw.loadData(dataPage).mappings
	else
		return require(dataPage).mappings
	end
end

function p.getNamespaceParameters(titleObj, mappings)
	-- We don't use title.nsText for the namespace name because it adds
	-- underscores.
	local mappingsKey
	if titleObj.isTalkPage then
		mappingsKey = 'talk'
	else
		mappingsKey = mw.site.namespaces[titleObj.namespace].name
	end
	mappingsKey = mw.ustring.lower(mappingsKey)
	return mappings[mappingsKey] or {}
end

return p</text>
      <sha1>omlsnhudxz6juptvtxz7ns97jutbzc5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/blacklist</title>
    <ns>828</ns>
    <id>136</id>
    <revision>
      <id>260</id>
      <parentid>259</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>259</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="761" sha1="fsv1drcay6t25e91hzhqxtyp7pckbpx" xml:space="preserve">-- This module contains the blacklist used by [[Module:Category handler]].
-- Pages that match Lua patterns in this list will not be categorised unless
-- categorisation is explicitly requested.

return {
	'^Main Page$', -- don't categorise the main page.

	-- Don't categorise the following pages or their subpages.
	-- "%f[/\0]" matches if the next character is "/" or the end of the string.
	'^Wikipedia:Cascade%-protected items%f[/\0]',
	'^User:UBX%f[/\0]', -- The userbox "template" space.
	'^User talk:UBX%f[/\0]',

	-- Don't categorise subpages of these pages, but allow
	-- categorisation of the base page.
	'^Wikipedia:Template index/.*$',

	-- Don't categorise archives.
	'/[aA]rchive',
	"^Wikipedia:Administrators' noticeboard/IncidentArchive%d+$",
}</text>
      <sha1>fsv1drcay6t25e91hzhqxtyp7pckbpx</sha1>
    </revision>
  </page>
  <page>
    <title>Template:PAGENAMEBASE</title>
    <ns>10</ns>
    <id>137</id>
    <revision>
      <id>262</id>
      <parentid>261</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>261</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="151" sha1="hfmr5rmcuhdncvzny8x6n6ob8hddcpq" xml:space="preserve">{{safesubst:&lt;noinclude/&gt;#invoke:String|replace|{{{1|{{safesubst:&lt;noinclude/&gt;PAGENAME}}}}}|%s+%b()$||1|false}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>hfmr5rmcuhdncvzny8x6n6ob8hddcpq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:EditAtWikidata</title>
    <ns>828</ns>
    <id>138</id>
    <revision>
      <id>264</id>
      <parentid>263</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>263</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1727" sha1="hod1hfo0n331jsuhscew67pebepcmju" xml:space="preserve">-- Module to display an icon with a tooltip such as "Edit this at Wikidata".
-- Icon is linked to the Wikidata entry for the article where this is placed.
-- This message is only displayed if a local_parameter is not supplied
-- i.e. when called from a template, it can be coded not to display the message.
-- The qid of a Wikidata entry can optionally be supplied for testing outside the article.
-- Usage:
-- {{#invoke:EditAtWikidata|showMessage|local_parameter}}
-- {{#invoke:EditAtWikidata|showMessage|qid=&lt;ArticleID&gt;|local_parameter}}

local p = {}

local i18n =
{
	["message"] = "Edit this at Wikidata"
}

local function trimToNil(text)
	-- Return trimmed non-empty text, or nil.
	if type(text) == 'string' then
		return text:match('(%S.-)%s*$')
	end
end

function p._showMessage(args)
	local local_parm = trimToNil(args[1])
	if local_parm then return "" end
	-- Parameter qid=x specifies the Wikidata ID for the article.
	-- This is not normally used except for testing outside the article.
	local qid = trimToNil(args.qid) or mw.wikibase.getEntityIdForCurrentPage()
	if qid and mw.wikibase.entityExists(qid) then
		-- Parameter pid=x uses x as an anchor in the link to the Wikidata entry.
		local anchor = trimToNil(args.pid)
		-- Parameter nbsp replaces the leading space with &amp;nbsp;
		local space = trimToNil(args.nbsp) and "&amp;nbsp;" or " "
		return
			space ..
			"[[File:OOjs UI icon edit-ltr-progressive.svg|frameless|text-top|10px" ..
			"|alt=" .. i18n.message ..
			"|link=https://www.wikidata.org/wiki/" .. qid ..
			(anchor and ("#" .. anchor) or "") ..
			"|class=noprint" ..
			"|" .. i18n.message ..
			"]]"
	end
	return ""
end

function p.showMessage(frame)
	return p._showMessage(frame.args)
end

return p</text>
      <sha1>hod1hfo0n331jsuhscew67pebepcmju</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite news</title>
    <ns>10</ns>
    <id>139</id>
    <revision>
      <id>266</id>
      <parentid>265</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>265</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="123" sha1="pbjnspfej5gxihr9izxrzkow3f1uf3i" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=news
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>pbjnspfej5gxihr9izxrzkow3f1uf3i</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Authority control</title>
    <ns>10</ns>
    <id>140</id>
    <revision>
      <id>268</id>
      <parentid>267</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>267</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="88" sha1="r48ujosbuyn94pk0voopv45idwf5fo2" xml:space="preserve">{{#invoke:Authority control|authorityControl}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>r48ujosbuyn94pk0voopv45idwf5fo2</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Authority control</title>
    <ns>828</ns>
    <id>141</id>
    <revision>
      <id>270</id>
      <parentid>269</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>269</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="13126" sha1="hwvwcau9qgclluoqlso3vj6gimuwpy6" xml:space="preserve">require('strict')
local p = {}
local frame = mw.getCurrentFrame()
local config_file = frame.args.config and frame.args.config~='' and ('/' .. frame.args.config) or ''
local config = mw.loadData('Module:Authority control/config' .. config_file)
local title = mw.title.getCurrentTitle()
local namespace = title.namespace
local testcases = title.subpageText == config.i18n.testcases

local wikilink = function(target, label)
	return label and '[[' .. target .. '|' .. label .. ']]' or '[[' .. target .. ']]'
end

local needsAttention = function(sortkey)
	return wikilink(config.i18n.category .. ':' .. config.i18n.attentioncat, sortkey .. title.text)
end

local addCat = function(cat, sortkey)
	if cat and cat~='' and (namespace==0 or namespace==14 or testcases) then
		local redlinkcat = ''
		if testcases==false then
			local success, exists = pcall(function() return mw.title.new(cat, 14).exists end)
			if success and not exists then 
				redlinkcat = needsAttention('N')
			end
		end
		return wikilink(config.i18n.category..':'..cat, sortkey and sortkey..title.text) .. redlinkcat
	else
		return ''
	end
end

local tooltip = function(text, label)
	if label and label~='' then
		return frame:expandTemplate{
			title = 'Tooltip',
			args = {text, label}
		}
	else
		return text
	end
end

local _makelink = function(id, val, additional, qid) --validate values and create a link
	local link = mw.html.create('span'):addClass('uid')
	if not additional and id.prefix then --show prefix on primary value
		link:wikitext(id.prefix .. ': ')
	end
	local valid_value = false
	if id.customlink then -- use function to validate and generate link
		local newlink = require(config.auxiliary)[id.customlink](val.id, additional)
		if newlink then
			link:wikitext(newlink)
			valid_value = true
		end
	else
		if id.pattern then -- check pattern to determine validity
			valid_value = string.match(val.id, '^' .. id.pattern .. '$')
		elseif id.patterns then -- check multiple patterns to determine validity
			for _, pattern in ipairs(id.patterns) do
				valid_value = val.id:match('^' .. pattern .. '$')
				if valid_value then break end
			end
		elseif id.valid then -- use function to determine validity
			valid_value = require(config.auxiliary)[id.valid](val.id)
		else -- no validation possible
			valid_value = val.id
		end
		if valid_value then
			local label = id.label
			if not label or additional then
				label = tostring(additional)
			end
			local newlink
			if id.link then
				valid_value = valid_value:gsub('%%', '%%%%')
				local target = mw.ustring.gsub(id.link, '%$1', valid_value):gsub(' ', '%%20')
				newlink = '[' .. target .. ' ' .. label .. ']'
			else
				newlink = valid_value
			end
			link:wikitext(tooltip(newlink, val.name))
		end
	end
	if valid_value then
		local cat =  id.category and string.format(config.i18n.cat, id.category)
		link:wikitext(addCat(cat))
	else
		local wdlink = qid and wikilink(':wikidata:' .. qid .. '#P' .. id.property) or ''
		local name = mw.wikibase.getLabel('P' .. id.property) or ''
		local tooltip = string.format(
			config.i18n.idnotvalid,
			name,
			val.id
		)
		local cat = id.category and string.format(
			config.i18n.cat,
			config.i18n.faulty .. ' ' .. id.category
		)
		link:wikitext(wikilink('File:' .. config.i18n.warningicon .. '|20px|frameless|link=' .. wdlink, tooltip .. '.'))
			:wikitext(addCat(cat))
			:wikitext(addCat(config.i18n.allfaultycat, name))
	end
	return link
end

local _makelinks = function(id, qid)
--[[==================================]]
--[[            Make links            ]]
--[[==================================]]
local getquals = function(statement, qualid)
	if statement.qualifiers and statement.qualifiers['P'..qualid] then
		return mw.wikibase.renderSnak(statement.qualifiers['P'..qualid][1])
	end
end
local ids = {}
if qid then
	for _, statement in ipairs(mw.wikibase.getBestStatements(qid, 'P'..id.property)) do
		if statement.mainsnak.datavalue then
			local val = statement.mainsnak.datavalue.value
			if val then
				local namedas = getquals(statement, 1810) or getquals(statement, 742) or ''
				table.insert(ids, {id=val, name=namedas})
end end end end
local links
if ids[1] then
	links = mw.html.create('li'):node(_makelink(id, ids[1], false, qid))
	if ids[2] then
		local sublinks = mw.html.create('ul')
		for n = 2, #ids do
			sublinks:tag('li'):node(_makelink(id, ids[n], n, qid)):done()
		end
		links:node(sublinks)
	end
end
return links
end

p.authorityControl = function(frame)
--[[==================================]]
--[[               Main               ]]
--[[==================================]]
local resolveQID = function(qid)
	if qid then
		qid = 'Q' .. mw.ustring.gsub(qid, '^[Qq]', '')
		if mw.wikibase.isValidEntityId(qid) and mw.wikibase.entityExists(qid) then
			local sitelink = mw.wikibase.getSitelink(qid)
			if sitelink then
				return mw.wikibase.getEntityIdForTitle(sitelink) or mw.wikibase.getEntity(qid).id
			end
			return mw.wikibase.getEntity(qid).id
end end end
local conf = config.config
local parentArgs = frame:getParent().args
local auxCats = ''
local rct = false -- boolean to track if there are any links to be returned
local qid, topic
if namespace==0 then
	qid = mw.wikibase.getEntityIdForCurrentPage()
end
if qid then -- article is connected to a Wikidata item
	if parentArgs.qid and resolveQID(parentArgs.qid)~=qid then -- non-matching qid parameter
		auxCats = auxCats .. needsAttention('D')
	end
else -- page is not connected to any Wikidata item
	qid = resolveQID(parentArgs.qid) -- check qid parameter if no wikidata item is connected
	if qid then -- qid parameter is valid, set topic to display
		topic = mw.wikibase.getLabel(qid)
		if topic then
			if mw.ustring.lower(title.subpageText)==mw.ustring.lower(topic) then -- suppress topic display if subpagename equals topic up to case change
				topic = nil
			end
			if topic and mw.wikibase.getSitelink(qid) then -- make wikilink to article
				topic = wikilink(mw.wikibase.getSitelink(qid), topic)
			end
		else
			auxCats = auxCats .. needsAttention('L')
		end
	elseif parentArgs.qid and parentArgs.qid~='' then -- invalid qid has been supplied, add to tracking cat
		auxCats = auxCats .. needsAttention('Q')
	end
end
local qids = {} -- setup any additional QIDs
if parentArgs.additional=='auto' and qid then  -- check P527 for parts to add additional qids
	local checkparts = function(property)
		local parts = mw.wikibase.getBestStatements(qid, property)
		if parts then
			for _, part in ipairs(parts) do
				if part.mainsnak.datavalue and part.mainsnak.datavalue.value.id then
					local resolvedqid = resolveQID(part.mainsnak.datavalue.value.id)
					if resolvedqid then
						table.insert(qids,resolvedqid)
	end end end end end
	for _, part in ipairs(config.auto_additional) do
		checkparts('P' .. part)
	end
elseif parentArgs.additional and parentArgs.additional~='' then
	for _, v in ipairs(mw.text.split(parentArgs.additional, '%s*,%s*')) do
		v = resolveQID(v)
		if v then
			if v==qid then -- duplicate of qid parameter
				auxCats = auxCats .. needsAttention('R')
			end
			table.insert(qids, v)
		else -- invalid QID specified
			auxCats = auxCats .. needsAttention('A')
		end
	end
end
local numsections, sections = 0, {}
for _, _ in ipairs(config.sections) do -- count number of regular sections
	numsections = numsections + 1
end
for _ = 1, #qids+numsections do
	table.insert(sections, {})
end

-- check which identifiers to show/suppress in template
local show, show_all_unsuppressed = {}, true
local stripP = function(pid) --strip P from property number
	if pid:match('^[Pp]%d+$') then
		pid = mw.ustring.gsub(pid, '[Pp]', '')
	end
	if pid:match('^%d+$') then
		return tonumber(pid)
	end
end
local addshowlist = function(list)
	if list and list~='' then
		for _, v in ipairs(mw.text.split(string.lower(list), '%s*,%s*')) do
			local vprop = stripP(v)
			if vprop then -- e.g. show=P214 to show one particular property
				show[vprop] = true
			else -- e.g. show=arts to use whitelist
				if config.whitelists[v] then
					for _, w in ipairs(config.whitelists[v].properties) do
						show[w] = true
		end end end end
		show_all_unsuppressed = false
end end
addshowlist(frame.args.show) -- check show parameter on wrapper template
addshowlist(parentArgs.show) -- check show parameter on article
addshowlist(parentArgs.country) -- check country parameter on article
if parentArgs.suppress then
	local suppresslist = mw.text.split(parentArgs.suppress, '%s*,%s*') -- split parameter by comma
	for _, v in ipairs(suppresslist) do
		v = stripP(v)
		if v then
			show[v] = false
			auxCats = auxCats .. wikilink(config.i18n.category .. ':' .. config.i18n.suppressedcat)
		else
			auxCats = auxCats .. needsAttention('P')
		end
	end
end

local makeSections = function(qid, addit)
	for _, id in ipairs(conf) do
		if id.suppressedbyproperty then
			for _, property in ipairs(id.suppressedbyproperty) do
				if show[property]=='used' then -- property is in use
					show[id.property] = false -- suppressed by another property
		end end end
		if show[id.property]==nil then
			show[id.property] = show_all_unsuppressed
		end
		if show[id.property] then
			local links = _makelinks(id, qid)
			if links then
				table.insert(
					sections[addit or id.section],
					links
				)
				show[id.property] = 'used'
				rct = true
			end
		end
	end
end
local pencil = function(qid)
	if qid then
		return require('Module:EditAtWikidata')._showMessage{
			pid = 'identifiers',
			qid = qid
		}
	else
		return ''
	end
end
makeSections(qid, false)
for c = 1, #qids do
	makeSections(qids[c], numsections+c)
end

--configure Navbox
local outString = ''
if rct then -- there is at least one link to display
	local Navbox = require('Module:Navbox')
	local sect, lastsect = 0, 0
	local navboxArgs = {
		name  = 'Authority control',
		navboxclass = 'authority-control',
		bodyclass = 'hlist',
		state = parentArgs.state or config.i18n.autocollapse,
		navbar = 'off'
	}
	for c = 1, numsections+#qids do
		if #sections[c]&gt;0 then -- section is non-empty
			sect = sect + 1
			lastsect = c
			local sectname
			if c&lt;=numsections then -- regular section
				sectname = config.sections[c].name
			else -- section from additional qid
				local qid = qids[c-numsections]
				local label, sitelink = mw.wikibase.getLabel(qid), mw.wikibase.getSitelink(qid)
				if label then
					if sitelink then
						local target = mw.title.new(sitelink)
						if target==title or (target.isRedirect and target.redirectTarget==title) then -- do not link
							sectname = label
						else -- make wikilink to article
							sectname = wikilink(sitelink, label)
						end
					else
						sectname = label
					end
				else
					auxCats = auxCats .. needsAttention('L')
					sectname = qid
				end
				sectname = sectname .. pencil(qid)
			end
			navboxArgs['group' .. c] = sectname
			local list = mw.html.create('ul')
			for _, link in ipairs(sections[c]) do
				list:node(link)
			end
			navboxArgs['list' .. c] = tostring(list)
		end
	end
	if topic then -- display in expanded form with topic
		navboxArgs.title = config.i18n.aclink .. ' &amp;ndash; ' .. topic .. pencil(qid)
	elseif sect==1 then -- special display when only one section
		if lastsect&lt;=numsections then
			if config.sections[lastsect].hidelabelwhenalone then -- no special label when only general or other IDs are present
				navboxArgs['group' .. lastsect] = config.i18n.aclink .. pencil(qid)
			else -- other regular section
				navboxArgs['group' .. lastsect] = config.i18n.aclink .. ': ' .. navboxArgs['group' .. lastsect] .. pencil(qid)
			end
		else -- section from additional qid
			navboxArgs['group' .. lastsect] = config.i18n.aclink .. ': ' .. navboxArgs['group' .. lastsect]
		end
	else -- add title to navbox
		navboxArgs.title = config.i18n.aclink .. pencil(qid)
	end
	outString = Navbox._navbox(navboxArgs)
end

if parentArgs.state
	and parentArgs.state~=''
	and parentArgs.state~=config.i18n.collapsed
	and parentArgs.state~=config.i18n.expanded
	and parentArgs.state~=config.i18n.autocollapse then --invalid state parameter
	auxCats = auxCats .. needsAttention('S')
end
if testcases then
	auxCats = mw.ustring.gsub(auxCats, '(%[%[)(' .. config.i18n.category .. ')', '%1:%2') --for easier checking
end

--out
outString = outString .. auxCats
if namespace~=0 then
	outString = mw.ustring.gsub(outString, '(%[%[)(' .. config.i18n.category .. ':' .. config.i18n.Articles .. ')([^%|%]]+)%|?[^%|%]]*(%]%])','%1:%2%3%4')
	outString = mw.ustring.gsub(outString, '(%[%[)(' .. config.i18n.category .. ':' .. config.i18n.All_articles .. ')([^%|%]]+)%|?[^%|%]]*(%]%])','%1:%2%3%4')
end
local check = require('Module:Check for unknown parameters')._check
local sortkey
if namespace==0 then
	sortkey = '*' .. title.text
else
	sortkey = title.fullText
end
outString = outString .. check({
	['unknown'] = wikilink(config.i18n.category .. ':' .. config.i18n.pageswithparams, sortkey),
	['preview'] = config.i18n.previewwarning, 'show', 'country', 'suppress', 'additional', 'qid', 'state'
	}, parentArgs)
return outString
end

p.makelink = function(id, qid)
	return _makelinks(id, qid)
end

return p</text>
      <sha1>hwvwcau9qgclluoqlso3vj6gimuwpy6</sha1>
    </revision>
  </page>
  <page>
    <title>Module:If preview</title>
    <ns>828</ns>
    <id>142</id>
    <revision>
      <id>272</id>
      <parentid>271</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>271</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1973" sha1="9xxiwh6yksz0t17svyd7nlq7rj3f5rk" xml:space="preserve">local p = {}
local getArgs = require("Module:Arguments").getArgs
local yn = require("Module:Yesno")
local cfg = mw.loadData('Module:If preview/configuration')

--[[
main

This function returns either the first argument or second argument passed to
this module, depending on whether the page is being previewed.

]]
function p.main(frame)
	local args = getArgs(frame)
	if cfg.preview then
		return args[1] or ''
	else
		return args[2] or ''
	end
end

--[[
pmain

This function returns either the first argument or second argument passed to
this module's parent (i.e. template using this module), depending on whether it
is being previewed.

]]
function p.pmain(frame)
	return p.main(frame:getParent())
end

local function warning_text(warning)
	return mw.ustring.format(
		cfg.warning_infrastructure,
		cfg.templatestyles,
		warning
	)
end

function p._warning(args)
	
	local warning = args[1] and args[1]:match('^%s*(.-)%s*$') or ''
	if warning == '' then
		return warning_text(cfg.missing_warning)
	end
	
	if not cfg.preview then return '' end
	
	if yn(args['consolewarning']) then mw.addWarning(args[1] or cfg.missing_warning) end
	return warning_text(warning)
end

--[[
warning

This function returns a "preview warning", which is the first argument marked
up with HTML and some supporting text, depending on whether the page is being previewed.

]]
-- function p.warning(frame)
-- 	mw.addWarning(frame.args[1] or cfg.missing_warning)
-- 	return p._warning(frame.args)
-- end

--[[
warning, but for pass-through templates like {{preview warning}}
]]
function p.pwarning(frame)
	local args = getArgs(frame)
	return p._warning(args)
end

--[[
Does both mw.addWarning and preview warning
]]

function p.warn(text)
	if text == nil or text == "" then return "" end
	mw.addWarning(text)
	return p._warning({text})
end

--[[
Console warning
]]
function p.consoleWarning(frame)
	local args = getArgs(frame)
	mw.addWarning(args[1] or cfg.missing_warning)
	return ''
end

return p</text>
      <sha1>9xxiwh6yksz0t17svyd7nlq7rj3f5rk</sha1>
    </revision>
  </page>
  <page>
    <title>Module:If preview/configuration</title>
    <ns>828</ns>
    <id>143</id>
    <revision>
      <id>274</id>
      <parentid>273</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>273</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="842" sha1="7ccf9c7e3yxw9p4ke6iw4ndcfniweno" xml:space="preserve">--[[
We perform the actual check for whether this is a preview here since
preprocessing is relatively expensive.
]]
local frame = mw.getCurrentFrame()

local function is_preview()
	local revision_id = frame:preprocess('{{REVISIONID}}')
	-- {{REVISIONID}} is usually the empty string when previewed.
	-- I don't know why we're checking for nil but hey, maybe someday things
	-- would have broken
	return revision_id == nil or revision_id == ''
end

local function templatestyles()
	return frame:extensionTag{
		name = 'templatestyles', args = { src = 'Module:If preview/styles.css' }
	}
end

return {
	preview = is_preview(),
	templatestyles = templatestyles(),
	warning_infrastructure = '%s&lt;div class="preview-warning"&gt;&lt;strong&gt;Preview warning:&lt;/strong&gt; %s&lt;/div&gt;',
	missing_warning = 'The template has no warning text. Please add a warning.'
}</text>
      <sha1>7ccf9c7e3yxw9p4ke6iw4ndcfniweno</sha1>
    </revision>
  </page>
  <page>
    <title>Module:If preview/styles.css</title>
    <ns>828</ns>
    <id>144</id>
    <revision>
      <id>276</id>
      <parentid>275</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>275</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="329" sha1="gaiz1uhqgmf5elgq82yqqfll7kgcbwe" xml:space="preserve">/* {{pp|small=yes}} */
.preview-warning {
	font-style: italic;
	/* @noflip */
	padding-left: 1.6em;
	margin-bottom: 0.5em;
	color: red;
}

/* The templatestyles element inserts a link element before hatnotes.
 * TODO: Remove link if/when WMF resolves T200206 */
.preview-warning + link + .preview-warning {
	margin-top: -0.5em;
}</text>
      <sha1>gaiz1uhqgmf5elgq82yqqfll7kgcbwe</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite magazine</title>
    <ns>10</ns>
    <id>145</id>
    <revision>
      <id>278</id>
      <parentid>277</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>277</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="127" sha1="ihdnkvb90c6voz3z3uc97mmw5bytrkw" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Citation/CS1|citation
|CitationClass=magazine
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>ihdnkvb90c6voz3z3uc97mmw5bytrkw</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite book</title>
    <ns>10</ns>
    <id>146</id>
    <revision>
      <id>280</id>
      <parentid>279</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>279</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="200" sha1="my4yy07itdv4e2t5sc1x4l3pzgpmzo7" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=book
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
{{collapse top|TemplateData}}
{{Cite book/TemplateData}}
{{collapse bottom}}
&lt;/noinclude&gt;</text>
      <sha1>my4yy07itdv4e2t5sc1x4l3pzgpmzo7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Good article</title>
    <ns>10</ns>
    <id>147</id>
    <revision>
      <id>282</id>
      <parentid>281</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>281</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="402" sha1="221gwbb46h6ou8b62bcm6lz8sgvgrvt" xml:space="preserve">{{Main other|{{Top icon
| imagename    = symbol support vote.svg
| wikilink     = Wikipedia:Good articles*
| description  = This is a good article. Click here for more information.
| id           = good-star
| maincat      = [[Category:Good articles]]
}}|&lt;includeonly&gt;{{Error|[[Template:Good article]] is only for [[Wikipedia:Good articles]].}}&lt;/includeonly&gt;}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>221gwbb46h6ou8b62bcm6lz8sgvgrvt</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Icon</title>
    <ns>10</ns>
    <id>148</id>
    <revision>
      <id>284</id>
      <parentid>283</parentid>
      <timestamp>2025-07-09T04:31:40Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>283</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="138" sha1="m4ab9noabl8v4ki5cx6t5ksjcjh5u8o" xml:space="preserve">{{#invoke:Icon|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>m4ab9noabl8v4ki5cx6t5ksjcjh5u8o</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Main</title>
    <ns>10</ns>
    <id>149</id>
    <revision>
      <id>286</id>
      <parentid>285</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>285</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="238" sha1="hz9saa715ercns6m73a0a1ud2ptzt26" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Labelled list hatnote|labelledList|Main article|Main articles|Main page|Main pages}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>hz9saa715ercns6m73a0a1ud2ptzt26</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Navbox</title>
    <ns>10</ns>
    <id>150</id>
    <revision>
      <id>288</id>
      <parentid>287</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>287</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="94" sha1="tqodcaa2vvhehqaod229udlla0wimek" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Navbox|navbox}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>tqodcaa2vvhehqaod229udlla0wimek</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Top icon</title>
    <ns>10</ns>
    <id>151</id>
    <revision>
      <id>290</id>
      <parentid>289</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>289</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1359" sha1="b5ha3emi1ayijkuc7vdxbblcmrqpf8c" xml:space="preserve">&lt;includeonly&gt;&lt;nowiki /&gt;&lt;!-- This nowiki tag helps prevent whitespace at the top of articles. --&gt;{{#tag:indicator|[[File:{{{image|{{{imagename|{{{1|}}}}}}}}}|{{#if:{{{width|}}}|{{Str number/trim|{{{width}}}}}|20}}x{{#if:{{{height|}}}|{{Str number/trim|{{{height}}}}}|20}}px&lt;!--
--&gt; {{#ifeq:{{{link|+}}}|{{{link|-}}}|{{!}}link={{{link}}}|{{#ifeq:{{{wikilink|+}}}|{{{wikilink|-}}}|{{!}}link={{{wikilink}}}|{{#ifeq:{{{2|+}}}|{{{2|-}}}|{{!}}link={{{2}}}|}}}}}}&lt;!--
--&gt; {{#if:{{{alt|}}}|{{!}}alt={{{alt}}}}}&lt;!--
--&gt; {{#if:{{{skin-invert|}}}|{{!}}class=skin-invert}}&lt;!--
--&gt; |{{{text|{{{description|{{{3|icon}}}}}}}}}]]
|name = {{#if:{{{sortkey|}}}|{{{sortkey}}}-}}{{#if:{{{name|}}}|{{{name}}}|{{#if:{{{id|}}}|{{{id}}}|{{{image|{{{imagename|{{{1|}}}}}}}}}}}}}}}{{Category handler
|user = {{{usercat|}}}
|main = {{{maincat|}}}
|subpage = {{{subpage|no}}}
|nocat = {{{nocat|}}}
}}&lt;!-- Tracking categories
--&gt;{{#invoke:Check for unknown parameters|check|unknown=[[Category:Pages using Top icon with unknown parameters|_VALUE_{{PAGENAME}}]]|preview=Page using [[Template:Top icon]] with unknown parameter "_VALUE_"|showblankpositional=1| 1 | 2 | 3 | alt | description | height | id | image | imagename | link | maincat | name | nocat | sortkey | subpage | text | usercat | width | wikilink | skin-invert }}&lt;!--
--&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>b5ha3emi1ayijkuc7vdxbblcmrqpf8c</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Exponential search</title>
    <ns>828</ns>
    <id>152</id>
    <revision>
      <id>292</id>
      <parentid>291</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>291</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1092" sha1="jqqi8l27tb73lglksbukg2g3bzt3fmv" xml:space="preserve">-- This module provides a generic exponential search algorithm.
require[[strict]]

local checkType = require('libraryUtil').checkType
local floor = math.floor

local function midPoint(lower, upper)
	return floor(lower + (upper - lower) / 2)
end

local function search(testFunc, i, lower, upper)
	if testFunc(i) then
		if i + 1 == upper then
			return i
		end
		lower = i
		if upper then
			i = midPoint(lower, upper)
		else
			i = i * 2
		end
		return search(testFunc, i, lower, upper)
	else
		upper = i
		i = midPoint(lower, upper)
		return search(testFunc, i, lower, upper)
	end
end

return function (testFunc, init)
	checkType('Exponential search', 1, testFunc, 'function')
	checkType('Exponential search', 2, init, 'number', true)
	if init and (init &lt; 1 or init ~= floor(init) or init == math.huge) then
		error(string.format(
			"invalid init value '%s' detected in argument #2 to " ..
			"'Exponential search' (init value must be a positive integer)",
			tostring(init)
		), 2)
	end
	init = init or 2
	if not testFunc(1) then
		return nil
	end
	return search(testFunc, init, 1, nil)
end</text>
      <sha1>jqqi8l27tb73lglksbukg2g3bzt3fmv</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Format link</title>
    <ns>828</ns>
    <id>153</id>
    <revision>
      <id>294</id>
      <parentid>293</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>293</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6484" sha1="252hp8jk2qv051cngf0qjx0ljcf0bof" xml:space="preserve">--------------------------------------------------------------------------------
-- Format link
--
-- Makes a wikilink from the given link and display values. Links are escaped
-- with colons if necessary, and links to sections are detected and displayed
-- with " § " as a separator rather than the standard MediaWiki "#". Used in
-- the {{format link}} template.
--------------------------------------------------------------------------------
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local checkTypeForNamedArg = libraryUtil.checkTypeForNamedArg
local mArguments -- lazily initialise [[Module:Arguments]]
local mError -- lazily initialise [[Module:Error]]
local yesno -- lazily initialise [[Module:Yesno]]

local p = {}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function getArgs(frame)
	-- Fetches the arguments from the parent frame. Whitespace is trimmed and
	-- blanks are removed.
	mArguments = require('Module:Arguments')
	return mArguments.getArgs(frame, {parentOnly = true})
end

local function removeInitialColon(s)
	-- Removes the initial colon from a string, if present.
	return s:match('^:?(.*)')
end

local function maybeItalicize(s, shouldItalicize)
	-- Italicize s if s is a string and the shouldItalicize parameter is true.
	if s and shouldItalicize then
		return '&lt;i&gt;' .. s .. '&lt;/i&gt;'
	else
		return s
	end
end

local function parseLink(link)
	-- Parse a link and return a table with the link's components.
	-- These components are:
	-- - link: the link, stripped of any initial colon (always present)
	-- - page: the page name (always present)
	-- - section: the page name (may be nil)
	-- - display: the display text, if manually entered after a pipe (may be nil)
	link = removeInitialColon(link)

	-- Find whether a faux display value has been added with the {{!}} magic
	-- word.
	local prePipe, display = link:match('^(.-)|(.*)$')
	link = prePipe or link

	-- Find the page, if it exists.
	-- For links like [[#Bar]], the page will be nil.
	local preHash, postHash = link:match('^(.-)#(.*)$')
	local page
	if not preHash then
		-- We have a link like [[Foo]].
		page = link
	elseif preHash ~= '' then
		-- We have a link like [[Foo#Bar]].
		page = preHash
	end

	-- Find the section, if it exists.
	local section
	if postHash and postHash ~= '' then
		section = postHash
	end
	
	return {
		link = link,
		page = page,
		section = section,
		display = display,
	}
end

local function formatDisplay(parsed, options)
	-- Formats a display string based on a parsed link table (matching the
	-- output of parseLink) and an options table (matching the input options for
	-- _formatLink).
	local page = maybeItalicize(parsed.page, options.italicizePage)
	local section = maybeItalicize(parsed.section, options.italicizeSection)
	if (not section) then
		return page
	elseif (not page) then
		return mw.ustring.format('§&amp;nbsp;%s', section)
	else
		return mw.ustring.format('%s §&amp;nbsp;%s', page, section)
	end
end

local function missingArgError(target)
	mError = require('Module:Error')
	return mError.error{message =
		'Error: no link or target specified! ([[' .. target .. '#Errors|help]])'
	}
end

--------------------------------------------------------------------------------
-- Main functions
--------------------------------------------------------------------------------

function p.formatLink(frame)
	-- The formatLink export function, for use in templates.
	yesno = require('Module:Yesno')
	local args = getArgs(frame)
	local link = args[1] or args.link
	local target = args[3] or args.target
	if not (link or target) then
		return missingArgError('Template:Format link')
	end

	return p._formatLink{
		link = link,
		display = args[2] or args.display,
		target = target,
		italicizePage = yesno(args.italicizepage),
		italicizeSection = yesno(args.italicizesection),
		categorizeMissing = args.categorizemissing
	}
end

function p._formatLink(options)
	-- The formatLink export function, for use in modules.
	checkType('_formatLink', 1, options, 'table')
	local function check(key, expectedType) --for brevity
		checkTypeForNamedArg(
			'_formatLink', key, options[key], expectedType or 'string', true
		)
	end
	check('link')
	check('display')
	check('target')
	check('italicizePage', 'boolean')
	check('italicizeSection', 'boolean')
	check('categorizeMissing')

	-- Normalize link and target and check that at least one is present
	if options.link == '' then options.link = nil end
	if options.target == '' then options.target = nil end
	if not (options.link or options.target) then
		return missingArgError('Module:Format link')
	end

	local parsed = parseLink(options.link)
	local display = options.display or parsed.display
	local catMissing = options.categorizeMissing
	local category = ''

	-- Find the display text
	if not display then display = formatDisplay(parsed, options) end

	-- Handle the target option if present
	if options.target then
		local parsedTarget = parseLink(options.target)
		parsed.link = parsedTarget.link
		parsed.page = parsedTarget.page
	end

	-- Test if page exists if a diagnostic category is specified
	if catMissing and (mw.ustring.len(catMissing) &gt; 0) then
		local title = nil
		if parsed.page then title = mw.title.new(parsed.page) end
		if title and (not title.isExternal) then
			local success, exists = pcall(function() return title.exists end)
			if success and not exists then
				category = mw.ustring.format('[[Category:%s]]', catMissing)
			end
		end
	end
	
	-- Format the result as a link
	if parsed.link == display then
		return mw.ustring.format('[[:%s]]%s', parsed.link, category)
	else
		return mw.ustring.format('[[:%s|%s]]%s', parsed.link, display, category)
	end
end

--------------------------------------------------------------------------------
-- Derived convenience functions
--------------------------------------------------------------------------------

function p.formatPages(options, pages)
	-- Formats an array of pages using formatLink and the given options table,
	-- and returns it as an array. Nil values are not allowed.
	local ret = {}
	for i, page in ipairs(pages) do
		ret[i] = p._formatLink{
			link = page,
			categorizeMissing = options.categorizeMissing,
			italicizePage = options.italicizePage,
			italicizeSection = options.italicizeSection
		}
	end
	return ret
end

return p</text>
      <sha1>252hp8jk2qv051cngf0qjx0ljcf0bof</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Hatnote list</title>
    <ns>828</ns>
    <id>154</id>
    <revision>
      <id>296</id>
      <parentid>295</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>295</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7325" sha1="3c31ivxc2t731ceyfvqcqlnp9acgg3s" xml:space="preserve">--------------------------------------------------------------------------------
--                           Module:Hatnote list                              --
--                                                                            --
-- This module produces and formats lists for use in hatnotes. In particular, --
-- it implements the for-see list, i.e. lists of "For X, see Y" statements,   --
-- as used in {{about}}, {{redirect}}, and their variants. Also introduced    --
-- are andList &amp; orList helpers for formatting lists with those conjunctions. --
--------------------------------------------------------------------------------

local mArguments --initialize lazily
local mFormatLink = require('Module:Format link')
local mHatnote = require('Module:Hatnote')
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local p = {}

--------------------------------------------------------------------------------
-- List stringification helper functions
--
-- These functions are used for stringifying lists, usually page lists inside
-- the "Y" portion of "For X, see Y" for-see items.
--------------------------------------------------------------------------------

--default options table used across the list stringification functions
local stringifyListDefaultOptions = {
	conjunction = "and",
	separator = ",",
	altSeparator = ";",
	space = " ",
	formatted = false
}

--Searches display text only
local function searchDisp(haystack, needle)
	return string.find(
		string.sub(haystack, (string.find(haystack, '|') or 0) + 1), needle
	)
end

-- Stringifies a list generically; probably shouldn't be used directly
local function stringifyList(list, options)
	-- Type-checks, defaults, and a shortcut
	checkType("stringifyList", 1, list, "table")
	if #list == 0 then return nil end
	checkType("stringifyList", 2, options, "table", true)
	options = options or {}
	for k, v in pairs(stringifyListDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	local s = options.space
	-- Format the list if requested
	if options.formatted then
		list = mFormatLink.formatPages(
			{categorizeMissing = mHatnote.missingTargetCat}, list
		)
	end
	-- Set the separator; if any item contains it, use the alternate separator
	local separator = options.separator
	for k, v in pairs(list) do
		if searchDisp(v, separator) then
			separator = options.altSeparator
			break
		end
	end
	-- Set the conjunction, apply Oxford comma, and force a comma if #1 has "§"
	local conjunction = s .. options.conjunction .. s
	if #list == 2 and searchDisp(list[1], "§") or #list &gt; 2 then
		conjunction = separator .. conjunction
	end
	-- Return the formatted string
	return mw.text.listToText(list, separator .. s, conjunction)
end

--DRY function
function p.conjList (conj, list, fmt)
	return stringifyList(list, {conjunction = conj, formatted = fmt})
end

-- Stringifies lists with "and" or "or"
function p.andList (...) return p.conjList("and", ...) end
function p.orList (...) return p.conjList("or", ...) end

--------------------------------------------------------------------------------
-- For see
--
-- Makes a "For X, see [[Y]]." list from raw parameters. Intended for the
-- {{about}} and {{redirect}} templates and their variants.
--------------------------------------------------------------------------------

--default options table used across the forSee family of functions
local forSeeDefaultOptions = {
	andKeyword = 'and',
	title = mw.title.getCurrentTitle().text,
	otherText = 'other uses',
	forSeeForm = 'For %s, see %s.',
}

--Collapses duplicate punctuation at end of string, ignoring italics and links
local function punctuationCollapse (text)
 	return text:match("[.?!]('?)%1(%]?)%2%.$") and text:sub(1, -2) or text
end

-- Structures arguments into a table for stringification, &amp; options
function p.forSeeArgsToTable (args, from, options)
	-- Type-checks and defaults
	checkType("forSeeArgsToTable", 1, args, 'table')
	checkType("forSeeArgsToTable", 2, from, 'number', true)
	from = from or 1
	checkType("forSeeArgsToTable", 3, options, 'table', true)
	options = options or {}
	for k, v in pairs(forSeeDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	-- maxArg's gotten manually because getArgs() and table.maxn aren't friends
	local maxArg = 0
	for k, v in pairs(args) do
		if type(k) == 'number' and k &gt; maxArg then maxArg = k end
	end
	-- Structure the data out from the parameter list:
	-- * forTable is the wrapper table, with forRow rows
	-- * Rows are tables of a "use" string &amp; a "pages" table of pagename strings
	-- * Blanks are left empty for defaulting elsewhere, but can terminate list
	local forTable = {}
	local i = from
	local terminated = false
	-- If there is extra text, and no arguments are given, give nil value
	-- to not produce default of "For other uses, see foo (disambiguation)"
	if options.extratext and i &gt; maxArg then return nil end
	-- Loop to generate rows
	repeat
		-- New empty row
		local forRow = {}
		-- On blank use, assume list's ended &amp; break at end of this loop
		forRow.use = args[i]
		if not args[i] then terminated = true end
		-- New empty list of pages
		forRow.pages = {}
		-- Insert first pages item if present
		table.insert(forRow.pages, args[i + 1])
		-- If the param after next is "and", do inner loop to collect params
		-- until the "and"'s stop. Blanks are ignored: "1|and||and|3" → {1, 3}
		while args[i + 2] == options.andKeyword do
			if args[i + 3] then
				table.insert(forRow.pages, args[i + 3])
			end
			-- Increment to next "and"
			i = i + 2
		end
		-- Increment to next use
		i = i + 2
		-- Append the row
		table.insert(forTable, forRow)
	until terminated or i &gt; maxArg

	return forTable
end

-- Stringifies a table as formatted by forSeeArgsToTable
function p.forSeeTableToString (forSeeTable, options)
	-- Type-checks and defaults
	checkType("forSeeTableToString", 1, forSeeTable, "table", true)
	checkType("forSeeTableToString", 2, options, "table", true)
	options = options or {}
	for k, v in pairs(forSeeDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	-- Stringify each for-see item into a list
	local strList = {}
	if forSeeTable then
		for k, v in pairs(forSeeTable) do
			local useStr = v.use or options.otherText
			local pagesStr =
				p.andList(v.pages, true) or
				mFormatLink._formatLink{
					categorizeMissing = mHatnote.missingTargetCat,
					link = mHatnote.disambiguate(options.title)
				}
			local forSeeStr = string.format(options.forSeeForm, useStr, pagesStr)
			forSeeStr = punctuationCollapse(forSeeStr)
			table.insert(strList, forSeeStr)
		end
	end
	if options.extratext then table.insert(strList, punctuationCollapse(options.extratext..'.')) end
	-- Return the concatenated list
	return table.concat(strList, ' ')
end

-- Produces a "For X, see [[Y]]" string from arguments. Expects index gaps
-- but not blank/whitespace values. Ignores named args and args &lt; "from".
function p._forSee (args, from, options)
	local forSeeTable = p.forSeeArgsToTable(args, from, options)
	return p.forSeeTableToString(forSeeTable, options)
end

-- As _forSee, but uses the frame.
function p.forSee (frame, from, options)
	mArguments = require('Module:Arguments')
	return p._forSee(mArguments.getArgs(frame), from, options)
end

return p</text>
      <sha1>3c31ivxc2t731ceyfvqcqlnp9acgg3s</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Icon</title>
    <ns>828</ns>
    <id>155</id>
    <revision>
      <id>298</id>
      <parentid>297</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>297</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2167" sha1="8okbheawnrs6vzrqplkkjbvepwe3nhw" xml:space="preserve">-- This module implements [[Template:Icon]].

require("strict")
local yesNo = require("Module:Yesno")
local getArgs = require("Module:Arguments").getArgs
local getPlain = nil

local p = {}

-- Determine whether we're being called from a sandbox
local sandbox = mw.getCurrentFrame():getTitle():find('sandbox', 1, true) and '/sandbox' or ''

-- Implements [[Template:Icon]]
-- Returns the icon image corresponding to a string (like 'B')
function p._main(args, data)
	local data_module = 'Module:Icon/data'..sandbox
	data = data or mw.loadData(data_module)
	local code = args.class or args[1]
	local iconData
	if code then
		code = code:match('^%s*(.-)%s*$'):lower() -- trim whitespace and put in lower case
		iconData = data[code]
	end
	if not iconData then
		iconData = data._DEFAULT
	end
	return string.format(
		'[[File:%s%s%s|%s|class=noviewer|alt=%s]]',
		iconData.image,
		iconData.tooltip and '|' .. iconData.tooltip or '',
		iconData.link == false and '|link=' or '',
		args.size or '16x16px',
		iconData.alt or ''
	)
end

-- Implements [[Template:Icon link]], a superset of [[Template:Icon]]
-- Returns an icon, plus a suitably formatted wikilink
function p._link(args, data)
	args.size = args.size or args.iconsize
	local icon = p._main(args, data)
	-- If no link given in args[2], default back to [[Template:Icon]]
	if not args[2] then
		return icon
	end
	-- Strip wiki markup out of link
	getPlain = getPlain or require("Module:Text").Text().getPlain
	local link = getPlain(args[2])
	local display = args[3] or args[2]
	-- italicize display string, if requested
	if yesNo(args.i) or yesNo(args.italic) or yesNo(args.italics) then
		display = '&lt;i&gt;'..display..'&lt;/i&gt;'
	end
	-- if display is link, just use standard wlink
	if link == display then
		return '&lt;span class="nowrap"&gt;'..icon..' &lt;/span&gt;[['..link..']]'
	end
	return '&lt;span class="nowrap"&gt;'..icon..' &lt;/span&gt;[['..link..'|'..display..']]'
end

function p.main(frame)
	local args = getArgs(frame,{parentFirst=true})
	return p._main(args)
end

function p.link(frame)
	local args = getArgs(frame,{parentFirst=true})
	return p._link(args)
end

p[''] = function (frame) return p._main(frame.args) end

return p</text>
      <sha1>8okbheawnrs6vzrqplkkjbvepwe3nhw</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Icon/data</title>
    <ns>828</ns>
    <id>156</id>
    <revision>
      <id>300</id>
      <parentid>299</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>299</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12374" sha1="8wmrl7v0oy61fgyg87ntpr2yxqkxlop" xml:space="preserve">-- This module stores icon data for [[Module:Icon]].

--------------------------------------------------------------------------------
-- Icon data
--------------------------------------------------------------------------------

local data = {
	fa = {
		image = "Featured article star.svg",
		tooltip = "Featured article",
		link = true,
	},
	far = {
		image = "Cscr-star piece.png",
		tooltip = "Featured article review",
		link = true,
	},
	farc = {
		image = "Cscr-star piece.png",
		tooltip = "Featured article removal candidate",
		link = true,
	},
	ffa = {
		aliases = {"dfa"},
		image = "Featured article star - cross.svg",
		tooltip = "Former featured article",
		link = true,
	},
	fac = {
		aliases = {"fan"},
		image = "Cscr-candidate.svg",
		tooltip = "Featured article candidate",
		link = true,
	},
	ffac = {
		aliases = {"nofa"},
		image = "Cscr-former.svg",
		tooltip = "Former featured article candidate",
		link = true,
	},
	fl = {
		image = "Featured article star.svg",
		tooltip = "Featured list",
		link = true,
	},
	flrc = {
		aliases = {"flr"},
		image = "Cscr-star piece.png",
		tooltip = "Featured list removal candidate",
		link = true,
	},
	ffl = {
		aliases = {"dfl"},
		image = "Cscr-featured-strike.svg",
		tooltip = "Former featured list",
		link = true,
	},
	flc = {
		aliases = {"fln"},
		image = "Cscr-candidate.svg",
		tooltip = "Featured list candidate",
		link = true,
	},
	fflc = {
		aliases = {"nofl"},
		image = "Cscr-former.svg",
		tooltip = "Former featured list candidate",
		link = true,
	},
	a = {
		image = "Symbol a class.svg",
		tooltip = "A-Class article",
		link = true,
	},
	admin = {
		aliases = {"mop"},
		image = "Wikipedia Administrator.svg",
		tooltip = "Administrator",
		link = true,
	},
	dac = {
		aliases = {"daa"},
		image = "Symbol unsupport A vote.svg",
		tooltip = "Demoted A-Class article",
		link = true,
	},
	acc = {
		aliases = {"acn", "aac"},
		image = "A candidate.svg",
		tooltip = "A-Class article candidate",
		link = true,
	},
	noac = {
		aliases = {"faac"},
		image = "Symbol unsupport A vote.svg",
		tooltip = "Failed A-Class article candidate",
		link = true,
	},
	ga = {
		image = "Symbol support vote.svg",
		tooltip = "Good article",
		link = false,
	},
	gar = {
		image = "GA Candidate Neutral vote(ChaosNil).svg",
		tooltip = "Good article reassessment",
		link = false,
	},
	dga = {
		image = "Symbol unsupport vote.svg",
		tooltip = "Delisted good article",
		link = false,
	},
	gan = {
		aliases = {"gac"},
		image = "GA candidate.svg",
		tooltip = "Good article nominee",
		link = false,
	},
	ga2 = {
		image = "Symbol neutral vote.svg",
		tooltip = "Good article, 2nd opinion",
		link = false,
	},
	gah = {
		image = "Symbol wait.svg",
		tooltip = "Good article on hold",
		link = false,
	},
	fgan = {
		aliases = {"noga", "gaf", "gf"},
		image = "Symbol oppose vote.svg",
		tooltip = "Former good article nominee",
		link = false,
	},
	fp = {
		image = "Cscr-featured.svg",
		tooltip = "Featured picture",
		link = true,
	},
	fpc = {
		aliases = {"fpn"},
		image = "Cscr-candidate.svg",
		tooltip = "Featured picture candidate",
		link = true,
	},
	ffp = {
		image = "Cscr-former.svg",
		tooltip = "Former featured picture",
		link = true,
	},
	vp = {
		image = "ENWP VP Logo.svg",
		tooltip = "Valued picture",
		link = true,
	},
	vpc = {
		image = "Valued pics 1.svg",
		tooltip = "Valued picture candidate",
		link = true,
	},
	fs = {
		image = "Cscr-featured.svg",
		tooltip = "Featured sound",
		link = true,
	},
	ffs = {
		image = "Cscr-former.svg",
		tooltip = "Former featured sound",
		link = true,
	},
	fsc = {
		image = "Cscr-candidate.svg",
		tooltip = "Featured sound candidate",
		link = true,
	},
	fpo = {
		image = "Linecons big-star.svg",
		tooltip = "Before the featured portal process ceased in 2017, this had been designated as a featured portal.",
		link = true,
	},
	fpor = {
		image = "Cscr-star piece.png",
		tooltip = "Featured portal review",
		link = true,
	},
	ffpo = {
		image = "Featured article star - cross.svg",
		tooltip = "Former featured portal",
		link = true,
	},
	fpoc = {
		image = "Cscr-candidate.svg",
		tooltip = "Featured portal candidate",
		link = true,
	},
	ft = {
		image = "Cscr-featuredtopic.svg",
		tooltip = "Featured topic",
		link = true,
	},
	ftrc = {
		image = "Cscr-star piece.png",
		tooltip = "Featured topic removal candidate",
		link = true,
	},
	fft = {
		aliases = {"dft"},
		image = "DFT candidate_cluster.svg",
		tooltip = "Former featured topic",
		link = true,
	},
	ftc = {
		aliases = {"ftn"},
		image = "FT candidate cluster.svg",
		tooltip = "Featured topic candidate",
		link = false,
	},
	gt = {
		image = "Support cluster.svg",
		tooltip = "Good topic",
		link = false,
	},
	gtrc = {
		image = "Symbol unsupport vote.svg",
		tooltip = "Good topic removal candidate",
		link = false,
	},
	gtc = {
		aliases = {"gtn"},
		image = "GA candidate cluster.svg",
		tooltip = "Good topic candidate",
		link = false,
	},
	bplus = {
		aliases = {"b+"},
		image = "Symbol bplus class.svg",
		tooltip = "Bplus-Class article",
		link = true,
	},
	b = {
		image = "Symbol b class.svg",
		tooltip = "B-Class article",
		link = true,
	},
	br = {
		aliases = {"bcr"},
		image = "Bclass-checklist.svg",
		tooltip = "B-Class review",
		link = true,
	},
	c = {
		image = "Symbol c class.svg",
		tooltip = "C-Class article",
		link = true,
	},
	start = {
		image = "Symbol start class.svg",
		tooltip = "Start-Class article",
		link = true,
	},
	stub = {
		image = "Symbol stub class.svg",
		tooltip = "Stub-Class article",
		link = true,
	},
	list = {
		aliases = {"comparison"},
		image = "Symbol list class.svg",
		tooltip = "List-Class article",
		link = false,
	},
	no = {
		image = "Crystal button cancel.svg",
		tooltip = "Unknown-Class article",
		link = true,
	},
	book = {
		image = "Symbol book class2.svg",
		tooltip = "Wikipedia book",
		link = true,
	},
	category = {
		aliases = {"cat", "categ"},
		image = "Symbol category class.svg",
		tooltip = "Category",
		link = false,
	},
	disambiguation = {
		aliases = {"dab", "disamb", "disambig"},
		image = "Symbol dab class.svg",
		tooltip = "Disambiguation page",
		link = true,
	},
	image = {
		aliases = {"file"},
		image = "Symbol file class.svg",
		tooltip = "File",
		link = true,
	},
	needed = {
		image = "Symbol needed class.svg",
		tooltip = "Needed article",
		link = false,
	},
	outline = {
		image = "Global thinking.svg",
		tooltip = "Outline",
		link = false,
	},
	portal = {
		image = "Symbol portal class.svg",
		tooltip = "Portal",
		link = true,
	},
	project = {
		image = "Symbol project class.svg",
		tooltip = "Project page",
		link = false,
	},
	redirect = {
		aliases = {"red", "redir"},
		image = "Symbol redirect vote2.svg",
		tooltip = "Redirect",
		link = true,
	},
	template = {
		aliases = {"temp", "templ"},
		image = "Symbol template class pink.svg",
		tooltip = "Template",
		link = false,
	},
	essay = {
		image = "Essay.svg",
		tooltip = "Essay",
		link = false,
	},
	na = {
		image = "Symbol na class.svg",
		tooltip = "Non-article page",
		link = true,
	},
	aa = {
		image = "Yes check.svg",
		tooltip = "Audited article of limited subject matter",
		link = false,
	},
	da = {
		image = "Symbol oppose vote.svg",
		tooltip = "Demoted article",
		link = false,
	},
	dyk = {
		image = "Symbol question.svg",
		tooltip = "Did You Know?",
		link = false,
	},
	dyk2 = {
		image = "DYK questionmark icon.svg",
		tooltip = "Did You Know?",
		link = false,
	},
	pr = {
		image = "Nuvola apps kedit.png",
		tooltip = "Peer review",
		link = true,
	},
	ppr = {
		image = "Nuvola apps kedit.png",
		tooltip = "Portal peer review",
		link = true,
	},
	q = {
		aliases = {"question"},
		image = "Symbol question.svg",
		tooltip = "Question",
		link = false,
	},
	cleanup = {
		image = "Edit-clear.svg",
		tooltip = "Cleanup work",
		link = false,
	},
	qi = {
		image = "Quality images logo.svg",
		tooltip = "Quality image on Wikimedia Commons",
		link = false,
	},
	vi = {
		image = "Valued image seal.svg",
		tooltip = "Valued image on Wikimedia Commons",
		link = false,
	},
	tfa = {
		image = "Wikipedia-logo.svg",
		tooltip = "Today's Featured Article",
		link = true,
	},
	tfl = {
		image = "Wikipedia-logo.svg",
		tooltip = "Today's Featured List",
		link = true,
	},
	itn = {
		image = "Globe current.svg",
		tooltip = "In The News",
		link = true,
	},
	otd = {
		image = "Nuvola apps date.svg",
		tooltip = "On This Day",
		link = true,
	},
	wikiproject = {
		image = "People icon.svg",
		tooltip = "WikiProject",
		link = false,
	},
	goce = {
		image = "Writing Magnifying.PNG",
		tooltip = "Guild of Copy Editors",
		link = true,
	},
	wikipedia = {
		image = "Wikipedia-logo.svg",
		tooltip = "Wikipedia page",
		link = true,
	},
	commons = {
		image = "Commons-logo.svg",
		tooltip = "Commons page",
		link = false,
	},
	wikiquote = {
		image = "Wikiquote-logo.svg",
		tooltip = "Wikiquote page",
		link = false,
	},
	wikiversity = {
		image = "Wikiversity logo 2017.svg",
		tooltip = "Wikiversity page",
		link = true,
	},
	wikibooks = {
		image = "Wikibooks-logo.svg",
		tooltip = "Wikibooks page",
		link = true,
	},
	wikisource = {
		image = "Wikisource-logo.svg",
		tooltip = "Wikisource page",
		link = true,
	},
	wiktionary = {
		image = "Wiktionary-logo.svg",
		tooltip = "Wiktionary page",
		link = true,
	},
	wikinews = {
		image = "Wikinews-logo.svg",
		tooltip = "Wikinews page",
		link = true,
	},
	wikispecies = {
		image = "Wikispecies-logo.svg",
		tooltip = "Wikispecies page",
		link = true,
	},
	wikidata = {
		image = "Wikidata-logo.svg",
		tooltip = "Wikidata page",
		link = false,
	},
	wikivoyage = {
		image = "Wikivoyage-logo.svg",
		tooltip = "Wikivoyage page",
		link = true,
	},
	 mediawiki = {
		 image = "MediaWiki-2020-icon.svg",
		 tooltip = "MediaWiki",
		 link = true,
	 },
	 phabricator = {
		 aliases = {"phab"},
		 image = "Favicon-Phabricator-WM.svg",
		 tooltip = "Phabricator",
		 link = false,
	 },
	 wikitech = {
		 image = "Wikitech-2021-blue-icon.svg",
		 tooltip = "Wikitech",
		 link = true,
	 },
	meta = {
		image = "Wikimedia Community Logo.svg",
		tooltip = "Meta-wiki page",
		link = false,
	},
	four = {
		aliases = {"4a"},
		image = "Four Award with draft icon.svg",
		tooltip = "Four Award",
		link = false,
	},
	million = {
		image = "Million award logo.svg",
		tooltip = "Million Award",
		link = true,
	},
	module = {
		image = "Lua-logo-nolabel.svg",
		tooltip = "Module",
		link = false,
	},
	vital = {
		image = "Círculos_Concéntricos.svg",
		tooltip = "Vital article",
		link = false,
	},
	potd  = {
		image = "Wikipedia-logo.svg",
		tooltip = "Picture of the Day",
		link = true,
	},
	draft = {
		image = "Symbol draft class.svg",
		tooltip = "Draft-Class article",
		link = true,
	},
	user = {
		image = "Symbol user class.svg",
		tooltip = "User-Class article",
		link = true,
	},
	info = {
		image = "Information icon.svg",
		tooltip = "Information",
		link = false,
	},
	discussionnotificaion = {
		image = "Echo edit-user-talk icon.svg",
		tooltip = "Discussion",
		link = false,
	},
	alert = {
		image = "OOjs UI icon alert.svg",
		tooltip = "Black alert",
		link = false,
	},
	['alert-imagewarning'] = {
		image = "OOjs UI icon alert image warning.svg",
		tooltip = "Alert",
		link = false,
	},
	['alert-constructive'] = {
		image = "OOjs UI icon alert-constructive.svg",
		tooltip = "Green alert",
		link = false,
	},
	['alert-blackred'] = {
		image = "OOjs UI icon alert destructive black-darkred.svg",
		tooltip = "Black, white, and red alert",
		link = false,
	},
	barnstar2 = {
		image = "Original Barnstar Hires.svg",
		tooltip = "Original barnstar hires",
		link = false,
	},
	barnstar = {
		image = "Original Barnstar.png",
		tooltip = "Original barnstar",
		link = false,
	},
	_DEFAULT = {
		image = "Symbol question.svg",
		link = false,
	}
}

--------------------------------------------------------------------------------
-- End icon data
--------------------------------------------------------------------------------

-- Make aliases work the same as normal keys, and remove the "aliases" subtables.
local ret= {}
for code, iconData in pairs(data) do
	iconData.canonicalCode = code
	if iconData.aliases then
		for _, alias in ipairs(iconData.aliases) do
			ret[alias] = iconData
		end
		iconData.aliases = nil
	end
	ret[code] = iconData
end

return ret</text>
      <sha1>8wmrl7v0oy61fgyg87ntpr2yxqkxlop</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Labelled list hatnote</title>
    <ns>828</ns>
    <id>157</id>
    <revision>
      <id>302</id>
      <parentid>301</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>301</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4927" sha1="eppzjpd24ihnmcl0ag7d4r08nhgbt7c" xml:space="preserve">--------------------------------------------------------------------------------
--                               Labelled list                                --
--                                                                            --
-- This module does the core work of creating a hatnote composed of a list    --
-- prefixed by a colon-terminated label, i.e. "LABEL: [andList of pages]",    --
-- for {{see also}} and similar templates.                                    --
--------------------------------------------------------------------------------

local mHatnote = require('Module:Hatnote')
local mHatlist = require('Module:Hatnote list')
local mArguments --initialize lazily
local yesno --initialize lazily
local p = {}

-- Defaults global to this module
local defaults = {
	label = 'See also', --Final fallback for label argument
	labelForm = '%s: %s',
	prefixes = {'label', 'label ', 'l'},
	template = 'Module:Labelled list hatnote'
}

-- Localizable message strings
local msg = {
	errorSuffix = '#Errors',
	noInputWarning = 'no page names specified',
	noOutputWarning =
		"'''[[%s]] — no output: none of the target pages exist.'''"
}

-- Helper function that pre-combines display parameters into page arguments.
-- Also compresses sparse arrays, as a desirable side-effect.
function p.preprocessDisplays (args, prefixes)
	-- Prefixes specify which parameters, in order, to check for display options
	-- They each have numbers auto-appended, e.g. 'label1', 'label 1', &amp; 'l1'
	prefixes = prefixes or defaults.prefixes
	local indices = {}
	local sparsePages = {}
	for k, v in pairs(args) do
		if type(k) == 'number' then
			indices[#indices + 1] = k
			local display
			for i = 1, #prefixes do
				display = args[prefixes[i] .. k]
				if display then break end
			end
			sparsePages[k] = display and
				string.format('%s|%s', string.gsub(v, '|.*$', ''), display) or v
		end
	end
	table.sort(indices)
	local pages = {}
	for k, v in ipairs(indices) do pages[#pages + 1] = sparsePages[v] end
	return pages
end

--Helper function to get a page target from a processed page string
--e.g. "Page|Label" → "Page" or "Target" → "Target"
local function getTarget(pagename)
 	local pipe = string.find(pagename, '|')
	return string.sub(pagename, 0, pipe and pipe - 1 or nil)
end

-- Produces a labelled pages-list hatnote.
-- The main frame (template definition) takes 1 or 2 arguments, for a singular
-- and (optionally) plural label respectively:
-- * {{#invoke:Labelled list hatnote|labelledList|Singular label|Plural label}}
-- The resulting template takes pagename &amp; label parameters normally.
function p.labelledList (frame)
	mArguments = require('Module:Arguments')
	yesno = require('Module:Yesno')
	local labels = {frame.args[1] or defaults.label}
	labels[2] = frame.args[2] or labels[1]
	labels[3] = frame.args[3] --no defaulting
	labels[4] = frame.args[4] --no defaulting
	local template = frame:getParent():getTitle()
	local args = mArguments.getArgs(frame, {parentOnly = true})
	local pages = p.preprocessDisplays(args)
	local options = {
		category = yesno(args.category),
		extraclasses = frame.args.extraclasses,
		ifexists = yesno(frame.args.ifexists),
		namespace = frame.args.namespace or args.namespace,
		selfref = yesno(frame.args.selfref or args.selfref),
		template = template
	}
	return p._labelledList(pages, labels, options)
end
local function exists(title)
	local success, result = pcall(function() return title.exists end)
	if success then
		return result
	else
		return true
	end
end

function p._labelledList (pages, labels, options)
	local removednonexist = false
	if options.ifexists then
		for k = #pages, 1, -1 do --iterate backwards to allow smooth removals
			local v = pages[k]
			if mw.ustring.sub(mw.text.trim(v), 1, 1) ~= "#" then
				local title = mw.title.new(getTarget(v), namespace)
				if (v == '') or (title == nil) or not exists(title) then
					table.remove(pages, k)
					removednonexist = true
				end
			end
		end
	end
	labels = labels or {}
	label = (#pages == 1 and labels[1] or labels[2]) or defaults.label
	for k, v in pairs(pages) do 
		if mHatnote.findNamespaceId(v) ~= 0 then
			label =
				(
					#pages == 1 and
					(labels[3] or labels[1] or defaults.label) or
					(labels[4] or labels[2] or defaults.label)
				) or defaults.label
		end
	end
	if #pages == 0 then
		if removednonexist then
			mw.addWarning(
				string.format(
					msg.noOutputWarning, options.template or defaults.template
				)
			)
			return ''
		else
			return mHatnote.makeWikitextError(
				msg.noInputWarning,
				(options.template or defaults.template) .. msg.errorSuffix,
				options.category
			)
		end
	end
	local text = string.format(
		options.labelForm or defaults.labelForm,
		label,
		mHatlist.andList(pages, true)
	)
	local hnOptions = {
		extraclasses = options.extraclasses,
		selfref = options.selfref
	}
	return mHatnote._hatnote(text, hnOptions)
end

return p</text>
      <sha1>eppzjpd24ihnmcl0ag7d4r08nhgbt7c</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Date</title>
    <ns>828</ns>
    <id>158</id>
    <revision>
      <id>304</id>
      <parentid>303</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>303</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="47959" sha1="8htfjg7cmqlbgysia559pe52c5tetp5" xml:space="preserve">-- Date functions for use by other modules.
-- I18N and time zones are not supported.

local MINUS = '−'  -- Unicode U+2212 MINUS SIGN
local floor = math.floor

local Date, DateDiff, diffmt  -- forward declarations
local uniq = { 'unique identifier' }

local function is_date(t)
	-- The system used to make a date read-only means there is no unique
	-- metatable that is conveniently accessible to check.
	return type(t) == 'table' and t._id == uniq
end

local function is_diff(t)
	return type(t) == 'table' and getmetatable(t) == diffmt
end

local function _list_join(list, sep)
	return table.concat(list, sep)
end

local function collection()
	-- Return a table to hold items.
	return {
		n = 0,
		add = function (self, item)
			self.n = self.n + 1
			self[self.n] = item
		end,
		join = _list_join,
	}
end

local function strip_to_nil(text)
	-- If text is a string, return its trimmed content, or nil if empty.
	-- Otherwise return text (convenient when Date fields are provided from
	-- another module which may pass a string, a number, or another type).
	if type(text) == 'string' then
		text = text:match('(%S.-)%s*$')
	end
	return text
end

local function is_leap_year(year, calname)
	-- Return true if year is a leap year.
	if calname == 'Julian' then
		return year % 4 == 0
	end
	return (year % 4 == 0 and year % 100 ~= 0) or year % 400 == 0
end

local function days_in_month(year, month, calname)
	-- Return number of days (1..31) in given month (1..12).
	if month == 2 and is_leap_year(year, calname) then
		return 29
	end
	return ({ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })[month]
end

local function h_m_s(time)
	-- Return hour, minute, second extracted from fraction of a day.
	time = floor(time * 24 * 3600 + 0.5)  -- number of seconds
	local second = time % 60
	time = floor(time / 60)
	return floor(time / 60), time % 60, second
end

local function hms(date)
	-- Return fraction of a day from date's time, where (0 &lt;= fraction &lt; 1)
	-- if the values are valid, but could be anything if outside range.
	return (date.hour + (date.minute + date.second / 60) / 60) / 24
end

local function julian_date(date)
	-- Return jd, jdz from a Julian or Gregorian calendar date where
	--   jd = Julian date and its fractional part is zero at noon
	--   jdz = same, but assume time is 00:00:00 if no time given
	-- http://www.tondering.dk/claus/cal/julperiod.php#formula
	-- Testing shows this works for all dates from year -9999 to 9999!
	-- JDN 0 is the 24-hour period starting at noon UTC on Monday
	--    1 January 4713 BC  = (-4712, 1, 1)   Julian calendar
	--   24 November 4714 BC = (-4713, 11, 24) Gregorian calendar
	local offset
	local a = floor((14 - date.month)/12)
	local y = date.year + 4800 - a
	if date.calendar == 'Julian' then
		offset = floor(y/4) - 32083
	else
		offset = floor(y/4) - floor(y/100) + floor(y/400) - 32045
	end
	local m = date.month + 12*a - 3
	local jd = date.day + floor((153*m + 2)/5) + 365*y + offset
	if date.hastime then
		jd = jd + hms(date) - 0.5
		return jd, jd
	end
	return jd, jd - 0.5
end

local function set_date_from_jd(date)
	-- Set the fields of table date from its Julian date field.
	-- Return true if date is valid.
	-- http://www.tondering.dk/claus/cal/julperiod.php#formula
	-- This handles the proleptic Julian and Gregorian calendars.
	-- Negative Julian dates are not defined but they work.
	local calname = date.calendar
	local low, high  -- min/max limits for date ranges −9999-01-01 to 9999-12-31
	if calname == 'Gregorian' then
		low, high = -1930999.5, 5373484.49999
	elseif calname == 'Julian' then
		low, high = -1931076.5, 5373557.49999
	else
		return
	end
	local jd = date.jd
	if not (type(jd) == 'number' and low &lt;= jd and jd &lt;= high) then
		return
	end
	local jdn = floor(jd)
	if date.hastime then
		local time = jd - jdn  -- 0 &lt;= time &lt; 1
		if time &gt;= 0.5 then    -- if at or after midnight of next day
			jdn = jdn + 1
			time = time - 0.5
		else
			time = time + 0.5
		end
		date.hour, date.minute, date.second = h_m_s(time)
	else
		date.second = 0
		date.minute = 0
		date.hour = 0
	end
	local b, c
	if calname == 'Julian' then
		b = 0
		c = jdn + 32082
	else  -- Gregorian
		local a = jdn + 32044
		b = floor((4*a + 3)/146097)
		c = a - floor(146097*b/4)
	end
	local d = floor((4*c + 3)/1461)
	local e = c - floor(1461*d/4)
	local m = floor((5*e + 2)/153)
	date.day = e - floor((153*m + 2)/5) + 1
	date.month = m + 3 - 12*floor(m/10)
	date.year = 100*b + d - 4800 + floor(m/10)
	return true
end

local function fix_numbers(numbers, y, m, d, H, M, S, partial, hastime, calendar)
	-- Put the result of normalizing the given values in table numbers.
	-- The result will have valid m, d values if y is valid; caller checks y.
	-- The logic of PHP mktime is followed where m or d can be zero to mean
	-- the previous unit, and -1 is the one before that, etc.
	-- Positive values carry forward.
	local date
	if not (1 &lt;= m and m &lt;= 12) then
		date = Date(y, 1, 1)
		if not date then return end
		date = date + ((m - 1) .. 'm')
		y, m = date.year, date.month
	end
	local days_hms
	if not partial then
		if hastime and H and M and S then
			if not (0 &lt;= H and H &lt;= 23 and
					0 &lt;= M and M &lt;= 59 and
					0 &lt;= S and S &lt;= 59) then
				days_hms = hms({ hour = H, minute = M, second = S })
			end
		end
		if days_hms or not (1 &lt;= d and d &lt;= days_in_month(y, m, calendar)) then
			date = date or Date(y, m, 1)
			if not date then return end
			date = date + (d - 1 + (days_hms or 0))
			y, m, d = date.year, date.month, date.day
			if days_hms then
				H, M, S = date.hour, date.minute, date.second
			end
		end
	end
	numbers.year = y
	numbers.month = m
	numbers.day = d
	if days_hms then
		-- Don't set H unless it was valid because a valid H will set hastime.
		numbers.hour = H
		numbers.minute = M
		numbers.second = S
	end
end

local function set_date_from_numbers(date, numbers, options)
	-- Set the fields of table date from numeric values.
	-- Return true if date is valid.
	if type(numbers) ~= 'table' then
		return
	end
	local y = numbers.year   or date.year
	local m = numbers.month  or date.month
	local d = numbers.day    or date.day
	local H = numbers.hour
	local M = numbers.minute or date.minute or 0
	local S = numbers.second or date.second or 0
	local need_fix
	if y and m and d then
		date.partial = nil
		if not (-9999 &lt;= y and y &lt;= 9999 and
			1 &lt;= m and m &lt;= 12 and
			1 &lt;= d and d &lt;= days_in_month(y, m, date.calendar)) then
				if not date.want_fix then
					return
				end
				need_fix = true
		end
	elseif y and date.partial then
		if d or not (-9999 &lt;= y and y &lt;= 9999) then
			return
		end
		if m and not (1 &lt;= m and m &lt;= 12) then
			if not date.want_fix then
				return
			end
			need_fix = true
		end
	else
		return
	end
	if date.partial then
		H = nil  -- ignore any time
		M = nil
		S = nil
	else
		if H then
			-- It is not possible to set M or S without also setting H.
			date.hastime = true
		else
			H = 0
		end
		if not (0 &lt;= H and H &lt;= 23 and
				0 &lt;= M and M &lt;= 59 and
				0 &lt;= S and S &lt;= 59) then
			if date.want_fix then
				need_fix = true
			else
				return
			end
		end
	end
	date.want_fix = nil
	if need_fix then
		fix_numbers(numbers, y, m, d, H, M, S, date.partial, date.hastime, date.calendar)
		return set_date_from_numbers(date, numbers, options)
	end
	date.year = y    -- -9999 to 9999 ('n BC' → year = 1 - n)
	date.month = m   -- 1 to 12 (may be nil if partial)
	date.day = d     -- 1 to 31 (* = nil if partial)
	date.hour = H    -- 0 to 59 (*)
	date.minute = M  -- 0 to 59 (*)
	date.second = S  -- 0 to 59 (*)
	if type(options) == 'table' then
		for _, k in ipairs({ 'am', 'era', 'format' }) do
			if options[k] then
				date.options[k] = options[k]
			end
		end
	end
	return true
end

local function make_option_table(options1, options2)
	-- If options1 is a string, return a table with its settings, or
	-- if it is a table, use its settings.
	-- Missing options are set from table options2 or defaults.
	-- If a default is used, a flag is set so caller knows the value was not intentionally set.
	-- Valid option settings are:
	-- am: 'am', 'a.m.', 'AM', 'A.M.'
	--     'pm', 'p.m.', 'PM', 'P.M.' (each has same meaning as corresponding item above)
	-- era: 'BCMINUS', 'BCNEGATIVE', 'BC', 'B.C.', 'BCE', 'B.C.E.', 'AD', 'A.D.', 'CE', 'C.E.'
	-- Option am = 'am' does not mean the hour is AM; it means 'am' or 'pm' is used, depending on the hour,
	--    and am = 'pm' has the same meaning.
	-- Similarly, era = 'BC' means 'BC' is used if year &lt;= 0.
	-- BCMINUS displays a MINUS if year &lt; 0 and the display format does not include %{era}.
	-- BCNEGATIVE is similar but displays a hyphen.
	local result = { bydefault = {} }
	if type(options1) == 'table' then
		result.am = options1.am
		result.era = options1.era
	elseif type(options1) == 'string' then
		-- Example: 'am:AM era:BC' or 'am=AM era=BC'.
		for item in options1:gmatch('%S+') do
			local lhs, rhs = item:match('^(%w+)[:=](.+)$')
			if lhs then
				result[lhs] = rhs
			end
		end
	end
	options2 = type(options2) == 'table' and options2 or {}
	local defaults = { am = 'am', era = 'BC' }
	for k, v in pairs(defaults) do
		if not result[k] then
			if options2[k] then
				result[k] = options2[k]
			else
				result[k] = v
				result.bydefault[k] = true
			end
		end
	end
	return result
end

local ampm_options = {
	-- lhs = input text accepted as an am/pm option
	-- rhs = code used internally
	['am']   = 'am',
	['AM']   = 'AM',
	['a.m.'] = 'a.m.',
	['A.M.'] = 'A.M.',
	['pm']   = 'am',  -- same as am
	['PM']   = 'AM',
	['p.m.'] = 'a.m.',
	['P.M.'] = 'A.M.',
}

local era_text = {
	-- Text for displaying an era with a positive year (after adjusting
	-- by replacing year with 1 - year if date.year &lt;= 0).
	-- options.era = { year&lt;=0 , year&gt;0 }
	['BCMINUS']    = { 'BC'    , ''    , isbc = true, sign = MINUS },
	['BCNEGATIVE'] = { 'BC'    , ''    , isbc = true, sign = '-'   },
	['BC']         = { 'BC'    , ''    , isbc = true },
	['B.C.']       = { 'B.C.'  , ''    , isbc = true },
	['BCE']        = { 'BCE'   , ''    , isbc = true },
	['B.C.E.']     = { 'B.C.E.', ''    , isbc = true },
	['AD']         = { 'BC'    , 'AD'   },
	['A.D.']       = { 'B.C.'  , 'A.D.' },
	['CE']         = { 'BCE'   , 'CE'   },
	['C.E.']       = { 'B.C.E.', 'C.E.' },
}

local function get_era_for_year(era, year)
	return (era_text[era] or era_text['BC'])[year &gt; 0 and 2 or 1] or ''
end

local function strftime(date, format, options)
	-- Return date formatted as a string using codes similar to those
	-- in the C strftime library function.
	local sformat = string.format
	local shortcuts = {
		['%c'] = '%-I:%M %p %-d %B %-Y %{era}',  -- date and time: 2:30 pm 1 April 2016
		['%x'] = '%-d %B %-Y %{era}',            -- date:          1 April 2016
		['%X'] = '%-I:%M %p',                    -- time:          2:30 pm
	}
	if shortcuts[format] then
		format = shortcuts[format]
	end
	local codes = {
		a = { field = 'dayabbr' },
		A = { field = 'dayname' },
		b = { field = 'monthabbr' },
		B = { field = 'monthname' },
		u = { fmt = '%d'  , field = 'dowiso' },
		w = { fmt = '%d'  , field = 'dow' },
		d = { fmt = '%02d', fmt2 = '%d', field = 'day' },
		m = { fmt = '%02d', fmt2 = '%d', field = 'month' },
		Y = { fmt = '%04d', fmt2 = '%d', field = 'year' },
		H = { fmt = '%02d', fmt2 = '%d', field = 'hour' },
		M = { fmt = '%02d', fmt2 = '%d', field = 'minute' },
		S = { fmt = '%02d', fmt2 = '%d', field = 'second' },
		j = { fmt = '%03d', fmt2 = '%d', field = 'dayofyear' },
		I = { fmt = '%02d', fmt2 = '%d', field = 'hour', special = 'hour12' },
		p = { field = 'hour', special = 'am' },
	}
	options = make_option_table(options, date.options)
	local amopt = options.am
	local eraopt = options.era
	local function replace_code(spaces, modifier, id)
		local code = codes[id]
		if code then
			local fmt = code.fmt
			if modifier == '-' and code.fmt2 then
				fmt = code.fmt2
			end
			local value = date[code.field]
			if not value then
				return nil  -- an undefined field in a partial date
			end
			local special = code.special
			if special then
				if special == 'hour12' then
					value = value % 12
					value = value == 0 and 12 or value
				elseif special == 'am' then
					local ap = ({
						['a.m.'] = { 'a.m.', 'p.m.' },
						['AM'] = { 'AM', 'PM' },
						['A.M.'] = { 'A.M.', 'P.M.' },
					})[ampm_options[amopt]] or { 'am', 'pm' }
					return (spaces == '' and '' or '&amp;nbsp;') .. (value &lt; 12 and ap[1] or ap[2])
				end
			end
			if code.field == 'year' then
				local sign = (era_text[eraopt] or {}).sign
				if not sign or format:find('%{era}', 1, true) then
					sign = ''
					if value &lt;= 0 then
						value = 1 - value
					end
				else
					if value &gt;= 0 then
						sign = ''
					else
						value = -value
					end
				end
				return spaces .. sign .. sformat(fmt, value)
			end
			return spaces .. (fmt and sformat(fmt, value) or value)
		end
	end
	local function replace_property(spaces, id)
		if id == 'era' then
			-- Special case so can use local era option.
			local result = get_era_for_year(eraopt, date.year)
			if result == '' then
				return ''
			end
			return (spaces == '' and '' or '&amp;nbsp;') .. result
		end
		local result = date[id]
		if type(result) == 'string' then
			return spaces .. result
		end
		if type(result) == 'number' then
			return  spaces .. tostring(result)
		end
		if type(result) == 'boolean' then
			return  spaces .. (result and '1' or '0')
		end
		-- This occurs if id is an undefined field in a partial date, or is the name of a function.
		return nil
	end
	local PERCENT = '\127PERCENT\127'
	return (format
		:gsub('%%%%', PERCENT)
		:gsub('(%s*)%%{(%w+)}', replace_property)
		:gsub('(%s*)%%(%-?)(%a)', replace_code)
		:gsub(PERCENT, '%%')
	)
end

local function _date_text(date, fmt, options)
	-- Return a formatted string representing the given date.
	if not is_date(date) then
		error('date:text: need a date (use "date:text()" with a colon)', 2)
	end
	if type(fmt) == 'string' and fmt:match('%S') then
		if fmt:find('%', 1, true) then
			return strftime(date, fmt, options)
		end
	elseif date.partial then
		fmt = date.month and 'my' or 'y'
	else
		fmt = 'dmy'
		if date.hastime then
			fmt = (date.second &gt; 0 and 'hms ' or 'hm ') .. fmt
		end
	end
	local function bad_format()
		-- For consistency with other format processing, return given format
		-- (or cleaned format if original was not a string) if invalid.
		return mw.text.nowiki(fmt)
	end
	if date.partial then
		-- Ignore days in standard formats like 'ymd'.
		if fmt == 'ym' or fmt == 'ymd' then
			fmt = date.month and '%Y-%m %{era}' or '%Y %{era}'
		elseif fmt == 'my' or fmt == 'dmy' or fmt == 'mdy' then
			fmt = date.month and '%B %-Y %{era}' or '%-Y %{era}'
		elseif fmt == 'y' then
			fmt = date.month and '%-Y %{era}' or '%-Y %{era}'
		else
			return bad_format()
		end
		return strftime(date, fmt, options)
	end
	local function hm_fmt()
		local plain = make_option_table(options, date.options).bydefault.am
		return plain and '%H:%M' or '%-I:%M %p'
	end
	local need_time = date.hastime
	local t = collection()
	for item in fmt:gmatch('%S+') do
		local f
		if item == 'hm' then
			f = hm_fmt()
			need_time = false
		elseif item == 'hms' then
			f = '%H:%M:%S'
			need_time = false
		elseif item == 'ymd' then
			f = '%Y-%m-%d %{era}'
		elseif item == 'mdy' then
			f = '%B %-d, %-Y %{era}'
		elseif item == 'dmy' then
			f = '%-d %B %-Y %{era}'
		else
			return bad_format()
		end
		t:add(f)
	end
	fmt = t:join(' ')
	if need_time then
		fmt = hm_fmt() .. ' ' .. fmt
	end
	return strftime(date, fmt, options)
end

local day_info = {
	-- 0=Sun to 6=Sat
	[0] = { 'Sun', 'Sunday' },
	{ 'Mon', 'Monday' },
	{ 'Tue', 'Tuesday' },
	{ 'Wed', 'Wednesday' },
	{ 'Thu', 'Thursday' },
	{ 'Fri', 'Friday' },
	{ 'Sat', 'Saturday' },
}

local month_info = {
	-- 1=Jan to 12=Dec
	{ 'Jan', 'January' },
	{ 'Feb', 'February' },
	{ 'Mar', 'March' },
	{ 'Apr', 'April' },
	{ 'May', 'May' },
	{ 'Jun', 'June' },
	{ 'Jul', 'July' },
	{ 'Aug', 'August' },
	{ 'Sep', 'September' },
	{ 'Oct', 'October' },
	{ 'Nov', 'November' },
	{ 'Dec', 'December' },
}

local function name_to_number(text, translate)
	if type(text) == 'string' then
		return translate[text:lower()]
	end
end

local function day_number(text)
	return name_to_number(text, {
		sun = 0, sunday = 0,
		mon = 1, monday = 1,
		tue = 2, tuesday = 2,
		wed = 3, wednesday = 3,
		thu = 4, thursday = 4,
		fri = 5, friday = 5,
		sat = 6, saturday = 6,
	})
end

local function month_number(text)
	return name_to_number(text, {
		jan = 1, january = 1,
		feb = 2, february = 2,
		mar = 3, march = 3,
		apr = 4, april = 4,
		may = 5,
		jun = 6, june = 6,
		jul = 7, july = 7,
		aug = 8, august = 8,
		sep = 9, september = 9, sept = 9,
		oct = 10, october = 10,
		nov = 11, november = 11,
		dec = 12, december = 12,
	})
end

local function _list_text(list, fmt)
	-- Return a list of formatted strings from a list of dates.
	if not type(list) == 'table' then
		error('date:list:text: need "list:text()" with a colon', 2)
	end
	local result = { join = _list_join }
	for i, date in ipairs(list) do
		result[i] = date:text(fmt)
	end
	return result
end

local function _date_list(date, spec)
	-- Return a possibly empty numbered table of dates meeting the specification.
	-- Dates in the list are in ascending order (oldest date first).
	-- The spec should be a string of form "&lt;count&gt; &lt;day&gt; &lt;op&gt;"
	-- where each item is optional and
	--   count = number of items wanted in list
	--   day = abbreviation or name such as Mon or Monday
	--   op = &gt;, &gt;=, &lt;, &lt;= (default is &gt; meaning after date)
	-- If no count is given, the list is for the specified days in date's month.
	-- The default day is date's day.
	-- The spec can also be a positive or negative number:
	--   -5 is equivalent to '5 &lt;'
	--   5  is equivalent to '5' which is '5 &gt;'
	if not is_date(date) then
		error('date:list: need a date (use "date:list()" with a colon)', 2)
	end
	local list = { text = _list_text }
	if date.partial then
		return list
	end
	local count, offset, operation
	local ops = {
		['&gt;='] = { before = false, include = true  },
		['&gt;']  = { before = false, include = false },
		['&lt;='] = { before = true , include = true  },
		['&lt;']  = { before = true , include = false },
	}
	if spec then
		if type(spec) == 'number' then
			count = floor(spec + 0.5)
			if count &lt; 0 then
				count = -count
				operation = ops['&lt;']
			end
		elseif type(spec) == 'string' then
			local num, day, op = spec:match('^%s*(%d*)%s*(%a*)%s*([&lt;&gt;=]*)%s*$')
			if not num then
				return list
			end
			if num ~= '' then
				count = tonumber(num)
			end
			if day ~= '' then
				local dow = day_number(day:gsub('[sS]$', ''))  -- accept plural days
				if not dow then
					return list
				end
				offset = dow - date.dow
			end
			operation = ops[op]
		else
			return list
		end
	end
	offset = offset or 0
	operation = operation or ops['&gt;']
	local datefrom, dayfirst, daylast
	if operation.before then
		if offset &gt; 0 or (offset == 0 and not operation.include) then
			offset = offset - 7
		end
		if count then
			if count &gt; 1 then
				offset = offset - 7*(count - 1)
			end
			datefrom = date + offset
		else
			daylast = date.day + offset
			dayfirst = daylast % 7
			if dayfirst == 0 then
				dayfirst = 7
			end
		end
	else
		if offset &lt; 0 or (offset == 0 and not operation.include) then
			offset = offset + 7
		end
		if count then
			datefrom = date + offset
		else
			dayfirst = date.day + offset
			daylast = date.monthdays
		end
	end
	if not count then
		if daylast &lt; dayfirst then
			return list
		end
		count = floor((daylast - dayfirst)/7) + 1
		datefrom = Date(date, {day = dayfirst})
	end
	for i = 1, count do
		if not datefrom then break end  -- exceeds date limits
		list[i] = datefrom
		datefrom = datefrom + 7
	end
	return list
end

-- A table to get the current date/time (UTC), but only if needed.
local current = setmetatable({}, {
	__index = function (self, key)
		local d = os.date('!*t')
		self.year = d.year
		self.month = d.month
		self.day = d.day
		self.hour = d.hour
		self.minute = d.min
		self.second = d.sec
		return rawget(self, key)
	end })

local function extract_date(newdate, text)
	-- Parse the date/time in text and return n, o where
	--   n = table of numbers with date/time fields
	--   o = table of options for AM/PM or AD/BC or format, if any
	-- or return nothing if date is known to be invalid.
	-- Caller determines if the values in n are valid.
	-- A year must be positive ('1' to '9999'); use 'BC' for BC.
	-- In a y-m-d string, the year must be four digits to avoid ambiguity
	-- ('0001' to '9999'). The only way to enter year &lt;= 0 is by specifying
	-- the date as three numeric parameters like ymd Date(-1, 1, 1).
	-- Dates of form d/m/y, m/d/y, y/m/d are rejected as potentially ambiguous.
	local date, options = {}, {}
	if text:sub(-1) == 'Z' then
		-- Extract date/time from a Wikidata timestamp.
		-- The year can be 1 to 16 digits but this module handles 1 to 4 digits only.
		-- Examples: '+2016-06-21T14:30:00Z', '-0000000180-00-00T00:00:00Z'.
		local sign, y, m, d, H, M, S = text:match('^([+%-])(%d+)%-(%d%d)%-(%d%d)T(%d%d):(%d%d):(%d%d)Z$')
		if sign then
			y = tonumber(y)
			if sign == '-' and y &gt; 0 then
				y = -y
			end
			if y &lt;= 0 then
				options.era = 'BCE'
			end
			date.year = y
			m = tonumber(m)
			d = tonumber(d)
			H = tonumber(H)
			M = tonumber(M)
			S = tonumber(S)
			if m == 0 then
				newdate.partial = true
				return date, options
			end
			date.month = m
			if d == 0 then
				newdate.partial = true
				return date, options
			end
			date.day = d
			if H &gt; 0 or M &gt; 0 or S &gt; 0 then
				date.hour = H
				date.minute = M
				date.second = S
			end
			return date, options
		end
		return
	end
	local function extract_ymd(item)
		-- Called when no day or month has been set.
		local y, m, d = item:match('^(%d%d%d%d)%-(%w+)%-(%d%d?)$')
		if y then
			if date.year then
				return
			end
			if m:match('^%d%d?$') then
				m = tonumber(m)
			else
				m = month_number(m)
			end
			if m then
				date.year = tonumber(y)
				date.month = m
				date.day = tonumber(d)
				return true
			end
		end
	end
	local function extract_day_or_year(item)
		-- Called when a day would be valid, or
		-- when a year would be valid if no year has been set and partial is set.
		local number, suffix = item:match('^(%d%d?%d?%d?)(.*)$')
		if number then
			local n = tonumber(number)
			if #number &lt;= 2 and n &lt;= 31 then
				suffix = suffix:lower()
				if suffix == '' or suffix == 'st' or suffix == 'nd' or suffix == 'rd' or suffix == 'th' then
					date.day = n
					return true
				end
			elseif suffix == '' and newdate.partial and not date.year then
				date.year = n
				return true
			end
		end
	end
	local function extract_month(item)
		-- A month must be given as a name or abbreviation; a number could be ambiguous.
		local m = month_number(item)
		if m then
			date.month = m
			return true
		end
	end
	local function extract_time(item)
		local h, m, s = item:match('^(%d%d?):(%d%d)(:?%d*)$')
		if date.hour or not h then
			return
		end
		if s ~= '' then
			s = s:match('^:(%d%d)$')
			if not s then
				return
			end
		end
		date.hour = tonumber(h)
		date.minute = tonumber(m)
		date.second = tonumber(s)  -- nil if empty string
		return true
	end
	local item_count = 0
	local index_time
	local function set_ampm(item)
		local H = date.hour
		if H and not options.am and index_time + 1 == item_count then
			options.am = ampm_options[item]  -- caller checked this is not nil
			if item:match('^[Aa]') then
				if not (1 &lt;= H and H &lt;= 12) then
					return
				end
				if H == 12 then
					date.hour = 0
				end
			else
				if not (1 &lt;= H and H &lt;= 23) then
					return
				end
				if H &lt;= 11 then
					date.hour = H + 12
				end
			end
			return true
		end
	end
	for item in text:gsub(',', ' '):gsub('&amp;nbsp;', ' '):gmatch('%S+') do
		item_count = item_count + 1
		if era_text[item] then
			-- Era is accepted in peculiar places.
			if options.era then
				return
			end
			options.era = item
		elseif ampm_options[item] then
			if not set_ampm(item) then
				return
			end
		elseif item:find(':', 1, true) then
			if not extract_time(item) then
				return
			end
			index_time = item_count
		elseif date.day and date.month then
			if date.year then
				return  -- should be nothing more so item is invalid
			end
			if not item:match('^(%d%d?%d?%d?)$') then
				return
			end
			date.year = tonumber(item)
		elseif date.day then
			if not extract_month(item) then
				return
			end
		elseif date.month then
			if not extract_day_or_year(item) then
				return
			end
		elseif extract_month(item) then
			options.format = 'mdy'
		elseif extract_ymd(item) then
			options.format = 'ymd'
		elseif extract_day_or_year(item) then
			if date.day then
				options.format = 'dmy'
			end
		else
			return
		end
	end
	if not date.year or date.year == 0 then
		return
	end
	local era = era_text[options.era]
	if era and era.isbc then
		date.year = 1 - date.year
	end
	return date, options
end

local function autofill(date1, date2)
	-- Fill any missing month or day in each date using the
	-- corresponding component from the other date, if present,
	-- or with 1 if both dates are missing the month or day.
	-- This gives a good result for calculating the difference
	-- between two partial dates when no range is wanted.
	-- Return filled date1, date2 (two full dates).
	local function filled(a, b)
		-- Return date a filled, if necessary, with month and/or day from date b.
		-- The filled day is truncated to fit the number of days in the month.
		local fillmonth, fillday
		if not a.month then
			fillmonth = b.month or 1
		end
		if not a.day then
			fillday = b.day or 1
		end
		if fillmonth or fillday then  -- need to create a new date
			a = Date(a, {
				month = fillmonth,
				day = math.min(fillday or a.day, days_in_month(a.year, fillmonth or a.month, a.calendar))
			})
		end
		return a
	end
	return filled(date1, date2), filled(date2, date1)
end

local function date_add_sub(lhs, rhs, is_sub)
	-- Return a new date from calculating (lhs + rhs) or (lhs - rhs),
	-- or return nothing if invalid.
	-- The result is nil if the calculated date exceeds allowable limits.
	-- Caller ensures that lhs is a date; its properties are copied for the new date.
	if lhs.partial then
		-- Adding to a partial is not supported.
		-- Can subtract a date or partial from a partial, but this is not called for that.
		return
	end
	local function is_prefix(text, word, minlen)
		local n = #text
		return (minlen or 1) &lt;= n and n &lt;= #word and text == word:sub(1, n)
	end
	local function do_days(n)
		local forcetime, jd
		if floor(n) == n then
			jd = lhs.jd
		else
			forcetime = not lhs.hastime
			jd = lhs.jdz
		end
		jd = jd + (is_sub and -n or n)
		if forcetime then
			jd = tostring(jd)
			if not jd:find('.', 1, true) then
				jd = jd .. '.0'
			end
		end
		return Date(lhs, 'juliandate', jd)
	end
	if type(rhs) == 'number' then
		-- Add/subtract days, including fractional days.
		return do_days(rhs)
	end
	if type(rhs) == 'string' then
		-- rhs is a single component like '26m' or '26 months' (with optional sign).
		-- Fractions like '3.25d' are accepted for the units which are handled as days.
		local sign, numstr, id = rhs:match('^%s*([+-]?)([%d%.]+)%s*(%a+)$')
		if sign then
			if sign == '-' then
				is_sub = not (is_sub and true or false)
			end
			local y, m, days
			local num = tonumber(numstr)
			if not num then
				return
			end
			id = id:lower()
			if is_prefix(id, 'years') then
				y = num
				m = 0
			elseif is_prefix(id, 'months') then
				y = floor(num / 12)
				m = num % 12
			elseif is_prefix(id, 'weeks') then
				days = num * 7
			elseif is_prefix(id, 'days') then
				days = num
			elseif is_prefix(id, 'hours') then
				days = num / 24
			elseif is_prefix(id, 'minutes', 3) then
				days = num / (24 * 60)
			elseif is_prefix(id, 'seconds') then
				days = num / (24 * 3600)
			else
				return
			end
			if days then
				return do_days(days)
			end
			if numstr:find('.', 1, true) then
				return
			end
			if is_sub then
				y = -y
				m = -m
			end
			assert(-11 &lt;= m and m &lt;= 11)
			y = lhs.year + y
			m = lhs.month + m
			if m &gt; 12 then
				y = y + 1
				m = m - 12
			elseif m &lt; 1 then
				y = y - 1
				m = m + 12
			end
			local d = math.min(lhs.day, days_in_month(y, m, lhs.calendar))
			return Date(lhs, y, m, d)
		end
	end
	if is_diff(rhs) then
		local days = rhs.age_days
		if (is_sub or false) ~= (rhs.isnegative or false) then
			days = -days
		end
		return lhs + days
	end
end

local full_date_only = {
	dayabbr = true,
	dayname = true,
	dow = true,
	dayofweek = true,
	dowiso = true,
	dayofweekiso = true,
	dayofyear = true,
	gsd = true,
	juliandate = true,
	jd = true,
	jdz = true,
	jdnoon = true,
}

-- Metatable for a date's calculated fields.
local datemt = {
	__index = function (self, key)
		if rawget(self, 'partial') then
			if full_date_only[key] then return end
			if key == 'monthabbr' or key == 'monthdays' or key == 'monthname' then
				if not self.month then return end
			end
		end
		local value
		if key == 'dayabbr' then
			value = day_info[self.dow][1]
		elseif key == 'dayname' then
			value = day_info[self.dow][2]
		elseif key == 'dow' then
			value = (self.jdnoon + 1) % 7  -- day-of-week 0=Sun to 6=Sat
		elseif key == 'dayofweek' then
			value = self.dow
		elseif key == 'dowiso' then
			value = (self.jdnoon % 7) + 1  -- ISO day-of-week 1=Mon to 7=Sun
		elseif key == 'dayofweekiso' then
			value = self.dowiso
		elseif key == 'dayofyear' then
			local first = Date(self.year, 1, 1, self.calendar).jdnoon
			value = self.jdnoon - first + 1  -- day-of-year 1 to 366
		elseif key == 'era' then
			-- Era text (never a negative sign) from year and options.
			value = get_era_for_year(self.options.era, self.year)
		elseif key == 'format' then
			value = self.options.format or 'dmy'
		elseif key == 'gsd' then
			-- GSD = 1 from 00:00:00 to 23:59:59 on 1 January 1 AD Gregorian calendar,
			-- which is from jd 1721425.5 to 1721426.49999.
			value = floor(self.jd - 1721424.5)
		elseif key == 'juliandate' or key == 'jd' or key == 'jdz' then
			local jd, jdz = julian_date(self)
			rawset(self, 'juliandate', jd)
			rawset(self, 'jd', jd)
			rawset(self, 'jdz', jdz)
			return key == 'jdz' and jdz or jd
		elseif key == 'jdnoon' then
			-- Julian date at noon (an integer) on the calendar day when jd occurs.
			value = floor(self.jd + 0.5)
		elseif key == 'isleapyear' then
			value = is_leap_year(self.year, self.calendar)
		elseif key == 'monthabbr' then
			value = month_info[self.month][1]
		elseif key == 'monthdays' then
			value = days_in_month(self.year, self.month, self.calendar)
		elseif key == 'monthname' then
			value = month_info[self.month][2]
		end
		if value ~= nil then
			rawset(self, key, value)
			return value
		end
	end,
}

-- Date operators.
local function mt_date_add(lhs, rhs)
	if not is_date(lhs) then
		lhs, rhs = rhs, lhs  -- put date on left (it must be a date for this to have been called)
	end
	return date_add_sub(lhs, rhs)
end

local function mt_date_sub(lhs, rhs)
	if is_date(lhs) then
		if is_date(rhs) then
			return DateDiff(lhs, rhs)
		end
		return date_add_sub(lhs, rhs, true)
	end
end

local function mt_date_concat(lhs, rhs)
	return tostring(lhs) .. tostring(rhs)
end

local function mt_date_tostring(self)
	return self:text()
end

local function mt_date_eq(lhs, rhs)
	-- Return true if dates identify same date/time where, for example,
	-- Date(-4712, 1, 1, 'Julian') == Date(-4713, 11, 24, 'Gregorian') is true.
	-- This is called only if lhs and rhs have the same type and the same metamethod.
	if lhs.partial or rhs.partial then
		-- One date is partial; the other is a partial or a full date.
		-- The months may both be nil, but must be the same.
		return lhs.year == rhs.year and lhs.month == rhs.month and lhs.calendar == rhs.calendar
	end
	return lhs.jdz == rhs.jdz
end

local function mt_date_lt(lhs, rhs)
	-- Return true if lhs &lt; rhs, for example,
	-- Date('1 Jan 2016') &lt; Date('06:00 1 Jan 2016') is true.
	-- This is called only if lhs and rhs have the same type and the same metamethod.
	if lhs.partial or rhs.partial then
		-- One date is partial; the other is a partial or a full date.
		if lhs.calendar ~= rhs.calendar then
			return lhs.calendar == 'Julian'
		end
		if lhs.partial then
			lhs = lhs.partial.first
		end
		if rhs.partial then
			rhs = rhs.partial.first
		end
	end
	return lhs.jdz &lt; rhs.jdz
end

--[[ Examples of syntax to construct a date:
Date(y, m, d, 'julian')             default calendar is 'gregorian'
Date(y, m, d, H, M, S, 'julian')
Date('juliandate', jd, 'julian')    if jd contains "." text output includes H:M:S
Date('currentdate')
Date('currentdatetime')
Date('1 April 1995', 'julian')      parse date from text
Date('1 April 1995 AD', 'julian')   using an era sets a flag to do the same for output
Date('04:30:59 1 April 1995', 'julian')
Date(date)                          copy of an existing date
Date(date, t)                       same, updated with y,m,d,H,M,S fields from table t
Date(t)                       		date with y,m,d,H,M,S fields from table t
]]
function Date(...)  -- for forward declaration above
	-- Return a table holding a date assuming a uniform calendar always applies
	-- (proleptic Gregorian calendar or proleptic Julian calendar), or
	-- return nothing if date is invalid.
	-- A partial date has a valid year, however its month may be nil, and
	-- its day and time fields are nil.
	-- Field partial is set to false (if a full date) or a table (if a partial date).
	local calendars = { julian = 'Julian', gregorian = 'Gregorian' }
	local newdate = {
		_id = uniq,
		calendar = 'Gregorian',  -- default is Gregorian calendar
		hastime = false,  -- true if input sets a time
		hour = 0,  -- always set hour/minute/second so don't have to handle nil
		minute = 0,
		second = 0,
		options = {},
		list = _date_list,
		subtract = function (self, rhs, options)
			return DateDiff(self, rhs, options)
		end,
		text = _date_text,
	}
	local argtype, datetext, is_copy, jd_number, tnums
	local numindex = 0
	local numfields = { 'year', 'month', 'day', 'hour', 'minute', 'second' }
	local numbers = {}
	for _, v in ipairs({...}) do
		v = strip_to_nil(v)
		local vlower = type(v) == 'string' and v:lower() or nil
		if v == nil then
			-- Ignore empty arguments after stripping so modules can directly pass template parameters.
		elseif calendars[vlower] then
			newdate.calendar = calendars[vlower]
		elseif vlower == 'partial' then
			newdate.partial = true
		elseif vlower == 'fix' then
			newdate.want_fix = true
		elseif is_date(v) then
			-- Copy existing date (items can be overridden by other arguments).
			if is_copy or tnums then
				return
			end
			is_copy = true
			newdate.calendar = v.calendar
			newdate.partial = v.partial
			newdate.hastime = v.hastime
			newdate.options = v.options
			newdate.year = v.year
			newdate.month = v.month
			newdate.day = v.day
			newdate.hour = v.hour
			newdate.minute = v.minute
			newdate.second = v.second
		elseif type(v) == 'table' then
			if tnums then
				return
			end
			tnums = {}
			local tfields = { year=1, month=1, day=1, hour=2, minute=2, second=2 }
			for tk, tv in pairs(v) do
				if tfields[tk] then
					tnums[tk] = tonumber(tv)
				end
				if tfields[tk] == 2 then
					newdate.hastime = true
				end
			end
		else
			local num = tonumber(v)
			if not num and argtype == 'setdate' and numindex == 1 then
				num = month_number(v)
			end
			if num then
				if not argtype then
					argtype = 'setdate'
				end
				if argtype == 'setdate' and numindex &lt; 6 then
					numindex = numindex + 1
					numbers[numfields[numindex]] = num
				elseif argtype == 'juliandate' and not jd_number then
					jd_number = num
					if type(v) == 'string' then
						if v:find('.', 1, true) then
							newdate.hastime = true
						end
					elseif num ~= floor(num) then
						-- The given value was a number. The time will be used
						-- if the fractional part is nonzero.
						newdate.hastime = true
					end
				else
					return
				end
			elseif argtype then
				return
			elseif type(v) == 'string' then
				if v == 'currentdate' or v == 'currentdatetime' or v == 'juliandate' then
					argtype = v
				else
					argtype = 'datetext'
					datetext = v
				end
			else
				return
			end
		end
	end
	if argtype == 'datetext' then
		if tnums or not set_date_from_numbers(newdate, extract_date(newdate, datetext)) then
			return
		end
	elseif argtype == 'juliandate' then
		newdate.partial = nil
		newdate.jd = jd_number
		if not set_date_from_jd(newdate) then
			return
		end
	elseif argtype == 'currentdate' or argtype == 'currentdatetime' then
		newdate.partial = nil
		newdate.year = current.year
		newdate.month = current.month
		newdate.day = current.day
		if argtype == 'currentdatetime' then
			newdate.hour = current.hour
			newdate.minute = current.minute
			newdate.second = current.second
			newdate.hastime = true
		end
		newdate.calendar = 'Gregorian'  -- ignore any given calendar name
	elseif argtype == 'setdate' then
		if tnums or not set_date_from_numbers(newdate, numbers) then
			return
		end
	elseif not (is_copy or tnums) then
		return
	end
	if tnums then
		newdate.jd = nil  -- force recalculation in case jd was set before changes from tnums
		if not set_date_from_numbers(newdate, tnums) then
			return
		end
	end
	if newdate.partial then
		local year = newdate.year
		local month = newdate.month
		local first = Date(year, month or 1, 1, newdate.calendar)
		month = month or 12
		local last = Date(year, month, days_in_month(year, month), newdate.calendar)
		newdate.partial = { first = first, last = last }
	else
		newdate.partial = false  -- avoid index lookup
	end
	setmetatable(newdate, datemt)
	local readonly = {}
	local mt = {
		__index = newdate,
		__newindex = function(t, k, v) error('date.' .. tostring(k) .. ' is read-only', 2) end,
		__add = mt_date_add,
		__sub = mt_date_sub,
		__concat = mt_date_concat,
		__tostring = mt_date_tostring,
		__eq = mt_date_eq,
		__lt = mt_date_lt,
	}
	return setmetatable(readonly, mt)
end

local function _diff_age(diff, code, options)
	-- Return a tuple of integer values from diff as specified by code, except that
	-- each integer may be a list of two integers for a diff with a partial date, or
	-- return nil if the code is not supported.
	-- If want round, the least significant unit is rounded to nearest whole unit.
	-- For a duration, an extra day is added.
	local wantround, wantduration, wantrange
	if type(options) == 'table' then
		wantround = options.round
		wantduration = options.duration
		wantrange = options.range
	else
		wantround = options
	end
	if not is_diff(diff) then
		local f = wantduration and 'duration' or 'age'
		error(f .. ': need a date difference (use "diff:' .. f .. '()" with a colon)', 2)
	end
	if diff.partial then
		-- Ignore wantround, wantduration.
		local function choose(v)
			if type(v) == 'table' then
				if not wantrange or v[1] == v[2] then
					-- Example: Date('partial', 2005) - Date('partial', 2001) gives
					-- diff.years = { 3, 4 } to show the range of possible results.
					-- If do not want a range, choose the second value as more expected.
					return v[2]
				end
			end
			return v
		end
		if code == 'ym' or code == 'ymd' then
			if not wantrange and diff.iszero then
				-- This avoids an unexpected result such as
				-- Date('partial', 2001) - Date('partial', 2001)
				-- giving diff = { years = 0, months = { 0, 11 } }
				-- which would be reported as 0 years and 11 months.
				return 0, 0
			end
			return choose(diff.partial.years), choose(diff.partial.months)
		end
		if code == 'y' then
			return choose(diff.partial.years)
		end
		if code == 'm' or code == 'w' or code == 'd' then
			return choose({ diff.partial.mindiff:age(code), diff.partial.maxdiff:age(code) })
		end
		return nil
	end
	local extra_days = wantduration and 1 or 0
	if code == 'wd' or code == 'w' or code == 'd' then
		local offset = wantround and 0.5 or 0
		local days = diff.age_days + extra_days
		if code == 'wd' or code == 'd' then
			days = floor(days + offset)
			if code == 'd' then
				return days
			end
			return floor(days/7), days % 7
		end
		return floor(days/7 + offset)
	end
	local H, M, S = diff.hours, diff.minutes, diff.seconds
	if code == 'dh' or code == 'dhm' or code == 'dhms' or code == 'h' or code == 'hm' or code == 'hms' or code == 'M' or code == 's' then
		local days = floor(diff.age_days + extra_days)
		local inc_hour
		if wantround then
			if code == 'dh' or code == 'h' then
				if M &gt;= 30 then
					inc_hour = true
				end
			elseif code == 'dhm' or code == 'hm' then
				if S &gt;= 30 then
					M = M + 1
					if M &gt;= 60 then
						M = 0
						inc_hour = true
					end
				end
			elseif code == 'M' then
				if S &gt;= 30 then
					M = M + 1
				end
			else
				-- Nothing needed because S is an integer.
			end
			if inc_hour then
				H = H + 1
				if H &gt;= 24 then
					H = 0
					days = days + 1
				end
			end
		end
		if code == 'dh' or code == 'dhm' or code == 'dhms' then
			if code == 'dh' then
				return days, H
			elseif code == 'dhm' then
				return days, H, M
			else
				return days, H, M, S
			end
		end
		local hours = days * 24 + H
		if code == 'h' then
			return hours
		elseif code == 'hm' then
			return hours, M
		elseif code == 'M' or code == 's' then
			M = hours * 60 + M
			if code == 'M' then
				return M
			end
			return M * 60 + S
		end
		return hours, M, S
	end
	if wantround then
		local inc_hour
		if code == 'ymdh' or code == 'ymwdh' then
			if M &gt;= 30 then
				inc_hour = true
			end
		elseif code == 'ymdhm' or code == 'ymwdhm' then
			if S &gt;= 30 then
				M = M + 1
				if M &gt;= 60 then
					M = 0
					inc_hour = true
				end
			end
		elseif code == 'ymd' or code == 'ymwd' or code == 'yd' or code == 'md' then
			if H &gt;= 12 then
				extra_days = extra_days + 1
			end
		end
		if inc_hour then
			H = H + 1
			if H &gt;= 24 then
				H = 0
				extra_days = extra_days + 1
			end
		end
	end
	local y, m, d = diff.years, diff.months, diff.days
	if extra_days &gt; 0 then
		d = d + extra_days
		if d &gt; 28 or code == 'yd' then
			-- Recalculate in case have passed a month.
			diff = diff.date1 + extra_days - diff.date2
			y, m, d = diff.years, diff.months, diff.days
		end
	end
	if code == 'ymd' then
		return y, m, d
	elseif code == 'yd' then
		if y &gt; 0 then
			-- It is known that diff.date1 &gt; diff.date2.
			diff = diff.date1 - (diff.date2 + (y .. 'y'))
		end
		return y, floor(diff.age_days)
	elseif code == 'md' then
		return y * 12 + m, d
	elseif code == 'ym' or code == 'm' then
		if wantround then
			if d &gt;= 16 then
				m = m + 1
				if m &gt;= 12 then
					m = 0
					y = y + 1
				end
			end
		end
		if code == 'ym' then
			return y, m
		end
		return y * 12 + m
	elseif code == 'ymw' then
		local weeks = floor(d/7)
		if wantround then
			local days = d % 7
			if days &gt; 3 or (days == 3 and H &gt;= 12) then
				weeks = weeks + 1
			end
		end
		return y, m, weeks
	elseif code == 'ymwd' then
		return y, m, floor(d/7), d % 7
	elseif code == 'ymdh' then
		return y, m, d, H
	elseif code == 'ymwdh' then
		return y, m, floor(d/7), d % 7, H
	elseif code == 'ymdhm' then
		return y, m, d, H, M
	elseif code == 'ymwdhm' then
		return y, m, floor(d/7), d % 7, H, M
	end
	if code == 'y' then
		if wantround and m &gt;= 6 then
			y = y + 1
		end
		return y
	end
	return nil
end

local function _diff_duration(diff, code, options)
	if type(options) ~= 'table' then
		options = { round = options }
	end
	options.duration = true
	return _diff_age(diff, code, options)
end

-- Metatable for some operations on date differences.
diffmt = {  -- for forward declaration above
	__concat = function (lhs, rhs)
		return tostring(lhs) .. tostring(rhs)
	end,
	__tostring = function (self)
		return tostring(self.age_days)
	end,
	__index = function (self, key)
		local value
		if key == 'age_days' then
			if rawget(self, 'partial') then
				local function jdz(date)
					return (date.partial and date.partial.first or date).jdz
				end
				value = jdz(self.date1) - jdz(self.date2)
			else
				value = self.date1.jdz - self.date2.jdz
			end
		end
		if value ~= nil then
			rawset(self, key, value)
			return value
		end
	end,
}

function DateDiff(date1, date2, options)  -- for forward declaration above
	-- Return a table with the difference between two dates (date1 - date2).
	-- The difference is negative if date1 is older than date2.
	-- Return nothing if invalid.
	-- If d = date1 - date2 then
	--     date1 = date2 + d
	-- If date1 &gt;= date2 and the dates have no H:M:S time specified then
	--     date1 = date2 + (d.years..'y') + (d.months..'m') + d.days
	-- where the larger time units are added first.
	-- The result of Date(2015,1,x) + '1m' is Date(2015,2,28) for
	-- x = 28, 29, 30, 31. That means, for example,
	--     d = Date(2015,3,3) - Date(2015,1,31)
	-- gives d.years, d.months, d.days = 0, 1, 3 (excluding date1).
	if not (is_date(date1) and is_date(date2) and date1.calendar == date2.calendar) then
		return
	end
	local wantfill
	if type(options) == 'table' then
		wantfill = options.fill
	end
	local isnegative = false
	local iszero = false
	if date1 &lt; date2 then
		isnegative = true
		date1, date2 = date2, date1
	elseif date1 == date2 then
		iszero = true
	end
	-- It is known that date1 &gt;= date2 (period is from date2 to date1).
	if date1.partial or date2.partial then
		-- Two partial dates might have timelines:
		---------------------A=================B--- date1 is from A to B inclusive
		--------C=======D-------------------------- date2 is from C to D inclusive
		-- date1 &gt; date2 iff A &gt; C (date1.partial.first &gt; date2.partial.first)
		-- The periods can overlap ('April 2001' - '2001'):
		-------------A===B------------------------- A=2001-04-01  B=2001-04-30
		--------C=====================D------------ C=2001-01-01  D=2001-12-31
		if wantfill then
			date1, date2 = autofill(date1, date2)
		else
			local function zdiff(date1, date2)
				local diff = date1 - date2
				if diff.isnegative then
					return date1 - date1  -- a valid diff in case we call its methods
				end
				return diff
			end
			local function getdate(date, which)
				return date.partial and date.partial[which] or date
			end
			local maxdiff = zdiff(getdate(date1, 'last'), getdate(date2, 'first'))
			local mindiff = zdiff(getdate(date1, 'first'), getdate(date2, 'last'))
			local years, months
			if maxdiff.years == mindiff.years then
				years = maxdiff.years
				if maxdiff.months == mindiff.months then
					months = maxdiff.months
				else
					months = { mindiff.months, maxdiff.months }
				end
			else
				years = { mindiff.years, maxdiff.years }
			end
			return setmetatable({
				date1 = date1,
				date2 = date2,
				partial = {
					years = years,
					months = months,
					maxdiff = maxdiff,
					mindiff = mindiff,
				},
				isnegative = isnegative,
				iszero = iszero,
				age = _diff_age,
				duration = _diff_duration,
			}, diffmt)
		end
	end
	local y1, m1 = date1.year, date1.month
	local y2, m2 = date2.year, date2.month
	local years = y1 - y2
	local months = m1 - m2
	local d1 = date1.day + hms(date1)
	local d2 = date2.day + hms(date2)
	local days, time
	if d1 &gt;= d2 then
		days = d1 - d2
	else
		months = months - 1
		-- Get days in previous month (before the "to" date) given December has 31 days.
		local dpm = m1 &gt; 1 and days_in_month(y1, m1 - 1, date1.calendar) or 31
		if d2 &gt;= dpm then
			days = d1 - hms(date2)
		else
			days = dpm - d2 + d1
		end
	end
	if months &lt; 0 then
		years = years - 1
		months = months + 12
	end
	days, time = math.modf(days)
	local H, M, S = h_m_s(time)
	return setmetatable({
		date1 = date1,
		date2 = date2,
		partial = false,  -- avoid index lookup
		years = years,
		months = months,
		days = days,
		hours = H,
		minutes = M,
		seconds = S,
		isnegative = isnegative,
		iszero = iszero,
		age = _diff_age,
		duration = _diff_duration,
	}, diffmt)
end

return {
	_current = current,
	_Date = Date,
	_days_in_month = days_in_month,
}</text>
      <sha1>8htfjg7cmqlbgysia559pe52c5tetp5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbar</title>
    <ns>828</ns>
    <id>159</id>
    <revision>
      <id>306</id>
      <parentid>305</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>305</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5296" sha1="0iwrh6fwqy52ve4qubv886e6mqvyrcq" xml:space="preserve">local p = {}
local cfg = mw.loadData('Module:Navbar/configuration')

local function get_title_arg(is_collapsible, template)
	local title_arg = 1
	if is_collapsible then title_arg = 2 end
	if template then title_arg = 'template' end
	return title_arg
end

local function choose_links(template, args)
	-- The show table indicates the default displayed items.
	-- view, talk, edit, hist, move, watch
	-- TODO: Move to configuration.
	local show = {true, true, true, false, false, false}
	if template then
		show[2] = false
		show[3] = false
		local index = {t = 2, d = 2, e = 3, h = 4, m = 5, w = 6,
			talk = 2, edit = 3, hist = 4, move = 5, watch = 6}
		-- TODO: Consider removing TableTools dependency.
		for _, v in ipairs(require ('Module:TableTools').compressSparseArray(args)) do
			local num = index[v]
			if num then show[num] = true end
		end
	end

	local remove_edit_link = args.noedit
	if remove_edit_link then show[3] = false end
	
	return show
	
end

local function add_link(link_description, ul, is_mini, font_style)
	local l
	if link_description.url then
		l = {'[', '', ']'}
	else
		l = {'[[', '|', ']]'}
	end
	ul:tag('li')
		:addClass('nv-' .. link_description.full)
		:wikitext(l[1] .. link_description.link .. l[2])
		:tag(is_mini and 'abbr' or 'span')
			:attr('title', link_description.html_title)
			:cssText(font_style)
			:wikitext(is_mini and link_description.mini or link_description.full)
			:done()
		:wikitext(l[3])
		:done()
end

local function make_list(title_text, has_brackets, displayed_links, is_mini, font_style)
	
	local title = mw.title.new(mw.text.trim(title_text), cfg.title_namespace)
	if not title then
		error(cfg.invalid_title .. title_text)
	end
	local talkpage = title.talkPageTitle and title.talkPageTitle.fullText or ''
	
	-- TODO: Get link_descriptions and show into the configuration module.
	-- link_descriptions should be easier...
	local link_descriptions = {
		{ ['mini'] = 'v', ['full'] = 'view', ['html_title'] = 'View this template',
			['link'] = title.fullText, ['url'] = false },
		{ ['mini'] = 't', ['full'] = 'talk', ['html_title'] = 'Discuss this template',
			['link'] = talkpage, ['url'] = false },
		{ ['mini'] = 'e', ['full'] = 'edit', ['html_title'] = 'Edit this template',
			['link'] = 'Special:EditPage/' .. title.fullText, ['url'] = false },
		{ ['mini'] = 'h', ['full'] = 'hist', ['html_title'] = 'History of this template',
			['link'] = 'Special:PageHistory/' .. title.fullText, ['url'] = false },
		{ ['mini'] = 'm', ['full'] = 'move', ['html_title'] = 'Move this template',
			['link'] = mw.title.new('Special:Movepage'):fullUrl('target='..title.fullText), ['url'] = true },
		{ ['mini'] = 'w', ['full'] = 'watch', ['html_title'] = 'Watch this template', 
			['link'] = title:fullUrl('action=watch'), ['url'] = true }
	}

	local ul = mw.html.create('ul')
	if has_brackets then
		ul:addClass(cfg.classes.brackets)
			:cssText(font_style)
	end
	
	for i, _ in ipairs(displayed_links) do
		if displayed_links[i] then add_link(link_descriptions[i], ul, is_mini, font_style) end
	end
	return ul:done()
	
end

function p._navbar(args)
	
	-- TODO: We probably don't need both fontstyle and fontcolor...
	local font_style = args.fontstyle
	local font_color = args.fontcolor
	local is_collapsible = args.collapsible
	local is_mini = args.mini
	local is_plain = args.plain
	
	local collapsible_class = nil
	if is_collapsible then
		collapsible_class = cfg.classes.collapsible
		if not is_plain then is_mini = 1 end
		if font_color then
			font_style = (font_style or '') .. '; color: ' .. font_color .. ';'
		end
	end
	
	local navbar_style = args.style
	local div = mw.html.create():tag('div')
	div
		:addClass(cfg.classes.navbar)
		:addClass(cfg.classes.plainlinks)
		:addClass(cfg.classes.horizontal_list)
		:addClass(collapsible_class) -- we made the determination earlier
		:cssText(navbar_style)

	if is_mini then div:addClass(cfg.classes.mini) end

	local box_text = (args.text or cfg.box_text) .. ' '
	 -- the concatenated space guarantees the box text is separated
	if not (is_mini or is_plain) then
		div
			:tag('span')
				:addClass(cfg.classes.box_text)
				:cssText(font_style)
				:wikitext(box_text)
	end
	
	local template = args.template
	local displayed_links = choose_links(template, args)
	local has_brackets = args.brackets
	local title_arg = get_title_arg(is_collapsible, template)
	local title_text = args[title_arg] or (':' .. mw.getCurrentFrame():getParent():getTitle())
	local list = make_list(title_text, has_brackets, displayed_links, is_mini, font_style)
	div:node(list)

	if is_collapsible then
		local title_text_class
		if is_mini then
			title_text_class = cfg.classes.collapsible_title_mini
		else
			title_text_class = cfg.classes.collapsible_title_full
		end
		div:done()
			:tag('div')
			:addClass(title_text_class)
			:cssText(font_style)
			:wikitext(args[1])
	end
	
	local frame = mw.getCurrentFrame()
	-- hlist -&gt; navbar is best-effort to preserve old Common.css ordering.
	return frame:extensionTag{
		name = 'templatestyles', args = { src = cfg.hlist_templatestyles }
	} .. frame:extensionTag{
		name = 'templatestyles', args = { src = cfg.templatestyles }
	} .. tostring(div:done())
end

function p.navbar(frame)
	return p._navbar(require('Module:Arguments').getArgs(frame))
end

return p</text>
      <sha1>0iwrh6fwqy52ve4qubv886e6mqvyrcq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbar/configuration</title>
    <ns>828</ns>
    <id>160</id>
    <revision>
      <id>308</id>
      <parentid>307</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>307</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="915" sha1="kk8qwxitcbzsvf797c9dznp7tw3a53p" xml:space="preserve">return {
	['templatestyles'] = 'Module:Navbar/styles.css',
	['hlist_templatestyles'] = 'Hlist/styles.css',
	['box_text'] = 'This box: ',			-- default text box when not plain or mini
	['title_namespace'] = 'Template',		-- namespace to default to for title
	['invalid_title'] = 'Invalid title ',
	['classes'] = { -- set a line to nil if you don't want it
		['navbar'] = 'navbar',
		['plainlinks'] = 'plainlinks', -- plainlinks
		['horizontal_list'] = 'hlist', -- horizontal list class
		['mini'] = 'navbar-mini', -- class indicating small links in the navbar
		['this_box'] = 'navbar-boxtext',
		['brackets'] = 'navbar-brackets',
		-- 'collapsible' is the key for a class to indicate the navbar is
		-- setting up the collapsible element in addition to the normal
		-- navbar.
		['collapsible'] = 'navbar-collapse',
		['collapsible_title_mini'] = 'navbar-ct-mini',
		['collapsible_title_full'] = 'navbar-ct-full'
	}
}</text>
      <sha1>kk8qwxitcbzsvf797c9dznp7tw3a53p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbar/styles.css</title>
    <ns>828</ns>
    <id>161</id>
    <revision>
      <id>310</id>
      <parentid>309</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>309</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1105" sha1="a68rpqs0zynjjfzlunkhpdlpnoe6c82" xml:space="preserve">/* {{pp|small=yes}} */
.navbar {
	display: inline;
	font-size: 88%;
	font-weight: normal;
}

.navbar-collapse {
	float: left;
	text-align: left;
}

.navbar-boxtext {
	word-spacing: 0;
}

.navbar ul {
	display: inline-block;
	white-space: nowrap;
	line-height: inherit;
}

.navbar-brackets::before {
	margin-right: -0.125em;
	content: '[ ';
}

.navbar-brackets::after {
	margin-left: -0.125em;
	content: ' ]';
}

.navbar li {
	word-spacing: -0.125em;
}

.navbar a &gt; span,
.navbar a &gt; abbr {
	text-decoration: inherit;
}

.navbar-mini abbr {
	font-variant: small-caps;
	border-bottom: none;
	text-decoration: none;
	cursor: inherit;
}

.navbar-ct-full {
	font-size: 114%;
	margin: 0 7em;
}

.navbar-ct-mini {
	font-size: 114%;
	margin: 0 4em;
}

/* not the usual @media screen, we simply remove navbar in @media print */
html.skin-theme-clientpref-night .navbar li a abbr {
	color: var(--color-base) !important;
}

@media (prefers-color-scheme: dark) {
	html.skin-theme-clientpref-os .navbar li a abbr {
		color: var(--color-base) !important;
	}
}

@media print {
	.navbar {
		display: none !important;
	}
}</text>
      <sha1>a68rpqs0zynjjfzlunkhpdlpnoe6c82</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbox</title>
    <ns>828</ns>
    <id>162</id>
    <revision>
      <id>312</id>
      <parentid>311</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>311</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="29178" sha1="9nuyd1y0flay2cj559n7z0gkbzwwin6" xml:space="preserve">require('strict')
local p = {}
local cfg = mw.loadData('Module:Navbox/configuration')
local inArray = require("Module:TableTools").inArray
local getArgs -- lazily initialized
local hiding_templatestyles = {} 

-- global passthrough variables
local passthrough = {
	[cfg.arg.above]=true,[cfg.arg.aboveclass]=true,[cfg.arg.abovestyle]=true,
	[cfg.arg.basestyle]=true,
	[cfg.arg.below]=true,[cfg.arg.belowclass]=true,[cfg.arg.belowstyle]=true,
	[cfg.arg.bodyclass]=true,
	[cfg.arg.groupclass]=true,
	[cfg.arg.image]=true,[cfg.arg.imageclass]=true,[cfg.arg.imagestyle]=true,
	[cfg.arg.imageleft]=true,[cfg.arg.imageleftstyle]=true,
	[cfg.arg.listclass]=true,
	[cfg.arg.name]=true,
	[cfg.arg.navbar]=true,
	[cfg.arg.state]=true,
	[cfg.arg.title]=true,[cfg.arg.titleclass]=true,[cfg.arg.titlestyle]=true,
	argHash=true
}

-- helper functions
local andnum = function(s, n) return string.format(cfg.arg[s .. '_and_num'], n) end
local isblank = function(v) return (v or '') == '' end

local function concatstrings(s)
	local r = table.concat(s, '')
	if r:match('^%s*$') then return nil end
	return r
end

local function concatstyles(s)
	local r = ''
	for _, v in ipairs(s) do
		v = mw.text.trim(v, "%s;")
		if not isblank(v) then r = r .. v .. ';' end
	end
	if isblank(r) then return nil end
	return r
end

local function getSubgroup(args, listnum, listText, prefix)
	local subArgs = {
		[cfg.arg.border] = cfg.keyword.border_subgroup,
		[cfg.arg.navbar] = cfg.keyword.navbar_plain,
		argHash = 0
	}
	local hasSubArgs = false
	local subgroups_and_num = prefix and {prefix} or cfg.arg.subgroups_and_num
	for k, v in pairs(args) do
		k = tostring(k)
		for _, w in ipairs(subgroups_and_num) do
			w = string.format(w, listnum) .. "_"
			if (#k &gt; #w) and (k:sub(1, #w) == w) then
				subArgs[k:sub(#w + 1)] = v
				hasSubArgs = true
				subArgs.argHash = subArgs.argHash + (v and #v or 0)
			end
		end
	end
	return hasSubArgs and p._navbox(subArgs) or listText
end

-- Main functions
function p._navbox(args)
	if args.type == cfg.keyword.with_collapsible_groups then
		return p._withCollapsibleGroups(args)
	elseif args.type == cfg.keyword.with_columns then
		return p._withColumns(args)
	end

	local function striped(wikitext, border)
		-- Return wikitext with markers replaced for odd/even striping.
		-- Child (subgroup) navboxes are flagged with a category that is removed
		-- by parent navboxes. The result is that the category shows all pages
		-- where a child navbox is not contained in a parent navbox.
		local orphanCat = cfg.category.orphan
		if border == cfg.keyword.border_subgroup and args[cfg.arg.orphan] ~= cfg.keyword.orphan_yes then
			-- No change; striping occurs in outermost navbox.
			return wikitext .. orphanCat
		end
		local first, second = cfg.class.navbox_odd_part, cfg.class.navbox_even_part
		if args[cfg.arg.evenodd] then
			if args[cfg.arg.evenodd] == cfg.keyword.evenodd_swap then
				first, second = second, first
			else
				first = args[cfg.arg.evenodd]
				second = first
			end
		end
		local changer
		if first == second then
			changer = first
		else
			local index = 0
			changer = function (code)
				if code == '0' then
					-- Current occurrence is for a group before a nested table.
					-- Set it to first as a valid although pointless class.
					-- The next occurrence will be the first row after a title
					-- in a subgroup and will also be first.
					index = 0
					return first
				end
				index = index + 1
				return index % 2 == 1 and first or second
			end
		end
		local regex = orphanCat:gsub('([%[%]])', '%%%1')
		return (wikitext:gsub(regex, ''):gsub(cfg.marker.regex, changer)) -- () omits gsub count
	end

	local function processItem(item, nowrapitems)
		if item:sub(1, 2) == '{|' then
			-- Applying nowrap to lines in a table does not make sense.
			-- Add newlines to compensate for trim of x in |parm=x in a template.
			return '\n' .. item .. '\n'
		end
		if nowrapitems == cfg.keyword.nowrapitems_yes then
			local lines = {}
			for line in (item .. '\n'):gmatch('([^\n]*)\n') do
				local prefix, content = line:match('^([*:;#]+)%s*(.*)')
				if prefix and not content:match(cfg.pattern.nowrap) then
					line = string.format(cfg.nowrap_item, prefix, content)
				end
				table.insert(lines, line)
			end
			item = table.concat(lines, '\n')
		end
		if item:match('^[*:;#]') then
			return '\n' .. item .. '\n'
		end
		return item
	end

	local function has_navbar()
		return args[cfg.arg.navbar] ~= cfg.keyword.navbar_off
			and args[cfg.arg.navbar] ~= cfg.keyword.navbar_plain
			and (
				args[cfg.arg.name]
				or mw.getCurrentFrame():getParent():getTitle():gsub(cfg.pattern.sandbox, '')
					~= cfg.pattern.navbox
			)
	end

	-- extract text color from css, which is the only permitted inline CSS for the navbar
	local function extract_color(css_str)
		-- return nil because navbar takes its argument into mw.html which handles
		-- nil gracefully, removing the associated style attribute
		return mw.ustring.match(';' .. css_str .. ';', '.*;%s*([Cc][Oo][Ll][Oo][Rr]%s*:%s*.-)%s*;') or nil
	end

	local function renderNavBar(titleCell)
		if has_navbar() then
			local navbar = require('Module:Navbar')._navbar
			titleCell:wikitext(navbar{
				[cfg.navbar.name] = args[cfg.arg.name],
				[cfg.navbar.mini] = 1,
				[cfg.navbar.fontstyle] = extract_color(
					(args[cfg.arg.basestyle] or '') .. ';' .. (args[cfg.arg.titlestyle] or '')
				)
			})
		end

	end

	local function renderTitleRow(tbl)
		if not args[cfg.arg.title] then return end

		local titleRow = tbl:tag('tr')

		local titleCell = titleRow:tag('th'):attr('scope', 'col')

		local titleColspan = 2
		if args[cfg.arg.imageleft] then titleColspan = titleColspan + 1 end
		if args[cfg.arg.image] then titleColspan = titleColspan + 1 end

		titleCell
			:cssText(args[cfg.arg.basestyle])
			:cssText(args[cfg.arg.titlestyle])
			:addClass(cfg.class.navbox_title)
			:attr('colspan', titleColspan)

		renderNavBar(titleCell)

		titleCell
			:tag('div')
				-- id for aria-labelledby attribute
				:attr('id', mw.uri.anchorEncode(args[cfg.arg.title]) .. args.argHash)
				:addClass(args[cfg.arg.titleclass])
				:css('font-size', '114%')
				:css('margin', '0 4em')
				:wikitext(processItem(args[cfg.arg.title]))
	end

	local function getAboveBelowColspan()
		local ret = 2
		if args[cfg.arg.imageleft] then ret = ret + 1 end
		if args[cfg.arg.image] then ret = ret + 1 end
		return ret
	end

	local function renderAboveRow(tbl)
		if not args[cfg.arg.above] then return end

		tbl:tag('tr')
			:tag('td')
				:addClass(cfg.class.navbox_abovebelow)
				:addClass(args[cfg.arg.aboveclass])
				:cssText(args[cfg.arg.basestyle])
				:cssText(args[cfg.arg.abovestyle])
				:attr('colspan', getAboveBelowColspan())
				:tag('div')
					-- id for aria-labelledby attribute, if no title
					:attr('id', (not args[cfg.arg.title]) and 
						(mw.uri.anchorEncode(args[cfg.arg.above]) .. args.argHash)
						or nil)
					:wikitext(processItem(args[cfg.arg.above], args[cfg.arg.nowrapitems]))
	end

	local function renderBelowRow(tbl)
		if not args[cfg.arg.below] then return end

		tbl:tag('tr')
			:tag('td')
				:addClass(cfg.class.navbox_abovebelow)
				:addClass(args[cfg.arg.belowclass])
				:cssText(args[cfg.arg.basestyle])
				:cssText(args[cfg.arg.belowstyle])
				:attr('colspan', getAboveBelowColspan())
				:tag('div')
					:wikitext(processItem(args[cfg.arg.below], args[cfg.arg.nowrapitems]))
	end

	local function renderListRow(tbl, index, listnum, listnums_size)
		local row = tbl:tag('tr')

		if index == 1 and args[cfg.arg.imageleft] then
			row
				:tag('td')
					:addClass(cfg.class.noviewer)
					:addClass(cfg.class.navbox_image)
					:addClass(args[cfg.arg.imageclass])
					:css('width', '1px')               -- Minimize width
					:css('padding', '0 2px 0 0')
					:cssText(args[cfg.arg.imageleftstyle])
					:attr('rowspan', listnums_size)
					:tag('div')
						:wikitext(processItem(args[cfg.arg.imageleft]))
		end

		local group_and_num = andnum('group', listnum)
		local groupstyle_and_num = andnum('groupstyle', listnum)
		if args[group_and_num] then
			local groupCell = row:tag('th')

			-- id for aria-labelledby attribute, if lone group with no title or above
			if listnum == 1 and not (args[cfg.arg.title] or args[cfg.arg.above] or args[cfg.arg.group2]) then
				groupCell
					:attr('id', mw.uri.anchorEncode(args[cfg.arg.group1]) .. args.argHash)
			end

			groupCell
				:attr('scope', 'row')
				:addClass(cfg.class.navbox_group)
				:addClass(args[cfg.arg.groupclass])
				:cssText(args[cfg.arg.basestyle])
				-- If groupwidth not specified, minimize width
				:css('width', args[cfg.arg.groupwidth] or '1%')

			groupCell
				:cssText(args[cfg.arg.groupstyle])
				:cssText(args[groupstyle_and_num])
				:wikitext(args[group_and_num])
		end

		local listCell = row:tag('td')

		if args[group_and_num] then
			listCell
				:addClass(cfg.class.navbox_list_with_group)
		else
			listCell:attr('colspan', 2)
		end

		if not args[cfg.arg.groupwidth] then
			listCell:css('width', '100%')
		end

		local rowstyle  -- usually nil so cssText(rowstyle) usually adds nothing
		if index % 2 == 1 then
			rowstyle = args[cfg.arg.oddstyle]
		else
			rowstyle = args[cfg.arg.evenstyle]
		end

		local list_and_num = andnum('list', listnum)
		local listText = inArray(cfg.keyword.subgroups, args[list_and_num])
			and getSubgroup(args, listnum, args[list_and_num]) or args[list_and_num]

		local oddEven = cfg.marker.oddeven
		if listText:sub(1, 12) == '&lt;/div&gt;&lt;table' then
			-- Assume list text is for a subgroup navbox so no automatic striping for this row.
			oddEven = listText:find(cfg.pattern.navbox_title) and cfg.marker.restart or cfg.class.navbox_odd_part
		end

		local liststyle_and_num = andnum('liststyle', listnum)
		local listclass_and_num = andnum('listclass', listnum)
		listCell
			:css('padding', '0')
			:cssText(args[cfg.arg.liststyle])
			:cssText(rowstyle)
			:cssText(args[liststyle_and_num])
			:addClass(cfg.class.navbox_list)
			:addClass(cfg.class.navbox_part .. oddEven)
			:addClass(args[cfg.arg.listclass])
			:addClass(args[listclass_and_num])
			:tag('div')
				:css('padding',
					(index == 1 and args[cfg.arg.list1padding]) or args[cfg.arg.listpadding] or '0 0.25em'
				)
				:wikitext(processItem(listText, args[cfg.arg.nowrapitems]))

		if index == 1 and args[cfg.arg.image] then
			row
				:tag('td')
					:addClass(cfg.class.noviewer)
					:addClass(cfg.class.navbox_image)
					:addClass(args[cfg.arg.imageclass])
					:css('width', '1px')               -- Minimize width
					:css('padding', '0 0 0 2px')
					:cssText(args[cfg.arg.imagestyle])
					:attr('rowspan', listnums_size)
					:tag('div')
						:wikitext(processItem(args[cfg.arg.image]))
		end
	end

	local function has_list_class(htmlclass)
		local patterns = {
			'^' .. htmlclass .. '$',
			'%s' .. htmlclass .. '$',
			'^' .. htmlclass .. '%s',
			'%s' .. htmlclass .. '%s'
		}

		for arg, _ in pairs(args) do
			if type(arg) == 'string' and mw.ustring.find(arg, cfg.pattern.class) then
				for _, pattern in ipairs(patterns) do
					if mw.ustring.find(args[arg] or '', pattern) then
						return true
					end
				end
			end
		end
		return false
	end

	-- there are a lot of list classes in the wild, so we add their TemplateStyles
	local function add_list_styles()
		local frame = mw.getCurrentFrame()
		local function add_list_templatestyles(htmlclass, templatestyles)
			if has_list_class(htmlclass) then
				return frame:extensionTag{
					name = 'templatestyles', args = { src = templatestyles }
				}
			else
				return ''
			end
		end

		local hlist_styles = add_list_templatestyles('hlist', cfg.hlist_templatestyles)
		local plainlist_styles = add_list_templatestyles('plainlist', cfg.plainlist_templatestyles)

		-- a second workaround for [[phab:T303378]]
		-- when that issue is fixed, we can actually use has_navbar not to emit the
		-- tag here if we want
		if has_navbar() and hlist_styles == '' then
			hlist_styles = frame:extensionTag{
				name = 'templatestyles', args = { src = cfg.hlist_templatestyles }
			}
		end

		-- hlist -&gt; plainlist is best-effort to preserve old Common.css ordering.
		-- this ordering is not a guarantee because most navboxes will emit only
		-- one of these classes [hlist_note]
		return hlist_styles .. plainlist_styles
	end

	local function needsHorizontalLists(border)
		if border == cfg.keyword.border_subgroup or args[cfg.arg.tracking] == cfg.keyword.tracking_no then
			return false
		end
		return not has_list_class(cfg.pattern.hlist) and not has_list_class(cfg.pattern.plainlist)
	end

	local function hasBackgroundColors()
		for _, key in ipairs({cfg.arg.titlestyle, cfg.arg.groupstyle,
			cfg.arg.basestyle, cfg.arg.abovestyle, cfg.arg.belowstyle}) do
			if tostring(args[key]):find('background', 1, true) then
				return true
			end
		end
		return false
	end

	local function hasBorders()
		for _, key in ipairs({cfg.arg.groupstyle, cfg.arg.basestyle,
			cfg.arg.abovestyle, cfg.arg.belowstyle}) do
			if tostring(args[key]):find('border', 1, true) then
				return true
			end
		end
		return false
	end

	local function isIllegible()
		local styleratio = require('Module:Color contrast')._styleratio
		for key, style in pairs(args) do
			if tostring(key):match(cfg.pattern.style) then
				if styleratio{mw.text.unstripNoWiki(style)} &lt; 4.5 then
					return true
				end
			end
		end
		return false
	end

	local function getTrackingCategories(border)
		local cats = {}
		if needsHorizontalLists(border) then table.insert(cats, cfg.category.horizontal_lists) end
		if hasBackgroundColors() then table.insert(cats, cfg.category.background_colors) end
		if isIllegible() then table.insert(cats, cfg.category.illegible) end
		if hasBorders() then table.insert(cats, cfg.category.borders) end
		return cats
	end

	local function renderTrackingCategories(builder, border)
		local title = mw.title.getCurrentTitle()
		if title.namespace ~= 10 then return end -- not in template space
		local subpage = title.subpageText
		if subpage == cfg.keyword.subpage_doc or subpage == cfg.keyword.subpage_sandbox
			or subpage == cfg.keyword.subpage_testcases then return end

		for _, cat in ipairs(getTrackingCategories(border)) do
			builder:wikitext('[[Category:' .. cat .. ']]')
		end
	end

	local function renderMainTable(border, listnums)
		local tbl = mw.html.create('table')
			:addClass(cfg.class.nowraplinks)
			:addClass(args[cfg.arg.bodyclass])

		local state = args[cfg.arg.state]
		if args[cfg.arg.title] and state ~= cfg.keyword.state_plain and state ~= cfg.keyword.state_off then
			if state == cfg.keyword.state_collapsed then
				state = cfg.class.collapsed
			end
			tbl
				:addClass(cfg.class.collapsible)
				:addClass(state or cfg.class.autocollapse)
		end

		tbl:css('border-spacing', 0)
		if border == cfg.keyword.border_subgroup or border == cfg.keyword.border_none then
			tbl
				:addClass(cfg.class.navbox_subgroup)
				:cssText(args[cfg.arg.bodystyle])
				:cssText(args[cfg.arg.style])
		else  -- regular navbox - bodystyle and style will be applied to the wrapper table
			tbl
				:addClass(cfg.class.navbox_inner)
				:css('background', 'transparent')
				:css('color', 'inherit')
		end
		tbl:cssText(args[cfg.arg.innerstyle])

		renderTitleRow(tbl)
		renderAboveRow(tbl)
		local listnums_size = #listnums
		for i, listnum in ipairs(listnums) do
			renderListRow(tbl, i, listnum, listnums_size)
		end
		renderBelowRow(tbl)

		return tbl
	end

	local function add_navbox_styles(hiding_templatestyles)
		local frame = mw.getCurrentFrame()
		-- This is a lambda so that it doesn't need the frame as a parameter
		local function add_user_styles(templatestyles)
			if not isblank(templatestyles) then
				return frame:extensionTag{
					name = 'templatestyles', args = { src = templatestyles }
				}
			end
			return ''
		end

		-- get templatestyles. load base from config so that Lua only needs to do
		-- the work once of parser tag expansion
		local base_templatestyles = cfg.templatestyles
		local templatestyles = add_user_styles(args[cfg.arg.templatestyles])
		local child_templatestyles = add_user_styles(args[cfg.arg.child_templatestyles])

		-- The 'navbox-styles' div exists to wrap the styles to work around T200206
		-- more elegantly. Instead of combinatorial rules, this ends up being linear
		-- number of CSS rules.
		return mw.html.create('div')
			:addClass(cfg.class.navbox_styles)
			:wikitext(
				add_list_styles() .. -- see [hlist_note] applied to 'before base_templatestyles'
				base_templatestyles ..
				templatestyles ..
				child_templatestyles ..
				table.concat(hiding_templatestyles)
			)
			:done()
	end

	-- work around [[phab:T303378]]
	-- for each arg: find all the templatestyles strip markers, insert them into a
	-- table. then remove all templatestyles markers from the arg
	local strip_marker_pattern = '(\127[^\127]*UNIQ%-%-templatestyles%-%x+%-QINU[^\127]*\127)'
	local argHash = 0
	for k, arg in pairs(args) do
		if type(arg) == 'string' then
			for marker in string.gfind(arg, strip_marker_pattern) do
				table.insert(hiding_templatestyles, marker)
			end
			argHash = argHash + #arg
			args[k] = string.gsub(arg, strip_marker_pattern, '')
		end
	end
	
	if not args.argHash then args.argHash = argHash end

	local listnums = {}

	for k, _ in pairs(args) do
		if type(k) == 'string' then
			local listnum = k:match(cfg.pattern.listnum)
			if listnum and args[andnum('list', tonumber(listnum))] then
				table.insert(listnums, tonumber(listnum))
			end
		end
	end
	table.sort(listnums)

	local border = mw.text.trim(args[cfg.arg.border] or args[1] or '')
	if border == cfg.keyword.border_child then
		border = cfg.keyword.border_subgroup
	end

	-- render the main body of the navbox
	local tbl = renderMainTable(border, listnums)

	local res = mw.html.create()
	-- render the appropriate wrapper for the navbox, based on the border param

	if border == cfg.keyword.border_none then
		res:node(add_navbox_styles(hiding_templatestyles))
		local nav = res:tag('div')
			:attr('role', 'navigation')
			:node(tbl)
		-- aria-labelledby title, otherwise above, otherwise lone group
		if args[cfg.arg.title] or args[cfg.arg.above] or (args[cfg.arg.group1]
			and not args[cfg.arg.group2]) then
			nav:attr(
				'aria-labelledby',
				mw.uri.anchorEncode(
					args[cfg.arg.title] or args[cfg.arg.above] or args[cfg.arg.group1]
				) .. args.argHash
			)
		else
			nav:attr('aria-label', cfg.aria_label)
		end
	elseif border == cfg.keyword.border_subgroup then
		-- We assume that this navbox is being rendered in a list cell of a
		-- parent navbox, and is therefore inside a div with padding:0em 0.25em.
		-- We start with a &lt;/div&gt; to avoid the padding being applied, and at the
		-- end add a &lt;div&gt; to balance out the parent's &lt;/div&gt;
		res
			:wikitext('&lt;/div&gt;')
			:node(tbl)
			:wikitext('&lt;div&gt;')
	else
		res:node(add_navbox_styles(hiding_templatestyles))
		local nav = res:tag('div')
			:attr('role', 'navigation')
			:addClass(cfg.class.navbox)
			:addClass(args[cfg.arg.navboxclass])
			:cssText(args[cfg.arg.bodystyle])
			:cssText(args[cfg.arg.style])
			:css('padding', '3px')
			:node(tbl)
		-- aria-labelledby title, otherwise above, otherwise lone group
		if args[cfg.arg.title] or args[cfg.arg.above]
			or (args[cfg.arg.group1] and not args[cfg.arg.group2]) then
			nav:attr(
				'aria-labelledby',
				mw.uri.anchorEncode(
					args[cfg.arg.title] or args[cfg.arg.above] or args[cfg.arg.group1]
				) .. args.argHash
			)
		else
			nav:attr('aria-label', cfg.aria_label .. args.argHash)
		end
	end

	if (args[cfg.arg.nocat] or cfg.keyword.nocat_false):lower() == cfg.keyword.nocat_false then
		renderTrackingCategories(res, border)
	end
	return striped(tostring(res), border)
end --p._navbox

function p._withCollapsibleGroups(pargs)
	-- table for args passed to navbox
	local targs = {}

	-- process args
	local passthroughLocal = {
		[cfg.arg.bodystyle] = true,
		[cfg.arg.border] = true,
		[cfg.arg.style] = true,
	}
	for k,v in pairs(pargs) do
		if k and type(k) == 'string' then
			if passthrough[k] or passthroughLocal[k] then
				targs[k] = v
			elseif (k:match(cfg.pattern.num)) then
				local n = k:match(cfg.pattern.num)
				local list_and_num = andnum('list', n)
				if ((k:match(cfg.pattern.listnum) or k:match(cfg.pattern.contentnum))
						and targs[list_and_num] == nil
						and pargs[andnum('group', n)] == nil
						and pargs[andnum('sect', n)] == nil
						and pargs[andnum('section', n)] == nil) then
					targs[list_and_num] = concatstrings({
						pargs[list_and_num] or '',
						pargs[andnum('content', n)] or ''
					})
					if (targs[list_and_num] and inArray(cfg.keyword.subgroups, targs[list_and_num])) then
						targs[list_and_num] = getSubgroup(pargs, n, targs[list_and_num])
					end
				elseif ((k:match(cfg.pattern.groupnum) or k:match(cfg.pattern.sectnum) or k:match(cfg.pattern.sectionnum))
						and targs[list_and_num] == nil) then
					local titlestyle = concatstyles({
						pargs[cfg.arg.groupstyle] or '',
						pargs[cfg.arg.secttitlestyle] or '', 
						pargs[andnum('groupstyle', n)] or '', 
						pargs[andnum('sectiontitlestyle', n)] or ''
					})
					local liststyle = concatstyles({
						pargs[cfg.arg.liststyle] or '',
						pargs[cfg.arg.contentstyle] or '', 
						pargs[andnum('liststyle', n)] or '', 
						pargs[andnum('contentstyle', n)] or ''
					})
					local title = concatstrings({
						pargs[andnum('group', n)] or '',
						pargs[andnum('sect', n)] or '',
						pargs[andnum('section', n)] or ''
					})
					local list = concatstrings({
						pargs[list_and_num] or '', 
						pargs[andnum('content', n)] or ''
					})
					if list and inArray(cfg.keyword.subgroups, list) then
						list = getSubgroup(pargs, n, list)
					end
					local abbr_and_num = andnum('abbr', n)
					local state = (pargs[abbr_and_num] and pargs[abbr_and_num] == pargs[cfg.arg.selected]) 
						and cfg.keyword.state_uncollapsed
						or (pargs[andnum('state', n)] or cfg.keyword.state_collapsed)
					
					targs[list_and_num] =p._navbox({
						cfg.keyword.border_child,
						[cfg.arg.navbar] = cfg.keyword.navbar_plain,
						[cfg.arg.state] = state,
						[cfg.arg.basestyle] = pargs[cfg.arg.basestyle],
						[cfg.arg.title] = title,
						[cfg.arg.titlestyle] = titlestyle,
						[andnum('list', 1)] = list,
						[cfg.arg.liststyle] = liststyle,
						[cfg.arg.listclass] = pargs[andnum('listclass', n)],
						[cfg.arg.image] = pargs[andnum('image', n)],
						[cfg.arg.imageleft] = pargs[andnum('imageleft', n)],
						[cfg.arg.listpadding] = pargs[cfg.arg.listpadding],
						argHash = pargs.argHash
					})
				end
			end
		end
	end
	-- ordering of style and bodystyle
	targs[cfg.arg.style] = concatstyles({targs[cfg.arg.style] or '', targs[cfg.arg.bodystyle] or ''})
	targs[cfg.arg.bodystyle] = nil

	-- child or subgroup
	if targs[cfg.arg.border] == nil then targs[cfg.arg.border] = pargs[1] end

	return p._navbox(targs)
end --p._withCollapsibleGroups

function p._withColumns(pargs)
	-- table for args passed to navbox
	local targs = {}

	-- tables of column numbers
	local colheadernums = {}
	local colnums = {}
	local colfooternums = {}

	-- process args
	local passthroughLocal = {
		[cfg.arg.evenstyle]=true,
		[cfg.arg.groupstyle]=true,
		[cfg.arg.liststyle]=true,
		[cfg.arg.oddstyle]=true,
		[cfg.arg.state]=true,
	}
	for k,v in pairs(pargs) do
		if passthrough[k] or passthroughLocal[k] then
			targs[k] = v
		elseif type(k) == 'string' then
			if k:match(cfg.pattern.listnum) then
				local n = k:match(cfg.pattern.listnum)
				targs[andnum('liststyle', n + 2)] = pargs[andnum('liststyle', n)]
				targs[andnum('group', n + 2)] = pargs[andnum('group', n)]
				targs[andnum('groupstyle', n + 2)] = pargs[andnum('groupstyle', n)]
				if v and inArray(cfg.keyword.subgroups, v) then
					targs[andnum('list', n + 2)] = getSubgroup(pargs, n, v)
				else
					targs[andnum('list', n + 2)] = v
				end
			elseif (k:match(cfg.pattern.colheadernum) and v ~= '') then
				table.insert(colheadernums, tonumber(k:match(cfg.pattern.colheadernum)))
			elseif (k:match(cfg.pattern.colnum) and v ~= '') then
				table.insert(colnums, tonumber(k:match(cfg.pattern.colnum)))
			elseif (k:match(cfg.pattern.colfooternum) and v ~= '') then
				table.insert(colfooternums, tonumber(k:match(cfg.pattern.colfooternum)))
			end
		end
	end
	table.sort(colheadernums)
	table.sort(colnums)
	table.sort(colfooternums)

	-- HTML table for list1
	local coltable = mw.html.create( 'table' ):addClass('navbox-columns-table')
	local row, col

	local tablestyle = ( (#colheadernums &gt; 0) or (not isblank(pargs[cfg.arg.fullwidth])) )
		and 'width:100%'
		or 'width:auto; margin-left:auto; margin-right:auto'

	coltable:cssText(concatstyles({
		'border-spacing: 0px; text-align:left',
		tablestyle,
		pargs[cfg.arg.coltablestyle] or ''
	}))

	--- Header row ---
	if (#colheadernums &gt; 0) then
		row = coltable:tag('tr')
		for k, n in ipairs(colheadernums) do
			col = row:tag('td'):addClass('navbox-abovebelow')
			col:cssText(concatstyles({
				(k &gt; 1) and 'border-left:2px solid #fdfdfd' or '',
				'font-weight:bold',
				pargs[cfg.arg.colheaderstyle] or '',
				pargs[andnum('colheaderstyle', n)] or ''
			}))
			col:attr('colspan', tonumber(pargs[andnum('colheadercolspan', n)]))
			col:wikitext(pargs[andnum('colheader', n)])
		end
	end

	--- Main columns ---
	row = coltable:tag('tr'):css('vertical-align', 'top')
	for k, n in ipairs(colnums) do
		if k == 1 and isblank(pargs[andnum('colheader', 1)])
				and isblank(pargs[andnum('colfooter', 1)])
				and isblank(pargs[cfg.arg.fullwidth]) then
			local nopad = inArray(
				{'off', '0', '0em', '0px'},
				mw.ustring.gsub(pargs[cfg.arg.padding] or '', '[;%%]', ''))
			if not nopad then
				row:tag('td'):wikitext('&amp;nbsp;&amp;nbsp;&amp;nbsp;')
					:css('width', (pargs[cfg.arg.padding] or '5em'))
			end
		end
		col = row:tag('td'):addClass('navbox-list')
		col:cssText(concatstyles({
			(k &gt; 1) and 'border-left:2px solid #fdfdfd' or '',
			'padding:0px',
			pargs[cfg.arg.colstyle] or '',
			((n%2 == 0) and pargs[cfg.arg.evencolstyle] or pargs[cfg.arg.oddcolstyle]) or '',
			pargs[andnum('colstyle', n)] or '',
			'width:' .. (pargs[andnum('colwidth', n)] or pargs[cfg.arg.colwidth] or '10em')
		}))
		local wt = pargs[andnum('col', n)]
		if wt and inArray(cfg.keyword.subgroups, wt) then
			wt = getSubgroup(pargs, n, wt, cfg.arg.col_and_num)
		end
		col:tag('div'):newline():wikitext(wt):newline()
	end

	--- Footer row ---
	if (#colfooternums &gt; 0) then
		row = coltable:tag('tr')
		for k, n in ipairs(colfooternums) do
			col = row:tag('td'):addClass('navbox-abovebelow')
			col:cssText(concatstyles({
				(k &gt; 1) and 'border-left:2px solid #fdfdfd' or '',
				'font-weight:bold',
				pargs[cfg.arg.colfooterstyle] or '',
				pargs[andnum('colfooterstyle', n)] or ''
			}))
			col:attr('colspan', tonumber(pargs[andnum('colfootercolspan', n)]))
			col:wikitext(pargs[andnum('colfooter', n)])
		end
	end

	-- assign table to list1
	targs[andnum('list', 1)] = tostring(coltable)
	if isblank(pargs[andnum('colheader', 1)]) 
			and isblank(pargs[andnum('col', 1)])
			and isblank(pargs[andnum('colfooter', 1)]) then
		targs[andnum('list', 1)] = targs[andnum('list', 1)] ..
			cfg.category.without_first_col
	end

	-- Other parameters
	targs[cfg.arg.border] = pargs[cfg.arg.border] or pargs[1]
	targs[cfg.arg.evenodd] = (not isblank(pargs[cfg.arg.evenodd])) and pargs[cfg.arg.evenodd] or nil
	targs[cfg.arg.list1padding] = '0px'
	targs[andnum('liststyle', 1)] = 'background:transparent;color:inherit;'
	targs[cfg.arg.style] = concatstyles({pargs[cfg.arg.style], pargs[cfg.arg.bodystyle]})
	targs[cfg.arg.tracking] = 'no'
	
	return p._navbox(targs)
end --p._withColumns

-- Template entry points
function p.navbox (frame, boxtype)
	local function readArgs(args, prefix)
		-- Read the arguments in the order they'll be output in, to make references
		-- number in the right order.
		local _ = 0
		_ = _ + (args[prefix .. cfg.arg.title] and #args[prefix .. cfg.arg.title] or 0)
		_ = _ + (args[prefix .. cfg.arg.above] and #args[prefix .. cfg.arg.above] or 0)
		-- Limit this to 20 as covering 'most' cases (that's a SWAG) and because
		-- iterator approach won't work here
		for i = 1, 20 do
			_ = _ + (args[prefix .. andnum('group', i)] and #args[prefix .. andnum('group', i)] or 0)
			if inArray(cfg.keyword.subgroups, args[prefix .. andnum('list', i)]) then
				for _, v in ipairs(cfg.arg.subgroups_and_num) do
					readArgs(args, prefix .. string.format(v, i) .. "_")
				end
				readArgs(args, prefix .. andnum('col', i) .. "_")
			end
		end
		_ = _ + (args[prefix .. cfg.arg.below] and #args[prefix .. cfg.arg.below] or 0)
		return _
	end

	if not getArgs then
		getArgs = require('Module:Arguments').getArgs
	end
	local args = getArgs(frame, {wrappers = {cfg.pattern[boxtype or 'navbox']}})
	args.argHash = readArgs(args, "")
	args.type = args.type or cfg.keyword[boxtype]
	return p['_navbox'](args)
end

p[cfg.keyword.with_collapsible_groups] = function (frame)
	return p.navbox(frame, 'with_collapsible_groups')
end

p[cfg.keyword.with_columns] = function (frame)
	return p.navbox(frame, 'with_columns')
end

return p</text>
      <sha1>9nuyd1y0flay2cj559n7z0gkbzwwin6</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbox/configuration</title>
    <ns>828</ns>
    <id>163</id>
    <revision>
      <id>314</id>
      <parentid>313</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>313</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5454" sha1="0k99w2evbl4a1tw2cv5rius1j58gss6" xml:space="preserve">return {
	aria_label = 'Navbox',
	nowrap_item = '%s&lt;span class="nowrap"&gt;%s&lt;/span&gt;',
	templatestyles = mw.getCurrentFrame():extensionTag{
		name = 'templatestyles', args = { src = 'Module:Navbox/styles.css' }
	},
	hlist_templatestyles = 'Hlist/styles.css',
	plainlist_templatestyles = 'Plainlist/styles.css',
	-- do not localize marker table
	marker = {
		oddeven = '\127_ODDEVEN_\127',
		restart = '\127_ODDEVEN0_\127',
		regex = '\127_ODDEVEN(%d?)_\127'
	},
	category = {
		orphan = '[[Category:Navbox orphans]]',
		horizontal_lists = 'Navigational boxes without horizontal lists',
		background_colors = 'Navboxes using background colours',
		illegible = 'Potentially illegible navboxes',
		borders = 'Navboxes using borders',
		without_first_col = '[[Category:Pages using navbox columns without the first column]]'
	},
	keyword = {
		border_subgroup = 'subgroup',
		border_child = 'child',
		border_none = 'none',
		evenodd_swap = 'swap',
		navbar_off = 'off',
		navbar_plain = 'plain',
		nocat_false = 'false',
		nowrapitems_yes = 'yes',
		orphan_yes = 'yes',
		state_collapsed = 'collapsed',
		state_off = 'off',
		state_plain = 'plain',
		state_uncollapsed = 'uncollapsed',
		subgroups = {'subgroup', 'child', ''},
		subpage_doc = 'doc',
		subpage_sandbox = 'sandbox',
		subpage_testcases = 'testcases',
		tracking_no = 'no',
		with_collapsible_groups = 'with collapsible groups',
		with_columns = 'with columns',
	},
	class = {
		autocollapse = 'autocollapse',
		collapsible = 'mw-collapsible',
		collapsed = 'mw-collapsed',
		-- Warning
		navbox = 'navbox', -- WMF currently hides 'navbox' from mobile,
		-- so you probably shouldn't change the navbox class.
		navbox_abovebelow = 'navbox-abovebelow',
		navbox_group = 'navbox-group',
		navbox_image = 'navbox-image',
		navbox_inner = 'navbox-inner',
		navbox_list = 'navbox-list',
		navbox_list_with_group = 'navbox-list-with-group',
		navbox_part = 'navbox-', -- do not l10n
		navbox_styles = 'navbox-styles',
		navbox_subgroup = 'navbox-subgroup',
		navbox_title = 'navbox-title', -- l10n only if you change pattern.navbox_title below
		navbox_odd_part = 'odd', -- do not l10n
		navbox_even_part = 'even', -- do not l10n
		nomobile = 'nomobile',
		nowraplinks = 'nowraplinks',
		noviewer = 'noviewer', -- used to remove images from MediaViewer
		notheme = 'notheme'
	},
	pattern = {
		class = 'class',
		colnum = '^col(%d+)$',
		colheadernum = '^col(%d+)header$',
		colfooternum = '^col(%d+)footer$',
		contentnum = '^content(%d+)$',
		groupnum = '^group(%d+)$',
		hlist = 'hlist',
		listnum = '^list(%d+)$',
		navbox = 'Template:Navbox',
		navbox_title = '&lt;th[^&gt;]*"navbox%-title"',
		nowrap = '^&lt;span class="nowrap"&gt;',
		num = '^%a+(%d+)$',
		plainlist = 'plainlist',
		sandbox = '/sandbox$',
		sectionnum = '^section(%d+)$',
		sectnum = '^sect(%d+)$',
		style = 'style$',
		with_collapsible_groups = 'Template:Navbox with collapsible groups',
		with_columns = 'Template:Navbox with columns',
	},
	arg = {
		abbr_and_num = 'abbr%d',
		above = 'above',
		aboveclass = 'aboveclass',
		abovestyle = 'abovestyle',
		basestyle = 'basestyle',
		below = 'below',
		belowclass = 'belowclass',
		belowstyle = 'belowstyle',
		bodyclass = 'bodyclass',
		bodystyle = 'bodystyle',
		border = 'border',
		content_and_num = 'content%d',
		contentstyle = 'contentstyle',
		contentstyle_and_num = 'content%dstyle',
		colheaderstyle = 'colheaderstyle',
		colheader_and_num = 'col%dheader',
		colheaderstyle_and_num = 'col%dheaderstyle',
		colheadercolspan_and_num = 'col%dheadercolspan',
		colstyle = 'colstyle',
		col_and_num = 'col%d',
		colstyle_and_num = 'col%dstyle',
		colwidth = 'colwidth',
		colwidth_and_num = 'col%dwidth',
		colfooterstyle = 'colfooterstyle',
		colfooter_and_num = 'col%dfooter',
		colfooterstyle_and_num = 'col%dfooterstyle',
		colfootercolspan_and_num = 'col%dfootercolspan',
		coltablestyle = 'coltablestyle',
		evencolstyle = 'evencolstyle',
		evenodd = 'evenodd',
		evenstyle = 'evenstyle',
		fullwidth = 'fullwidth',
		group1 = 'group1',
		group2 = 'group2',
		group_and_num = 'group%d',
		groupclass = 'groupclass',
		groupstyle = 'groupstyle',
		groupstyle_and_num = 'group%dstyle',
		groupwidth = 'groupwidth',
		image = 'image',
		image_and_num = 'image%d',
		imageclass = 'imageclass',
		imageleft = 'imageleft',
		imageleft_and_num = 'imageleft%d',
		imageleftstyle = 'imageleftstyle',
		imagestyle = 'imagestyle',
		innerstyle = 'innerstyle',
		list1padding = 'list1padding',
		list_and_num = 'list%d',
		listclass = 'listclass',
		listclass_and_num = 'list%dclass',
		listpadding = 'listpadding',
		liststyle = 'liststyle',
		liststyle_and_num = 'list%dstyle',
		name = 'name',
		navbar = 'navbar',
		navboxclass = 'navboxclass',
		nocat = 'nocat',
		nowrapitems = 'nowrapitems',
		oddcolstyle = 'oddcolstyle',
		oddstyle = 'oddstyle',
		orphan = 'orphan',
		padding = 'padding',
		sect_and_num = 'sect%d',
		section_and_num = 'section%d',
		sectiontitlestyle_and_num = 'section%dtitlestyle',
		secttitlestyle = 'secttitlestyle',
		selected = 'selected',
		state = 'state',
		state_and_num = 'state%d',
		style = 'style',
		subgroups_and_num = {'subgroup%d', 'child%d', '%d'},
		templatestyles = 'templatestyles',
		child_templatestyles = 'child templatestyles',
		title = 'title',
		titleclass = 'titleclass',
		titlestyle = 'titlestyle',
		tracking = 'tracking',
	},
	-- names of navbar arguments
	navbar = {
		name = 1,
		fontstyle = 'fontstyle',
		mini = 'mini'
	}
}</text>
      <sha1>0k99w2evbl4a1tw2cv5rius1j58gss6</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbox/styles.css</title>
    <ns>828</ns>
    <id>164</id>
    <revision>
      <id>316</id>
      <parentid>315</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>315</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="2342" sha1="fg3ep7u2ikj39r86m5x2aj17kpqgies" xml:space="preserve">/* {{pp|small=y}} */
.navbox {
	box-sizing: border-box;
	border: 1px solid #a2a9b1;
	width: 100%;
	clear: both;
	font-size: 88%;
	text-align: center;
	padding: 1px;
	margin: 1em auto 0; /* Prevent preceding content from clinging to navboxes */
}

.navbox .navbox {
	margin-top: 0; /* No top margin for nested navboxes */
}

.navbox + .navbox, /* TODO: remove first line after transclusions have updated */
.navbox + .navbox-styles + .navbox {
	margin-top: -1px; /* Single pixel border between adjacent navboxes */
}

.navbox-inner,
.navbox-subgroup {
	width: 100%;
}

.navbox-group,
.navbox-title,
.navbox-abovebelow {
	padding: 0.25em 1em;
	line-height: 1.5em;
	text-align: center;
}

.navbox-group {
	white-space: nowrap;
	/* @noflip */
	text-align: right;
}

.navbox,
.navbox-subgroup {
	background-color: #fdfdfd;
}

.navbox-list {
	line-height: 1.5em;
	border-color: #fdfdfd; /* Must match background color */
}

.navbox-list-with-group {
	text-align: left;
	border-left-width: 2px;
	border-left-style: solid;
}

/* cell spacing for navbox cells */
/* Borders above 2nd, 3rd, etc. rows */
/* TODO: figure out how to replace tr as structure;
 * with div structure it should be just a matter of first-child */
tr + tr &gt; .navbox-abovebelow,
tr + tr &gt; .navbox-group,
tr + tr &gt; .navbox-image,
tr + tr &gt; .navbox-list {
	border-top: 2px solid #fdfdfd; /* Must match background color */
}

.navbox-title {
	background-color: #ccf; /* Level 1 color */
}

.navbox-abovebelow,
.navbox-group,
.navbox-subgroup .navbox-title {
	background-color: #ddf; /* Level 2 color */
}

.navbox-subgroup .navbox-group,
.navbox-subgroup .navbox-abovebelow {
	background-color: #e6e6ff; /* Level 3 color */
}

.navbox-even {
	background-color: #f7f7f7;
}

.navbox-odd {
	background-color: transparent;
}

/* TODO: figure out how to remove reliance on td as structure */
.navbox .hlist td dl,
.navbox .hlist td ol,
.navbox .hlist td ul,
.navbox td.hlist dl,
.navbox td.hlist ol,
.navbox td.hlist ul {
	padding: 0.125em 0;
}

.navbox .navbar {
	display: block;
	font-size: 100%;
}

.navbox-title .navbar {
	/* @noflip */
	float: left;
	/* @noflip */
	text-align: left;
	/* @noflip */
	margin-right: 0.5em;
}

/** T367463 */
body.skin--responsive .navbox-image img {
	max-width: none !important;
}

@media print {
	body.ns-0 .navbox {
		display: none !important;
	}
}</text>
      <sha1>fg3ep7u2ikj39r86m5x2aj17kpqgies</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal bar</title>
    <ns>828</ns>
    <id>165</id>
    <revision>
      <id>318</id>
      <parentid>317</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>317</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2829" sha1="c7p57p1u4f7i16ztm0ndswnq2g77epa" xml:space="preserve">-- This module implements {{portal bar}}.

require('strict')

-- determine whether we're being called from a sandbox
local isSandbox = mw.getCurrentFrame():getTitle():find('sandbox', 1, true)
local sandbox = isSandbox and '/sandbox' or ''

local portalModule = require('Module:Portal'..sandbox)
local getImageName = portalModule._image
local checkPortals = portalModule._checkPortals
local processPortalArgs = portalModule._processPortalArgs
local yesno = require( 'Module:Yesno' )
local getArgs = require('Module:Arguments').getArgs
local p = {}

local function sandboxVersion(s)
	return isSandbox and s.."-sand" or s
end

-- Builds the portal bar used by {{portal bar}}.
function p._main( portals, args )
	
	-- check for sensible args
	args = type(args) == "table" and args or {}
	
	-- Normalize arguments
	for key, default in pairs({border=true,redlinks=false,tracking=true}) do
		if args[key] == nil then args[key] = default end
		args[key] = yesno(args[key], default)
	end

	local nav = mw.html.create( 'div' )
		:addClass(sandboxVersion('portal-bar'))
		:addClass( 'noprint metadata noviewer' )
		:attr( 'role', 'navigation' )
		:attr( 'aria-label' , 'Portals' )
		:addClass(sandboxVersion(args.border and 'portal-bar-bordered' or 'portal-bar-unbordered'))
	
	local trackingCat = ''
	-- Allow any number of portals
	args.minPortals = 0
	args.maxPortals = -1
	-- Check to see whether there are redlinks, filter out unless args.redlink is true
	portals, trackingCat = checkPortals(portals, args)
	nav:wikitext(trackingCat)
	if #portals == 0 then
		return trackingCat
	end

	local related = yesno(args.related)
	if related then
		nav:addClass(sandboxVersion('portal-bar-related'))
	else
		local header = nav:tag('span')
		header:addClass(sandboxVersion('portal-bar-header'))
		header:wikitext('[[Wikipedia:Contents/Portals|Portal]]')
		if #portals &gt; 1 then
			header:wikitext('s')
		end
		header:wikitext(':')
	end
	local container = nav:tag('ul')
	container:addClass(sandboxVersion('portal-bar-content'))
	if related then
		container:addClass(sandboxVersion('portal-bar-content-related'))
	end
	local size = related and '28x24px' or '21x19px'
	for _, portal in ipairs( portals ) do
		container
			:tag( 'li' )
			:addClass(sandboxVersion('portal-bar-item'))
			:wikitext( string.format('&lt;span class="nowrap"&gt;[[File:%s|%s]] &lt;/span&gt;[[Portal:%s|%s]]',
					getImageName(portal,true), size, portal, portal))
	end
	
	local styleFile = 'Module:Portal bar'..sandbox..'/styles.css'
	return mw.getCurrentFrame():extensionTag{
		name = 'templatestyles', args = { src = styleFile }
	} .. tostring( nav ) 
end

-- Processes external arguments and sends them to the other functions.
function p.main( frame )
	local origArgs = getArgs(frame)
	local portals, args = processPortalArgs(origArgs)
	return p._main( portals, args )
end

return p</text>
      <sha1>c7p57p1u4f7i16ztm0ndswnq2g77epa</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal bar/styles.css</title>
    <ns>828</ns>
    <id>166</id>
    <revision>
      <id>320</id>
      <parentid>319</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>319</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1774" sha1="s0fon05lkva209oa075g32i87uhnl6l" xml:space="preserve">/* {{pp|small=y}} */
.portal-bar {
	font-size: 88%;
	font-weight: bold;
	display:flex;
	justify-content: center;
	align-items: baseline;
}

.portal-bar-bordered {
	padding: 0 2em;
	background-color: #fdfdfd;
	border: 1px solid #a2a9b1;
	clear: both;
	margin: 1em auto 0;
}

.portal-bar-related {
	font-size: 100%;
	justify-content: flex-start;
}

.portal-bar-unbordered {
	padding: 0 1.7em;
	margin-left: 0;
}

.portal-bar-header {
    margin: 0 1em 0 0.5em;
    flex: 0 0 auto;
    min-height: 24px;
}

.portal-bar-content {
	display:flex;
	flex-flow: row wrap;
	flex:0 1 auto;
	padding: 0.15em 0;
	column-gap: 1em;
	align-items: baseline;
	margin: 0;
	list-style: none;
}

.portal-bar-content-related {
	margin: 0;
	list-style: none;
}

.portal-bar-item {
	display:inline-block;
	margin:0.15em 0.2em;
	min-height:24px;
	line-height:24px;
}

@media screen and (max-width:768px) {
	.portal-bar {
		font-size: 88%;
		font-weight: bold;
		display:flex;
		flex-flow: column wrap;
		align-items: baseline;
	}
	
	.portal-bar-header {
		text-align: center;
		flex:0;
		padding-left: 0.5em;
		margin: 0 auto;
	}
	
	.portal-bar-related {
		font-size: 100%;
		align-items: flex-start;
	}

	.portal-bar-content {
		display:flex;
		flex-flow: row wrap;
		align-items: center;
		flex:0;
		column-gap: 1em;
		border-top: 1px solid #a2a9b1;
		margin: 0 auto;
		list-style: none;
	}
	
	.portal-bar-content-related {
		border-top: none;
		margin: 0;
		list-style: none;
	}
}

.navbox + link + .portal-bar,
.navbox + style + .portal-bar,
.navbox + link + .portal-bar-bordered,
.navbox + style + .portal-bar-bordered,
.sister-bar + link + .portal-bar,
.sister-bar + style + .portal-bar,
.portal-bar + .navbox-styles + .navbox,
.portal-bar + .navbox-styles + .sister-bar {
	margin-top: -1px;
}</text>
      <sha1>s0fon05lkva209oa075g32i87uhnl6l</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Side box</title>
    <ns>828</ns>
    <id>167</id>
    <revision>
      <id>322</id>
      <parentid>321</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>321</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3691" sha1="13mb9x4khy3x9kci53p03u6xw7fwg3p" xml:space="preserve">local yesno = require('Module:Yesno')
local p = {}

local function makeData(args)
	local data = {}

	-- Main table classes
	data.classes = {}
	if yesno(args.metadata) ~= false then
		table.insert(data.classes, 'metadata')
	end
	if args.position and args.position:lower() == 'left' then
		table.insert(data.classes, 'side-box-left')
	else
		table.insert(data.classes, 'side-box-right')
	end
	
	if args.collapsible then
		table.insert(data.classes, 'mw-collapsible')
		if args.collapsible == "collapsed" then
			table.insert(data.classes, 'mw-collapsed')
		end
		data.collapsible = true
	end

	table.insert(data.classes, args.class)
	
	-- Image
	if args.image and args.image ~= 'none' then
		data.image = args.image
	end
	
	-- we have to check to see if a downstream use has plainlist like
	-- Template:Sister_project. also it's the default. wikitext is :(
	if args.textclass == 'plainlist' or not args.textclass then
		data.textclass = 'plainlist'
		data.plainlist_templatestyles = 'Plainlist/styles.css'
	else
		data.textclass = args.textclass
	end

	-- Copy over data that does not need adjusting
	local argsToCopy = {
		-- aria qualities
		'role',
		'labelledby',

		-- Styles
		'style',
		'textstyle',
		'templatestyles',

		-- Above row
		'above',
		'abovestyle',

		-- Body row
		'text',
		'imageright',

		-- Below row
		'below',
	}
	for i, key in ipairs(argsToCopy) do
		data[key] = args[key]
	end

	return data
end

local function renderSidebox(data)
	-- Renders the sidebox HTML.

	-- Table root
	local root = mw.html.create('div')
	root:attr('role', data.role)
		:attr('aria-labelledby', data.labelledby)
		:addClass('side-box')
	for i, class in ipairs(data.classes or {}) do
		root:addClass(class)
	end
	if data.style then
		root:cssText(data.style)
	end
	
	local frame = mw.getCurrentFrame()
	if data.plainlist_templatestyles then
		root:wikitext(frame:extensionTag{
			name = 'templatestyles', args = { src = data.plainlist_templatestyles }
		})
	end

	-- The "above" row
	if data.above then
		local above = root:newline():tag('div')
		above:addClass('side-box-abovebelow')
			:newline()
			:wikitext(data.above)
		if data.textstyle then
			above:cssText(data.textstyle)
		end
		if data.abovestyle then
			above:cssText(data.abovestyle)
		end
	end

	-- The body row
	local body = root:newline():tag('div')
		body:addClass('side-box-flex')
			:addClass(data.collapsible and 'mw-collapsible-content')
			:newline()
	if data.image then
		body:tag('div')
			:addClass('side-box-image')
			:wikitext(data.image)
	end
	local text = body:newline():tag('div')
	text:addClass('side-box-text')
		:addClass(data.textclass)
	if data.textstyle then
		text:cssText(data.textstyle)
	end
	text:wikitext(data.text)
	if data.imageright then
		body:newline():tag('div')
			:addClass('side-box-imageright')
			:wikitext(data.imageright)
	end

	-- The below row
	if data.below then
		local below = root:newline():tag('div')
		below
			:addClass('side-box-abovebelow')
			:wikitext(data.below)
		if data.textstyle then
			below:cssText(data.textstyle)
		end
	end

	root:newline()
	local templatestyles = ''
	if data.templatestyles then
		templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = data.templatestyles }
		}
	end
	return frame:extensionTag{
		name = 'templatestyles', args = { src = 'Module:Side box/styles.css' }
	} .. templatestyles .. tostring(root)
end

function p._main(args)
	local data = makeData(args)
	return renderSidebox(data)
end

function p.main(frame)
	local origArgs = frame:getParent().args
	local args = {}
	for k, v in pairs(origArgs) do
		v = v:match('%s*(.-)%s*$')
		if v ~= '' then
			args[k] = v
		end
	end
	return p._main(args)
end

return p</text>
      <sha1>13mb9x4khy3x9kci53p03u6xw7fwg3p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Unicode data/scripts</title>
    <ns>828</ns>
    <id>168</id>
    <revision>
      <id>324</id>
      <parentid>323</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>323</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="34558" sha1="85z627whc28kcj8na9y8648zqt8tlmy" xml:space="preserve">--[=[
-- Official Unicode script values for individual codepoints and ranges of
-- codepoints.

-- https://www.unicode.org/Public/UNIDATA/Scripts.txt provided
-- the script names, and https://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt
-- provided script codes corresponding to the names (see [[Script (Unicode)]]).
--]=]

local data = {
	singles = {
		[0x000AA] = "Latn",
		[0x000BA] = "Latn",
		[0x000D7] = "Zyyy",
		[0x000F7] = "Zyyy",
		[0x00374] = "Zyyy",
		[0x0037E] = "Zyyy",
		[0x0037F] = "Grek",
		[0x00384] = "Grek",
		[0x00385] = "Zyyy",
		[0x00386] = "Grek",
		[0x00387] = "Zyyy",
		[0x0038C] = "Grek",
		[0x00605] = "Zyyy",
		[0x0060C] = "Zyyy",
		[0x0061B] = "Zyyy",
		[0x0061F] = "Zyyy",
		[0x00640] = "Zyyy",
		[0x00670] = "Zinh",
		[0x006DD] = "Zyyy",
		[0x0085E] = "Mand",
		[0x008E2] = "Zyyy",
		[0x009B2] = "Beng",
		[0x009D7] = "Beng",
		[0x00A3C] = "Guru",
		[0x00A51] = "Guru",
		[0x00A5E] = "Guru",
		[0x00AD0] = "Gujr",
		[0x00B9C] = "Taml",
		[0x00BD0] = "Taml",
		[0x00BD7] = "Taml",
		[0x00C5D] = "Telu",
		[0x00DBD] = "Sinh",
		[0x00DCA] = "Sinh",
		[0x00DD6] = "Sinh",
		[0x00E3F] = "Zyyy",
		[0x00E84] = "Laoo",
		[0x00EA5] = "Laoo",
		[0x00EC6] = "Laoo",
		[0x010C7] = "Geor",
		[0x010CD] = "Geor",
		[0x010FB] = "Zyyy",
		[0x01258] = "Ethi",
		[0x012C0] = "Ethi",
		[0x0171F] = "Tglg",
		[0x01804] = "Mong",
		[0x01805] = "Zyyy",
		[0x01940] = "Limb",
		[0x01CD3] = "Zyyy",
		[0x01CE1] = "Zyyy",
		[0x01CED] = "Zinh",
		[0x01CF4] = "Zinh",
		[0x01CFA] = "Zyyy",
		[0x01D2B] = "Cyrl",
		[0x01D78] = "Cyrl",
		[0x01DBF] = "Grek",
		[0x01F59] = "Grek",
		[0x01F5B] = "Grek",
		[0x01F5D] = "Grek",
		[0x02071] = "Latn",
		[0x0207F] = "Latn",
		[0x02126] = "Grek",
		[0x02132] = "Latn",
		[0x0214E] = "Latn",
		[0x02D27] = "Geor",
		[0x02D2D] = "Geor",
		[0x02D7F] = "Tfng",
		[0x03005] = "Hani",
		[0x03006] = "Zyyy",
		[0x03007] = "Hani",
		[0x030A0] = "Zyyy",
		[0x031EF] = "Zyyy",
		[0x032FF] = "Zyyy",
		[0x0A7D3] = "Latn",
		[0x0A92E] = "Zyyy",
		[0x0A92F] = "Kali",
		[0x0A95F] = "Rjng",
		[0x0A9CF] = "Zyyy",
		[0x0AB5B] = "Zyyy",
		[0x0AB65] = "Grek",
		[0x0FB3E] = "Hebr",
		[0x0FDCF] = "Arab",
		[0x0FEFF] = "Zyyy",
		[0x0FF70] = "Zyyy",
		[0x101A0] = "Grek",
		[0x101FD] = "Zinh",
		[0x102E0] = "Zinh",
		[0x1039F] = "Ugar",
		[0x1056F] = "Aghb",
		[0x10808] = "Cprt",
		[0x1083C] = "Cprt",
		[0x1083F] = "Cprt",
		[0x1091F] = "Phnx",
		[0x1093F] = "Lydi",
		[0x1107F] = "Brah",
		[0x110CD] = "Kthi",
		[0x11288] = "Mult",
		[0x1133B] = "Zinh",
		[0x11350] = "Gran",
		[0x11357] = "Gran",
		[0x1138B] = "Tutg",
		[0x1138E] = "Tutg",
		[0x113C2] = "Tutg",
		[0x113C5] = "Tutg",
		[0x118FF] = "Wara",
		[0x11909] = "Diak",
		[0x11D3A] = "Gonm",
		[0x11FB0] = "Lisu",
		[0x11FFF] = "Taml",
		[0x16FE0] = "Tang",
		[0x16FE1] = "Nshu",
		[0x16FE4] = "Kits",
		[0x18CFF] = "Kits",
		[0x1B000] = "Kana",
		[0x1B132] = "Hira",
		[0x1B155] = "Kana",
		[0x1D4A2] = "Zyyy",
		[0x1D4BB] = "Zyyy",
		[0x1D546] = "Zyyy",
		[0x1E08F] = "Cyrl",
		[0x1E2FF] = "Wcho",
		[0x1E5FF] = "Onao",
		[0x1EE24] = "Arab",
		[0x1EE27] = "Arab",
		[0x1EE39] = "Arab",
		[0x1EE3B] = "Arab",
		[0x1EE42] = "Arab",
		[0x1EE47] = "Arab",
		[0x1EE49] = "Arab",
		[0x1EE4B] = "Arab",
		[0x1EE54] = "Arab",
		[0x1EE57] = "Arab",
		[0x1EE59] = "Arab",
		[0x1EE5B] = "Arab",
		[0x1EE5D] = "Arab",
		[0x1EE5F] = "Arab",
		[0x1EE64] = "Arab",
		[0x1EE7E] = "Arab",
		[0x1F200] = "Hira",
		[0x1F7F0] = "Zyyy",
		[0xE0001] = "Zyyy",
	},
	
	ranges = {
		{ 0x00000, 0x00040, "Zyyy" },
		{ 0x00041, 0x0005A, "Latn" },
		{ 0x0005B, 0x00060, "Zyyy" },
		{ 0x00061, 0x0007A, "Latn" },
		{ 0x0007B, 0x000A9, "Zyyy" },
		{ 0x000AB, 0x000B9, "Zyyy" },
		{ 0x000BB, 0x000BF, "Zyyy" },
		{ 0x000C0, 0x000D6, "Latn" },
		{ 0x000D8, 0x000F6, "Latn" },
		{ 0x000F8, 0x002B8, "Latn" },
		{ 0x002B9, 0x002DF, "Zyyy" },
		{ 0x002E0, 0x002E4, "Latn" },
		{ 0x002E5, 0x002E9, "Zyyy" },
		{ 0x002EA, 0x002EB, "Bopo" },
		{ 0x002EC, 0x002FF, "Zyyy" },
		{ 0x00300, 0x0036F, "Zinh" },
		{ 0x00370, 0x00373, "Grek" },
		{ 0x00375, 0x00377, "Grek" },
		{ 0x0037A, 0x0037D, "Grek" },
		{ 0x00388, 0x0038A, "Grek" },
		{ 0x0038E, 0x003A1, "Grek" },
		{ 0x003A3, 0x003E1, "Grek" },
		{ 0x003E2, 0x003EF, "Copt" },
		{ 0x003F0, 0x003FF, "Grek" },
		{ 0x00400, 0x00484, "Cyrl" },
		{ 0x00485, 0x00486, "Zinh" },
		{ 0x00487, 0x0052F, "Cyrl" },
		{ 0x00531, 0x00556, "Armn" },
		{ 0x00559, 0x0058A, "Armn" },
		{ 0x0058D, 0x0058F, "Armn" },
		{ 0x00591, 0x005C7, "Hebr" },
		{ 0x005D0, 0x005EA, "Hebr" },
		{ 0x005EF, 0x005F4, "Hebr" },
		{ 0x00600, 0x00604, "Arab" },
		{ 0x00606, 0x0060B, "Arab" },
		{ 0x0060D, 0x0061A, "Arab" },
		{ 0x0061C, 0x0061E, "Arab" },
		{ 0x00620, 0x0063F, "Arab" },
		{ 0x00641, 0x0064A, "Arab" },
		{ 0x0064B, 0x00655, "Zinh" },
		{ 0x00656, 0x0066F, "Arab" },
		{ 0x00671, 0x006DC, "Arab" },
		{ 0x006DE, 0x006FF, "Arab" },
		{ 0x00700, 0x0070D, "Syrc" },
		{ 0x0070F, 0x0074A, "Syrc" },
		{ 0x0074D, 0x0074F, "Syrc" },
		{ 0x00750, 0x0077F, "Arab" },
		{ 0x00780, 0x007B1, "Thaa" },
		{ 0x007C0, 0x007FA, "Nkoo" },
		{ 0x007FD, 0x007FF, "Nkoo" },
		{ 0x00800, 0x0082D, "Samr" },
		{ 0x00830, 0x0083E, "Samr" },
		{ 0x00840, 0x0085B, "Mand" },
		{ 0x00860, 0x0086A, "Syrc" },
		{ 0x00870, 0x0088E, "Arab" },
		{ 0x00890, 0x00891, "Arab" },
		{ 0x00897, 0x008E1, "Arab" },
		{ 0x008E3, 0x008FF, "Arab" },
		{ 0x00900, 0x00950, "Deva" },
		{ 0x00951, 0x00954, "Zinh" },
		{ 0x00955, 0x00963, "Deva" },
		{ 0x00964, 0x00965, "Zyyy" },
		{ 0x00966, 0x0097F, "Deva" },
		{ 0x00980, 0x00983, "Beng" },
		{ 0x00985, 0x0098C, "Beng" },
		{ 0x0098F, 0x00990, "Beng" },
		{ 0x00993, 0x009A8, "Beng" },
		{ 0x009AA, 0x009B0, "Beng" },
		{ 0x009B6, 0x009B9, "Beng" },
		{ 0x009BC, 0x009C4, "Beng" },
		{ 0x009C7, 0x009C8, "Beng" },
		{ 0x009CB, 0x009CE, "Beng" },
		{ 0x009DC, 0x009DD, "Beng" },
		{ 0x009DF, 0x009E3, "Beng" },
		{ 0x009E6, 0x009FE, "Beng" },
		{ 0x00A01, 0x00A03, "Guru" },
		{ 0x00A05, 0x00A0A, "Guru" },
		{ 0x00A0F, 0x00A10, "Guru" },
		{ 0x00A13, 0x00A28, "Guru" },
		{ 0x00A2A, 0x00A30, "Guru" },
		{ 0x00A32, 0x00A33, "Guru" },
		{ 0x00A35, 0x00A36, "Guru" },
		{ 0x00A38, 0x00A39, "Guru" },
		{ 0x00A3E, 0x00A42, "Guru" },
		{ 0x00A47, 0x00A48, "Guru" },
		{ 0x00A4B, 0x00A4D, "Guru" },
		{ 0x00A59, 0x00A5C, "Guru" },
		{ 0x00A66, 0x00A76, "Guru" },
		{ 0x00A81, 0x00A83, "Gujr" },
		{ 0x00A85, 0x00A8D, "Gujr" },
		{ 0x00A8F, 0x00A91, "Gujr" },
		{ 0x00A93, 0x00AA8, "Gujr" },
		{ 0x00AAA, 0x00AB0, "Gujr" },
		{ 0x00AB2, 0x00AB3, "Gujr" },
		{ 0x00AB5, 0x00AB9, "Gujr" },
		{ 0x00ABC, 0x00AC5, "Gujr" },
		{ 0x00AC7, 0x00AC9, "Gujr" },
		{ 0x00ACB, 0x00ACD, "Gujr" },
		{ 0x00AE0, 0x00AE3, "Gujr" },
		{ 0x00AE6, 0x00AF1, "Gujr" },
		{ 0x00AF9, 0x00AFF, "Gujr" },
		{ 0x00B01, 0x00B03, "Orya" },
		{ 0x00B05, 0x00B0C, "Orya" },
		{ 0x00B0F, 0x00B10, "Orya" },
		{ 0x00B13, 0x00B28, "Orya" },
		{ 0x00B2A, 0x00B30, "Orya" },
		{ 0x00B32, 0x00B33, "Orya" },
		{ 0x00B35, 0x00B39, "Orya" },
		{ 0x00B3C, 0x00B44, "Orya" },
		{ 0x00B47, 0x00B48, "Orya" },
		{ 0x00B4B, 0x00B4D, "Orya" },
		{ 0x00B55, 0x00B57, "Orya" },
		{ 0x00B5C, 0x00B5D, "Orya" },
		{ 0x00B5F, 0x00B63, "Orya" },
		{ 0x00B66, 0x00B77, "Orya" },
		{ 0x00B82, 0x00B83, "Taml" },
		{ 0x00B85, 0x00B8A, "Taml" },
		{ 0x00B8E, 0x00B90, "Taml" },
		{ 0x00B92, 0x00B95, "Taml" },
		{ 0x00B99, 0x00B9A, "Taml" },
		{ 0x00B9E, 0x00B9F, "Taml" },
		{ 0x00BA3, 0x00BA4, "Taml" },
		{ 0x00BA8, 0x00BAA, "Taml" },
		{ 0x00BAE, 0x00BB9, "Taml" },
		{ 0x00BBE, 0x00BC2, "Taml" },
		{ 0x00BC6, 0x00BC8, "Taml" },
		{ 0x00BCA, 0x00BCD, "Taml" },
		{ 0x00BE6, 0x00BFA, "Taml" },
		{ 0x00C00, 0x00C0C, "Telu" },
		{ 0x00C0E, 0x00C10, "Telu" },
		{ 0x00C12, 0x00C28, "Telu" },
		{ 0x00C2A, 0x00C39, "Telu" },
		{ 0x00C3C, 0x00C44, "Telu" },
		{ 0x00C46, 0x00C48, "Telu" },
		{ 0x00C4A, 0x00C4D, "Telu" },
		{ 0x00C55, 0x00C56, "Telu" },
		{ 0x00C58, 0x00C5A, "Telu" },
		{ 0x00C60, 0x00C63, "Telu" },
		{ 0x00C66, 0x00C6F, "Telu" },
		{ 0x00C77, 0x00C7F, "Telu" },
		{ 0x00C80, 0x00C8C, "Knda" },
		{ 0x00C8E, 0x00C90, "Knda" },
		{ 0x00C92, 0x00CA8, "Knda" },
		{ 0x00CAA, 0x00CB3, "Knda" },
		{ 0x00CB5, 0x00CB9, "Knda" },
		{ 0x00CBC, 0x00CC4, "Knda" },
		{ 0x00CC6, 0x00CC8, "Knda" },
		{ 0x00CCA, 0x00CCD, "Knda" },
		{ 0x00CD5, 0x00CD6, "Knda" },
		{ 0x00CDD, 0x00CDE, "Knda" },
		{ 0x00CE0, 0x00CE3, "Knda" },
		{ 0x00CE6, 0x00CEF, "Knda" },
		{ 0x00CF1, 0x00CF3, "Knda" },
		{ 0x00D00, 0x00D0C, "Mlym" },
		{ 0x00D0E, 0x00D10, "Mlym" },
		{ 0x00D12, 0x00D44, "Mlym" },
		{ 0x00D46, 0x00D48, "Mlym" },
		{ 0x00D4A, 0x00D4F, "Mlym" },
		{ 0x00D54, 0x00D63, "Mlym" },
		{ 0x00D66, 0x00D7F, "Mlym" },
		{ 0x00D81, 0x00D83, "Sinh" },
		{ 0x00D85, 0x00D96, "Sinh" },
		{ 0x00D9A, 0x00DB1, "Sinh" },
		{ 0x00DB3, 0x00DBB, "Sinh" },
		{ 0x00DC0, 0x00DC6, "Sinh" },
		{ 0x00DCF, 0x00DD4, "Sinh" },
		{ 0x00DD8, 0x00DDF, "Sinh" },
		{ 0x00DE6, 0x00DEF, "Sinh" },
		{ 0x00DF2, 0x00DF4, "Sinh" },
		{ 0x00E01, 0x00E3A, "Thai" },
		{ 0x00E40, 0x00E5B, "Thai" },
		{ 0x00E81, 0x00E82, "Laoo" },
		{ 0x00E86, 0x00E8A, "Laoo" },
		{ 0x00E8C, 0x00EA3, "Laoo" },
		{ 0x00EA7, 0x00EBD, "Laoo" },
		{ 0x00EC0, 0x00EC4, "Laoo" },
		{ 0x00EC8, 0x00ECE, "Laoo" },
		{ 0x00ED0, 0x00ED9, "Laoo" },
		{ 0x00EDC, 0x00EDF, "Laoo" },
		{ 0x00F00, 0x00F47, "Tibt" },
		{ 0x00F49, 0x00F6C, "Tibt" },
		{ 0x00F71, 0x00F97, "Tibt" },
		{ 0x00F99, 0x00FBC, "Tibt" },
		{ 0x00FBE, 0x00FCC, "Tibt" },
		{ 0x00FCE, 0x00FD4, "Tibt" },
		{ 0x00FD5, 0x00FD8, "Zyyy" },
		{ 0x00FD9, 0x00FDA, "Tibt" },
		{ 0x01000, 0x0109F, "Mymr" },
		{ 0x010A0, 0x010C5, "Geor" },
		{ 0x010D0, 0x010FA, "Geor" },
		{ 0x010FC, 0x010FF, "Geor" },
		{ 0x01100, 0x011FF, "Hang" },
		{ 0x01200, 0x01248, "Ethi" },
		{ 0x0124A, 0x0124D, "Ethi" },
		{ 0x01250, 0x01256, "Ethi" },
		{ 0x0125A, 0x0125D, "Ethi" },
		{ 0x01260, 0x01288, "Ethi" },
		{ 0x0128A, 0x0128D, "Ethi" },
		{ 0x01290, 0x012B0, "Ethi" },
		{ 0x012B2, 0x012B5, "Ethi" },
		{ 0x012B8, 0x012BE, "Ethi" },
		{ 0x012C2, 0x012C5, "Ethi" },
		{ 0x012C8, 0x012D6, "Ethi" },
		{ 0x012D8, 0x01310, "Ethi" },
		{ 0x01312, 0x01315, "Ethi" },
		{ 0x01318, 0x0135A, "Ethi" },
		{ 0x0135D, 0x0137C, "Ethi" },
		{ 0x01380, 0x01399, "Ethi" },
		{ 0x013A0, 0x013F5, "Cher" },
		{ 0x013F8, 0x013FD, "Cher" },
		{ 0x01400, 0x0167F, "Cans" },
		{ 0x01680, 0x0169C, "Ogam" },
		{ 0x016A0, 0x016EA, "Runr" },
		{ 0x016EB, 0x016ED, "Zyyy" },
		{ 0x016EE, 0x016F8, "Runr" },
		{ 0x01700, 0x01715, "Tglg" },
		{ 0x01720, 0x01734, "Hano" },
		{ 0x01735, 0x01736, "Zyyy" },
		{ 0x01740, 0x01753, "Buhd" },
		{ 0x01760, 0x0176C, "Tagb" },
		{ 0x0176E, 0x01770, "Tagb" },
		{ 0x01772, 0x01773, "Tagb" },
		{ 0x01780, 0x017DD, "Khmr" },
		{ 0x017E0, 0x017E9, "Khmr" },
		{ 0x017F0, 0x017F9, "Khmr" },
		{ 0x01800, 0x01801, "Mong" },
		{ 0x01802, 0x01803, "Zyyy" },
		{ 0x01806, 0x01819, "Mong" },
		{ 0x01820, 0x01878, "Mong" },
		{ 0x01880, 0x018AA, "Mong" },
		{ 0x018B0, 0x018F5, "Cans" },
		{ 0x01900, 0x0191E, "Limb" },
		{ 0x01920, 0x0192B, "Limb" },
		{ 0x01930, 0x0193B, "Limb" },
		{ 0x01944, 0x0194F, "Limb" },
		{ 0x01950, 0x0196D, "Tale" },
		{ 0x01970, 0x01974, "Tale" },
		{ 0x01980, 0x019AB, "Talu" },
		{ 0x019B0, 0x019C9, "Talu" },
		{ 0x019D0, 0x019DA, "Talu" },
		{ 0x019DE, 0x019DF, "Talu" },
		{ 0x019E0, 0x019FF, "Khmr" },
		{ 0x01A00, 0x01A1B, "Bugi" },
		{ 0x01A1E, 0x01A1F, "Bugi" },
		{ 0x01A20, 0x01A5E, "Lana" },
		{ 0x01A60, 0x01A7C, "Lana" },
		{ 0x01A7F, 0x01A89, "Lana" },
		{ 0x01A90, 0x01A99, "Lana" },
		{ 0x01AA0, 0x01AAD, "Lana" },
		{ 0x01AB0, 0x01ACE, "Zinh" },
		{ 0x01B00, 0x01B4C, "Bali" },
		{ 0x01B4E, 0x01B7F, "Bali" },
		{ 0x01B80, 0x01BBF, "Sund" },
		{ 0x01BC0, 0x01BF3, "Batk" },
		{ 0x01BFC, 0x01BFF, "Batk" },
		{ 0x01C00, 0x01C37, "Lepc" },
		{ 0x01C3B, 0x01C49, "Lepc" },
		{ 0x01C4D, 0x01C4F, "Lepc" },
		{ 0x01C50, 0x01C7F, "Olck" },
		{ 0x01C80, 0x01C8A, "Cyrl" },
		{ 0x01C90, 0x01CBA, "Geor" },
		{ 0x01CBD, 0x01CBF, "Geor" },
		{ 0x01CC0, 0x01CC7, "Sund" },
		{ 0x01CD0, 0x01CD2, "Zinh" },
		{ 0x01CD4, 0x01CE0, "Zinh" },
		{ 0x01CE2, 0x01CE8, "Zinh" },
		{ 0x01CE9, 0x01CEC, "Zyyy" },
		{ 0x01CEE, 0x01CF3, "Zyyy" },
		{ 0x01CF5, 0x01CF7, "Zyyy" },
		{ 0x01CF8, 0x01CF9, "Zinh" },
		{ 0x01D00, 0x01D25, "Latn" },
		{ 0x01D26, 0x01D2A, "Grek" },
		{ 0x01D2C, 0x01D5C, "Latn" },
		{ 0x01D5D, 0x01D61, "Grek" },
		{ 0x01D62, 0x01D65, "Latn" },
		{ 0x01D66, 0x01D6A, "Grek" },
		{ 0x01D6B, 0x01D77, "Latn" },
		{ 0x01D79, 0x01DBE, "Latn" },
		{ 0x01DC0, 0x01DFF, "Zinh" },
		{ 0x01E00, 0x01EFF, "Latn" },
		{ 0x01F00, 0x01F15, "Grek" },
		{ 0x01F18, 0x01F1D, "Grek" },
		{ 0x01F20, 0x01F45, "Grek" },
		{ 0x01F48, 0x01F4D, "Grek" },
		{ 0x01F50, 0x01F57, "Grek" },
		{ 0x01F5F, 0x01F7D, "Grek" },
		{ 0x01F80, 0x01FB4, "Grek" },
		{ 0x01FB6, 0x01FC4, "Grek" },
		{ 0x01FC6, 0x01FD3, "Grek" },
		{ 0x01FD6, 0x01FDB, "Grek" },
		{ 0x01FDD, 0x01FEF, "Grek" },
		{ 0x01FF2, 0x01FF4, "Grek" },
		{ 0x01FF6, 0x01FFE, "Grek" },
		{ 0x02000, 0x0200B, "Zyyy" },
		{ 0x0200C, 0x0200D, "Zinh" },
		{ 0x0200E, 0x02064, "Zyyy" },
		{ 0x02066, 0x02070, "Zyyy" },
		{ 0x02074, 0x0207E, "Zyyy" },
		{ 0x02080, 0x0208E, "Zyyy" },
		{ 0x02090, 0x0209C, "Latn" },
		{ 0x020A0, 0x020C0, "Zyyy" },
		{ 0x020D0, 0x020F0, "Zinh" },
		{ 0x02100, 0x02125, "Zyyy" },
		{ 0x02127, 0x02129, "Zyyy" },
		{ 0x0212A, 0x0212B, "Latn" },
		{ 0x0212C, 0x02131, "Zyyy" },
		{ 0x02133, 0x0214D, "Zyyy" },
		{ 0x0214F, 0x0215F, "Zyyy" },
		{ 0x02160, 0x02188, "Latn" },
		{ 0x02189, 0x0218B, "Zyyy" },
		{ 0x02190, 0x02429, "Zyyy" },
		{ 0x02440, 0x0244A, "Zyyy" },
		{ 0x02460, 0x027FF, "Zyyy" },
		{ 0x02800, 0x028FF, "Brai" },
		{ 0x02900, 0x02B73, "Zyyy" },
		{ 0x02B76, 0x02B95, "Zyyy" },
		{ 0x02B97, 0x02BFF, "Zyyy" },
		{ 0x02C00, 0x02C5F, "Glag" },
		{ 0x02C60, 0x02C7F, "Latn" },
		{ 0x02C80, 0x02CF3, "Copt" },
		{ 0x02CF9, 0x02CFF, "Copt" },
		{ 0x02D00, 0x02D25, "Geor" },
		{ 0x02D30, 0x02D67, "Tfng" },
		{ 0x02D6F, 0x02D70, "Tfng" },
		{ 0x02D80, 0x02D96, "Ethi" },
		{ 0x02DA0, 0x02DA6, "Ethi" },
		{ 0x02DA8, 0x02DAE, "Ethi" },
		{ 0x02DB0, 0x02DB6, "Ethi" },
		{ 0x02DB8, 0x02DBE, "Ethi" },
		{ 0x02DC0, 0x02DC6, "Ethi" },
		{ 0x02DC8, 0x02DCE, "Ethi" },
		{ 0x02DD0, 0x02DD6, "Ethi" },
		{ 0x02DD8, 0x02DDE, "Ethi" },
		{ 0x02DE0, 0x02DFF, "Cyrl" },
		{ 0x02E00, 0x02E5D, "Zyyy" },
		{ 0x02E80, 0x02E99, "Hani" },
		{ 0x02E9B, 0x02EF3, "Hani" },
		{ 0x02F00, 0x02FD5, "Hani" },
		{ 0x02FF0, 0x03004, "Zyyy" },
		{ 0x03008, 0x03020, "Zyyy" },
		{ 0x03021, 0x03029, "Hani" },
		{ 0x0302A, 0x0302D, "Zinh" },
		{ 0x0302E, 0x0302F, "Hang" },
		{ 0x03030, 0x03037, "Zyyy" },
		{ 0x03038, 0x0303B, "Hani" },
		{ 0x0303C, 0x0303F, "Zyyy" },
		{ 0x03041, 0x03096, "Hira" },
		{ 0x03099, 0x0309A, "Zinh" },
		{ 0x0309B, 0x0309C, "Zyyy" },
		{ 0x0309D, 0x0309F, "Hira" },
		{ 0x030A1, 0x030FA, "Kana" },
		{ 0x030FB, 0x030FC, "Zyyy" },
		{ 0x030FD, 0x030FF, "Kana" },
		{ 0x03105, 0x0312F, "Bopo" },
		{ 0x03131, 0x0318E, "Hang" },
		{ 0x03190, 0x0319F, "Zyyy" },
		{ 0x031A0, 0x031BF, "Bopo" },
		{ 0x031C0, 0x031E5, "Zyyy" },
		{ 0x031F0, 0x031FF, "Kana" },
		{ 0x03200, 0x0321E, "Hang" },
		{ 0x03220, 0x0325F, "Zyyy" },
		{ 0x03260, 0x0327E, "Hang" },
		{ 0x0327F, 0x032CF, "Zyyy" },
		{ 0x032D0, 0x032FE, "Kana" },
		{ 0x03300, 0x03357, "Kana" },
		{ 0x03358, 0x033FF, "Zyyy" },
		{ 0x03400, 0x04DBF, "Hani" },
		{ 0x04DC0, 0x04DFF, "Zyyy" },
		{ 0x04E00, 0x09FFF, "Hani" },
		{ 0x0A000, 0x0A48C, "Yiii" },
		{ 0x0A490, 0x0A4C6, "Yiii" },
		{ 0x0A4D0, 0x0A4FF, "Lisu" },
		{ 0x0A500, 0x0A62B, "Vaii" },
		{ 0x0A640, 0x0A69F, "Cyrl" },
		{ 0x0A6A0, 0x0A6F7, "Bamu" },
		{ 0x0A700, 0x0A721, "Zyyy" },
		{ 0x0A722, 0x0A787, "Latn" },
		{ 0x0A788, 0x0A78A, "Zyyy" },
		{ 0x0A78B, 0x0A7CD, "Latn" },
		{ 0x0A7D0, 0x0A7D1, "Latn" },
		{ 0x0A7D5, 0x0A7DC, "Latn" },
		{ 0x0A7F2, 0x0A7FF, "Latn" },
		{ 0x0A800, 0x0A82C, "Sylo" },
		{ 0x0A830, 0x0A839, "Zyyy" },
		{ 0x0A840, 0x0A877, "Phag" },
		{ 0x0A880, 0x0A8C5, "Saur" },
		{ 0x0A8CE, 0x0A8D9, "Saur" },
		{ 0x0A8E0, 0x0A8FF, "Deva" },
		{ 0x0A900, 0x0A92D, "Kali" },
		{ 0x0A930, 0x0A953, "Rjng" },
		{ 0x0A960, 0x0A97C, "Hang" },
		{ 0x0A980, 0x0A9CD, "Java" },
		{ 0x0A9D0, 0x0A9D9, "Java" },
		{ 0x0A9DE, 0x0A9DF, "Java" },
		{ 0x0A9E0, 0x0A9FE, "Mymr" },
		{ 0x0AA00, 0x0AA36, "Cham" },
		{ 0x0AA40, 0x0AA4D, "Cham" },
		{ 0x0AA50, 0x0AA59, "Cham" },
		{ 0x0AA5C, 0x0AA5F, "Cham" },
		{ 0x0AA60, 0x0AA7F, "Mymr" },
		{ 0x0AA80, 0x0AAC2, "Tavt" },
		{ 0x0AADB, 0x0AADF, "Tavt" },
		{ 0x0AAE0, 0x0AAF6, "Mtei" },
		{ 0x0AB01, 0x0AB06, "Ethi" },
		{ 0x0AB09, 0x0AB0E, "Ethi" },
		{ 0x0AB11, 0x0AB16, "Ethi" },
		{ 0x0AB20, 0x0AB26, "Ethi" },
		{ 0x0AB28, 0x0AB2E, "Ethi" },
		{ 0x0AB30, 0x0AB5A, "Latn" },
		{ 0x0AB5C, 0x0AB64, "Latn" },
		{ 0x0AB66, 0x0AB69, "Latn" },
		{ 0x0AB6A, 0x0AB6B, "Zyyy" },
		{ 0x0AB70, 0x0ABBF, "Cher" },
		{ 0x0ABC0, 0x0ABED, "Mtei" },
		{ 0x0ABF0, 0x0ABF9, "Mtei" },
		{ 0x0AC00, 0x0D7A3, "Hang" },
		{ 0x0D7B0, 0x0D7C6, "Hang" },
		{ 0x0D7CB, 0x0D7FB, "Hang" },
		{ 0x0F900, 0x0FA6D, "Hani" },
		{ 0x0FA70, 0x0FAD9, "Hani" },
		{ 0x0FB00, 0x0FB06, "Latn" },
		{ 0x0FB13, 0x0FB17, "Armn" },
		{ 0x0FB1D, 0x0FB36, "Hebr" },
		{ 0x0FB38, 0x0FB3C, "Hebr" },
		{ 0x0FB40, 0x0FB41, "Hebr" },
		{ 0x0FB43, 0x0FB44, "Hebr" },
		{ 0x0FB46, 0x0FB4F, "Hebr" },
		{ 0x0FB50, 0x0FBC2, "Arab" },
		{ 0x0FBD3, 0x0FD3D, "Arab" },
		{ 0x0FD3E, 0x0FD3F, "Zyyy" },
		{ 0x0FD40, 0x0FD8F, "Arab" },
		{ 0x0FD92, 0x0FDC7, "Arab" },
		{ 0x0FDF0, 0x0FDFF, "Arab" },
		{ 0x0FE00, 0x0FE0F, "Zinh" },
		{ 0x0FE10, 0x0FE19, "Zyyy" },
		{ 0x0FE20, 0x0FE2D, "Zinh" },
		{ 0x0FE2E, 0x0FE2F, "Cyrl" },
		{ 0x0FE30, 0x0FE52, "Zyyy" },
		{ 0x0FE54, 0x0FE66, "Zyyy" },
		{ 0x0FE68, 0x0FE6B, "Zyyy" },
		{ 0x0FE70, 0x0FE74, "Arab" },
		{ 0x0FE76, 0x0FEFC, "Arab" },
		{ 0x0FF01, 0x0FF20, "Zyyy" },
		{ 0x0FF21, 0x0FF3A, "Latn" },
		{ 0x0FF3B, 0x0FF40, "Zyyy" },
		{ 0x0FF41, 0x0FF5A, "Latn" },
		{ 0x0FF5B, 0x0FF65, "Zyyy" },
		{ 0x0FF66, 0x0FF6F, "Kana" },
		{ 0x0FF71, 0x0FF9D, "Kana" },
		{ 0x0FF9E, 0x0FF9F, "Zyyy" },
		{ 0x0FFA0, 0x0FFBE, "Hang" },
		{ 0x0FFC2, 0x0FFC7, "Hang" },
		{ 0x0FFCA, 0x0FFCF, "Hang" },
		{ 0x0FFD2, 0x0FFD7, "Hang" },
		{ 0x0FFDA, 0x0FFDC, "Hang" },
		{ 0x0FFE0, 0x0FFE6, "Zyyy" },
		{ 0x0FFE8, 0x0FFEE, "Zyyy" },
		{ 0x0FFF9, 0x0FFFD, "Zyyy" },
		{ 0x10000, 0x1000B, "Linb" },
		{ 0x1000D, 0x10026, "Linb" },
		{ 0x10028, 0x1003A, "Linb" },
		{ 0x1003C, 0x1003D, "Linb" },
		{ 0x1003F, 0x1004D, "Linb" },
		{ 0x10050, 0x1005D, "Linb" },
		{ 0x10080, 0x100FA, "Linb" },
		{ 0x10100, 0x10102, "Zyyy" },
		{ 0x10107, 0x10133, "Zyyy" },
		{ 0x10137, 0x1013F, "Zyyy" },
		{ 0x10140, 0x1018E, "Grek" },
		{ 0x10190, 0x1019C, "Zyyy" },
		{ 0x101D0, 0x101FC, "Zyyy" },
		{ 0x10280, 0x1029C, "Lyci" },
		{ 0x102A0, 0x102D0, "Cari" },
		{ 0x102E1, 0x102FB, "Zyyy" },
		{ 0x10300, 0x10323, "Ital" },
		{ 0x1032D, 0x1032F, "Ital" },
		{ 0x10330, 0x1034A, "Goth" },
		{ 0x10350, 0x1037A, "Perm" },
		{ 0x10380, 0x1039D, "Ugar" },
		{ 0x103A0, 0x103C3, "Xpeo" },
		{ 0x103C8, 0x103D5, "Xpeo" },
		{ 0x10400, 0x1044F, "Dsrt" },
		{ 0x10450, 0x1047F, "Shaw" },
		{ 0x10480, 0x1049D, "Osma" },
		{ 0x104A0, 0x104A9, "Osma" },
		{ 0x104B0, 0x104D3, "Osge" },
		{ 0x104D8, 0x104FB, "Osge" },
		{ 0x10500, 0x10527, "Elba" },
		{ 0x10530, 0x10563, "Aghb" },
		{ 0x10570, 0x1057A, "Vith" },
		{ 0x1057C, 0x1058A, "Vith" },
		{ 0x1058C, 0x10592, "Vith" },
		{ 0x10594, 0x10595, "Vith" },
		{ 0x10597, 0x105A1, "Vith" },
		{ 0x105A3, 0x105B1, "Vith" },
		{ 0x105B3, 0x105B9, "Vith" },
		{ 0x105BB, 0x105BC, "Vith" },
		{ 0x105C0, 0x105F3, "Todr" },
		{ 0x10600, 0x10736, "Lina" },
		{ 0x10740, 0x10755, "Lina" },
		{ 0x10760, 0x10767, "Lina" },
		{ 0x10780, 0x10785, "Latn" },
		{ 0x10787, 0x107B0, "Latn" },
		{ 0x107B2, 0x107BA, "Latn" },
		{ 0x10800, 0x10805, "Cprt" },
		{ 0x1080A, 0x10835, "Cprt" },
		{ 0x10837, 0x10838, "Cprt" },
		{ 0x10840, 0x10855, "Armi" },
		{ 0x10857, 0x1085F, "Armi" },
		{ 0x10860, 0x1087F, "Palm" },
		{ 0x10880, 0x1089E, "Nbat" },
		{ 0x108A7, 0x108AF, "Nbat" },
		{ 0x108E0, 0x108F2, "Hatr" },
		{ 0x108F4, 0x108F5, "Hatr" },
		{ 0x108FB, 0x108FF, "Hatr" },
		{ 0x10900, 0x1091B, "Phnx" },
		{ 0x10920, 0x10939, "Lydi" },
		{ 0x10980, 0x1099F, "Mero" },
		{ 0x109A0, 0x109B7, "Merc" },
		{ 0x109BC, 0x109CF, "Merc" },
		{ 0x109D2, 0x109FF, "Merc" },
		{ 0x10A00, 0x10A03, "Khar" },
		{ 0x10A05, 0x10A06, "Khar" },
		{ 0x10A0C, 0x10A13, "Khar" },
		{ 0x10A15, 0x10A17, "Khar" },
		{ 0x10A19, 0x10A35, "Khar" },
		{ 0x10A38, 0x10A3A, "Khar" },
		{ 0x10A3F, 0x10A48, "Khar" },
		{ 0x10A50, 0x10A58, "Khar" },
		{ 0x10A60, 0x10A7F, "Sarb" },
		{ 0x10A80, 0x10A9F, "Narb" },
		{ 0x10AC0, 0x10AE6, "Mani" },
		{ 0x10AEB, 0x10AF6, "Mani" },
		{ 0x10B00, 0x10B35, "Avst" },
		{ 0x10B39, 0x10B3F, "Avst" },
		{ 0x10B40, 0x10B55, "Prti" },
		{ 0x10B58, 0x10B5F, "Prti" },
		{ 0x10B60, 0x10B72, "Phli" },
		{ 0x10B78, 0x10B7F, "Phli" },
		{ 0x10B80, 0x10B91, "Phlp" },
		{ 0x10B99, 0x10B9C, "Phlp" },
		{ 0x10BA9, 0x10BAF, "Phlp" },
		{ 0x10C00, 0x10C48, "Orkh" },
		{ 0x10C80, 0x10CB2, "Hung" },
		{ 0x10CC0, 0x10CF2, "Hung" },
		{ 0x10CFA, 0x10CFF, "Hung" },
		{ 0x10D00, 0x10D27, "Rohg" },
		{ 0x10D30, 0x10D39, "Rohg" },
		{ 0x10D40, 0x10D65, "Gara" },
		{ 0x10D69, 0x10D85, "Gara" },
		{ 0x10D8E, 0x10D8F, "Gara" },
		{ 0x10E60, 0x10E7E, "Arab" },
		{ 0x10E80, 0x10EA9, "Yezi" },
		{ 0x10EAB, 0x10EAD, "Yezi" },
		{ 0x10EB0, 0x10EB1, "Yezi" },
		{ 0x10EC2, 0x10EC4, "Arab" },
		{ 0x10EFC, 0x10EFF, "Arab" },
		{ 0x10F00, 0x10F27, "Sogo" },
		{ 0x10F30, 0x10F59, "Sogd" },
		{ 0x10F70, 0x10F89, "Ougr" },
		{ 0x10FB0, 0x10FCB, "Chrs" },
		{ 0x10FE0, 0x10FF6, "Elym" },
		{ 0x11000, 0x1104D, "Brah" },
		{ 0x11052, 0x11075, "Brah" },
		{ 0x11080, 0x110C2, "Kthi" },
		{ 0x110D0, 0x110E8, "Sora" },
		{ 0x110F0, 0x110F9, "Sora" },
		{ 0x11100, 0x11134, "Cakm" },
		{ 0x11136, 0x11147, "Cakm" },
		{ 0x11150, 0x11176, "Mahj" },
		{ 0x11180, 0x111DF, "Shrd" },
		{ 0x111E1, 0x111F4, "Sinh" },
		{ 0x11200, 0x11211, "Khoj" },
		{ 0x11213, 0x11241, "Khoj" },
		{ 0x11280, 0x11286, "Mult" },
		{ 0x1128A, 0x1128D, "Mult" },
		{ 0x1128F, 0x1129D, "Mult" },
		{ 0x1129F, 0x112A9, "Mult" },
		{ 0x112B0, 0x112EA, "Sind" },
		{ 0x112F0, 0x112F9, "Sind" },
		{ 0x11300, 0x11303, "Gran" },
		{ 0x11305, 0x1130C, "Gran" },
		{ 0x1130F, 0x11310, "Gran" },
		{ 0x11313, 0x11328, "Gran" },
		{ 0x1132A, 0x11330, "Gran" },
		{ 0x11332, 0x11333, "Gran" },
		{ 0x11335, 0x11339, "Gran" },
		{ 0x1133C, 0x11344, "Gran" },
		{ 0x11347, 0x11348, "Gran" },
		{ 0x1134B, 0x1134D, "Gran" },
		{ 0x1135D, 0x11363, "Gran" },
		{ 0x11366, 0x1136C, "Gran" },
		{ 0x11370, 0x11374, "Gran" },
		{ 0x11380, 0x11389, "Tutg" },
		{ 0x11390, 0x113B5, "Tutg" },
		{ 0x113B7, 0x113C0, "Tutg" },
		{ 0x113C7, 0x113CA, "Tutg" },
		{ 0x113CC, 0x113D5, "Tutg" },
		{ 0x113D7, 0x113D8, "Tutg" },
		{ 0x113E1, 0x113E2, "Tutg" },
		{ 0x11400, 0x1145B, "Newa" },
		{ 0x1145D, 0x11461, "Newa" },
		{ 0x11480, 0x114C7, "Tirh" },
		{ 0x114D0, 0x114D9, "Tirh" },
		{ 0x11580, 0x115B5, "Sidd" },
		{ 0x115B8, 0x115DD, "Sidd" },
		{ 0x11600, 0x11644, "Modi" },
		{ 0x11650, 0x11659, "Modi" },
		{ 0x11660, 0x1166C, "Mong" },
		{ 0x11680, 0x116B9, "Takr" },
		{ 0x116C0, 0x116C9, "Takr" },
		{ 0x116D0, 0x116E3, "Mymr" },
		{ 0x11700, 0x1171A, "Ahom" },
		{ 0x1171D, 0x1172B, "Ahom" },
		{ 0x11730, 0x11746, "Ahom" },
		{ 0x11800, 0x1183B, "Dogr" },
		{ 0x118A0, 0x118F2, "Wara" },
		{ 0x11900, 0x11906, "Diak" },
		{ 0x1190C, 0x11913, "Diak" },
		{ 0x11915, 0x11916, "Diak" },
		{ 0x11918, 0x11935, "Diak" },
		{ 0x11937, 0x11938, "Diak" },
		{ 0x1193B, 0x11946, "Diak" },
		{ 0x11950, 0x11959, "Diak" },
		{ 0x119A0, 0x119A7, "Nand" },
		{ 0x119AA, 0x119D7, "Nand" },
		{ 0x119DA, 0x119E4, "Nand" },
		{ 0x11A00, 0x11A47, "Zanb" },
		{ 0x11A50, 0x11AA2, "Soyo" },
		{ 0x11AB0, 0x11ABF, "Cans" },
		{ 0x11AC0, 0x11AF8, "Pauc" },
		{ 0x11B00, 0x11B09, "Deva" },
		{ 0x11BC0, 0x11BE1, "Sunu" },
		{ 0x11BF0, 0x11BF9, "Sunu" },
		{ 0x11C00, 0x11C08, "Bhks" },
		{ 0x11C0A, 0x11C36, "Bhks" },
		{ 0x11C38, 0x11C45, "Bhks" },
		{ 0x11C50, 0x11C6C, "Bhks" },
		{ 0x11C70, 0x11C8F, "Marc" },
		{ 0x11C92, 0x11CA7, "Marc" },
		{ 0x11CA9, 0x11CB6, "Marc" },
		{ 0x11D00, 0x11D06, "Gonm" },
		{ 0x11D08, 0x11D09, "Gonm" },
		{ 0x11D0B, 0x11D36, "Gonm" },
		{ 0x11D3C, 0x11D3D, "Gonm" },
		{ 0x11D3F, 0x11D47, "Gonm" },
		{ 0x11D50, 0x11D59, "Gonm" },
		{ 0x11D60, 0x11D65, "Gong" },
		{ 0x11D67, 0x11D68, "Gong" },
		{ 0x11D6A, 0x11D8E, "Gong" },
		{ 0x11D90, 0x11D91, "Gong" },
		{ 0x11D93, 0x11D98, "Gong" },
		{ 0x11DA0, 0x11DA9, "Gong" },
		{ 0x11EE0, 0x11EF8, "Maka" },
		{ 0x11F00, 0x11F10, "Kawi" },
		{ 0x11F12, 0x11F3A, "Kawi" },
		{ 0x11F3E, 0x11F5A, "Kawi" },
		{ 0x11FC0, 0x11FF1, "Taml" },
		{ 0x12000, 0x12399, "Xsux" },
		{ 0x12400, 0x1246E, "Xsux" },
		{ 0x12470, 0x12474, "Xsux" },
		{ 0x12480, 0x12543, "Xsux" },
		{ 0x12F90, 0x12FF2, "Cpmn" },
		{ 0x13000, 0x13455, "Egyp" },
		{ 0x13460, 0x143FA, "Egyp" },
		{ 0x14400, 0x14646, "Hluw" },
		{ 0x16100, 0x16139, "Gukh" },
		{ 0x16800, 0x16A38, "Bamu" },
		{ 0x16A40, 0x16A5E, "Mroo" },
		{ 0x16A60, 0x16A69, "Mroo" },
		{ 0x16A6E, 0x16A6F, "Mroo" },
		{ 0x16A70, 0x16ABE, "Tnsa" },
		{ 0x16AC0, 0x16AC9, "Tnsa" },
		{ 0x16AD0, 0x16AED, "Bass" },
		{ 0x16AF0, 0x16AF5, "Bass" },
		{ 0x16B00, 0x16B45, "Hmng" },
		{ 0x16B50, 0x16B59, "Hmng" },
		{ 0x16B5B, 0x16B61, "Hmng" },
		{ 0x16B63, 0x16B77, "Hmng" },
		{ 0x16B7D, 0x16B8F, "Hmng" },
		{ 0x16D40, 0x16D79, "Krai" },
		{ 0x16E40, 0x16E9A, "Medf" },
		{ 0x16F00, 0x16F4A, "Plrd" },
		{ 0x16F4F, 0x16F87, "Plrd" },
		{ 0x16F8F, 0x16F9F, "Plrd" },
		{ 0x16FE2, 0x16FE3, "Hani" },
		{ 0x16FF0, 0x16FF1, "Hani" },
		{ 0x17000, 0x187F7, "Tang" },
		{ 0x18800, 0x18AFF, "Tang" },
		{ 0x18B00, 0x18CD5, "Kits" },
		{ 0x18D00, 0x18D08, "Tang" },
		{ 0x1AFF0, 0x1AFF3, "Kana" },
		{ 0x1AFF5, 0x1AFFB, "Kana" },
		{ 0x1AFFD, 0x1AFFE, "Kana" },
		{ 0x1B001, 0x1B11F, "Hira" },
		{ 0x1B120, 0x1B122, "Kana" },
		{ 0x1B150, 0x1B152, "Hira" },
		{ 0x1B164, 0x1B167, "Kana" },
		{ 0x1B170, 0x1B2FB, "Nshu" },
		{ 0x1BC00, 0x1BC6A, "Dupl" },
		{ 0x1BC70, 0x1BC7C, "Dupl" },
		{ 0x1BC80, 0x1BC88, "Dupl" },
		{ 0x1BC90, 0x1BC99, "Dupl" },
		{ 0x1BC9C, 0x1BC9F, "Dupl" },
		{ 0x1BCA0, 0x1BCA3, "Zyyy" },
		{ 0x1CC00, 0x1CCF9, "Zyyy" },
		{ 0x1CD00, 0x1CEB3, "Zyyy" },
		{ 0x1CF00, 0x1CF2D, "Zinh" },
		{ 0x1CF30, 0x1CF46, "Zinh" },
		{ 0x1CF50, 0x1CFC3, "Zyyy" },
		{ 0x1D000, 0x1D0F5, "Zyyy" },
		{ 0x1D100, 0x1D126, "Zyyy" },
		{ 0x1D129, 0x1D166, "Zyyy" },
		{ 0x1D167, 0x1D169, "Zinh" },
		{ 0x1D16A, 0x1D17A, "Zyyy" },
		{ 0x1D17B, 0x1D182, "Zinh" },
		{ 0x1D183, 0x1D184, "Zyyy" },
		{ 0x1D185, 0x1D18B, "Zinh" },
		{ 0x1D18C, 0x1D1A9, "Zyyy" },
		{ 0x1D1AA, 0x1D1AD, "Zinh" },
		{ 0x1D1AE, 0x1D1EA, "Zyyy" },
		{ 0x1D200, 0x1D245, "Grek" },
		{ 0x1D2C0, 0x1D2D3, "Zyyy" },
		{ 0x1D2E0, 0x1D2F3, "Zyyy" },
		{ 0x1D300, 0x1D356, "Zyyy" },
		{ 0x1D360, 0x1D378, "Zyyy" },
		{ 0x1D400, 0x1D454, "Zyyy" },
		{ 0x1D456, 0x1D49C, "Zyyy" },
		{ 0x1D49E, 0x1D49F, "Zyyy" },
		{ 0x1D4A5, 0x1D4A6, "Zyyy" },
		{ 0x1D4A9, 0x1D4AC, "Zyyy" },
		{ 0x1D4AE, 0x1D4B9, "Zyyy" },
		{ 0x1D4BD, 0x1D4C3, "Zyyy" },
		{ 0x1D4C5, 0x1D505, "Zyyy" },
		{ 0x1D507, 0x1D50A, "Zyyy" },
		{ 0x1D50D, 0x1D514, "Zyyy" },
		{ 0x1D516, 0x1D51C, "Zyyy" },
		{ 0x1D51E, 0x1D539, "Zyyy" },
		{ 0x1D53B, 0x1D53E, "Zyyy" },
		{ 0x1D540, 0x1D544, "Zyyy" },
		{ 0x1D54A, 0x1D550, "Zyyy" },
		{ 0x1D552, 0x1D6A5, "Zyyy" },
		{ 0x1D6A8, 0x1D7CB, "Zyyy" },
		{ 0x1D7CE, 0x1D7FF, "Zyyy" },
		{ 0x1D800, 0x1DA8B, "Sgnw" },
		{ 0x1DA9B, 0x1DA9F, "Sgnw" },
		{ 0x1DAA1, 0x1DAAF, "Sgnw" },
		{ 0x1DF00, 0x1DF1E, "Latn" },
		{ 0x1DF25, 0x1DF2A, "Latn" },
		{ 0x1E000, 0x1E006, "Glag" },
		{ 0x1E008, 0x1E018, "Glag" },
		{ 0x1E01B, 0x1E021, "Glag" },
		{ 0x1E023, 0x1E024, "Glag" },
		{ 0x1E026, 0x1E02A, "Glag" },
		{ 0x1E030, 0x1E06D, "Cyrl" },
		{ 0x1E100, 0x1E12C, "Hmnp" },
		{ 0x1E130, 0x1E13D, "Hmnp" },
		{ 0x1E140, 0x1E149, "Hmnp" },
		{ 0x1E14E, 0x1E14F, "Hmnp" },
		{ 0x1E290, 0x1E2AE, "Toto" },
		{ 0x1E2C0, 0x1E2F9, "Wcho" },
		{ 0x1E4D0, 0x1E4F9, "Nagm" },
		{ 0x1E5D0, 0x1E5FA, "Onao" },
		{ 0x1E7E0, 0x1E7E6, "Ethi" },
		{ 0x1E7E8, 0x1E7EB, "Ethi" },
		{ 0x1E7ED, 0x1E7EE, "Ethi" },
		{ 0x1E7F0, 0x1E7FE, "Ethi" },
		{ 0x1E800, 0x1E8C4, "Mend" },
		{ 0x1E8C7, 0x1E8D6, "Mend" },
		{ 0x1E900, 0x1E94B, "Adlm" },
		{ 0x1E950, 0x1E959, "Adlm" },
		{ 0x1E95E, 0x1E95F, "Adlm" },
		{ 0x1EC71, 0x1ECB4, "Zyyy" },
		{ 0x1ED01, 0x1ED3D, "Zyyy" },
		{ 0x1EE00, 0x1EE03, "Arab" },
		{ 0x1EE05, 0x1EE1F, "Arab" },
		{ 0x1EE21, 0x1EE22, "Arab" },
		{ 0x1EE29, 0x1EE32, "Arab" },
		{ 0x1EE34, 0x1EE37, "Arab" },
		{ 0x1EE4D, 0x1EE4F, "Arab" },
		{ 0x1EE51, 0x1EE52, "Arab" },
		{ 0x1EE61, 0x1EE62, "Arab" },
		{ 0x1EE67, 0x1EE6A, "Arab" },
		{ 0x1EE6C, 0x1EE72, "Arab" },
		{ 0x1EE74, 0x1EE77, "Arab" },
		{ 0x1EE79, 0x1EE7C, "Arab" },
		{ 0x1EE80, 0x1EE89, "Arab" },
		{ 0x1EE8B, 0x1EE9B, "Arab" },
		{ 0x1EEA1, 0x1EEA3, "Arab" },
		{ 0x1EEA5, 0x1EEA9, "Arab" },
		{ 0x1EEAB, 0x1EEBB, "Arab" },
		{ 0x1EEF0, 0x1EEF1, "Arab" },
		{ 0x1F000, 0x1F02B, "Zyyy" },
		{ 0x1F030, 0x1F093, "Zyyy" },
		{ 0x1F0A0, 0x1F0AE, "Zyyy" },
		{ 0x1F0B1, 0x1F0BF, "Zyyy" },
		{ 0x1F0C1, 0x1F0CF, "Zyyy" },
		{ 0x1F0D1, 0x1F0F5, "Zyyy" },
		{ 0x1F100, 0x1F1AD, "Zyyy" },
		{ 0x1F1E6, 0x1F1FF, "Zyyy" },
		{ 0x1F201, 0x1F202, "Zyyy" },
		{ 0x1F210, 0x1F23B, "Zyyy" },
		{ 0x1F240, 0x1F248, "Zyyy" },
		{ 0x1F250, 0x1F251, "Zyyy" },
		{ 0x1F260, 0x1F265, "Zyyy" },
		{ 0x1F300, 0x1F6D7, "Zyyy" },
		{ 0x1F6DC, 0x1F6EC, "Zyyy" },
		{ 0x1F6F0, 0x1F6FC, "Zyyy" },
		{ 0x1F700, 0x1F776, "Zyyy" },
		{ 0x1F77B, 0x1F7D9, "Zyyy" },
		{ 0x1F7E0, 0x1F7EB, "Zyyy" },
		{ 0x1F800, 0x1F80B, "Zyyy" },
		{ 0x1F810, 0x1F847, "Zyyy" },
		{ 0x1F850, 0x1F859, "Zyyy" },
		{ 0x1F860, 0x1F887, "Zyyy" },
		{ 0x1F890, 0x1F8AD, "Zyyy" },
		{ 0x1F8B0, 0x1F8BB, "Zyyy" },
		{ 0x1F8C0, 0x1F8C1, "Zyyy" },
		{ 0x1F900, 0x1FA53, "Zyyy" },
		{ 0x1FA60, 0x1FA6D, "Zyyy" },
		{ 0x1FA70, 0x1FA7C, "Zyyy" },
		{ 0x1FA80, 0x1FA89, "Zyyy" },
		{ 0x1FA8F, 0x1FAC6, "Zyyy" },
		{ 0x1FACE, 0x1FADC, "Zyyy" },
		{ 0x1FADF, 0x1FAE9, "Zyyy" },
		{ 0x1FAF0, 0x1FAF8, "Zyyy" },
		{ 0x1FB00, 0x1FB92, "Zyyy" },
		{ 0x1FB94, 0x1FBF9, "Zyyy" },
		{ 0x20000, 0x2A6DF, "Hani" },
		{ 0x2A700, 0x2B739, "Hani" },
		{ 0x2B740, 0x2B81D, "Hani" },
		{ 0x2B820, 0x2CEA1, "Hani" },
		{ 0x2CEB0, 0x2EBE0, "Hani" },
		{ 0x2EBF0, 0x2EE5D, "Hani" },
		{ 0x2F800, 0x2FA1D, "Hani" },
		{ 0x30000, 0x3134A, "Hani" },
		{ 0x31350, 0x323AF, "Hani" },
		{ 0xE0020, 0xE007F, "Zyyy" },
		{ 0xE0100, 0xE01EF, "Zinh" },
	},
	-- Scripts.txt gives full names; here we consider them aliases to save space.
	aliases = {
		Adlm = "Adlam",
		Aghb = "Caucasian Albanian",
		Ahom = "Ahom",
		Arab = "Arabic",
		Armi = "Imperial Aramaic",
		Armn = "Armenian",
		Avst = "Avestan",
		Bali = "Balinese",
		Bamu = "Bamum",
		Bass = "Bassa Vah",
		Batk = "Batak",
		Beng = "Bengali",
		Bhks = "Bhaiksuki",
		Bopo = "Bopomofo",
		Brah = "Brahmi",
		Brai = "Braille",
		Bugi = "Buginese",
		Buhd = "Buhid",
		Cakm = "Chakma",
		Cans = "Canadian Aboriginal",
		Cari = "Carian",
		Cham = "Cham",
		Cher = "Cherokee",
		Chrs = "Chorasmian",
		Copt = "Coptic",
		Cpmn = "Cypro Minoan",
		Cprt = "Cypriot",
		Cyrl = "Cyrillic",
		Deva = "Devanagari",
		Diak = "Dives Akuru",
		Dogr = "Dogra",
		Dsrt = "Deseret",
		Dupl = "Duployan",
		Egyp = "Egyptian Hieroglyphs",
		Elba = "Elbasan",
		Elym = "Elymaic",
		Ethi = "Ethiopic",
		Gara = "Garay",
		Geor = "Georgian",
		Glag = "Glagolitic",
		Gong = "Gunjala Gondi",
		Gonm = "Masaram Gondi",
		Goth = "Gothic",
		Gran = "Grantha",
		Grek = "Greek",
		Gujr = "Gujarati",
		Gukh = "Gurung Khema",
		Guru = "Gurmukhi",
		Hang = "Hangul",
		Hani = "Han",
		Hano = "Hanunoo",
		Hatr = "Hatran",
		Hebr = "Hebrew",
		Hira = "Hiragana",
		Hluw = "Anatolian Hieroglyphs",
		Hmng = "Pahawh Hmong",
		Hmnp = "Nyiakeng Puachue Hmong",
		Hrkt = "Katakana Or Hiragana",
		Hung = "Old Hungarian",
		Ital = "Old Italic",
		Java = "Javanese",
		Kali = "Kayah Li",
		Kana = "Katakana",
		Kawi = "Kawi",
		Khar = "Kharoshthi",
		Khmr = "Khmer",
		Khoj = "Khojki",
		Kits = "Khitan Small Script",
		Knda = "Kannada",
		Krai = "Kirat Rai",
		Kthi = "Kaithi",
		Lana = "Tai Tham",
		Laoo = "Lao",
		Latn = "Latin",
		Lepc = "Lepcha",
		Limb = "Limbu",
		Lina = "Linear A",
		Linb = "Linear B",
		Lisu = "Lisu",
		Lyci = "Lycian",
		Lydi = "Lydian",
		Mahj = "Mahajani",
		Maka = "Makasar",
		Mand = "Mandaic",
		Mani = "Manichaean",
		Marc = "Marchen",
		Medf = "Medefaidrin",
		Mend = "Mende Kikakui",
		Merc = "Meroitic Cursive",
		Mero = "Meroitic Hieroglyphs",
		Mlym = "Malayalam",
		Modi = "Modi",
		Mong = "Mongolian",
		Mroo = "Mro",
		Mtei = "Meetei Mayek",
		Mult = "Multani",
		Mymr = "Myanmar",
		Nagm = "Nag Mundari",
		Nand = "Nandinagari",
		Narb = "Old North Arabian",
		Nbat = "Nabataean",
		Newa = "Newa",
		Nkoo = "NKo",
		Nshu = "Nushu",
		Ogam = "Ogham",
		Olck = "Ol Chiki",
		Onao = "Ol Onal",
		Orkh = "Old Turkic",
		Orya = "Oriya",
		Osge = "Osage",
		Osma = "Osmanya",
		Ougr = "Old Uyghur",
		Palm = "Palmyrene",
		Pauc = "Pau Cin Hau",
		Perm = "Old Permic",
		Phag = "Phags Pa",
		Phli = "Inscriptional Pahlavi",
		Phlp = "Psalter Pahlavi",
		Phnx = "Phoenician",
		Plrd = "Miao",
		Prti = "Inscriptional Parthian",
		Rjng = "Rejang",
		Rohg = "Hanifi Rohingya",
		Runr = "Runic",
		Samr = "Samaritan",
		Sarb = "Old South Arabian",
		Saur = "Saurashtra",
		Sgnw = "SignWriting",
		Shaw = "Shavian",
		Shrd = "Sharada",
		Sidd = "Siddham",
		Sind = "Khudawadi",
		Sinh = "Sinhala",
		Sogd = "Sogdian",
		Sogo = "Old Sogdian",
		Sora = "Sora Sompeng",
		Soyo = "Soyombo",
		Sund = "Sundanese",
		Sunu = "Sunuwar",
		Sylo = "Syloti Nagri",
		Syrc = "Syriac",
		Tagb = "Tagbanwa",
		Takr = "Takri",
		Tale = "Tai Le",
		Talu = "New Tai Lue",
		Taml = "Tamil",
		Tang = "Tangut",
		Tavt = "Tai Viet",
		Telu = "Telugu",
		Tfng = "Tifinagh",
		Tglg = "Tagalog",
		Thaa = "Thaana",
		Thai = "Thai",
		Tibt = "Tibetan",
		Tirh = "Tirhuta",
		Tnsa = "Tangsa",
		Todr = "Todhri",
		Toto = "Toto",
		Tutg = "Tulu Tigalari",
		Ugar = "Ugaritic",
		Vaii = "Vai",
		Vith = "Vithkuqi",
		Wara = "Warang Citi",
		Wcho = "Wancho",
		Xpeo = "Old Persian",
		Xsux = "Cuneiform",
		Yezi = "Yezidi",
		Yiii = "Yi",
		Zanb = "Zanabazar Square",
		Zinh = "Inherited",
		Zyyy = "Common",
		Zzzz = "Unknown",
	},
}

-- Required for binary search function in [[Module:Language/scripts]].
-- Cannot get length of module loaded with mw.loadData.
data.ranges.length = #data.ranges

data.rtl = {}

for _, script in ipairs(mw.loadData "Module:Lang/data".rtl_scripts) do
	-- [[Module:Lang/data]] has script codes in lowercase;
	-- this module has script codes with the first letter capitalized.
	data.rtl[script:gsub("^%a", string.upper)] = true
end

return data</text>
      <sha1>85z627whc28kcj8na9y8648zqt8tlmy</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Further</title>
    <ns>10</ns>
    <id>169</id>
    <revision>
      <id>326</id>
      <parentid>325</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>325</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="251" sha1="pu1ae8is2dmdurv2yovsfwxjajnhn2s" xml:space="preserve">&lt;includeonly&gt;{{#invoke:labelled list hatnote|labelledList|Further information{{#if:{{{topic|}}}|&amp;#32;on {{{topic|}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>pu1ae8is2dmdurv2yovsfwxjajnhn2s</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Multiple image</title>
    <ns>10</ns>
    <id>170</id>
    <revision>
      <id>328</id>
      <parentid>327</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>327</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="131" sha1="q9oxjh8m7wtojz4v77x8mc2nmpowt0r" xml:space="preserve">{{#invoke:Multiple image|render}}&lt;noinclude&gt;{{documentation}}&lt;!-- PLEASE ADD CATEGORIES TO THE /doc SUBPAGE, THANKS --&gt;&lt;/noinclude&gt;</text>
      <sha1>q9oxjh8m7wtojz4v77x8mc2nmpowt0r</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Multiple image/styles.css</title>
    <ns>10</ns>
    <id>171</id>
    <revision>
      <id>330</id>
      <parentid>329</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>329</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1738" sha1="22o7hf626c55odee4pnupn4anonwfy3" xml:space="preserve">/* {{pp-template}} */
/* this is a block */
.multiimageinner {
	display: flex;
	flex-direction: column;
}

.trow {
	display: flex;
	flex-direction: row;
	clear: left;
	flex-wrap: wrap;
	width: 100%;
	box-sizing: border-box;
}

/* this is a cell */
.tsingle {
	margin: 1px;
	float: left;
}

.theader {
	clear: both;
	font-weight: bold;
	text-align: center;
	align-self: center;
	background-color: transparent;
	width: 100%;
}

.thumbcaption {
	background-color: transparent;
}

.text-align-left {
	text-align: left;
}

.text-align-right {
	text-align: right;
}

.text-align-center {
	text-align: center;
}

@media all and ( max-width: 720px ) {
	.thumbinner {
		/* not !important usage can be removed when these are no longer inline styles
		inside Template:Multiple image and media query using min-width is introduced */
		width: 100% !important;
		box-sizing: border-box;
		max-width: none !important;
		align-items: center;
	}
	.trow {
		justify-content: center;
	}
	.tsingle {
		/* not !important usage can be removed when these are no longer inline styles
		inside Template:Multiple image and media query using min-width is introduced */
	    float: none !important;
	    max-width: 100% !important;
	    box-sizing: border-box;
	    text-align: center;
	}
	.tsingle .thumbcaption {
		text-align: left;
	}
	.trow &gt; .thumbcaption {
		text-align: center;
	}
}

@media screen {
	html.skin-theme-clientpref-night .multiimageinner span:not(.skin-invert-image):not(.skin-invert):not(.bg-transparent) img {
		background-color: white;
	}
}
@media screen and (prefers-color-scheme: dark) {
	html.skin-theme-clientpref-os .multiimageinner span:not(.skin-invert-image):not(.skin-invert):not(.bg-transparent) img {
		background-color: white;
	}
}</text>
      <sha1>22o7hf626c55odee4pnupn4anonwfy3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Trim</title>
    <ns>10</ns>
    <id>172</id>
    <revision>
      <id>332</id>
      <parentid>331</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>331</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="97" sha1="757g7pokoq514f9oi2nwaddkdp2ohtn" xml:space="preserve">&lt;includeonly&gt;{{safesubst:#if:1|{{{1|}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>757g7pokoq514f9oi2nwaddkdp2ohtn</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Multiple image</title>
    <ns>828</ns>
    <id>173</id>
    <revision>
      <id>334</id>
      <parentid>333</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>333</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="9449" sha1="f7ujj8xva6mclea30bfr0pwhsx7t2ek" xml:space="preserve">-- implements [[template:multiple image]]
local p = {}

local autoscaledimages
local nonautoscaledimages

local function isnotempty(s)
	return s and s:match( '^%s*(.-)%s*$' ) ~= ''
end

local function removepx(s)
	return tostring(s or ''):match('^(.*)[Pp][Xx]%s*$') or s
end

local function getdimensions(s, w, h)
	if tonumber(w) and tonumber(h) then
		nonautoscaledimages = true
		return tonumber(w), tonumber(h)
	end
	local file = s and mw.title.new('File:' .. mw.uri.decode(mw.ustring.gsub(s,'%|.*$',''), 'WIKI'))
	file = file and file.file or {width = 0, height = 0}
	w = tonumber(file.width) or 0
	h = tonumber(file.height) or 0
	autoscaledimages = true
	return w, h
end

local function renderImageCell(image, width, height, link, alt, thumbtime, caption, class, textalign, istyle, border)
	local root = mw.html.create('')

	local altstr = '|alt=' .. (alt or '')
	local classstr = class and ('|class=' .. class) or ''
	local linkstr = link and ('|link=' .. link) or ''
	local widthstr = '|' .. tostring(width) .. 'px'
	local thumbtimestr = ''

	if widthstr == '|-nanpx' then
		widthstr = ''
	end
	if isnotempty( thumbtime ) then
		thumbtimestr = '|thumbtime=' .. thumbtime
	end

	local imagediv = root:tag('div')
	imagediv:addClass((border ~= 'infobox') and 'thumbimage' or nil)
	imagediv:cssText(istyle)
	if( height ) then
		imagediv:css('height', tostring(height) .. 'px')
		imagediv:css('overflow', 'hidden')
	end
	imagediv:wikitext('[[file:' .. image .. classstr .. widthstr .. linkstr .. altstr .. thumbtimestr .. ']]')
	if isnotempty(caption) then
		local captiondiv = root:tag('div')
		captiondiv:addClass((border ~= 'infobox') and 'thumbcaption' or nil)
		if isnotempty(textalign) then
			captiondiv:addClass('text-align-' .. textalign)
		end
		captiondiv:wikitext(caption)
	end
	return tostring(root)
end

local function getWidth(w1, w2)
	local w
	if isnotempty(w1) then
		w = tonumber(w1)
	elseif isnotempty(w2) then
		w = tonumber(w2)
	end
	return w or 200
end

local function getPerRow(pstr, ic)
	-- split string into array using any non-digit as a dilimiter
	local pr = mw.text.split(pstr or '', '[^%d][^%d]*')
	-- if split failed, assume a single row
	if (#pr &lt; 1) then
		pr = {tostring(ic)}
	end
	-- convert the array of strings to an array of numbers,
	-- adding any implied/missing numbers at the end of the array
	local r = 1
	local thisrow = tonumber(pr[1] or ic) or ic
	local prownum = {}
	while( ic &gt; 0 ) do
		prownum[r] = thisrow
		ic = ic - thisrow
		r = r + 1
		-- use the previous if the next is missing and
		-- make sure we don't overstep the number of images
		thisrow = math.min(tonumber(pr[r] or thisrow) or ic, ic)
	end
	return prownum
end

local function renderMultipleImages(frame)
	local pargs = frame:getParent().args
	local args = frame.args
	local width = removepx(pargs['width'] or '')
	local dir = pargs['direction'] or ''
	local border = pargs['border'] or args['border'] or ''
	local align = pargs['align'] or args['align'] or (border == 'infobox' and 'center' or '')
	local capalign = pargs['caption_align'] or args['caption_align'] or ''
	local totalwidth = removepx(pargs['total_width'] or args['total_width'] or '')
	local imgstyle = pargs['image_style'] or args['image_style']
	local header = pargs['header'] or pargs['title'] or ''
	local footer = pargs['footer'] or ''
	local imagegap = tonumber(pargs['image_gap'] or '1') or 1
	local perrow = nil
	local thumbclass = {
		["left"] = 'tleft',
		["none"] = 'tnone',
		["center"] = 'tnone',
		["centre"] = 'tnone',
		["right"] = 'tright'
		}

	-- find all the nonempty images
	local imagenumbers = {}
	local imagecount = 0
	for k, v in pairs( pargs ) do
		local i = tonumber(tostring(k):match( '^%s*image([%d]+)%s*$' ) or '0')
		if( i &gt; 0 and isnotempty(v) ) then
			table.insert( imagenumbers, i)
			imagecount = imagecount + 1
		end
	end

	-- sort the imagenumbers
	table.sort(imagenumbers)

	-- create an array with the number of images per row
	perrow = getPerRow(dir == 'vertical' and '1' or pargs['perrow'], imagecount)

	-- compute the number of rows
	local rowcount = #perrow

	-- store the image widths and compute row widths and maximum row width
	local heights = {}
	local widths = {}
	local widthmax = 0
	local widthsum = {}
	local k = 0
	for r=1,rowcount do
		widthsum[r] = 0
		for c=1,perrow[r] do
			k = k + 1
			if( k &lt;= imagecount ) then
				local i = imagenumbers[k]
				if( isnotempty(totalwidth) ) then
					widths[k], heights[k] = getdimensions(pargs['image' .. i], pargs['width' .. i], pargs['height' .. i])
				else
					widths[k] = getWidth(width, pargs['width' .. i])
				end
				widthsum[r] = widthsum[r] + widths[k]
			end
		end
		widthmax = math.max(widthmax, widthsum[r])
	end

	-- make sure the gap is non-negative
	if imagegap &lt; 0 then imagegap = 0 end

	-- if total_width has been specified, rescale the image widths
	if( isnotempty(totalwidth) ) then
		totalwidth = tonumber(totalwidth)
		widthmax = 0
		local k = 0
		for r=1,rowcount do
			local koffset = k
			local tw = totalwidth - (3 + imagegap) * (perrow[r] - 1) - 12
			local ar = {}
			local arsum = 0
			for j=1,perrow[r] do
				k = k + 1
				if( k&lt;= imagecount ) then
					local i = imagenumbers[k]
					local h = heights[k] or 0
					if (h &gt; 0) then
						ar[j] = widths[k]/h
						heights[k] = h
					else
						ar[j] = widths[k]/100
					end
					arsum = arsum + ar[j]
				end
			end
			local ht = tw/arsum
			local ws = 0
			k = koffset
			for j=1,perrow[r] do
				k = k + 1
				if( k&lt;= imagecount ) then
					local i = imagenumbers[k]
					widths[k] = math.floor(ar[j]*ht + 0.5)
					ws = ws + widths[k]
					if heights[k] then
						heights[k] = math.floor(ht)
					end
				end
			end
			widthsum[r] = ws
			widthmax = math.max(widthmax, widthsum[r])
		end
	end

	-- start building the array of images, if there are images
	if( imagecount &gt; 0 ) then
		-- compute width of outer div
		local bodywidth = 0
		for r=1,rowcount do
			if( widthmax == widthsum[r] ) then
				bodywidth = widthmax + (3 + imagegap) * (perrow[r] - 1) + 12
			end
		end
		-- The body has a min-width of 100, which needs to be taken into account on specific widths
		bodywidth = math.max( 100, bodywidth - 8);

		local bg = pargs['background color'] or ''
		-- create the array of images
		local root = mw.html.create('div')
		root:addClass('thumb')
		root:addClass('tmulti')
		-- root:addClass('tmulti-sandbox')
		root:addClass(thumbclass[align] or 'tright')

		if( align == 'center' or align == 'centre' ) then
			root:addClass('center')
		end
		if( bg ~= '' ) then
			root:css('background-color', bg)
		end

		local div = root:tag('div')
		div:addClass((border ~= 'infobox') and 'thumbinner multiimageinner' or 'multiimageinner')
		div:css('width', tostring(bodywidth) .. 'px')
			:css('max-width', tostring(bodywidth) .. 'px')
		if( bg ~= '' ) then
			div:css('background-color', bg)
		end
		if( border == 'infobox' or border == 'none') then
			div:css('border', 'none')
		end
		-- add the header
		if( isnotempty(header) ) then
			div:tag('div')
				:addClass('trow')
				:tag('div')
					:addClass('theader')
					:css('text-align', pargs['header_align'])
					:css('background-color', 
						(pargs['header_background'] ~= '') and pargs['header_background'] or nil)
					:wikitext(header)
		end
		-- loop through the images
		local k = 0
		for r=1,rowcount do
			local rowdiv = div:tag('div'):addClass('trow');
			for j=1,perrow[r] do
				k = k + 1
				if( k &lt;= imagecount ) then
					local imagediv = rowdiv:tag('div')
					imagediv:addClass('tsingle')
					if bg ~= '' then
						imagediv:css('background-color', bg);
					end
					if imagegap &gt; 1 and k &lt; imagecount then
						if dir == 'vertical' then
							imagediv:css('margin-bottom', tostring(imagegap) .. 'px')	
						elseif j &lt; perrow[r] then
							imagediv:css('margin-right', tostring(imagegap) .. 'px')
						end
					end
					local i = imagenumbers[k]
					local img = pargs['image' .. i]
					local w = widths[k]
					imagediv:css('width', tostring(2 + w) .. 'px')
						:css('max-width', tostring(2 + w) .. 'px')
					imagediv:wikitext(renderImageCell(img, w, heights[k],
						pargs['link' .. i], pargs['alt' .. i],
						pargs['thumbtime' .. i], pargs['caption' .. i], pargs['class' .. i], capalign, imgstyle, border))
				end
			end
		end
		-- add the footer
		if( isnotempty(footer) ) then
			local falign = string.lower(pargs['footer_align'] or args['footer_align'] or '')
			falign = (falign == 'centre') and 'center' or falign
			div:tag('div')
				:addClass('trow')
				:css('display', (falign ~= '') and 'flow-root' or 'flex')
				:tag('div')
					:addClass((border ~= 'infobox') and 'thumbcaption' or nil)
					:css('text-align', (falign ~= '') and falign or nil)
					:css('background-color', 
						(pargs['footer_background'] ~= '') and pargs['footer_background'] or nil)
					:wikitext(footer)
		end
		return tostring(root)
	end
	return ''
end

function p.render( frame )
	autoscaledimages = false
	nonautoscaledimages = false

	return frame:extensionTag {name = 'templatestyles', args = {src = 'Multiple image/styles.css', wrapper = ".tmulti"}}
		.. renderMultipleImages( frame )
		.. (autoscaledimages and '[[Category:Pages using multiple image with auto scaled images]]' or '')
		.. (nonautoscaledimages and '[[Category:Pages using multiple image with manual scaled images]]' or '')
end

p[''] = function( frame ) return p.render( frame:newChild{title = frame:getTitle()} ) end

return p</text>
      <sha1>f7ujj8xva6mclea30bfr0pwhsx7t2ek</sha1>
    </revision>
  </page>
  <page>
    <title>Module:WikidataIB</title>
    <ns>828</ns>
    <id>174</id>
    <revision>
      <id>336</id>
      <parentid>335</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>335</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="142142" sha1="o26pvdzoveksr04pobp213ncnrqerd6" xml:space="preserve">-- Version: 2023-07-10
-- Module to implement use of a blacklist and whitelist for infobox fields
-- Can take a named parameter |qid which is the Wikidata ID for the article
-- if not supplied, it will use the Wikidata ID associated with the current page.
-- Fields in blacklist are never to be displayed, i.e. module must return nil in all circumstances
-- Fields in whitelist return local value if it exists or the Wikidata value otherwise
-- The name of the field that this function is called from is passed in named parameter |name
-- The name is compulsory when blacklist or whitelist is used,
-- so the module returns nil if it is not supplied.
-- blacklist is passed in named parameter |suppressfields (or |spf)
-- whitelist is passed in named parameter |fetchwikidata (or |fwd)

require("strict")
local p = {}

local cdate -- initialise as nil and only load _complex_date function if needed
-- Module:Complex date is loaded lazily and has the following dependencies:
-- Module:Calendar
-- Module:ISOdate
-- Module:DateI18n
-- Module:I18n/complex date
-- Module:Ordinal
-- Module:I18n/ordinal
-- Module:Yesno
-- Module:Formatnum
-- Module:Linguistic
--
-- The following, taken from https://www.mediawiki.org/wiki/Wikibase/DataModel#Dates_and_times,
-- is needed to use Module:Complex date which seemingly requires date precision as a string.
-- It would work better if only the authors of the mediawiki page could spell 'millennium'.
local dp = {
	[6] = "millennium",
	[7] = "century",
	[8] = "decade",
	[9] = "year",
	[10] = "month",
	[11] = "day",
}

local i18n =
{
	["errors"] =
	{
		["property-not-found"] = "Property not found.",
		["No property supplied"] = "No property supplied",
		["entity-not-found"] = "Wikidata entity not found.",
		["unknown-claim-type"] = "Unknown claim type.",
		["unknown-entity-type"] = "Unknown entity type.",
		["qualifier-not-found"] = "Qualifier not found.",
		["site-not-found"] = "Wikimedia project not found.",
		["labels-not-found"] = "No labels found.",
		["descriptions-not-found"] = "No descriptions found.",
		["aliases-not-found"] = "No aliases found.",
		["unknown-datetime-format"] = "Unknown datetime format.",
		["local-article-not-found"] = "Article is available on Wikidata, but not on Wikipedia",
		["dab-page"] = " (dab)",
	},
	["months"] =
	{
		"January", "February", "March", "April", "May", "June",
		"July", "August", "September", "October", "November", "December"
	},
	["century"] = "century",
	["BC"] = "BC",
	["BCE"] = "BCE",
	["ordinal"] =
	{
		[1] = "st",
		[2] = "nd",
		[3] = "rd",
		["default"] = "th"
	},
	["filespace"] = "File",
	["Unknown"] = "Unknown",
	["NaN"] = "Not a number",
	-- set the following to the name of a tracking category,
	-- e.g. "[[Category:Articles with missing Wikidata information]]", or "" to disable:
	["missinginfocat"] = "[[Category:Articles with missing Wikidata information]]",
	["editonwikidata"] = "Edit this on Wikidata",
	["latestdatequalifier"] = function (date) return "before " .. date end,
	-- some languages, e.g. Bosnian use a period as a suffix after each number in a date
	["datenumbersuffix"] = "",
	["list separator"] = ", ",
	["multipliers"] = {
		[0]  = "",
		[3]  = " thousand",
		[6]  = " million",
		[9]  = " billion",
		[12] = " trillion",
	}
}
-- This allows an internationisation module to override the above table
if 'en' ~= mw.getContentLanguage():getCode() then
	require("Module:i18n").loadI18n("Module:WikidataIB/i18n", i18n)
end

-- This piece of html implements a collapsible container. Check the classes exist on your wiki.
local collapsediv = '&lt;div class="mw-collapsible mw-collapsed" style="width:100%; overflow:auto;" data-expandtext="{{int:show}}" data-collapsetext="{{int:hide}}"&gt;'

-- Some items should not be linked.
-- Each wiki can create a list of those in Module:WikidataIB/nolinks
-- It should return a table called itemsindex, containing true for each item not to be linked
local donotlink = {}
local nolinks_exists, nolinks = pcall(mw.loadData, "Module:WikidataIB/nolinks")
if nolinks_exists then
	donotlink = nolinks.itemsindex
end

-- To satisfy Wikipedia:Manual of Style/Titles, certain types of items are italicised, and others are quoted.
-- The submodule [[Module:WikidataIB/titleformats]] lists the entity-ids used in 'instance of' (P31),
-- which allows this module to identify the values that should be formatted.
-- WikidataIB/titleformats exports a table p.formats, which is indexed by entity-id, and contains the value " or ''
local formats = {}
local titleformats_exists, titleformats = pcall(mw.loadData, "Module:WikidataIB/titleformats")
if titleformats_exists then
	formats = titleformats.formats
end

-------------------------------------------------------------------------------
-- Private functions
-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------
-- makeOrdinal needs to be internationalised along with the above:
-- takes cardinal number as a numeric and returns the ordinal as a string
-- we need three exceptions in English for 1st, 2nd, 3rd, 21st, .. 31st, etc.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local makeOrdinal = function(cardinal)
	local ordsuffix = i18n.ordinal.default
	if cardinal % 10 == 1 then
		ordsuffix = i18n.ordinal[1]
	elseif cardinal % 10 == 2 then
		ordsuffix = i18n.ordinal[2]
	elseif cardinal % 10 == 3 then
		ordsuffix = i18n.ordinal[3]
	end
	-- In English, 1, 21, 31, etc. use 'st', but 11, 111, etc. use 'th'
	-- similarly for 12 and 13, etc.
	if (cardinal % 100 == 11) or (cardinal % 100 == 12) or (cardinal % 100 == 13) then
		ordsuffix = i18n.ordinal.default
	end
	return tostring(cardinal) .. ordsuffix
end


-------------------------------------------------------------------------------
-- findLang takes a "langcode" parameter if supplied and valid
-- otherwise it tries to create it from the user's set language ({{int:lang}})
-- failing that it uses the wiki's content language.
-- It returns a language object
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local findLang = function(langcode)
	local langobj
	langcode = mw.text.trim(langcode or "")
	if mw.language.isKnownLanguageTag(langcode) then
		langobj = mw.language.new( langcode )
	else
		langcode = mw.getCurrentFrame():callParserFunction('int', {'lang'})
		if mw.language.isKnownLanguageTag(langcode) then
			langobj = mw.language.new( langcode )
		else
			langobj = mw.language.getContentLanguage()
		end
	end
	return langobj
end


-------------------------------------------------------------------------------
-- _getItemLangCode takes a qid parameter (using the current page's qid if blank)
-- If the item for that qid has property country (P17) it looks at the first preferred value
-- If the country has an official language (P37), it looks at the first preferred value
-- If that official language has a language code (P424), it returns the first preferred value
-- Otherwise it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local _getItemLangCode = function(qid)
	qid = mw.text.trim(qid or ""):upper()
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return end
	local prop17 = mw.wikibase.getBestStatements(qid, "P17")[1]
	if not prop17 or prop17.mainsnak.snaktype ~= "value" then return end
	local qid17 = prop17.mainsnak.datavalue.value.id
	local prop37 = mw.wikibase.getBestStatements(qid17, "P37")[1]
	if not prop37 or prop37.mainsnak.snaktype ~= "value" then return end
	local qid37 = prop37.mainsnak.datavalue.value.id
	local prop424 = mw.wikibase.getBestStatements(qid37, "P424")[1]
	if not prop424 or prop424.mainsnak.snaktype ~= "value" then return end
	return prop424.mainsnak.datavalue.value
end


-------------------------------------------------------------------------------
-- roundto takes a number (x)
-- and returns it rounded to (sf) significant figures
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local roundto = function(x, sf)
	if x == 0 then return 0 end
	local s = 1
	if x &lt; 0 then
		x = -x
		s = -1
	end
	if sf &lt; 1 then sf = 1 end
	local p = 10 ^ (math.floor(math.log10(x)) - sf + 1)
	x = math.floor(x / p + 0.5) * p * s
	-- if it's integral, cast to an integer:
	if x == math.floor(x) then x = math.floor(x) end
	return x
end


-------------------------------------------------------------------------------
-- decimalToDMS takes a decimal degrees (x) with precision (p)
-- and returns degrees/minutes/seconds according to the precision
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local decimalToDMS = function(x, p)
	-- if p is not supplied, use a precision around 0.1 seconds
	if not tonumber(p) then p = 1e-4 end
	local d = math.floor(x)
	local ms = (x - d) * 60
	if p &gt; 0.5 then -- precision is &gt; 1/2 a degree
		if ms &gt; 30 then d = d + 1 end
		ms = 0
	end
	local m = math.floor(ms)
	local s = (ms - m) * 60
	if p &gt; 0.008 then -- precision is &gt; 1/2 a minute
		if s &gt; 30 then m = m +1 end
		s = 0
	elseif p &gt; 0.00014 then -- precision is &gt; 1/2 a second
		s = math.floor(s + 0.5)
	elseif p &gt; 0.000014 then -- precision is &gt; 1/20 second
		s = math.floor(10 * s + 0.5) / 10
	elseif p &gt; 0.0000014 then -- precision is &gt; 1/200 second
		s = math.floor(100 * s + 0.5) / 100
	else -- cap it at 3 dec places for now
		s = math.floor(1000 * s + 0.5) / 1000
	end
	return d, m, s
end


-------------------------------------------------------------------------------
-- decimalPrecision takes a decimal (x) with precision (p)
-- and returns x rounded approximately to the given precision
-- precision should be between 1 and 1e-6, preferably a power of 10.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local decimalPrecision = function(x, p)
	local s = 1
	if x &lt; 0 then
		x = -x
		s = -1
	end
	-- if p is not supplied, pick an arbitrary precision
	if not tonumber(p) then p = 1e-4
	elseif p &gt; 1 then p = 1
	elseif p &lt; 1e-6 then p = 1e-6
	else p = 10 ^ math.floor(math.log10(p))
	end
	x = math.floor(x / p + 0.5) * p * s
	-- if it's integral, cast to an integer:
	if  x == math.floor(x) then x = math.floor(x) end
	-- if it's less than 1e-4, it will be in exponent form, so return a string with 6dp
	-- 9e-5 becomes 0.000090
	if math.abs(x) &lt; 1e-4 then x = string.format("%f", x) end
	return x
end


-------------------------------------------------------------------------------
-- formatDate takes a datetime of the usual format from mw.wikibase.entity:formatPropertyValues
-- like "1 August 30 BCE" as parameter 1
-- and formats it according to the df (date format) and bc parameters
-- df = ["dmy" / "mdy" / "y"] default will be "dmy"
-- bc = ["BC" / "BCE"] default will be "BCE"
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local format_Date = function(datetime, dateformat, bc)
	local datetime = datetime or "1 August 30 BCE" -- in case of nil value
	-- chop off multiple vales and/or any hours, mins, etc.
	-- keep anything before punctuation - we just want a single date:
	local dateval = string.match( datetime, "[%w ]+")

	local dateformat = string.lower(dateformat or "dmy") -- default to dmy

	local bc = string.upper(bc or "") -- can't use nil for bc
	-- we only want to accept two possibilities: BC or default to BCE
	if bc == "BC" then
		bc = "&amp;nbsp;" .. i18n["BC"] -- prepend a non-breaking space.
	else
		bc = "&amp;nbsp;" .. i18n["BCE"]
	end

	local postchrist = true -- start by assuming no BCE
	local dateparts = {}
	for word in string.gmatch(dateval, "%w+") do
		if word == "BCE" or word == "BC" then -- *** internationalise later ***
			postchrist = false
		else
			-- we'll keep the parts that are not 'BCE' in a table
			dateparts[#dateparts + 1] = word
		end
	end
	if postchrist then bc = "" end -- set AD dates to no suffix *** internationalise later ***

	local sep = "&amp;nbsp;" -- separator is nbsp
	local fdate = table.concat(dateparts, sep) -- set formatted date to same order as input

	-- if we have day month year, check dateformat
	if #dateparts == 3 then
		if dateformat == "y" then
			fdate = dateparts[3]
		elseif dateformat == "mdy" then
			fdate = dateparts[2] .. sep .. dateparts[1] .. "," .. sep .. dateparts[3]
		end
	elseif #dateparts == 2 and dateformat == "y" then
		fdate = dateparts[2]
	end

	return fdate .. bc
end


-------------------------------------------------------------------------------
-- dateFormat is the handler for properties that are of type "time"
-- It takes timestamp, precision (6 to 11 per mediawiki), dateformat (y/dmy/mdy), BC format (BC/BCE),
-- a plaindate switch (yes/no/adj) to en/disable "sourcing circumstances"/use adjectival form,
-- any qualifiers for the property, the language, and any adjective to use like 'before'.
-- It passes the date through the "complex date" function
-- and returns a string with the internatonalised date formatted according to preferences.
-------------------------------------------------------------------------------
-- Dependencies: findLang(); cdate(); dp[]
-------------------------------------------------------------------------------
local dateFormat = function(timestamp, dprec, df, bcf, pd, qualifiers, lang, adj, model)
	-- output formatting according to preferences (y/dmy/mdy/ymd)
	df = (df or ""):lower()
	-- if ymd is required, return the part of the timestamp in YYYY-MM-DD form
	-- but apply Year zero#Astronomers fix: 1 BC = 0000; 2 BC = -0001; etc.
	if df == "ymd" then
		if timestamp:sub(1,1) == "+" then
			return timestamp:sub(2,11)
		else
			local yr = tonumber(timestamp:sub(2,5)) - 1
			yr = ("000" .. yr):sub(-4)
			if yr ~= "0000" then yr = "-" .. yr end
			return yr .. timestamp:sub(6,11)
		end
	end
	-- A year can be stored like this: "+1872-00-00T00:00:00Z",
	-- which is processed here as if it were the day before "+1872-01-01T00:00:00Z",
	-- and that's the last day of 1871, so the year is wrong.
	-- So fix the month 0, day 0 timestamp to become 1 January instead:
	timestamp = timestamp:gsub("%-00%-00T", "-01-01T")
	-- just in case date precision is missing
	dprec = dprec or 11
	-- override more precise dates if required dateformat is year alone:
	if df == "y" and dprec &gt; 9 then dprec = 9 end
	-- complex date only deals with precisions from 6 to 11, so clip range
	dprec = dprec&gt;11 and 11 or dprec
	dprec = dprec&lt;6 and 6 or dprec
	-- BC format is "BC" or "BCE"
	bcf = (bcf or ""):upper()
	-- plaindate only needs the first letter (y/n/a)
	pd = (pd or ""):sub(1,1):lower()
	if pd == "" or pd == "n" or pd == "f" or pd == "0" then pd = false end
	-- in case language isn't passed
	lang = lang or findLang().code
	-- set adj as empty if nil
	adj = adj or ""
	-- extract the day, month, year from the timestamp
	local bc = timestamp:sub(1, 1)=="-" and "BC" or ""
	local year, month, day = timestamp:match("[+-](%d*)-(%d*)-(%d*)T")
	local iso = tonumber(year) -- if year is missing, let it throw an error
	-- this will adjust the date format to be compatible with cdate
	-- possible formats are Y, YY, YYY0, YYYY, YYYY-MM, YYYY-MM-DD
	if dprec == 6 then iso = math.floor( (iso - 1) / 1000 ) + 1 end
	if dprec == 7 then iso = math.floor( (iso - 1) / 100 ) + 1 end
	if dprec == 8 then iso = math.floor( iso / 10 ) .. "0" end
	if dprec == 10 then iso = year .. "-" .. month end
	if dprec == 11 then iso = year .. "-" .. month .. "-" .. day end
	-- add "circa" (Q5727902) from "sourcing circumstances" (P1480)
	local sc = not pd and qualifiers and qualifiers.P1480
	if sc then
		for k1, v1 in pairs(sc) do
			if v1.datavalue and v1.datavalue.value.id == "Q5727902" then
				adj = "circa"
				break
			end
		end
	end
	-- deal with Julian dates:
	-- no point in saying that dates before 1582 are Julian - they are by default
	-- doesn't make sense for dates less precise than year
	-- we can suppress it by setting |plaindate, e.g. for use in constructing categories.
	local calendarmodel = ""
	if tonumber(year) &gt; 1582
		and dprec &gt; 8
		and not pd
		and model == "http://www.wikidata.org/entity/Q1985786" then
		calendarmodel = "julian"
	end
	if not cdate then
		cdate = require("Module:Complex date")._complex_date
	end
	local fdate = cdate(calendarmodel, adj, tostring(iso), dp[dprec], bc, "", "", "", "", lang, 1)
	-- this may have QuickStatements info appended to it in a div, so remove that
	fdate = fdate:gsub(' &lt;div style="display: none;"&gt;[^&lt;]*&lt;/div&gt;', '')
	-- it may also be returned wrapped in a microformat, so remove that
	fdate = fdate:gsub("&lt;[^&gt;]*&gt;", "")
	-- there may be leading zeros that we should remove
	fdate = fdate:gsub("^0*", "")
	-- if a plain date is required, then remove any links (like BC linked)
	if pd then
		fdate = fdate:gsub("%[%[.*|", ""):gsub("]]", "")
	end
	-- if 'circa', use the abbreviated form *** internationalise later ***
	fdate = fdate:gsub('circa ', '&lt;abbr title="circa"&gt;c.&lt;/abbr&gt;&amp;nbsp;')
	-- deal with BC/BCE
	if bcf == "BCE" then
		fdate = fdate:gsub('BC', 'BCE')
	end
	-- deal with mdy format
	if df == "mdy" then
		fdate = fdate:gsub("(%d+) (%w+) (%d+)", "%2 %1, %3")
	end
	-- deal with adjectival form *** internationalise later ***
	if pd == "a" then
		fdate = fdate:gsub(' century', '-century')
	end
	return fdate
end


-------------------------------------------------------------------------------
-- parseParam takes a (string) parameter, e.g. from the list of frame arguments,
-- and makes "false", "no", and "0" into the (boolean) false
-- it makes the empty string and nil into the (boolean) value passed as default
-- allowing the parameter to be true or false by default.
-- It returns a boolean.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local parseParam = function(param, default)
	if type(param) == "boolean" then param = tostring(param) end
	if param and param ~= "" then
		param = param:lower()
		if (param == "false") or (param:sub(1,1) == "n") or (param == "0") then
			return false
		else
			return true
		end
	else
		return default
	end
end


-------------------------------------------------------------------------------
-- _getSitelink takes the qid of a Wikidata entity passed as |qid=
-- It takes an optional parameter |wiki= to determine which wiki is to be checked for a sitelink
-- If the parameter is blank, then it uses the local wiki.
-- If there is a sitelink to an article available, it returns the plain text link to the article
-- If there is no sitelink, it returns nil.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local _getSitelink = function(qid, wiki)
	qid = (qid or ""):upper()
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return nil end
	wiki = wiki or ""
	local sitelink
	if wiki == "" then
		sitelink = mw.wikibase.getSitelink(qid)
	else
		sitelink = mw.wikibase.getSitelink(qid, wiki)
	end
	return sitelink
end


-------------------------------------------------------------------------------
-- _getCommonslink takes an optional qid of a Wikidata entity passed as |qid=
-- It returns one of the following in order of preference:
-- 	the Commons sitelink of the Wikidata entity - but not if onlycat=true and it's not a category;
-- 	the Commons sitelink of the topic's main category of the Wikidata entity;
-- 	the Commons category of the Wikidata entity - unless fallback=false.
-------------------------------------------------------------------------------
-- Dependencies: _getSitelink(); parseParam()
-------------------------------------------------------------------------------
local _getCommonslink = function(qid, onlycat, fallback)
	qid = (qid or ""):upper()
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return nil end
	onlycat = parseParam(onlycat, false)
	if fallback == "" then fallback = nil end
	local sitelink = _getSitelink(qid, "commonswiki")
	if onlycat and sitelink and sitelink:sub(1,9) ~= "Category:" then sitelink = nil end
	if not sitelink then
		-- check for topic's main category
		local prop910 = mw.wikibase.getBestStatements(qid, "P910")[1]
		if prop910 then
			local tmcid = prop910.mainsnak.datavalue and prop910.mainsnak.datavalue.value.id
			sitelink = _getSitelink(tmcid, "commonswiki")
		end
		if not sitelink then
			-- check for list's main category
			local prop1754 = mw.wikibase.getBestStatements(qid, "P1754")[1]
			if prop1754 then
				local tmcid = prop1754.mainsnak.datavalue and prop1754.mainsnak.datavalue.value.id
				sitelink = _getSitelink(tmcid, "commonswiki")
			end
		end
	end
	if not sitelink and fallback then
		-- check for Commons category (string value)
		local prop373 = mw.wikibase.getBestStatements(qid, "P373")[1]
		if prop373 then
			sitelink = prop373.mainsnak.datavalue and prop373.mainsnak.datavalue.value
			if sitelink then sitelink = "Category:" .. sitelink end
		end
	end
	return sitelink
end


-------------------------------------------------------------------------------
-- The label in a Wikidata item is subject to vulnerabilities
-- that an attacker might try to exploit.
-- It needs to be 'sanitised' by removing any wikitext before use.
-- If it doesn't exist, return the id for the item
-- a second (boolean) value is also returned, value is true when the label exists
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local labelOrId = function(id, lang)
	if lang == "default" then lang = findLang().code end
	local label
	if lang then
		label = mw.wikibase.getLabelByLang(id, lang)
	else
		label = mw.wikibase.getLabel(id)
	end
	if label then
		return mw.text.nowiki(label), true
	else
		return id, false
	end
end


-------------------------------------------------------------------------------
-- linkedItem takes an entity-id and returns a string, linked if possible.
-- This is the handler for "wikibase-item". Preferences:
-- 1. Display linked disambiguated sitelink if it exists
-- 2. Display linked label if it is a redirect
-- 3. TBA: Display an inter-language link for the label if it exists other than in default language
-- 4. Display unlinked label if it exists
-- 5. Display entity-id for now to indicate a label could be provided
-- dtxt is text to be used instead of label, or nil.
-- shortname is boolean switch to use P1813 (short name) instead of label if true.
-- lang is the current language code.
-- uselbl is boolean switch to force display of the label instead of the sitelink (default: false)
-- linkredir is boolean switch to allow linking to a redirect (default: false)
-- formatvalue is boolean switch to allow formatting as italics or quoted (default: false)
-------------------------------------------------------------------------------
-- Dependencies: labelOrId(); donotlink[]
-------------------------------------------------------------------------------
local linkedItem = function(id, args)
	local lprefix = (args.lp or args.lprefix or args.linkprefix or ""):gsub('"', '') -- toughen against nil values passed
	local lpostfix = (args.lpostfix or ""):gsub('"', '')
	local prefix = (args.prefix or ""):gsub('"', '')
	local postfix = (args.postfix or ""):gsub('"', '')
	local dtxt = args.dtxt
	local shortname = args.shortname or args.sn
	local lang = args.lang or "en" -- fallback to default if missing
	local uselbl = args.uselabel or args.uselbl
	uselbl = parseParam(uselbl, false)
	local linkredir = args.linkredir
	linkredir = parseParam(linkredir, false)
	local formatvalue = args.formatvalue or args.fv
	formatvalue = parseParam(formatvalue, false)
	-- see if item might need italics or quotes
	local fmt = ""
	if next(formats) and formatvalue then
		for k, v in ipairs( mw.wikibase.getBestStatements(id, "P31") ) do
			if v.mainsnak.datavalue and formats[v.mainsnak.datavalue.value.id] then
				fmt = formats[v.mainsnak.datavalue.value.id]
				break -- pick the first match
			end
		end
	end
	local disp
	local sitelink = mw.wikibase.getSitelink(id)
	local label, islabel
	if dtxt then
		label, islabel = dtxt, true
	elseif shortname then
		-- see if there is a shortname in our language, and set label to it
		for k, v in ipairs( mw.wikibase.getBestStatements(id, "P1813") ) do
			if v.mainsnak.datavalue.value.language == lang then
				label, islabel = v.mainsnak.datavalue.value.text, true
				break
			end -- test for language match
		end -- loop through values of short name
		-- if we have no label set, then there was no shortname available
		if not islabel then
			label, islabel = labelOrId(id)
			shortname = false
		end
	else
		label, islabel = labelOrId(id)
	end
	if mw.site.siteName ~= "Wikimedia Commons" then
		if sitelink then
			if not (dtxt or shortname) then
				-- if sitelink and label are the same except for case, no need to process further
				if sitelink:lower() ~= label:lower() then
					-- strip any namespace or dab from the sitelink
					local pos = sitelink:find(":") or 0
					local slink = sitelink
					if pos &gt; 0 then
						local pfx = sitelink:sub(1,pos-1)
						if mw.site.namespaces[pfx] then -- that prefix is a valid namespace, so remove it
							slink = sitelink:sub(pos+1)
						end
					end
					-- remove stuff after commas or inside parentheses - ie. dabs
					slink = slink:gsub("%s%(.+%)$", ""):gsub(",.+$", "")
					-- if uselbl is false, use sitelink instead of label
					if not uselbl then
						--  use slink as display, preserving label case - find("^%u") is true for 1st char uppercase
						if label:find("^%u") then
							label = slink:gsub("^(%l)", string.upper)
						else
							label = slink:gsub("^(%u)", string.lower)
						end
					end
				end
			end
			if donotlink[label] then
				disp = prefix .. fmt .. label .. fmt .. postfix
			else
				disp = "[[" .. lprefix .. sitelink .. lpostfix .. "|" .. prefix .. fmt .. label .. fmt .. postfix .. "]]"
			end
		elseif islabel then
			-- no sitelink, label exists, so check if a redirect with that title exists, if linkredir is true
			-- display plain label by default
			disp = prefix .. fmt .. label .. fmt .. postfix
			if linkredir then
				local artitle = mw.title.new(label, 0) -- only nil if label has invalid chars
				if not donotlink[label] and artitle and artitle.redirectTarget then
					-- there's a redirect with the same title as the label, so let's link to that
					disp = "[[".. lprefix .. label .. lpostfix .. "|" .. prefix .. fmt .. label .. fmt .. postfix .. "]]"
				end
			end -- test if article title exists as redirect on current Wiki
		else
			-- no sitelink and no label, so return whatever was returned from labelOrId for now
			-- add tracking category [[Category:Articles with missing Wikidata information]]
			-- for enwiki, just return the tracking category
			if mw.wikibase.getGlobalSiteId() == "enwiki" then
				disp = i18n.missinginfocat
			else
				disp = prefix .. label .. postfix .. i18n.missinginfocat
			end
		end
	else
		local ccat = mw.wikibase.getBestStatements(id, "P373")[1]
		if ccat and ccat.mainsnak.datavalue then
			ccat = ccat.mainsnak.datavalue.value
			disp = "[[" .. lprefix .. "Category:" .. ccat .. lpostfix .. "|" .. prefix .. label .. postfix .. "]]"
		elseif sitelink then
			-- this asumes that if a sitelink exists, then a label also exists
			disp = "[[" .. lprefix .. sitelink .. lpostfix .. "|" .. prefix .. label .. postfix .. "]]"
		else
			-- no sitelink and no Commons cat, so return label from labelOrId for now
			disp = prefix .. label .. postfix
		end
	end
	return disp
end


-------------------------------------------------------------------------------
-- sourced takes a table representing a statement that may or may not have references
-- it looks for a reference sourced to something not containing the word "wikipedia"
-- it returns a boolean = true if it finds a sourced reference.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local sourced = function(claim)
	if claim.references then
		for kr, vr in pairs(claim.references) do
			local ref = mw.wikibase.renderSnaks(vr.snaks)
			if not ref:find("Wiki") then
				return true
			end
		end
	end
end


-------------------------------------------------------------------------------
-- setRanks takes a flag (parameter passed) that requests the values to return
-- "b[est]" returns preferred if available, otherwise normal
-- "p[referred]" returns preferred
-- "n[ormal]" returns normal
-- "d[eprecated]" returns deprecated
-- multiple values are allowed, e.g. "preferred normal" (which is the default)
-- "best" will override the other flags, and set p and n
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local setRanks = function(rank)
	rank = (rank or ""):lower()
	-- if nothing passed, return preferred and normal
	-- if rank == "" then rank = "p n" end
	local ranks = {}
	for w in string.gmatch(rank, "%a+") do
		w = w:sub(1,1)
		if w == "b" or w == "p" or w == "n" or w == "d" then
			ranks[w] = true
		end
	end
	-- check if "best" is requested or no ranks requested; and if so, set preferred and normal
	if ranks.b or not next(ranks) then
		ranks.p = true
		ranks.n = true
	end
	return ranks
end


-------------------------------------------------------------------------------
-- parseInput processes the Q-id , the blacklist and the whitelist
-- if an input parameter is supplied, it returns that and ends the call.
-- it returns (1) either the qid or nil indicating whether or not the call should continue
-- and (2) a table containing all of the statements for the propertyID and relevant Qid
-- if "best" ranks are requested, it returns those instead of all non-deprecated ranks
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local parseInput = function(frame, input_parm, property_id)
	-- There may be a local parameter supplied, if it's blank, set it to nil
	input_parm = mw.text.trim(input_parm or "")
	if input_parm == "" then input_parm = nil end

	-- return nil if Wikidata is not available
	if not mw.wikibase then return false, input_parm end

	local args = frame.args

	-- can take a named parameter |qid which is the Wikidata ID for the article.
	-- if it's not supplied, use the id for the current page
	local qid = args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	-- if there's no Wikidata item for the current page return nil
	if not qid then return false, input_parm end

	-- The blacklist is passed in named parameter |suppressfields
	local blacklist = args.suppressfields or args.spf or ""

	-- The whitelist is passed in named parameter |fetchwikidata
	local whitelist = args.fetchwikidata or args.fwd or ""
	if whitelist == "" then whitelist = "NONE" end

	-- The name of the field that this function is called from is passed in named parameter |name
	local fieldname = args.name or ""

	if blacklist ~= "" then
		-- The name is compulsory when blacklist is used, so return nil if it is not supplied
		if fieldname == "" then return false, nil end
		-- If this field is on the blacklist, then return nil
		if blacklist:find(fieldname) then return false, nil end
	end

	-- If we got this far then we're not on the blacklist
	-- The blacklist overrides any locally supplied parameter as well
	-- If a non-blank input parameter was supplied return it
	if input_parm then return false, input_parm end

	-- We can filter out non-valid properties
	if property_id:sub(1,1):upper() ~="P" or property_id == "P0" then return false, nil end

	-- Otherwise see if this field is on the whitelist:
	-- needs a bit more logic because find will return its second value = 0 if fieldname is ""
	-- but nil if fieldname not found on whitelist
	local _, found = whitelist:find(fieldname)
	found = ((found or 0) &gt; 0)
	if whitelist ~= 'ALL' and (whitelist:upper() == "NONE" or not found) then
		return false, nil
	end

	-- See what's on Wikidata (the call always returns a table, but it may be empty):
	local props = {}
	if args.reqranks.b then
		props = mw.wikibase.getBestStatements(qid, property_id)
	else
		props = mw.wikibase.getAllStatements(qid, property_id)
	end
	if props[1] then
		return qid, props
	end
	-- no property on Wikidata
	return false, nil
end


-------------------------------------------------------------------------------
-- createicon assembles the "Edit at Wikidata" pen icon.
-- It returns a wikitext string inside a span class="penicon"
-- if entityID is nil or empty, the ID associated with current page is used
-- langcode and propertyID may be nil or empty
-------------------------------------------------------------------------------
-- Dependencies: i18n[];
-------------------------------------------------------------------------------
local createicon = function(langcode, entityID, propertyID)
	langcode = langcode or ""
	if not entityID or entityID == "" then entityID= mw.wikibase.getEntityIdForCurrentPage() end
	propertyID = propertyID or ""
	local icon = "&amp;nbsp;&lt;span class='penicon autoconfirmed-show'&gt;[["
	-- "&amp;nbsp;&lt;span data-bridge-edit-flow='overwrite' class='penicon'&gt;[[" -&gt; enable Wikidata Bridge
	.. i18n["filespace"]
	.. ":OOjs UI icon edit-ltr-progressive.svg |frameless |text-top |10px |alt="
	.. i18n["editonwikidata"]
	.. "|link=https://www.wikidata.org/wiki/" .. entityID
	if langcode ~= "" then icon = icon .. "?uselang=" .. langcode end
	if propertyID ~= "" then icon = icon .. "#" .. propertyID end
	icon = icon .. "|" .. i18n["editonwikidata"] .. "]]&lt;/span&gt;"
	return icon
end


-------------------------------------------------------------------------------
-- assembleoutput takes the sequence table containing the property values
-- and formats it according to switches given. It returns a string or nil.
-- It uses the entityID (and optionally propertyID) to create a link in the pen icon.
-------------------------------------------------------------------------------
-- Dependencies: parseParam();
-------------------------------------------------------------------------------
local assembleoutput = function(out, args, entityID, propertyID)

	-- sorted is a boolean passed to enable sorting of the values returned
	-- if nothing or an empty string is passed set it false
	-- if "false" or "no" or "0" is passed set it false
	local sorted = parseParam(args.sorted, false)

	-- noicon is a boolean passed to suppress the trailing "edit at Wikidata" icon
	-- for use when the value is processed further by the infobox
	-- if nothing or an empty string is passed set it false
	-- if "false" or "no" or "0" is passed set it false
	local noic = parseParam(args.noicon, false)

	-- list is the name of a template that a list of multiple values is passed through
	-- examples include "hlist" and "ubl"
	-- setting it to "prose" produces something like "1, 2, 3, and 4"
	local list = args.list or ""

	-- sep is a string that is used to separate multiple returned values
	-- if nothing or an empty string is passed set it to the default
	-- any double-quotes " are stripped out, so that spaces may be passed
	-- e.g. |sep=" - "
	local sepdefault = i18n["list separator"]
	local separator = args.sep or ""
	separator = string.gsub(separator, '"', '')
	if separator == "" then
		separator = sepdefault
	end

	-- collapse is a number that determines the maximum number of returned values
	-- before the output is collapsed.
	-- Zero or not a number result in no collapsing (default becomes 0).
	local collapse = tonumber(args.collapse) or 0

	-- replacetext (rt) is a string that is returned instead of any non-empty Wikidata value
	-- this is useful for tracking and debugging
	local replacetext = mw.text.trim(args.rt or args.replacetext or "")

	-- if there's anything to return, then return a list
	-- comma-separated by default, but may be specified by the sep parameter
	-- optionally specify a hlist or ubl or a prose list, etc.
	local strout
	if #out &gt; 0 then
		if sorted then table.sort(out) end
		-- if there's something to display and a pen icon is wanted, add it the end of the last value
		local hasdisplay = false
		for i, v in ipairs(out) do
			if v ~= i18n.missinginfocat then
				hasdisplay = true
				break
			end
		end
		if not noic and hasdisplay then
			out[#out] = out[#out] .. createicon(args.langobj.code, entityID, propertyID)
		end
		if list == "" then
			strout = table.concat(out, separator)
		elseif list:lower() == "prose" then
			strout = mw.text.listToText( out )
		else
			strout = mw.getCurrentFrame():expandTemplate{title = list, args = out}
		end
		if collapse &gt;0 and #out &gt; collapse then
			strout = collapsediv .. strout .. "&lt;/div&gt;"
		end
	else
		strout = nil -- no items had valid reference
	end
	if replacetext ~= "" and strout then strout = replacetext end
	return strout
end


-------------------------------------------------------------------------------
-- rendersnak takes a table (propval) containing the information stored on one property value
-- and returns the value as a string and its language if monolingual text.
-- It handles data of type:
--		wikibase-item
--		time
--		string, url, commonsMedia, external-id
--		quantity
--		globe-coordinate
--		monolingualtext
-- It also requires linked, the link/pre/postfixes, uabbr, and the arguments passed from frame.
-- The optional filter parameter allows quantities to be be filtered by unit Qid.
-------------------------------------------------------------------------------
-- Dependencies: parseParam(); labelOrId(); i18n[]; dateFormat();
-- roundto(); decimalPrecision(); decimalToDMS(); linkedItem();
-------------------------------------------------------------------------------
local rendersnak = function(propval, args, linked, lpre, lpost, pre, post, uabbr, filter)
	lpre = lpre or ""
	lpost = lpost or ""
	pre = pre or ""
	post = post or ""
	args.lang = args.lang or findLang().code
	-- allow values to display a fixed text instead of label
	local dtxt = args.displaytext or args.dt
	if dtxt == "" then dtxt = nil end
	-- switch to use display of short name (P1813) instead of label
	local shortname = args.shortname or args.sn
	shortname = parseParam(shortname, false)
	local snak = propval.mainsnak or propval
	local dtype = snak.datatype
	local dv = snak.datavalue
	dv = dv and dv.value
	-- value and monolingual text language code returned
	local val, mlt
	if propval.rank and not args.reqranks[propval.rank:sub(1, 1)] then
		-- val is nil: value has a rank that isn't requested
		------------------------------------
	elseif snak.snaktype == "somevalue" then -- value is unknown
		val = i18n["Unknown"]
		------------------------------------
	elseif snak.snaktype == "novalue" then -- value is none
		-- val = "No value" -- don't return anything
		------------------------------------
	elseif dtype == "wikibase-item" then -- data type is a wikibase item:
		-- it's wiki-linked value, so output as link if enabled and possible
		local qnumber = dv.id
		if linked then
			val = linkedItem(qnumber, args)
		else -- no link wanted so check for display-text, otherwise test for lang code
			local label, islabel
			if dtxt then
				label = dtxt
			else
				label, islabel = labelOrId(qnumber)
				local langlabel = mw.wikibase.getLabelByLang(qnumber, args.lang)
				if langlabel then
					label = mw.text.nowiki( langlabel )
				end
			end
			val = pre .. label .. post
		end -- test for link required
		------------------------------------
	elseif dtype == "time" then -- data type is time:
		-- time is in timestamp format
		-- date precision is integer per mediawiki
		-- output formatting according to preferences (y/dmy/mdy)
		-- BC format as BC or BCE
		-- plaindate is passed to disable looking for "sourcing cirumstances"
		-- or to set the adjectival form
		-- qualifiers (if any) is a nested table or nil
		-- lang is given, or user language, or site language
		--
		-- Here we can check whether args.df has a value
		-- If not, use code from Module:Sandbox/RexxS/Getdateformat to set it from templates like {{Use mdy dates}}
		val = dateFormat(dv.time, dv.precision, args.df, args.bc, args.pd, propval.qualifiers, args.lang, "", dv.calendarmodel)
		------------------------------------
	-- data types which are strings:
	elseif dtype == "commonsMedia" or dtype == "external-id" or dtype == "string" or dtype == "url" then
		-- commonsMedia or external-id or string or url
		-- all have mainsnak.datavalue.value as string
		if (lpre == "" or lpre == ":") and lpost == "" then
			-- don't link if no linkpre/postfix or linkprefix is just ":"
			val = pre .. dv .. post
		elseif dtype == "external-id" then
			val = "[" .. lpre .. dv .. lpost .. " " .. pre .. dv .. post .. "]"
		else
			val = "[[" .. lpre .. dv .. lpost .. "|" .. pre .. dv .. post .. "]]"
		end -- check for link requested (i.e. either linkprefix or linkpostfix exists)
		------------------------------------
	-- data types which are quantities:
	elseif dtype == "quantity" then
		-- quantities have mainsnak.datavalue.value.amount and mainsnak.datavalue.value.unit
		-- the unit is of the form http://www.wikidata.org/entity/Q829073
		--
		-- implement a switch to turn on/off numerical formatting later
		local fnum = true
		--
		-- a switch to turn on/off conversions - only for en-wiki
		local conv = parseParam(args.conv or args.convert, false)
		-- if we have conversions, we won't have formatted numbers or scales
		if conv then
			uabbr = true
			fnum = false
			args.scale = "0"
		end
		--
		-- a switch to turn on/off showing units, default is true
		local showunits = parseParam(args.su or args.showunits, true)
		--
		-- convert amount to a number
		local amount = tonumber(dv.amount) or i18n["NaN"]
		--
		-- scale factor for millions, billions, etc.
		local sc = tostring(args.scale or ""):sub(1,1):lower()
		local scale
		if sc == "a" then
			-- automatic scaling
			if amount &gt; 1e15 then
				scale = 12
			elseif amount &gt; 1e12 then
				scale = 9
			elseif amount &gt; 1e9 then
				scale = 6
			elseif amount &gt; 1e6 then
				scale = 3
			else
				scale = 0
			end
		else
			scale = tonumber(args.scale) or 0
			if scale &lt; 0 or scale &gt; 12 then scale = 0 end
			scale = math.floor(scale/3) * 3
		end
		local factor = 10^scale
		amount = amount / factor
		-- ranges:
		local range = ""
		-- check if upper and/or lower bounds are given and significant
		local upb = tonumber(dv.upperBound)
		local lowb = tonumber(dv.lowerBound)
		if upb and lowb then
			-- differences rounded to 2 sig fig:
			local posdif = roundto(upb - amount, 2) / factor
			local negdif = roundto(amount - lowb, 2) / factor
			upb, lowb = amount + posdif, amount - negdif
			-- round scaled numbers to integers or 4 sig fig
			if (scale &gt; 0 or sc == "a") then
				if amount &lt; 1e4 then
					amount = roundto(amount, 4)
				else
					amount = math.floor(amount + 0.5)
				end
			end
			if fnum then amount = args.langobj:formatNum( amount ) end
			if posdif ~= negdif then
				-- non-symmetrical
				range = " +" .. posdif .. " -" .. negdif
			elseif posdif ~= 0 then
				-- symmetrical and non-zero
				range = " ±" .. posdif
			else
				-- otherwise range is zero, so leave it as ""
			end
		else
			-- round scaled numbers to integers or 4 sig fig
			if (scale &gt; 0 or sc == "a") then
				if amount &lt; 1e4 then
					amount = roundto(amount, 4)
				else
					amount = math.floor(amount + 0.5)
				end
			end
			if fnum then amount = args.langobj:formatNum( amount ) end
		end
		-- unit names and symbols:
		-- extract the qid in the form 'Qnnn' from the value.unit url
		-- and then fetch the label from that - or symbol if unitabbr is true
		local unit = ""
		local usep = ""
		local usym = ""
		local unitqid = string.match( dv.unit, "(Q%d+)" )
		if filter and unitqid ~= filter then return nil end
		if unitqid and showunits then
			local uname = mw.wikibase.getLabelByLang(unitqid, args.lang) or ""
			if uname ~= "" then usep, unit = " ", uname end
			if uabbr then
				-- see if there's a unit symbol (P5061)
				local unitsymbols = mw.wikibase.getBestStatements(unitqid, "P5061")
				-- construct fallback table, add local lang and multiple languages
				local fbtbl = mw.language.getFallbacksFor( args.lang )
				table.insert( fbtbl, 1, args.lang )
				table.insert( fbtbl, 1, "mul" )
				local found = false
				for idx1, us in ipairs(unitsymbols) do
					for idx2, fblang in ipairs(fbtbl) do
						if us.mainsnak.datavalue.value.language == fblang then
							usym = us.mainsnak.datavalue.value.text
							found = true
							break
						end
					if found then break end
					end -- loop through fallback table
				end -- loop through values of P5061
				if found then usep, unit = "&amp;nbsp;", usym end
			end
		end
		-- format display:
		if conv then
			if range == "" then
				val = mw.getCurrentFrame():expandTemplate{title = "cvt", args = {amount, unit}}
			else
				val = mw.getCurrentFrame():expandTemplate{title = "cvt", args = {lowb, "to", upb, unit}}
			end
		elseif unit == "$" or unit == "£" then
			val = unit .. amount .. range .. i18n.multipliers[scale]
		else
			val = amount .. range .. i18n.multipliers[scale] .. usep .. unit
		end
		------------------------------------
	-- datatypes which are global coordinates:
	elseif dtype == "globe-coordinate" then
		-- 'display' parameter defaults to "inline, title" *** unused for now ***
		-- local disp = args.display or ""
		-- if disp == "" then disp = "inline, title" end
		--
		-- format parameter switches from deg/min/sec to decimal degrees
		-- default is deg/min/sec -- decimal degrees needs |format = dec
		local form = (args.format or ""):lower():sub(1,3)
		if form ~= "dec" then form = "dms" end -- not needed for now
		--
		-- show parameter allows just the latitude, or just the longitude, or both
		-- to be returned as a signed decimal, ignoring the format parameter.
		local show = (args.show or ""):lower()
		if show ~= "longlat" then show = show:sub(1,3) end
		--
		local lat, long, prec = dv.latitude, dv.longitude, dv.precision
		if show == "lat" then
			val = decimalPrecision(lat, prec)
		elseif show == "lon" then
			val = decimalPrecision(long, prec)
		elseif show == "longlat" then
			val = decimalPrecision(long, prec) .. ", " .. decimalPrecision(lat, prec)
		else
			local ns = "N"
			local ew = "E"
			if lat &lt; 0 then
				ns = "S"
				lat = - lat
			end
			if long &lt; 0 then
				ew = "W"
				long = - long
			end
			if form == "dec" then
				lat = decimalPrecision(lat, prec)
				long = decimalPrecision(long, prec)
				val = lat .. "°" .. ns .. " " .. long ..  "°" .. ew
			else
				local latdeg, latmin, latsec = decimalToDMS(lat, prec)
				local longdeg, longmin, longsec = decimalToDMS(long, prec)

				if latsec == 0 and longsec == 0 then
					if latmin == 0 and longmin == 0 then
						val = latdeg .. "°" .. ns .. " " .. longdeg ..  "°" .. ew
					else
						val = latdeg .. "°" .. latmin .. "′" .. ns .. " "
						val = val .. longdeg .. "°".. longmin .. "′" .. ew
					end
				else
					val = latdeg .. "°" .. latmin .. "′" .. latsec .. "″" .. ns .. " "
					val = val .. longdeg .. "°" .. longmin .. "′" .. longsec .. "″" .. ew
				end
			end
		end
		------------------------------------
	elseif dtype == "monolingualtext" then -- data type is Monolingual text:
		-- has mainsnak.datavalue.value as a table containing language/text pairs
		-- collect all the values in 'out' and languages in 'mlt' and process them later
		val = pre .. dv.text .. post
		mlt = dv.language
		------------------------------------
	else
		-- some other data type so write a specific handler
		val = "unknown data type: " .. dtype
	end -- of datatype/unknown value/sourced check
	return val, mlt
end


-------------------------------------------------------------------------------
-- propertyvalueandquals takes a property object, the arguments passed from frame,
-- and a qualifier propertyID.
-- It returns a sequence (table) of values representing the values of that property
-- and qualifiers that match the qualifierID if supplied.
-------------------------------------------------------------------------------
-- Dependencies: parseParam(); sourced(); labelOrId(); i18n.latestdatequalifier(); format_Date();
-- makeOrdinal(); roundto(); decimalPrecision(); decimalToDMS(); assembleoutput();
-------------------------------------------------------------------------------
local function propertyvalueandquals(objproperty, args, qualID)
	-- needs this style of declaration because it's re-entrant

	-- onlysourced is a boolean passed to return only values sourced to other than Wikipedia
	-- if nothing or an empty string is passed set it true
	local onlysrc = parseParam(args.onlysourced or args.osd, true)

	-- linked is a a boolean that enables the link to a local page via sitelink
	-- if nothing or an empty string is passed set it true
	local linked = parseParam(args.linked, true)

	-- prefix is a string that may be nil, empty (""), or a string of characters
	-- this is prefixed to each value
	-- useful when when multiple values are returned
	-- any double-quotes " are stripped out, so that spaces may be passed
	local prefix = (args.prefix or ""):gsub('"', '')

	-- postfix is a string that may be nil, empty (""), or a string of characters
	-- this is postfixed to each value
	-- useful when when multiple values are returned
	-- any double-quotes " are stripped out, so that spaces may be passed
	local postfix = (args.postfix or ""):gsub('"', '')

	-- linkprefix is a string that may be nil, empty (""), or a string of characters
	-- this creates a link and is then prefixed to each value
	-- useful when when multiple values are returned and indirect links are needed
	-- any double-quotes " are stripped out, so that spaces may be passed
	local lprefix = (args.linkprefix or args.lp or ""):gsub('"', '')

	-- linkpostfix is a string that may be nil, empty (""), or a string of characters
	-- this is postfixed to each value when linking is enabled with lprefix
	-- useful when when multiple values are returned
	-- any double-quotes " are stripped out, so that spaces may be passed
	local lpostfix = (args.linkpostfix or ""):gsub('"', '')

	-- wdlinks is a boolean passed to enable links to Wikidata when no article exists
	-- if nothing or an empty string is passed set it false
	local wdl = parseParam(args.wdlinks or args.wdl, false)

	-- unitabbr is a boolean passed to enable unit abbreviations for common units
	-- if nothing or an empty string is passed set it false
	local uabbr = parseParam(args.unitabbr or args.uabbr, false)

	-- qualsonly is a boolean passed to return just the qualifiers
	-- if nothing or an empty string is passed set it false
	local qualsonly = parseParam(args.qualsonly or args.qo, false)

	-- maxvals is a string that may be nil, empty (""), or a number
	-- this determines how many items may be returned when multiple values are available
	-- setting it = 1 is useful where the returned string is used within another call, e.g. image
	local maxvals = tonumber(args.maxvals) or 0

	-- pd (plain date) is a string: yes/true/1 | no/false/0 | adj
	-- to disable/enable "sourcing cirumstances" or use adjectival form for the plain date
	local pd = args.plaindate or args.pd or "no"
	args.pd = pd

	-- allow qualifiers to have a different date format; default to year unless qualsonly is set
	args.qdf = args.qdf or args.qualifierdateformat or args.df or (not qualsonly and "y")

	local lang = args.lang or findLang().code

    -- qualID is a string list of wanted qualifiers or "ALL"
    qualID = qualID or ""
    -- capitalise list of wanted qualifiers and substitute "DATES"
    qualID = qualID:upper():gsub("DATES", "P580, P582")
    local allflag = (qualID == "ALL")
    -- create table of wanted qualifiers as key
    local qwanted = {}
    -- create sequence of wanted qualifiers
    local qorder = {}
    for q in mw.text.gsplit(qualID, "%p") do -- split at punctuation and iterate
        local qtrim = mw.text.trim(q)
        if qtrim ~= "" then
            qwanted[mw.text.trim(q)] = true
            qorder[#qorder+1] = qtrim
        end
    end
    -- qsep is the output separator for rendering qualifier list
    local qsep = (args.qsep or ""):gsub('"', '')
    -- qargs are the arguments to supply to assembleoutput()
    local qargs = {
        ["osd"]         = "false",
        ["linked"]      = tostring(linked),
        ["prefix"]      = args.qprefix,
        ["postfix"]     = args.qpostfix,
        ["linkprefix"]  = args.qlinkprefix or args.qlp,
        ["linkpostfix"] = args.qlinkpostfix,
        ["wdl"]         = "false",
        ["unitabbr"]    = tostring(uabbr),
        ["maxvals"]     = 0,
        ["sorted"]      = tostring(args.qsorted),
        ["noicon"]      = "true",
        ["list"]        = args.qlist,
        ["sep"]         = qsep,
        ["langobj"]     = args.langobj,
        ["lang"]        = args.langobj.code,
        ["df"]          = args.qdf,
        ["sn"]          = parseParam(args.qsn or args.qshortname, false),
    }

	-- all proper values of a Wikidata property will be the same type as the first
	-- qualifiers don't have a mainsnak, properties do
	local datatype = objproperty[1].datatype or objproperty[1].mainsnak.datatype

	-- out[] holds the a list of returned values for this property
	-- mlt[] holds the language code if the datatype is monolingual text
	local out = {}
	local mlt = {}

	for k, v in ipairs(objproperty) do
		local hasvalue = true
		if (onlysrc and not sourced(v)) then
			-- no value: it isn't sourced when onlysourced=true
			hasvalue = false
		else
			local val, lcode = rendersnak(v, args, linked, lprefix, lpostfix, prefix, postfix, uabbr)
			if not val then
				hasvalue = false -- rank doesn't match
			elseif qualsonly and qualID then
				-- suppress value returned: only qualifiers are requested
			else
				out[#out+1], mlt[#out+1] = val, lcode
			end
		end

		-- See if qualifiers are to be returned:
		local snak = v.mainsnak or v
		if hasvalue and v.qualifiers and qualID ~= "" and snak.snaktype~="novalue" then
            -- collect all wanted qualifier values returned in qlist, indexed by propertyID
			local qlist = {}
			local timestart, timeend = "", ""
            -- loop through qualifiers
            for k1, v1 in pairs(v.qualifiers) do
                if allflag or qwanted[k1] then
                    if k1 == "P1326" then
                        local ts = v1[1].datavalue.value.time
                        local dp = v1[1].datavalue.value.precision
                        qlist[k1] = dateFormat(ts, dp, args.qdf, args.bc, pd, "", lang, "before")
                    elseif k1 == "P1319" then
                        local ts = v1[1].datavalue.value.time
                        local dp = v1[1].datavalue.value.precision
                        qlist[k1] = dateFormat(ts, dp, args.qdf, args.bc, pd, "", lang, "after")
                    elseif k1 == "P580" then
                        timestart = propertyvalueandquals(v1, qargs)[1] or "" -- treat only one start time as valid
                    elseif k1 == "P582" then
                        timeend = propertyvalueandquals(v1, qargs)[1] or "" -- treat only one end time as valid
                    else
                        local q = assembleoutput(propertyvalueandquals(v1, qargs), qargs)
                        -- we already deal with circa via 'sourcing circumstances' if the datatype was time
                        -- circa may be either linked or unlinked *** internationalise later ***
                        if datatype ~= "time" or q ~= "circa" and not (type(q) == "string" and q:find("circa]]")) then
                            qlist[k1] = q
                        end
                    end
                end -- of test for wanted
            end -- of loop through qualifiers
            -- set date separator
			local t = timestart .. timeend
			-- *** internationalise date separators later ***
			local dsep = "&amp;ndash;"
			if t:find("%s") or t:find("&amp;nbsp;") then dsep = " &amp;ndash; " end
            -- set the order for the list of qualifiers returned; start time and end time go last
			if next(qlist) then
                local qlistout = {}
                if allflag then
                    for k2, v2 in pairs(qlist) do
                        qlistout[#qlistout+1] = v2
                    end
                else
                    for i2, v2 in ipairs(qorder) do
                        qlistout[#qlistout+1] = qlist[v2]
                    end
                end
                if t ~= "" then
                    qlistout[#qlistout+1] = timestart .. dsep .. timeend
                end
				local qstr = assembleoutput(qlistout, qargs)
				if qualsonly then
					out[#out+1] = qstr
				else
					out[#out] = out[#out] .. " (" .. qstr .. ")"
				end
			elseif t ~= "" then
				if qualsonly then
					if timestart == "" then
						out[#out+1] = timeend
					elseif timeend == "" then
						out[#out+1] = timestart
					else
						out[#out+1] = timestart .. dsep .. timeend
					end
				else
					out[#out] = out[#out] .. " (" .. timestart .. dsep .. timeend .. ")"
				end
			end
		end -- of test for qualifiers wanted

		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end -- of for each value loop

	-- we need to pick one value to return if the datatype was "monolingualtext"
	-- if there's only one value, use that
	-- otherwise look through the fallback languages for a match
	if datatype == "monolingualtext" and #out &gt;1 then
		lang = mw.text.split( lang, '-', true )[1]
		local fbtbl = mw.language.getFallbacksFor( lang )
		table.insert( fbtbl, 1, lang )
		local bestval = ""
		local found = false
		for idx1, lang1 in ipairs(fbtbl) do
			for idx2, lang2 in ipairs(mlt) do
				if (lang1 == lang2) and not found then
					bestval = out[idx2]
					found = true
					break
				end
			end -- loop through values of property
		end -- loop through fallback languages
		if found then
			-- replace output table with a table containing the best value
			out = { bestval }
		else
			-- more than one value and none of them on the list of fallback languages
			-- sod it, just give them the first one
			out = { out[1] }
		end
	end
	return out
end


-------------------------------------------------------------------------------
-- Common code for p.getValueByQual and p.getValueByLang
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; assembleoutput;
-------------------------------------------------------------------------------
local _getvaluebyqual = function(frame, qualID, checkvalue)

	-- The property ID that will have a qualifier is the first unnamed parameter
	local propertyID = mw.text.trim(frame.args[1] or "")
	if propertyID == "" then return "no property supplied" end

	if qualID == "" then return "no qualifier supplied" end

	-- onlysourced is a boolean passed to return property values
	-- only when property values are sourced to something other than Wikipedia
	-- if nothing or an empty string is passed set it true
	-- if "false" or "no" or 0 is passed set it false
	local onlysrc = parseParam(frame.args.onlysourced or frame.args.osd, true)

	-- set the requested ranks flags
	frame.args.reqranks = setRanks(frame.args.rank)

	-- set a language object and code in the frame.args table
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code

	local args = frame.args

	-- check for locally supplied parameter in second unnamed parameter
	-- success means no local parameter and the property exists
	local qid, props = parseInput(frame, args[2], propertyID)

	local linked = parseParam(args.linked, true)
	local lpre = (args.linkprefix or args.lp or ""):gsub('"', '')
	local lpost = (args.linkpostfix or ""):gsub('"', '')
	local pre = (args.prefix or ""):gsub('"', '')
	local post = (args.postfix or ""):gsub('"', '')
	local uabbr = parseParam(args.unitabbr or args.uabbr, false)
	local filter = (args.unit or ""):upper()
	local maxvals = tonumber(args.maxvals) or 0
	if filter == "" then filter = nil end

	if qid then
		local out = {}
		-- Scan through the values of the property
		-- we want something like property is "pronunciation audio (P443)" in propertyID
		-- with a qualifier like "language of work or name (P407)" in qualID
		-- whose value has the required ID, like "British English (Q7979)", in qval
		for k1, v1 in ipairs(props) do
			if v1.mainsnak.snaktype == "value" then
				-- check if it has the right qualifier
				local v1q = v1.qualifiers
				if v1q and v1q[qualID] then
					if onlysrc == false or sourced(v1) then
						-- if we've got this far, we have a (sourced) claim with qualifiers
						-- so see if matches the required value
						-- We'll only deal with wikibase-items and strings for now
						if v1q[qualID][1].datatype == "wikibase-item" then
							if checkvalue(v1q[qualID][1].datavalue.value.id) then
								out[#out + 1] = rendersnak(v1, args, linked, lpre, lpost, pre, post, uabbr, filter)
							end
						elseif v1q[qualID][1].datatype == "string" then
							if checkvalue(v1q[qualID][1].datavalue.value) then
								out[#out + 1] = rendersnak(v1, args, linked, lpre, lpost, pre, post, uabbr, filter)
							end
						end
					end -- of check for sourced
				end -- of check for matching required value and has qualifiers
			else
				return nil
			end -- of check for string
			if maxvals &gt; 0 and #out &gt;= maxvals then break end
		end -- of loop through values of propertyID
		return assembleoutput(out, frame.args, qid, propertyID)
	else
		return props -- either local parameter or nothing
	end -- of test for success
	return nil
end


-------------------------------------------------------------------------------
-- _location takes Q-id and follows P276 (location)
-- or P131 (located in the administrative territorial entity) or P706 (located on terrain feature)
-- from the initial item to higher level territories/locations until it reaches the highest.
-- An optional boolean, 'first', determines whether the first item is returned (default: false).
-- An optional boolean 'skip' toggles the display to skip to the last item (default: false).
-- It returns a table containing the locations - linked where possible, except for the highest.
-------------------------------------------------------------------------------
-- Dependencies: findLang(); labelOrId(); linkedItem
-------------------------------------------------------------------------------
local _location = function(qid, first, skip)
	first = parseParam(first, false)
	skip = parseParam(skip, false)
	local locs = {"P276", "P131", "P706"}
	local out = {}
	local langcode = findLang():getCode()
	local finished = false
	local count = 0
	local prevqid = "Q0"
	repeat
		local prop
		for i1, v1 in ipairs(locs) do
			local proptbl = mw.wikibase.getBestStatements(qid, v1)
			if #proptbl &gt; 1 then
				-- there is more than one higher location
				local prevP131, prevP131id
				if prevqid ~= "Q0" then
					prevP131 = mw.wikibase.getBestStatements(prevqid, "P131")[1]
					prevP131id = prevP131
					and prevP131.mainsnak.datavalue
					and prevP131.mainsnak.datavalue.value.id
				end
				for i2, v2 in ipairs(proptbl) do
					local parttbl = v2.qualifiers and v2.qualifiers.P518
					if parttbl then
						-- this higher location has qualifier 'applies to part' (P518)
						for i3, v3 in ipairs(parttbl) do
							if v3.snaktype == "value" and v3.datavalue.value.id == prevqid then
								-- it has a value equal to the previous location
								prop = proptbl[i2]
								break
							end -- of test for matching last location
						end -- of loop through values of 'applies to part'
					else
						-- there's no qualifier 'applies to part' (P518)
						-- so check if the previous location had a P131 that matches this alternate
						if qid == prevP131id then
								prop = proptbl[i2]
								break
						end -- of test for matching previous P131
					end
				end -- of loop through parent locations
				-- fallback to second value if match not found
				prop = prop or proptbl[2]
			elseif #proptbl &gt; 0 then
				prop = proptbl[1]
			end
			if prop then break end
		end

		-- check if it's an instance of (P31) a country (Q6256) or sovereign state (Q3624078)
		-- and terminate the chain if it is
		local inst = mw.wikibase.getAllStatements(qid, "P31")
		if #inst &gt; 0 then
			for k, v in ipairs(inst) do
				local instid = v.mainsnak.datavalue and v.mainsnak.datavalue.value.id
				-- stop if it's a country (or a country within the United Kingdom if skip is true)
				if instid == "Q6256" or instid == "Q3624078" or (skip and instid == "Q3336843") then
					prop = nil -- this will ensure this is treated as top-level location
					break
				end
			end
		end

		-- get the name of this location and update qid to point to the parent location
		if prop and prop.mainsnak.datavalue then
			if not skip or count == 0 then
				local args = { lprefix = ":" }
				out[#out+1] = linkedItem(qid, args) -- get a linked value if we can
			end
			qid, prevqid = prop.mainsnak.datavalue.value.id, qid
		else
			-- This is top-level location, so get short name except when this is the first item
			-- Use full label if there's no short name or this is the first item
			local prop1813 = mw.wikibase.getAllStatements(qid, "P1813")
			-- if there's a short name and this isn't the only item
			if prop1813[1] and (#out &gt; 0)then
				local shortname
				-- short name is monolingual text, so look for match to the local language
				-- choose the shortest 'short name' in that language
				for k, v in pairs(prop1813) do
					if v.mainsnak.datavalue.value.language == langcode then
						local name = v.mainsnak.datavalue.value.text
						if (not shortname) or (#name &lt; #shortname) then
							shortname = name
						end
					end
				end
				-- add the shortname if one is found, fallback to the label
				-- but skip it if it's "USA"
				if shortname ~= "USA" then
					out[#out+1] = shortname or labelOrId(qid)
				else
					if skip then out[#out+1] = "US" end
				end
			else
				-- no shortname, so just add the label
				local loc = labelOrId(qid)
				-- exceptions go here:
				if loc == "United States of America" then
					out[#out+1] = "United States"
				else
					out[#out+1] = loc
				end
			end
			finished = true
		end
		count = count + 1
	until finished or count &gt;= 10 -- limit to 10 levels to avoid infinite loops

	-- remove the first location if not required
	if not first then table.remove(out, 1) end

	-- we might have duplicate text for consecutive locations, so remove them
	if #out &gt; 2 then
		local plain = {}
		for i, v in ipairs(out) do
			-- strip any links
			plain[i] = v:gsub("^%[%[[^|]*|", ""):gsub("]]$", "")
		end
		local idx = 2
		repeat
			if plain[idx] == plain[idx-1] then
				-- duplicate found
				local removeidx = 0
				if (plain[idx] ~= out[idx]) and (plain[idx-1] == out[idx-1]) then
					-- only second one is linked, so drop the first
					removeidx = idx - 1
				elseif (plain[idx] == out[idx]) and (plain[idx-1] ~= out[idx-1]) then
					-- only first one is linked, so drop the second
					removeidx = idx
				else
					-- pick one
					removeidx = idx - (os.time()%2)
				end
				table.remove(out, removeidx)
				table.remove(plain, removeidx)
			else
				idx = idx +1
			end
		until idx &gt;= #out
	end
	return out
end


-------------------------------------------------------------------------------
-- _getsumofparts scans the property 'has part' (P527) for values matching a list.
-- The list (args.vlist) consists of a string of Qids separated by spaces or any usual punctuation.
-- If the matched values have a qualifer 'quantity' (P1114), those quantites are summed.
-- The sum is returned as a number (i.e. 0 if none)
-- a table of arguments is supplied implementing the usual parameters.
-------------------------------------------------------------------------------
-- Dependencies: setRanks; parseParam; parseInput; sourced; assembleoutput;
-------------------------------------------------------------------------------
local _getsumofparts = function(args)
	local vallist = (args.vlist or ""):upper()
	if vallist == "" then return end
	args.reqranks = setRanks(args.rank)
	local f = {}
	f.args = args
	local qid, props = parseInput(f, "", "P527")
	if not qid then return 0 end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local sum = 0
	for k1, v1 in ipairs(props) do
		if (onlysrc == false or sourced(v1))
			and v1.mainsnak.snaktype == "value"
			and v1.mainsnak.datavalue.type == "wikibase-entityid"
			and vallist:match( v1.mainsnak.datavalue.value.id )
			and v1.qualifiers
			then
			local quals = v1.qualifiers["P1114"]
			if quals then
				for k2, v2 in ipairs(quals) do
					sum = sum + v2.datavalue.value.amount
				end
			end
		end
	end
	return sum
end


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Public functions
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- _getValue makes the functionality of getValue available to other modules
-------------------------------------------------------------------------------
-- Dependencies: setRanks; parseInput; propertyvalueandquals; assembleoutput; parseParam; sourced;
-- labelOrId; i18n.latestdatequalifier; format_Date; makeOrdinal; roundto; decimalPrecision; decimalToDMS;
-------------------------------------------------------------------------------
p._getValue = function(args)
	-- parameter sets for commonly used groups of parameters
	local paraset = tonumber(args.ps or args.parameterset or 0)
	if paraset == 1 then
		-- a common setting
		args.rank = "best"
		args.fetchwikidata = "ALL"
		args.onlysourced = "no"
		args.noicon = "true"
	elseif paraset == 2 then
		-- equivalent to raw
		args.rank = "best"
		args.fetchwikidata = "ALL"
		args.onlysourced = "no"
		args.noicon = "true"
		args.linked = "no"
		args.pd = "true"
	elseif paraset == 3 then
		-- third set goes here
	end

	-- implement eid parameter
	local eid = args.eid
	if eid == "" then
		return nil
	elseif eid then
		args.qid = eid
	end

	local propertyID = mw.text.trim(args[1] or "")

	args.reqranks = setRanks(args.rank)

	-- replacetext (rt) is a string that is returned instead of any non-empty Wikidata value
	-- this is useful for tracking and debugging, so we set fetchwikidata=ALL to fill the whitelist
	local replacetext = mw.text.trim(args.rt or args.replacetext or "")
	if replacetext ~= "" then
		args.fetchwikidata = "ALL"
	end

	local f = {}
	f.args = args
	local entityid, props = parseInput(f, f.args[2], propertyID)

	if not entityid then
		return props -- either the input parameter or nothing
	end

	-- qual is a string containing the property ID of the qualifier(s) to be returned
	-- if qual == "ALL" then all qualifiers returned
	-- if qual == "DATES" then qualifiers P580 (start time) and P582 (end time) returned
	-- if nothing or an empty string is passed set it nil -&gt; no qualifiers returned
	local qualID = mw.text.trim(args.qual or ""):upper()
	if qualID == "" then qualID = nil end

	-- set a language object and code in the args table
	args.langobj = findLang(args.lang)
	args.lang = args.langobj.code

	-- table 'out' stores the return value(s):
	local out = propertyvalueandquals(props, args, qualID)

	-- format the table of values and return it as a string:
	return assembleoutput(out, args, entityid, propertyID)
end


-------------------------------------------------------------------------------
-- getValue is used to get the value(s) of a property
-- The property ID is passed as the first unnamed parameter and is required.
-- A locally supplied parameter may optionaly be supplied as the second unnamed parameter.
-- The function will now also return qualifiers if parameter qual is supplied
-------------------------------------------------------------------------------
-- Dependencies: _getValue; setRanks; parseInput; propertyvalueandquals; assembleoutput; parseParam; sourced;
-- labelOrId; i18n.latestdatequalifier; format_Date; makeOrdinal; roundto; decimalPrecision; decimalToDMS;
-------------------------------------------------------------------------------
p.getValue = function(frame)
	local args= frame.args
	if not args[1] then
		args = frame:getParent().args
		if not args[1] then return i18n.errors["No property supplied"] end
	end

	return p._getValue(args)
end


-------------------------------------------------------------------------------
-- getPreferredValue is used to get a value,
-- (or a comma separated list of them if multiple values exist).
-- If preferred ranks are set, it will return those values, otherwise values with normal ranks
-- now redundant to getValue with |rank=best
-------------------------------------------------------------------------------
-- Dependencies: p.getValue; setRanks; parseInput; propertyvalueandquals; assembleoutput;
-- parseParam; sourced; labelOrId; i18n.latestdatequalifier; format_Date;
-- makeOrdinal; roundto; decimalPrecision; decimalToDMS;
-------------------------------------------------------------------------------
p.getPreferredValue = function(frame)
	frame.args.rank = "best"
	return p.getValue(frame)
end


-------------------------------------------------------------------------------
-- getCoords is used to get coordinates for display in an infobox
-- whitelist and blacklist are implemented
-- optional 'display' parameter is allowed, defaults to nil - was "inline, title"
-------------------------------------------------------------------------------
-- Dependencies: setRanks(); parseInput(); decimalPrecision();
-------------------------------------------------------------------------------
p.getCoords = function(frame)
	local propertyID = "P625"

	-- if there is a 'display' parameter supplied, use it
	-- otherwise default to nothing
	local disp = frame.args.display or ""
	if disp == "" then
		disp = nil -- default to not supplying display parameter, was "inline, title"
	end

	-- there may be a format parameter to switch from deg/min/sec to decimal degrees
	-- default is deg/min/sec
	-- decimal degrees needs |format = dec
	local form = (frame.args.format or ""):lower():sub(1,3)
	if form ~= "dec" then
		form = "dms"
	end

	-- just deal with best values
	frame.args.reqranks = setRanks("best")

	local qid, props = parseInput(frame, frame.args[1], propertyID)
	if not qid then
		return props -- either local parameter or nothing
	else
		local dv = props[1].mainsnak.datavalue.value
		local lat, long, prec = dv.latitude, dv.longitude, dv.precision
		lat = decimalPrecision(lat, prec)
		long = decimalPrecision(long, prec)
		local lat_long = { lat, long }
		lat_long["display"] = disp
		lat_long["format"] = form
		-- invoke template Coord with the values stored in the table
		return frame:expandTemplate{title = 'coord', args = lat_long}
	end
end


-------------------------------------------------------------------------------
-- getQualifierValue is used to get a formatted value of a qualifier
--
-- The call needs:	a property (the unnamed parameter or 1=)
-- 					a target value for that property (pval=)
--					a qualifier for that target value (qual=)
-- The usual whitelisting and blacklisting of the property is implemented
-- The boolean onlysourced= parameter can be set to return nothing
-- when the property is unsourced (or only sourced to Wikipedia)
-------------------------------------------------------------------------------
-- Dependencies: parseParam(); setRanks(); parseInput(); sourced();
-- propertyvalueandquals(); assembleoutput();
-- labelOrId(); i18n.latestdatequalifier(); format_Date();
-- findLang(); makeOrdinal(); roundto(); decimalPrecision(); decimalToDMS();
-------------------------------------------------------------------------------
p.getQualifierValue = function(frame)

	-- The property ID that will have a qualifier is the first unnamed parameter
	local propertyID = mw.text.trim(frame.args[1] or "")

	-- The value of the property we want to match whose qualifier value is to be returned
	-- is passed in named parameter |pval=
	local propvalue = frame.args.pval

	-- The property ID of the qualifier
	-- whose value is to be returned is passed in named parameter |qual=
	local qualifierID = frame.args.qual

	-- A filter can be set like this: filter=P642==Q22674854
	local filter, fprop, fval
	local ftable = mw.text.split(frame.args.filter or "", "==")
	if ftable[2] then
		fprop = mw.text.trim(ftable[1])
		fval = mw.text.trim(ftable[2])
		filter = true
	end

	-- onlysourced is a boolean passed to return qualifiers
	-- only when property values are sourced to something other than Wikipedia
	-- if nothing or an empty string is passed set it true
	-- if "false" or "no" or 0 is passed set it false
	local onlysrc = parseParam(frame.args.onlysourced or frame.args.osd, true)

	-- set a language object and language code in the frame.args table
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code

	-- set the requested ranks flags
	frame.args.reqranks = setRanks(frame.args.rank)

	-- check for locally supplied parameter in second unnamed parameter
	-- success means no local parameter and the property exists
	local qid, props = parseInput(frame, frame.args[2], propertyID)
	if qid then
		local out = {}
		-- Scan through the values of the property
		-- we want something like property is P793, significant event (in propertyID)
		-- whose value is something like Q385378, construction (in propvalue)
		-- then we can return the value(s) of a qualifier such as P580, start time (in qualifierID)
		for k1, v1 in pairs(props) do
			if v1.mainsnak.snaktype == "value" and v1.mainsnak.datavalue.type == "wikibase-entityid" then
				-- It's a wiki-linked value, so check if it's the target (in propvalue) and if it has qualifiers
				if v1.mainsnak.datavalue.value.id == propvalue and v1.qualifiers then
					if onlysrc == false or sourced(v1) then
						-- if we've got this far, we have a (sourced) claim with qualifiers
						-- which matches the target, so apply the filter and find the value(s) of the qualifier we want
						if not filter or (v1.qualifiers[fprop] and v1.qualifiers[fprop][1].datavalue.value.id == fval) then
							local quals = v1.qualifiers[qualifierID]
							if quals then
								-- can't reference qualifer, so set onlysourced = "no" (args are strings, not boolean)
								local qargs = frame.args
								qargs.onlysourced = "no"
								local vals = propertyvalueandquals(quals, qargs, qid)
								for k, v in ipairs(vals) do
									out[#out + 1] = v
								end
							end
						end
					end -- of check for sourced
				end -- of check for matching required value and has qualifiers
			end -- of check for wikibase entity
		end -- of loop through values of propertyID
		return assembleoutput(out, frame.args, qid, propertyID)
	else
		return props -- either local parameter or nothing
	end -- of test for success
	return nil
end


-------------------------------------------------------------------------------
-- getSumOfParts scans the property 'has part' (P527) for values matching a list.
-- The list is passed in parameter vlist.
-- It consists of a string of Qids separated by spaces or any usual punctuation.
-- If the matched values have a qualifier 'quantity' (P1114), those quantities are summed.
-- The sum is returned as a number or nothing if zero.
-------------------------------------------------------------------------------
-- Dependencies: _getsumofparts;
-------------------------------------------------------------------------------
p.getSumOfParts = function(frame)
	local sum = _getsumofparts(frame.args)
	if sum == 0 then return end
	return sum
end


-------------------------------------------------------------------------------
-- getValueByQual gets the value of a property which has a qualifier with a given entity value
-- The call needs:
--					a property ID (the unnamed parameter or 1=Pxxx)
--					the ID of a qualifier for that property (qualID=Pyyy)
--					either the Wikibase-entity ID of a value for that qualifier (qvalue=Qzzz)
--					or a string value for that qualifier (qvalue=abc123)
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: _getvaluebyqual; parseParam; setRanks; parseInput; sourced;
-- assembleoutput;
-------------------------------------------------------------------------------
p.getValueByQual = function(frame)
	local qualID = frame.args.qualID
	-- The Q-id of the value for the qualifier we want to match is in named parameter |qvalue=
	local qval = frame.args.qvalue or ""
	if qval == "" then return "no qualifier value supplied" end
	local function checkQID(id)
		return id == qval
	end
	return _getvaluebyqual(frame, qualID, checkQID)
end


-------------------------------------------------------------------------------
-- getValueByLang gets the value of a property which has a qualifier P407
-- ("language of work or name") whose value has the given language code
-- The call needs:
--					a property ID (the unnamed parameter or 1=Pxxx)
--					the MediaWiki language code to match the language (lang=xx[-yy])
--					(if no code is supplied, it uses the default language)
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: _getvaluebyqual; parseParam; setRanks; parseInput; sourced; assembleoutput;
-------------------------------------------------------------------------------
p.getValueByLang = function(frame)
	-- The language code for the qualifier we want to match is in named parameter |lang=
	local langcode = findLang(frame.args.lang).code
	local function checkLanguage(id)
		-- id should represent a language like "British English (Q7979)"
		-- it should have string property "Wikimedia language code (P424)"
		-- qlcode will be a table:
		local qlcode = mw.wikibase.getBestStatements(id, "P424")
		if (#qlcode &gt; 0) and (qlcode[1].mainsnak.datavalue.value == langcode) then
			return true
		end
	end
	return _getvaluebyqual(frame, "P407", checkLanguage)
end


-------------------------------------------------------------------------------
-- getValueByRefSource gets the value of a property which has a reference "stated in" (P248)
-- whose value has the given entity-ID.
-- The call needs:
--					a property ID (the unnamed parameter or 1=Pxxx)
--					the entity ID of a value to match where the reference is stated in (match=Qzzz)
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getValueByRefSource = function(frame)
	-- The property ID that we want to check is the first unnamed parameter
	local propertyID = mw.text.trim(frame.args[1] or ""):upper()
	if propertyID == "" then return "no property supplied" end

	-- The Q-id of the value we want to match is in named parameter |qvalue=
	local qval = (frame.args.match or ""):upper()
	if qval == "" then qval = "Q21540096" end

	local unit = (frame.args.unit or ""):upper()
	if unit == "" then unit = "Q4917" end

	local onlysrc = parseParam(frame.args.onlysourced or frame.args.osd, true)

	-- set the requested ranks flags
	frame.args.reqranks = setRanks(frame.args.rank)

	-- set a language object and code in the frame.args table
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code

	local linked = parseParam(frame.args.linked, true)

	local uabbr = parseParam(frame.args.uabbr or frame.args.unitabbr, false)

	-- qid not nil means no local parameter and the property exists
	local qid, props = parseInput(frame, frame.args[2], propertyID)

	if qid then
		local out = {}
		local mlt= {}
		for k1, v1 in ipairs(props) do
			if onlysrc == false or sourced(v1) then
				if v1.references then
					for k2, v2 in ipairs(v1.references) do
						if v2.snaks.P248 then
							for k3, v3 in ipairs(v2.snaks.P248) do
								if v3.datavalue.value.id == qval then
									out[#out+1], mlt[#out+1] = rendersnak(v1, frame.args, linked, "", "", "", "", uabbr, unit)
									if not mlt[#out] then
										-- we only need one match per property value
										-- unless datatype was monolingual text
										break
									end
								end -- of test for match
							end -- of loop through values "stated in"
						end -- of test that "stated in" exists
					end -- of loop through references
				end -- of test that references exist
			end -- of test for sourced
		end -- of loop through values of propertyID
		if #mlt &gt; 0 then
			local langcode = frame.args.lang
			langcode = mw.text.split( langcode, '-', true )[1]
			local fbtbl = mw.language.getFallbacksFor( langcode )
			table.insert( fbtbl, 1, langcode )
			local bestval = ""
			local found = false
			for idx1, lang1 in ipairs(fbtbl) do
				for idx2, lang2 in ipairs(mlt) do
					if (lang1 == lang2) and not found then
						bestval = out[idx2]
						found = true
						break
					end
				end -- loop through values of property
			end -- loop through fallback languages
			if found then
				-- replace output table with a table containing the best value
				out = { bestval }
			else
				-- more than one value and none of them on the list of fallback languages
				-- sod it, just give them the first one
				out = { out[1] }
			end
		end
		return assembleoutput(out, frame.args, qid, propertyID)
	else
		return props -- no property or local parameter supplied
	end -- of test for success
end


-------------------------------------------------------------------------------
-- getPropertyIDs takes most of the usual parameters.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented.
-- It returns the Entity-IDs (Qids) of the values of a property if it is a Wikibase-Entity.
-- Otherwise it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p._getPropertyIDs = function(args)
	args.reqranks = setRanks(args.rank)
	args.langobj = findLang(args.lang)
	args.lang = args.langobj.code
	-- change default for noicon to true
	args.noicon = tostring(parseParam(args.noicon or "", true))
	local f = {}
	f.args = args
	local pid = mw.text.trim(args[1] or ""):upper()

	-- get the qid and table of claims for the property, or nothing and the local value passed
	local qid, props = parseInput(f, args[2], pid)
	if not qid then return props end
	if not props[1] then return nil end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0

	local out = {}
	for i, v in ipairs(props) do
		local snak = v.mainsnak
		if ( snak.datatype == "wikibase-item" )
			and ( v.rank and args.reqranks[v.rank:sub(1, 1)] )
			and ( snak.snaktype == "value" )
			and ( sourced(v) or not onlysrc )
			then
			out[#out+1] = snak.datavalue.value.id
		end
		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end

	return assembleoutput(out, args, qid, pid)
end

p.getPropertyIDs = function(frame)
	local args = frame.args
	return p._getPropertyIDs(args)
end


-------------------------------------------------------------------------------
-- getQualifierIDs takes most of the usual parameters.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented.
-- It takes a property-id as the first unnamed parameter, and an optional parameter qlist
-- which is a list of qualifier property-ids to search for (default is "ALL")
-- It returns the Entity-IDs (Qids) of the values of a property if it is a Wikibase-Entity.
-- Otherwise it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getQualifierIDs = function(frame)
	local args = frame.args
	args.reqranks = setRanks(args.rank)
	args.langobj = findLang(args.lang)
	args.lang = args.langobj.code
	-- change default for noicon to true
	args.noicon = tostring(parseParam(args.noicon or "", true))
	local f = {}
	f.args = args
	local pid = mw.text.trim(args[1] or ""):upper()

	-- get the qid and table of claims for the property, or nothing and the local value passed
	local qid, props = parseInput(f, args[2], pid)
	if not qid then return props end
	if not props[1] then return nil end
	-- get the other parameters
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0
	local qlist = args.qlist or ""
	if qlist == "" then qlist = "ALL" end
	qlist = qlist:gsub("[%p%s]+", " ") .. " "

	local out = {}
	for i, v in ipairs(props) do
		local snak = v.mainsnak
		if ( v.rank and args.reqranks[v.rank:sub(1, 1)] )
			and ( snak.snaktype == "value" )
			and ( sourced(v) or not onlysrc )
			then
			if v.qualifiers then
				for k1, v1 in pairs(v.qualifiers) do
					if qlist == "ALL " or qlist:match(k1 .. " ") then
						for i2, v2 in ipairs(v1) do
							if v2.datatype == "wikibase-item" and v2.snaktype == "value" then
								out[#out+1] = v2.datavalue.value.id
							end -- of test that id exists
						end -- of loop through qualifier values
					end -- of test for kq in qlist
				end -- of loop through qualifiers
			end -- of test for qualifiers
		end -- of test for rank value, sourced, and value exists
		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end -- of loop through property values

	return assembleoutput(out, args, qid, pid)
end


-------------------------------------------------------------------------------
-- getPropOfProp takes two propertyIDs: prop1 and prop2 (as well as the usual parameters)
-- If the value(s) of prop1 are of type "wikibase-item" then it returns the value(s) of prop2
-- of each of those wikibase-items.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p._getPropOfProp = function(args)
	-- parameter sets for commonly used groups of parameters
	local paraset = tonumber(args.ps or args.parameterset or 0)
	if paraset == 1 then
		-- a common setting
		args.rank = "best"
		args.fetchwikidata = "ALL"
		args.onlysourced = "no"
		args.noicon = "true"
	elseif paraset == 2 then
		-- equivalent to raw
		args.rank = "best"
		args.fetchwikidata = "ALL"
		args.onlysourced = "no"
		args.noicon = "true"
		args.linked = "no"
		args.pd = "true"
	elseif paraset == 3 then
		-- third set goes here
	end

	args.reqranks = setRanks(args.rank)
	args.langobj = findLang(args.lang)
	args.lang = args.langobj.code
	local pid1 = args.prop1 or args.pid1 or ""
	local pid2 = args.prop2 or args.pid2 or ""
	if pid1 == "" or pid2 == "" then return nil end

	local f = {}
	f.args = args
	local qid1, statements1 = parseInput(f, args[1], pid1)
	-- parseInput nulls empty args[1] and returns args[1] if nothing on Wikidata
	if not qid1 then return statements1 end
	-- otherwise it returns the qid and a table for the statement
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0
	local qualID = mw.text.trim(args.qual or ""):upper()
	if qualID == "" then qualID = nil end
	local out = {}
	for k, v in ipairs(statements1) do
		if not onlysrc or sourced(v) then
			local snak = v.mainsnak
			if snak.datatype == "wikibase-item" and snak.snaktype == "value" then
				local qid2 = snak.datavalue.value.id
				local statements2 = {}
				if args.reqranks.b then
					statements2 = mw.wikibase.getBestStatements(qid2, pid2)
				else
					statements2 = mw.wikibase.getAllStatements(qid2, pid2)
				end
				if statements2[1] then
					local out2 = propertyvalueandquals(statements2, args, qualID)
					out[#out+1] = assembleoutput(out2, args, qid2, pid2)
				end
			end -- of test for valid property1 value
		end -- of test for sourced
		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end -- of loop through values of property1
	return assembleoutput(out, args, qid1, pid1)
end

p.getPropOfProp = function(frame)
	local args= frame.args
	if not args.prop1 and not args.pid1 then
		args = frame:getParent().args
		if not args.prop1 and not args.pid1 then return i18n.errors["No property supplied"] end
	end

	return p._getPropOfProp(args)
end


-------------------------------------------------------------------------------
-- getAwardCat takes most of the usual parameters. If the item has values of P166 (award received),
-- then it examines each of those awards for P2517 (category for recipients of this award).
-- If it exists, it returns the corresponding category,
-- with the item's P734 (family name) as sort key, or no sort key if there is no family name.
-- The sort key may be overridden by the parameter |sortkey (alias |sk).
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getAwardCat = function(frame)
	frame.args.reqranks = setRanks(frame.args.rank)
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code
	local args = frame.args
	args.sep = " "
	local pid1 = args.prop1 or "P166"
	local pid2 = args.prop2 or "P2517"
	if pid1 == "" or pid2 == "" then return nil end
	-- locally supplied value:
	local localval = mw.text.trim(args[1] or "")
	local qid1, statements1 = parseInput(frame, localval, pid1)
	if not qid1 then return localval end
	-- linkprefix (strip quotes)
	local lp = (args.linkprefix or args.lp or ""):gsub('"', '')
	-- sort key (strip quotes, hyphens and periods):
	local sk = (args.sortkey or args.sk or ""):gsub('["-.]', '')
	-- family name:
	local famname = ""
	if sk == "" then
		local p734 = mw.wikibase.getBestStatements(qid1, "P734")[1]
		local p734id = p734 and p734.mainsnak.snaktype == "value" and p734.mainsnak.datavalue.value.id or ""
		famname = mw.wikibase.getSitelink(p734id) or ""
		-- strip namespace and disambigation
		local pos = famname:find(":") or 0
		famname = famname:sub(pos+1):gsub("%s%(.+%)$", "")
		if famname == "" then
			local lbl = mw.wikibase.getLabel(p734id)
			famname = lbl and mw.text.nowiki(lbl) or ""
		end
	end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0
	local qualID = mw.text.trim(args.qual or ""):upper()
	if qualID == "" then qualID = nil end
	local out = {}
	for k, v in ipairs(statements1) do
		if not onlysrc or sourced(v) then
			local snak = v.mainsnak
			if snak.datatype == "wikibase-item" and snak.snaktype == "value" then
				local qid2 = snak.datavalue.value.id
				local statements2 = {}
				if args.reqranks.b then
					statements2 = mw.wikibase.getBestStatements(qid2, pid2)
				else
					statements2 = mw.wikibase.getAllStatements(qid2, pid2)
				end
				if statements2[1] and statements2[1].mainsnak.snaktype == "value" then
					local qid3 = statements2[1].mainsnak.datavalue.value.id
					local sitelink = mw.wikibase.getSitelink(qid3)
					-- if there's no local sitelink, create the sitelink from English label
					if not sitelink then
						local lbl = mw.wikibase.getLabelByLang(qid3, "en")
						if lbl then
							if lbl:sub(1,9) == "Category:" then
								sitelink = mw.text.nowiki(lbl)
							else
								sitelink = "Category:" .. mw.text.nowiki(lbl)
							end
						end
					end
					if sitelink then
						if sk ~= "" then
							out[#out+1] = "[[" .. lp .. sitelink .. "|" .. sk .. "]]"
						elseif famname ~= "" then
							out[#out+1] = "[[" .. lp .. sitelink .. "|" .. famname .. "]]"
						else
							out[#out+1] = "[[" .. lp .. sitelink .. "]]"
						end -- of check for sort keys
					end -- of test for sitelink
				end -- of test for category
			end -- of test for wikibase item has a value
		end -- of test for sourced
		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end -- of loop through values of property1
	return assembleoutput(out, args, qid1, pid1)
end


-------------------------------------------------------------------------------
-- getIntersectCat takes most of the usual parameters.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-- It takes two properties, |prop1 and |prop2 (e.g. occupation and country of citizenship)
-- Each property's value is a wiki-base entity
-- For each value of the first parameter (ranks implemented) it fetches the value's main category
-- and then each value of the second parameter (possibly substituting a simpler description)
-- then it returns all of the categories representing the intersection of those properties,
-- (e.g. Category:Actors from Canada). A joining term may be supplied (e.g. |join=from).
-- The item's P734 (family name) is the sort key, or no sort key if there is no family name.
-- The sort key may be overridden by the parameter |sortkey (alias |sk).
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getIntersectCat = function(frame)
	frame.args.reqranks = setRanks(frame.args.rank)
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code
	local args = frame.args
	args.sep = " "
	args.linked = "no"
	local pid1 = args.prop1 or "P106"
	local pid2 = args.prop2 or "P27"
	if pid1 == "" or pid2 == "" then return nil end
	local qid, statements1 = parseInput(frame, "", pid1)
	if not qid then return nil end
	local qid, statements2 = parseInput(frame, "", pid2)
	if not qid then return nil end
	-- topics like countries may have different names in categories from their label in Wikidata
	local subs_exists, subs = pcall(mw.loadData, "Module:WikidataIB/subs")
	local join = args.join or ""
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0
	-- linkprefix (strip quotes)
	local lp = (args.linkprefix or args.lp or ""):gsub('"', '')
	-- sort key (strip quotes, hyphens and periods):
	local sk = (args.sortkey or args.sk or ""):gsub('["-.]', '')
	-- family name:
	local famname = ""
	if sk == "" then
		local p734 = mw.wikibase.getBestStatements(qid, "P734")[1]
		local p734id = p734 and p734.mainsnak.snaktype == "value" and p734.mainsnak.datavalue.value.id or ""
		famname = mw.wikibase.getSitelink(p734id) or ""
		-- strip namespace and disambigation
		local pos = famname:find(":") or 0
		famname = famname:sub(pos+1):gsub("%s%(.+%)$", "")
		if famname == "" then
			local lbl = mw.wikibase.getLabel(p734id)
			famname = lbl and mw.text.nowiki(lbl) or ""
		end
	end
	local cat1 = {}
	for k, v in ipairs(statements1) do
		if not onlysrc or sourced(v) then
			-- get the ID representing the value of the property
			local pvalID = (v.mainsnak.snaktype == "value") and v.mainsnak.datavalue.value.id
			if pvalID then
				-- get the topic's main category (P910) for that entity
				local p910 = mw.wikibase.getBestStatements(pvalID, "P910")[1]
				if p910 and p910.mainsnak.snaktype == "value" then
					local tmcID = p910.mainsnak.datavalue.value.id
					-- use sitelink or the English label for the cat
					local cat = mw.wikibase.getSitelink(tmcID)
					if not cat then
						local lbl = mw.wikibase.getLabelByLang(tmcID, "en")
						if lbl then
							if lbl:sub(1,9) == "Category:" then
								cat = mw.text.nowiki(lbl)
							else
								cat = "Category:" .. mw.text.nowiki(lbl)
							end
						end
					end
					cat1[#cat1+1] = cat
				end -- of test for topic's main category exists
			end -- of test for property has vaild value
		end -- of test for sourced
		if maxvals &gt; 0 and #cat1 &gt;= maxvals then break end
	end
	local cat2 = {}
	for k, v in ipairs(statements2) do
		if not onlysrc or sourced(v) then
			local cat = rendersnak(v, args)
			if subs[cat] then cat = subs[cat] end
			cat2[#cat2+1] = cat
		end
		if maxvals &gt; 0 and #cat2 &gt;= maxvals then break end
	end
	local out = {}
	for k1, v1 in ipairs(cat1) do
		for k2, v2 in ipairs(cat2) do
			if sk ~= "" then
				out[#out+1] = "[[" .. lp .. v1 .. " " .. join .. " " .. v2 .. "|" .. sk .. "]]"
			elseif famname ~= "" then
				out[#out+1] = "[[" .. lp .. v1 .. " " .. join .. " " .. v2 .. "|" .. famname .. "]]"
			else
				out[#out+1] = "[[" .. lp .. v1 .. " " .. join .. " " .. v2 .. "]]"
			end -- of check for sort keys
		end
	end
	args.noicon = "true"
	return assembleoutput(out, args, qid, pid1)
end


-------------------------------------------------------------------------------
-- qualsToTable takes most of the usual parameters.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented.
-- A qid may be given, and the first unnamed parameter is the property ID, which is of type wikibase item.
-- It takes a list of qualifier property IDs as |quals=
-- For a given qid and property, it creates the rows of an html table,
-- each row being a value of the property (optionally only if the property matches the value in |pval= )
-- each cell being the first value of the qualifier corresponding to the list in |quals
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced;
-------------------------------------------------------------------------------
p.qualsToTable = function(frame)
	local args = frame.args

	local quals = args.quals or ""
	if quals == "" then return "" end

	args.reqranks = setRanks(args.rank)

	local propertyID = mw.text.trim(args[1] or "")
	local f = {}
	f.args = args
	local entityid, props = parseInput(f, "", propertyID)
	if not entityid then return "" end

	args.langobj = findLang(args.lang)
	args.lang = args.langobj.code

	local pval = args.pval or ""

	local qplist = mw.text.split(quals, "%p") -- split at punctuation and make a sequential table
	for i, v in ipairs(qplist) do
		qplist[i] = mw.text.trim(v):upper() -- remove whitespace and capitalise
	end

	local col1 = args.firstcol or ""
	if col1 ~= "" then
		col1 = col1 .. "&lt;/td&gt;&lt;td&gt;"
	end

	local emptycell = args.emptycell or "&amp;nbsp;"

	-- construct a 2-D array of qualifier values in qvals
	local qvals = {}
	for i, v in ipairs(props) do
		local skip = false
		if pval ~= "" then
			local pid = v.mainsnak.datavalue and v.mainsnak.datavalue.value.id
			if pid ~= pval then skip = true end
		end
		if not skip then
			local qval = {}
			local vqualifiers = v.qualifiers or {}
			-- go through list of wanted qualifier properties
			for i1, v1 in ipairs(qplist) do
				-- check for that property ID in the statement's qualifiers
				local qv, qtype
				if vqualifiers[v1] then
					qtype = vqualifiers[v1][1].datatype
					if qtype == "time" then
						if vqualifiers[v1][1].snaktype == "value" then
							qv = mw.wikibase.renderSnak(vqualifiers[v1][1])
							qv = frame:expandTemplate{title="dts", args={qv}}
						else
							qv = "?"
						end
					elseif qtype == "url" then
						if vqualifiers[v1][1].snaktype == "value" then
							qv = mw.wikibase.renderSnak(vqualifiers[v1][1])
							local display = mw.ustring.match( mw.uri.decode(qv, "WIKI"), "([%w ]+)$" )
							if display then
								qv = "[" .. qv .. " " .. display .. "]"
							end
						end
					else
						qv = mw.wikibase.formatValue(vqualifiers[v1][1])
					end
				end
				-- record either the value or a placeholder
				qval[i1] = qv or emptycell
			end -- of loop through list of qualifiers
			-- add the list of qualifier values as a "row" in the main list
			qvals[#qvals+1] = qval
		end
	end -- of for each value loop

	local out = {}
	for i, v in ipairs(qvals) do
		out[i] = "&lt;tr&gt;&lt;td&gt;" .. col1 .. table.concat(qvals[i], "&lt;/td&gt;&lt;td&gt;") .. "&lt;/td&gt;&lt;/tr&gt;"
	end
	return table.concat(out, "\n")
end


-------------------------------------------------------------------------------
-- getGlobe takes an optional qid of a Wikidata entity passed as |qid=
-- otherwise it uses the linked item for the current page.
-- If returns the Qid of the globe used in P625 (coordinate location),
-- or nil if there isn't one.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getGlobe = function(frame)
	local qid = frame.args.qid or frame.args[1] or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	local coords = mw.wikibase.getBestStatements(qid, "P625")[1]
	local globeid
	if coords and coords.mainsnak.snaktype == "value" then
		globeid = coords.mainsnak.datavalue.value.globe:match("(Q%d+)")
	end
	return globeid
end


-------------------------------------------------------------------------------
-- getCommonsLink takes an optional qid of a Wikidata entity passed as |qid=
-- It returns one of the following in order of preference:
-- the Commons sitelink of the linked Wikidata item;
-- the Commons sitelink of the topic's main category of the linked Wikidata item;
-------------------------------------------------------------------------------
-- Dependencies: _getCommonslink(); _getSitelink(); parseParam()
-------------------------------------------------------------------------------
p.getCommonsLink = function(frame)
	local oc = frame.args.onlycat or frame.args.onlycategories
	local fb = parseParam(frame.args.fallback or frame.args.fb, true)
	return _getCommonslink(frame.args.qid, oc, fb)
end


-------------------------------------------------------------------------------
-- getSitelink takes the qid of a Wikidata entity passed as |qid=
-- It takes an optional parameter |wiki= to determine which wiki is to be checked for a sitelink
-- If the parameter is blank, then it uses the local wiki.
-- If there is a sitelink to an article available, it returns the plain text link to the article
-- If there is no sitelink, it returns nil.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getSiteLink = function(frame)
	return _getSitelink(frame.args.qid, frame.args.wiki or mw.text.trim(frame.args[1] or ""))
end


-------------------------------------------------------------------------------
-- getLink has the qid of a Wikidata entity passed as the first unnamed parameter or as |qid=
-- If there is a sitelink to an article on the local Wiki, it returns a link to the article
-- with the Wikidata label as the displayed text.
-- If there is no sitelink, it returns the label as plain text.
-- If there is no label in the local language, it displays the qid instead.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getLink = function(frame)
	local itemID = mw.text.trim(frame.args[1] or frame.args.qid or "")
	if itemID == "" then return end
	local sitelink = mw.wikibase.getSitelink(itemID)
	local label = labelOrId(itemID)
	if sitelink then
		return "[[:" .. sitelink .. "|" .. label .. "]]"
	else
		return label
	end
end


-------------------------------------------------------------------------------
-- getLabel has the qid of a Wikidata entity passed as the first unnamed parameter or as |qid=
-- It returns the Wikidata label for the local language as plain text.
-- If there is no label in the local language, it displays the qid instead.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getLabel = function(frame)
	local itemID = mw.text.trim(frame.args[1] or frame.args.qid or "")
	if itemID == "" then return end
	local lang = frame.args.lang or ""
	if lang == "" then lang = nil end
	local label = labelOrId(itemID, lang)
	return label
end


-------------------------------------------------------------------------------
-- label has the qid of a Wikidata entity passed as the first unnamed parameter or as |qid=
-- if no qid is supplied, it uses the qid associated with the current page.
-- It returns the Wikidata label for the local language as plain text.
-- If there is no label in the local language, it returns nil.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.label = function(frame)
	local qid = mw.text.trim(frame.args[1] or frame.args.qid or "")
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return end
	local lang = frame.args.lang or ""
	if lang == "" then lang = nil end
	local label, success = labelOrId(qid, lang)
	if success then return label end
end


-------------------------------------------------------------------------------
-- getAT (Article Title)
-- has the qid of a Wikidata entity passed as the first unnamed parameter or as |qid=
-- If there is a sitelink to an article on the local Wiki, it returns the sitelink as plain text.
-- If there is no sitelink or qid supplied, it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getAT = function(frame)
	local itemID = mw.text.trim(frame.args[1] or frame.args.qid or "")
	if itemID == "" then return end
	return mw.wikibase.getSitelink(itemID)
end


-------------------------------------------------------------------------------
-- getDescription has the qid of a Wikidata entity passed as |qid=
-- (it defaults to the associated qid of the current article if omitted)
-- and a local parameter passed as the first unnamed parameter.
-- Any local parameter passed (other than "Wikidata" or "none") becomes the return value.
-- It returns the article description for the Wikidata entity if the local parameter is "Wikidata".
-- Nothing is returned if the description doesn't exist or "none" is passed as the local parameter.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getDescription = function(frame)
	local desc = mw.text.trim(frame.args[1] or "")
	local itemID = mw.text.trim(frame.args.qid or "")
	if itemID == "" then itemID = nil end
	if desc:lower() == 'wikidata' then
		return mw.wikibase.getDescription(itemID)
	elseif desc:lower() == 'none' then
		return nil
	else
		return desc
	end
end


-------------------------------------------------------------------------------
-- getAliases has the qid of a Wikidata entity passed as |qid=
-- (it defaults to the associated qid of the current article if omitted)
-- and a local parameter passed as the first unnamed parameter.
-- It implements blacklisting and whitelisting with a field name of "alias" by default.
-- Any local parameter passed becomes the return value.
-- Otherwise it returns the aliases for the Wikidata entity with the usual list options.
-- Nothing is returned if the aliases do not exist.
-------------------------------------------------------------------------------
-- Dependencies: findLang(); assembleoutput()
-------------------------------------------------------------------------------
p.getAliases = function(frame)
	local args = frame.args

	local fieldname = args.name or ""
	if fieldname == "" then fieldname = "alias" end

	local blacklist = args.suppressfields or args.spf or ""
	if blacklist:find(fieldname) then return nil end

	local localval = mw.text.trim(args[1] or "")
	if localval ~= "" then return localval end

	local whitelist = args.fetchwikidata or args.fwd or ""
	if whitelist == "" then whitelist = "NONE" end
	if not (whitelist == 'ALL' or whitelist:find(fieldname)) then return nil end

	local qid = args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid or not mw.wikibase.entityExists(qid) then return nil end

	local aliases = mw.wikibase.getEntity(qid).aliases
	if not aliases then return nil end

	args.langobj = findLang(args.lang)
	local langcode = args.langobj.code
	args.lang = langcode

	local out = {}
	for k1, v1 in pairs(aliases) do
		if v1[1].language == langcode then
			for k1, v2 in ipairs(v1) do
				out[#out+1] = v2.value
			end
			break
		end
	end

	return assembleoutput(out, args, qid)
end


-------------------------------------------------------------------------------
-- pageId returns the page id (entity ID, Qnnn) of the current page
-- returns nothing if the page is not connected to Wikidata
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.pageId = function(frame)
	return mw.wikibase.getEntityIdForCurrentPage()
end


-------------------------------------------------------------------------------
-- formatDate is a wrapper to export the private function format_Date
-------------------------------------------------------------------------------
-- Dependencies: format_Date();
-------------------------------------------------------------------------------
p.formatDate = function(frame)
	return format_Date(frame.args[1], frame.args.df, frame.args.bc)
end


-------------------------------------------------------------------------------
-- location is a wrapper to export the private function _location
-- it takes the entity-id as qid or the first unnamed parameter
-- optional boolean parameter first toggles the display of the first item
-- optional boolean parameter skip toggles the display to skip to the last item
-- parameter debug=&lt;y/n&gt; (default 'n') adds error msg if not a location
-------------------------------------------------------------------------------
-- Dependencies: _location();
-------------------------------------------------------------------------------
p.location = function(frame)
	local debug = (frame.args.debug or ""):sub(1, 1):lower()
	if debug == "" then debug = "n" end
	local qid = mw.text.trim(frame.args.qid or frame.args[1] or ""):upper()
	if qid == "" then qid=mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then
		if debug ~= "n" then
			return i18n.errors["entity-not-found"]
		else
			return nil
		end
	end
	local first = mw.text.trim(frame.args.first or "")
	local skip = mw.text.trim(frame.args.skip or "")
	return table.concat( _location(qid, first, skip), ", " )
end


-------------------------------------------------------------------------------
-- checkBlacklist implements a test to check whether a named field is allowed
-- returns true if the field is not blacklisted (i.e. allowed)
-- returns false if the field is blacklisted (i.e. disallowed)
-- {{#if:{{#invoke:WikidataIB |checkBlacklist |name=Joe |suppressfields=Dave; Joe; Fred}} | not blacklisted | blacklisted}}
-- displays "blacklisted"
-- {{#if:{{#invoke:WikidataIB |checkBlacklist |name=Jim |suppressfields=Dave; Joe; Fred}} | not blacklisted | blacklisted}}
-- displays "not blacklisted"
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.checkBlacklist = function(frame)
	local blacklist = frame.args.suppressfields or frame.args.spf or ""
	local fieldname = frame.args.name or ""
	if blacklist ~= "" and fieldname ~= "" then
		if blacklist:find(fieldname) then
			return false
		else
			return true
		end
	else
		-- one of the fields is missing: let's call that "not on the list"
		return true
	end
end


-------------------------------------------------------------------------------
-- emptyor returns nil if its first unnamed argument is just punctuation, whitespace or html tags
-- otherwise it returns the argument unchanged (including leading/trailing space).
-- If the argument may contain "=", then it must be called explicitly:
-- |1=arg
-- (In that case, leading and trailing spaces are trimmed)
-- It finds use in infoboxes where it can replace tests like:
-- {{#if: {{#invoke:WikidatIB |getvalue |P99 |fwd=ALL}} | &lt;span class="xxx"&gt;{{#invoke:WikidatIB |getvalue |P99 |fwd=ALL}}&lt;/span&gt; | }}
-- with a form that uses just a single call to Wikidata:
-- {{#invoke |WikidataIB |emptyor |1= &lt;span class="xxx"&gt;{{#invoke:WikidataIB |getvalue |P99 |fwd=ALL}}&lt;/span&gt; }}
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.emptyor = function(frame)
	local s = frame.args[1] or ""
	if s == "" then return nil end
	local sx = s:gsub("%s", ""):gsub("&lt;[^&gt;]*&gt;", ""):gsub("%p", "")
	if sx == "" then
		return nil
	else
		return s
	end
end


-------------------------------------------------------------------------------
-- labelorid is a public function to expose the output of labelOrId()
-- Pass the Q-number as |qid= or as an unnamed parameter.
-- It returns the Wikidata label for that entity or the qid if no label exists.
-------------------------------------------------------------------------------
-- Dependencies: labelOrId
-------------------------------------------------------------------------------
p.labelorid = function(frame)
	return (labelOrId(frame.args.qid or frame.args[1]))
end


-------------------------------------------------------------------------------
-- getLang returns the MediaWiki language code of the current content.
-- If optional parameter |style=full, it returns the language name.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getLang = function(frame)
	local style = (frame.args.style or ""):lower()
	local langcode = mw.language.getContentLanguage().code
	if style == "full" then
		return mw.language.fetchLanguageName( langcode )
	end
	return langcode
end


-------------------------------------------------------------------------------
-- getItemLangCode takes a qid parameter (using the current page's qid if blank)
-- If the item for that qid has property country (P17) it looks at the first preferred value
-- If the country has an official language (P37), it looks at the first preferred value
-- If that official language has a language code (P424), it returns the first preferred value
-- Otherwise it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: _getItemLangCode()
-------------------------------------------------------------------------------
p.getItemLangCode = function(frame)
	return _getItemLangCode(frame.args.qid or frame.args[1])
end


-------------------------------------------------------------------------------
-- findLanguage exports the local findLang() function
-- It takes an optional language code and returns, in order of preference:
-- the code if a known language;
-- the user's language, if set;
-- the server's content language.
-------------------------------------------------------------------------------
-- Dependencies: findLang
-------------------------------------------------------------------------------
p.findLanguage = function(frame)
	return findLang(frame.args.lang or frame.args[1]).code
end


-------------------------------------------------------------------------------
-- getQid returns the qid, if supplied
-- failing that, the Wikidata entity ID of the "category's main topic (P301)", if it exists
-- failing that, the Wikidata entity ID associated with the current page, if it exists
-- otherwise, nothing
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getQid = function(frame)
	local qid = (frame.args.qid or ""):upper()
	-- check if a qid was passed; if so, return it:
	if qid ~= "" then return qid end
	-- check if there's a "category's main topic (P301)":
	qid = mw.wikibase.getEntityIdForCurrentPage()
	if qid then
		local prop301 = mw.wikibase.getBestStatements(qid, "P301")
		if prop301[1] then
			local mctid = prop301[1].mainsnak.datavalue.value.id
			if mctid then return mctid end
		end
	end
	-- otherwise return the page qid (if any)
	return qid
end


-------------------------------------------------------------------------------
-- followQid takes four optional parameters: qid, props, list and all.
-- If qid is not given, it uses the qid for the connected page
-- or returns nil if there isn't one.
-- props is a list of properties, separated by punctuation.
-- If props is given, the Wikidata item for the qid is examined for each property in turn.
-- If that property contains a value that is another Wikibase-item, that item's qid is returned,
-- and the search terminates, unless |all=y when all of the qids are returned, separated by spaces.
-- If |list= is set to a template, the qids are passed as arguments to the template.
-- If props is not given, the qid is returned.
-------------------------------------------------------------------------------
-- Dependencies: parseParam()
-------------------------------------------------------------------------------
p._followQid = function(args)
	local qid = (args.qid or ""):upper()
	local all = parseParam(args.all, false)
	local list = args.list or ""
	if list == "" then list = nil end
	if qid == "" then
		qid = mw.wikibase.getEntityIdForCurrentPage()
	end
	if not qid then return nil end
	local out = {}
	local props = (args.props or ""):upper()
	if props ~= "" then
		for p in mw.text.gsplit(props, "%p") do -- split at punctuation and iterate
			p = mw.text.trim(p)
			for i, v in ipairs( mw.wikibase.getBestStatements(qid, p) ) do
				local linkedid = v.mainsnak.datavalue and v.mainsnak.datavalue.value.id
				if linkedid then
					if all then
						out[#out+1] = linkedid
					else
						return linkedid
					end -- test for all or just the first one found
				end -- test for value exists for that property
			end -- loop through values of property to follow
		end -- loop through list of properties to follow
	end
	if #out &gt; 0 then
		local ret = ""
		if list then
			ret = mw.getCurrentFrame():expandTemplate{title = list, args = out}
		else
			ret = table.concat(out, " ")
		end
		return ret
	else
		return qid
	end
end

p.followQid = function(frame)
	return p._followQid(frame.args)
end


-------------------------------------------------------------------------------
-- globalSiteID returns the globalSiteID for the current wiki
-- e.g. returns "enwiki" for the English Wikipedia, "enwikisource" for English Wikisource, etc.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.globalSiteID = function(frame)
	return mw.wikibase.getGlobalSiteId()
end


-------------------------------------------------------------------------------
-- siteID returns the root of the globalSiteID
-- e.g. "en" for "enwiki", "enwikisource", etc.
-- treats "en-gb" as "en", etc.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.siteID = function(frame)
	local txtlang = frame:callParserFunction('int', {'lang'}) or ""
	-- This deals with specific exceptions: be-tarask -&gt; be-x-old
	if txtlang == "be-tarask" then
		return "be_x_old"
	end
	local pos = txtlang:find("-")
	local ret = ""
	if pos then
		ret = txtlang:sub(1, pos-1)
	else
		ret = txtlang
	end
	return ret
end


-------------------------------------------------------------------------------
-- projID returns the code used to link to the reader's language's project
-- e.g "en" for [[:en:WikidataIB]]
-- treats "en-gb" as "en", etc.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.projID = function(frame)
	local txtlang = frame:callParserFunction('int', {'lang'}) or ""
	-- This deals with specific exceptions: be-tarask -&gt; be-x-old
	if txtlang == "be-tarask" then
		return "be-x-old"
	end
	local pos = txtlang:find("-")
	local ret = ""
	if pos then
		ret = txtlang:sub(1, pos-1)
	else
		ret = txtlang
	end
	return ret
end


-------------------------------------------------------------------------------
-- formatNumber formats a number according to the the supplied language code ("|lang=")
-- or the default language if not supplied.
-- The number is the first unnamed parameter or "|num="
-------------------------------------------------------------------------------
-- Dependencies: findLang()
-------------------------------------------------------------------------------
p.formatNumber = function(frame)
	local lang
	local num = tonumber(frame.args[1] or frame.args.num) or 0
	lang = findLang(frame.args.lang)
	return lang:formatNum( num )
end


-------------------------------------------------------------------------------
-- examine dumps the property (the unnamed parameter or pid)
-- from the item given by the parameter 'qid' (or the other unnamed parameter)
-- or from the item corresponding to the current page if qid is not supplied.
-- e.g. {{#invoke:WikidataIB |examine |pid=P26 |qid=Q42}}
-- or {{#invoke:WikidataIB |examine |P26 |Q42}} or any combination of these
-- or {{#invoke:WikidataIB |examine |P26}} for the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.examine = function( frame )
	local args
	if frame.args[1] or frame.args.pid or frame.args.qid then
		args = frame.args
	else
		args = frame:getParent().args
	end
	local par = {}
	local pid = (args.pid or ""):upper()
	local qid = (args.qid or ""):upper()
	par[1] = mw.text.trim( args[1] or "" ):upper()
	par[2] = mw.text.trim( args[2] or "" ):upper()
	table.sort(par)
	if par[2]:sub(1,1) == "P" then par[1], par[2] = par[2], par[1] end
	if pid == "" then pid = par[1] end
	if qid == "" then qid = par[2] end
	local q1 = qid:sub(1,1)
	if pid:sub(1,1) ~= "P" then return "No property supplied" end
	if q1 ~= "Q" and q1 ~= "M" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return "No item for this page" end
	return "&lt;pre&gt;" .. mw.dumpObject( mw.wikibase.getAllStatements( qid, pid ) ) .. "&lt;/pre&gt;"
end


-------------------------------------------------------------------------------
-- checkvalue looks for 'val' as a wikibase-item value of a property (the unnamed parameter or pid)
-- from the item given by the parameter 'qid'
-- or from the Wikidata item associated with the current page if qid is not supplied.
-- It only checks ranks that are requested (preferred and normal by default)
-- If property is not supplied, then P31 (instance of) is assumed.
-- It returns val if found or nothing if not found.
-- e.g. {{#invoke:WikidataIB |checkvalue |val=Q5 |pid=P31 |qid=Q42}}
-- or {{#invoke:WikidataIB |checkvalue |val=Q5 |P31 |qid=Q42}}
-- or {{#invoke:WikidataIB |checkvalue |val=Q5 |qid=Q42}}
-- or {{#invoke:WikidataIB |checkvalue |val=Q5 |P31}} for the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.checkvalue = function( frame )
	local args
	if frame.args.val then
		args = frame.args
	else
		args = frame:getParent().args
	end
	local val = args.val
	if not val then return nil end
	local pid = mw.text.trim(args.pid or args[1] or "P31"):upper()
	local qid = (args.qid or ""):upper()
	if pid:sub(1,1) ~= "P" then return nil end
	if qid:sub(1,1) ~= "Q" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return nil end
	local ranks = setRanks(args.rank)
	local stats = {}
	if ranks.b then
		stats = mw.wikibase.getBestStatements(qid, pid)
	else
		stats = mw.wikibase.getAllStatements( qid, pid )
	end
	if not stats[1] then return nil end
	if stats[1].mainsnak.datatype == "wikibase-item" then
		for k, v in pairs( stats ) do
			local ms = v.mainsnak
			if ranks[v.rank:sub(1,1)] and ms.snaktype == "value" and ms.datavalue.value.id == val then
				return val
			end
		end
	end
	return nil
end


-------------------------------------------------------------------------------
-- url2 takes a parameter url= that is a proper url and formats it for use in an infobox.
-- If no parameter is supplied, it returns nothing.
-- This is the equivalent of Template:URL
-- but it keeps the "edit at Wikidata" pen icon out of the microformat.
-- Usually it will take its url parameter directly from a Wikidata call:
-- e.g. {{#invoke:WikidataIB |url2 |url={{wdib |P856 |qid=Q23317 |fwd=ALL |osd=no}} }}
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.url2 = function(frame)
	local txt = frame.args.url or ""
	if txt == "" then return nil end
	-- extract any icon
	local url, icon = txt:match("(.+)&amp;nbsp;(.+)")
	-- make sure there's at least a space at the end
	url = (url or txt) .. " "
	icon = icon or ""
	-- extract any protocol like https://
	local prot = url:match("(https*://).+[ \"\']")
	-- extract address
	local addr = ""
	if prot then
		addr = url:match("https*://(.+)[ \"\']") or " "
	else
		prot = "//"
		addr = url:match("[^%p%s]+%.(.+)[ \"\']") or " "
	end
	-- strip trailing / from end of domain-only url and add &lt;wbr/&gt; before . and /
	local disp, n = addr:gsub( "^([^/]+)/$", "%1" ):gsub("%/", "&lt;wbr/&gt;/"):gsub("%.", "&lt;wbr/&gt;.")
	return '&lt;span class="url"&gt;[' .. prot .. addr .. " " .. disp .. "]&lt;/span&gt;&amp;nbsp;" .. icon
end


-------------------------------------------------------------------------------
-- getWebsite fetches the Official website (P856) and formats it for use in an infobox.
-- This is similar to Template:Official website but with a url displayed,
-- and it adds the "edit at Wikidata" pen icon beyond the microformat if enabled.
-- A local value will override the Wikidata value. "NONE" returns nothing.
-- e.g. {{#invoke:WikidataIB |getWebsite |qid= |noicon= |lang= |url= }}
-------------------------------------------------------------------------------
-- Dependencies: findLang(); parseParam();
-------------------------------------------------------------------------------
p.getWebsite = function(frame)
	local url = frame.args.url or ""
	if url:upper() == "NONE" then return nil end
	local urls = {}
	local quals = {}
	local qid = frame.args.qid or ""
	if url and url ~= "" then
		urls[1] = url
	else
		if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
		if not qid then return nil end

		local prop856 = mw.wikibase.getBestStatements(qid, "P856")
		for k, v in pairs(prop856) do
			if v.mainsnak.snaktype == "value" then
				urls[#urls+1] = v.mainsnak.datavalue.value
				if v.qualifiers and v.qualifiers["P1065"] then
					 -- just take the first archive url (P1065)
					local au = v.qualifiers["P1065"][1]
					if au.snaktype == "value" then
						quals[#urls] = au.datavalue.value
					end -- test for archive url having a value
				end -- test for qualifers
			end -- test for website having a value
		end -- loop through website(s)
	end
	if #urls == 0 then return nil end

	local out = {}
	for i, u in ipairs(urls) do
		local link = quals[i] or u
		local prot, addr = u:match("(http[s]*://)(.+)")
		addr = addr or u
		local disp, n = addr:gsub("%.", "&lt;wbr/&gt;%.")
		out[#out+1] = '&lt;span class="url"&gt;[' .. link .. " " .. disp .. "]&lt;/span&gt;"
	end

	local langcode = findLang(frame.args.lang).code
	local noicon = parseParam(frame.args.noicon, false)
	if url == "" and not noicon then
		out[#out] = out[#out] .. createicon(langcode, qid, "P856")
	end

	local ret = ""
	if #out &gt; 1 then
		ret = mw.getCurrentFrame():expandTemplate{title = "ubl", args = out}
	else
		ret = out[1]
	end

	return ret
end


-------------------------------------------------------------------------------
-- getAllLabels fetches the set of labels and formats it for display as wikitext.
-- It takes a parameter 'qid' for arbitrary access, otherwise it uses the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getAllLabels = function(frame)
	local args = frame.args or frame:getParent().args or {}

	local qid = args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid or not mw.wikibase.entityExists(qid) then return i18n["entity-not-found"] end

	local labels = mw.wikibase.getEntity(qid).labels
	if not labels then return i18n["labels-not-found"] end

	local out = {}
	for k, v in pairs(labels) do
		out[#out+1] = v.value .. " (" .. v.language .. ")"
	end

	return table.concat(out, "; ")
end


-------------------------------------------------------------------------------
-- getAllDescriptions fetches the set of descriptions and formats it for display as wikitext.
-- It takes a parameter 'qid' for arbitrary access, otherwise it uses the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getAllDescriptions = function(frame)
	local args = frame.args or frame:getParent().args or {}

	local qid = args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid or not mw.wikibase.entityExists(qid) then return i18n["entity-not-found"] end

	local descriptions = mw.wikibase.getEntity(qid).descriptions
	if not descriptions then return i18n["descriptions-not-found"] end

	local out = {}
	for k, v in pairs(descriptions) do
		out[#out+1] = v.value .. " (" .. v.language .. ")"
	end

	return table.concat(out, "; ")
end


-------------------------------------------------------------------------------
-- getAllAliases fetches the set of aliases and formats it for display as wikitext.
-- It takes a parameter 'qid' for arbitrary access, otherwise it uses the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getAllAliases = function(frame)
	local args = frame.args or frame:getParent().args or {}

	local qid = args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid or not mw.wikibase.entityExists(qid) then return i18n["entity-not-found"] end

	local aliases = mw.wikibase.getEntity(qid).aliases
	if not aliases then return i18n["aliases-not-found"] end

	local out = {}
	for k1, v1 in pairs(aliases) do
		local lang = v1[1].language
		local val = {}
		for k1, v2 in ipairs(v1) do
			val[#val+1] = v2.value
		end
		out[#out+1] = table.concat(val, ", ") .. " (" .. lang .. ")"
	end

	return table.concat(out, "; ")
end


-------------------------------------------------------------------------------
-- showNoLinks displays the article titles that should not be linked.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.showNoLinks = function(frame)
	local out = {}
	for k, v in pairs(donotlink) do
		out[#out+1] = k
	end
	table.sort( out )
	return table.concat(out, "; ")
end


-------------------------------------------------------------------------------
-- checkValidity checks whether the first unnamed parameter represents a valid entity-id,
-- that is, something like Q1235 or P123.
-- It returns the strings "true" or "false".
-- Change false to nil to return "true" or "" (easier to test with #if:).
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
function p.checkValidity(frame)
	local id = mw.text.trim(frame.args[1] or "")
	if mw.wikibase.isValidEntityId(id) then
		return true
	else
		return false
	end
end


-------------------------------------------------------------------------------
-- getEntityFromTitle returns the Entity-ID (Q-number) for a given title.
-- Modification of Module:ResolveEntityId
-- The title is the first unnamed parameter.
-- The site parameter determines the site/language for the title. Defaults to current wiki.
-- The showdab parameter determines whether dab pages should return the Q-number or nil. Defaults to true.
-- Returns the Q-number or nil if it does not exist.
-------------------------------------------------------------------------------
-- Dependencies: parseParam
-------------------------------------------------------------------------------
function p.getEntityFromTitle(frame)
	local args=frame.args
	if not args[1] then args=frame:getParent().args end
	if not args[1] then return nil end
	local title = mw.text.trim(args[1])
	local site = args.site or ""
	local showdab = parseParam(args.showdab, true)
	local qid = mw.wikibase.getEntityIdForTitle(title, site)
	if qid then
		local prop31 = mw.wikibase.getBestStatements(qid, "P31")[1]
		if not showdab and prop31 and prop31.mainsnak.datavalue.value.id == "Q4167410" then
			return nil
		else
			return qid
		end
	end
end


-------------------------------------------------------------------------------
-- getDatePrecision returns the number representing the precision of the first best date value
-- for the given property.
-- It takes the qid and property ID
-- The meanings are given at https://www.mediawiki.org/wiki/Wikibase/DataModel#Dates_and_times
-- 0 = 1 billion years .. 6 = millennium, 7 = century, 8 = decade, 9 = year, 10 = month, 11 = day
-- Returns 0 (or the second unnamed parameter) if the Wikidata does not exist.
-------------------------------------------------------------------------------
-- Dependencies: parseParam; sourced;
-------------------------------------------------------------------------------
function p.getDatePrecision(frame)
	local args=frame.args
	if not args[1] then args=frame:getParent().args end
	local default = tonumber(args[2] or args.default) or 0
	local prop = mw.text.trim(args[1] or "")
	if prop == "" then return default end
	local qid = args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return default end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local stat = mw.wikibase.getBestStatements(qid, prop)
	for i, v in ipairs(stat) do
		local prec = (onlysrc == false or sourced(v))
			and v.mainsnak.datavalue
			and v.mainsnak.datavalue.value
			and v.mainsnak.datavalue.value.precision
		if prec then return prec end
	end
	return default
end


return p


-------------------------------------------------------------------------------
-- List of exported functions
-------------------------------------------------------------------------------
--[[
_getValue
getValue
getPreferredValue
getCoords
getQualifierValue
getSumOfParts
getValueByQual
getValueByLang
getValueByRefSource
getPropertyIDs
getQualifierIDs
getPropOfProp
getAwardCat
getIntersectCat
getGlobe
getCommonsLink
getSiteLink
getLink
getLabel
label
getAT
getDescription
getAliases
pageId
formatDate
location
checkBlacklist
emptyor
labelorid
getLang
getItemLangCode
findLanguage
getQID
followQid
globalSiteID
siteID
projID
formatNumber
examine
checkvalue
url2
getWebsite
getAllLabels
getAllDescriptions
getAllAliases
showNoLinks
checkValidity
getEntityFromTitle
getDatePrecision
--]]
-------------------------------------------------------------------------------</text>
      <sha1>o26pvdzoveksr04pobp213ncnrqerd6</sha1>
    </revision>
  </page>
  <page>
    <title>Module:WikidataIB/nolinks</title>
    <ns>828</ns>
    <id>175</id>
    <revision>
      <id>338</id>
      <parentid>337</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>337</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="832" sha1="os706fxg7ivfr0wq2o2z1afni11n93q" xml:space="preserve">local p ={}

--[[
The values here are the English sitelinks for items that should not be linked.
These 36 are not definitive and may be altered to suit.
--]]
p.items = {
	"Australia",
	"Austria",
	"Belgium",
	"Canada",
	"China",
	"Denmark",
	"England",
	"France",
	"Germany",
	"Greece",
	"Hungary",
	"Iceland",
	"India",
	"Republic of Ireland",
	"Israel",
	"Italy",
	"Jamaica",
	"Japan",
	"Luxembourg",
	"Mexico",
	"Netherlands",
	"New Zealand",
	"Northern Ireland",
	"Norway",
	"Poland",
	"Portugal",
	"Russia",
	"Scotland",
	"South Africa",
	"Spain",
	"Sweden",
	"Switzerland",
	"Turkey",
	"United Kingdom",
	"UK",
	"United States",
	"USA",
	"Wales",
}

--[[
This provides a convenient way to create a test whether an item is on the list.
--]]
p.itemsindex = {}
for i, v in ipairs(p.items) do
	p.itemsindex[v] = true
end

return p</text>
      <sha1>os706fxg7ivfr0wq2o2z1afni11n93q</sha1>
    </revision>
  </page>
  <page>
    <title>Module:WikidataIB/titleformats</title>
    <ns>828</ns>
    <id>176</id>
    <revision>
      <id>340</id>
      <parentid>339</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>339</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1061" sha1="kf27lmax414v7k61jzza3jomkstxn1m" xml:space="preserve">--[[
To satisfy Wikipedia:Manual of Style/Titles, certain types of items are italicised,
and others are quoted.
This submodule lists the entity-ids used in 'instance of' (P31),
which allows a module to identify the values that should be formatted.
The table p.formats is indexed by entity-id, and contains the value " or ''
--]]

local p = {}

p.italics = {
	"Q571",			-- book
	"Q13593966",	-- literary trilogy
	"Q277759",		-- book series
	"Q2188189",		-- musical work
	"Q11424",		-- film
	"Q13593818",	-- film trilogy
	"Q24856",		-- film series
	"Q5398426",		-- television series
	"Q482994",		-- album
	"Q169930",		-- extended play
	"Q1760610",		-- comic book
	"Q7889",		-- video game
	"Q7058673",		-- video game series
	"Q25379",		-- play
	"Q2743",		-- musical
	"Q37484",		-- epic poem
	"Q41298",		-- magazine
}

p.quotes = { 
	"Q207628",		-- musical composition
}

p.size = 0
p.formats = {}

for i, v in ipairs(p.italics) do
	p.formats[v] = "''"
	p.size = p.size + 1
end

for i, v in ipairs(p.quotes) do
	p.formats[v] = '"'
	p.size = p.size + 1
end

return p</text>
      <sha1>kf27lmax414v7k61jzza3jomkstxn1m</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Portal bar</title>
    <ns>10</ns>
    <id>177</id>
    <revision>
      <id>342</id>
      <parentid>341</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>341</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="144" sha1="2e7c1lv0yixzmy178249a9kefzw3mbg" xml:space="preserve">{{#invoke:Portal bar|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>2e7c1lv0yixzmy178249a9kefzw3mbg</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Side box</title>
    <ns>10</ns>
    <id>178</id>
    <revision>
      <id>344</id>
      <parentid>343</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>343</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="142" sha1="s1zpy5c500y28mjgve7gykq14088u4e" xml:space="preserve">{{#invoke:Side box|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>s1zpy5c500y28mjgve7gykq14088u4e</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sister project</title>
    <ns>10</ns>
    <id>179</id>
    <revision>
      <id>346</id>
      <parentid>345</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>345</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1578" sha1="57n9y0e9wlqxuyatova8i0lc7p8rbm1" xml:space="preserve">{{Side box
| templatestyles = Sister project/styles.css
| metadata=no
| position = {{{position|}}}
| image    = 
  {{#switch: {{{image|}}}
  | none =    &lt;!-- "image=none", do nothing --&gt;
  |      =    &lt;!-- No image fed, select an image --&gt;
    [[File:{{#switch: {{lc: {{{project|}}} }}
    | commons|c              = Commons-logo.svg
    | meta|metawiki|m        = Wikimedia Community Logo.svg
    | wikibooks|wbk|wb|b     = Wikibooks-logo-en-noslogan.svg
    | wikidata|data          = Wikidata-logo.svg
    | wikiquote|quote|wqt|q  = Wikiquote-logo.svg
    | wikipedia|wp|w|iw      = Wikipedia-logo-v2.svg
    | wikisource|source|ws|s = Wikisource-logo.svg
    | wiktionary|wikt|wkt|wdy|d = Wiktionary-logo-en-v2.svg
    | wikinews|news|wnw|n    = Wikinews-logo.svg
    | wikispecies|species    = Wikispecies-logo.svg
    | wikiversity|wvy|v      = Wikiversity logo 2017.svg
    | wikivoyage|voyage|voy  = Wikivoyage-Logo-v3-icon.svg
    | mediawiki|mw           = MediaWiki-2020-icon.svg
    | outreachwiki|outreach  = Wikimedia Outreach.png
    | incubator              = Incubator-notext.svg
    | wikifunctions = Wikifunctions-logo.svg
    | #default               = Wikimedia-logo.svg
    }}|40x40px|class=noviewer|alt=
    ]]
  | #default = {{{image|}}}
  }}
| textclass  = {{{textclass|plainlist}}}
| textstyle  = {{{textstyle|}}}
| text       = {{{text}}}
| below      = {{{below|}}}
| imageright = {{{imageright|}}}
| class      = plainlinks sistersitebox
}}&lt;noinclude&gt;{{Documentation}}&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;&lt;/noinclude&gt;</text>
      <sha1>57n9y0e9wlqxuyatova8i0lc7p8rbm1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Tooltip</title>
    <ns>10</ns>
    <id>180</id>
    <revision>
      <id>348</id>
      <parentid>347</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>347</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="976" sha1="1dhk9zer622306s06jtqhb2qcrxf4d5" xml:space="preserve">&lt;templatestyles src="Template:Tooltip/styles.css" /&gt;{{#ifeq:{{yesno-no|{{{link}}}}}|yes
 |[[{{{1}}}|&lt;span class="rt-commentedText tooltip {{#ifeq:{{yesno-yes|{{{dotted}}}}}|no||tooltip-dotted}} {{{class|}}}" {{#if:{{{id|}}}|id="{{{id}}}"}} {{#if:{{{style|}}}|style="{{{style}}}"}} title="{{#tag:nowiki|{{#invoke:String|replace|{{{2|}}}|"|&amp;quot;}}}}"&gt;{{{1|}}}&lt;/span&gt;]]
 |&lt;span class="rt-commentedText tooltip {{#ifeq:{{yesno-yes|{{{dotted}}}}}|no||tooltip-dotted}} {{{class|}}}" {{#if:{{{id|}}}|id="{{{id}}}"}} {{#if:{{{style|}}}|style="{{{style}}}"}} title="{{#tag:nowiki|{{#invoke:String|replace|{{{2|}}}|"|&amp;quot;}}}}"&gt;{{{1|}}}&lt;/span&gt;
}}{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using tooltip with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Tooltip]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | 2 | class | dotted | id | link | style }}&lt;noinclude&gt;
{{Documentation|Template:Abbr/doc}}
&lt;/noinclude&gt;</text>
      <sha1>1dhk9zer622306s06jtqhb2qcrxf4d5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Tooltip/styles.css</title>
    <ns>10</ns>
    <id>181</id>
    <revision>
      <id>350</id>
      <parentid>349</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>349</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="84" sha1="a3nuuy8e07xkoz1hiw7pmpuv4gixony" xml:space="preserve">/* {{pp-template}} */
.tooltip-dotted {
	border-bottom: 1px dotted;
	cursor: help;
}</text>
      <sha1>a3nuuy8e07xkoz1hiw7pmpuv4gixony</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Yesno-no</title>
    <ns>10</ns>
    <id>182</id>
    <revision>
      <id>352</id>
      <parentid>351</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>351</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="269" sha1="34vmtxa9ubuh1vz2ulp78m5ela68riu" xml:space="preserve">{{safesubst:&lt;noinclude /&gt;yesno|{{{1}}}|yes={{{yes|yes}}}|no={{{no|no}}}|blank={{{blank|no}}}|¬={{{¬|no}}}|def={{{def|no}}}}}&lt;noinclude&gt;
{{Documentation|Template:Yesno/doc}}
&lt;!--Categories go in the doc page referenced above; interwikis go in Wikidata.--&gt;
&lt;/noinclude&gt;</text>
      <sha1>34vmtxa9ubuh1vz2ulp78m5ela68riu</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Official website</title>
    <ns>10</ns>
    <id>183</id>
    <revision>
      <id>354</id>
      <parentid>353</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>353</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="387" sha1="kt3e2mvx6fpqh8sworf90p599xfs7ku" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Official website|main}}{{#invoke:Check for unknown parameters|check|showblankpositional=1|unknown={{main other|1=[[Category:Pages using Official website with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Official website]] with unknown parameter "_VALUE_"|1|2|URL|url|name}}&lt;/includeonly&gt;&lt;!--

--&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>kt3e2mvx6fpqh8sworf90p599xfs7ku</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Official website</title>
    <ns>828</ns>
    <id>184</id>
    <revision>
      <id>356</id>
      <parentid>355</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>355</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4349" sha1="4jzg7nbqawz513abbisnr4vyql6odjz" xml:space="preserve">local makeUrl = require('Module:URL')._url

local p = {}

-- Wrapper for pcall which returns nil on failure.
local function quickPcall(func)
	local success, result = pcall(func)
	if success then
		return result
	end
end

-- Gets the rank for a Wikidata property table. Returns 1, 0 or -1, in
-- order of rank.
local function getRank(prop)
	local rank = prop.rank
	if rank == 'preferred' then
		return 1
	elseif rank == 'normal' then
		return 0
	elseif rank == 'deprecated' then
		return -1
	else
		-- No rank or undefined rank is treated as "normal".
		return 0
	end
end

-- Finds whether a Wikidata property is qualified as being in English.
local function isEnglish(prop)
	local ret = quickPcall(function ()
		for i, lang in ipairs(prop.qualifiers.P407) do
			if lang.datavalue.value['numeric-id'] == 1860 then
				return true
			end
		end
		return false
	end)
	return ret == true
end

-- Fetches the official website URL from Wikidata.
local fetchWikidataUrl
fetchWikidataUrl = function()
	-- Get objects for all official sites on Wikidata.
	local websites = quickPcall(function ()
		return mw.wikibase.getAllStatements(mw.wikibase.getEntityIdForCurrentPage(), 'P856')
	end)

	-- Clone the objects in case other code needs them in their original order.
	websites = websites and mw.clone(websites) or {}

	-- Add the table index to the objects in case it is needed in the sort.
	for i, website in ipairs(websites) do
		website._index = i
	end

	-- Sort the websites, first by highest rank, and then by websites in the
	-- English language, then by the website's original position in the
	-- property list. When we are done, get the URL from the highest-sorted
	-- object.
	table.sort(websites, function(ws1, ws2)
		local r1 = getRank(ws1)
		local r2 = getRank(ws2)
		if r1 ~= r2 then
			return r1 &gt; r2
		end
		local e1 = isEnglish(ws1)
		local e2 = isEnglish(ws2)
		if e1 ~= e2 then
			return e1
		end
		return ws1._index &lt; ws2._index
	end)
	local url = quickPcall(function ()
		return websites[1].mainsnak.datavalue.value
	end)

	-- Cache the result so that we only do the heavy lifting once per #invoke.
	fetchWikidataUrl = function ()
		return url
	end

	return url
end

-- Render the URL link, plus other visible output.
local function renderUrl(options)
	if not options.url and not options.wikidataurl then
		local qid = mw.wikibase.getEntityIdForCurrentPage()
		local result = '&lt;strong class="error"&gt;' ..
			'No URL found. Please specify a URL here or add one to Wikidata.' ..
			'&lt;/strong&gt;'
		if qid then
			result = result.. ' [[File:OOjs UI icon edit-ltr-progressive.svg |frameless |text-top |10px |alt=Edit this at Wikidata |link=https://www.wikidata.org/wiki/' .. qid .. '#P856|Edit this at Wikidata]]'
		end
		return result
	end
	local ret = {}
	ret[#ret + 1] = string.format(
		'&lt;span class="official-website"&gt;%s&lt;/span&gt;',
		makeUrl(options.url or options.wikidataurl, options.display)
	)
	if options.wikidataurl and not options.url then
		local qid = mw.wikibase.getEntityIdForCurrentPage()
		if qid then
			ret[#ret + 1] = '[[File:OOjs UI icon edit-ltr-progressive.svg |frameless |text-top |10px |alt=Edit this at Wikidata |link=https://www.wikidata.org/wiki/' .. qid .. '#P856|Edit this at Wikidata]]'
		end
	end
	return table.concat(ret, ' ')
end

-- Render the tracking category.
local function renderTrackingCategory(url, wikidataurl)
	if mw.title.getCurrentTitle().namespace ~= 0 then
		return ''
	end
	local category
	if not url and not wikidataurl then
		category = 'Official website missing URL'
	elseif not url and wikidataurl then
		return ''
	elseif url and wikidataurl then
		if url:gsub('/%s*$', '') ~= wikidataurl:gsub('/%s*$', '') then
			category = 'Official website different in Wikidata and Wikipedia'
		end
	else
		category = 'Official website not in Wikidata'
	end
	return category and string.format('[[Category:%s]]', category) or ''
end

function p._main(args)
	local url = args[1] or args.URL or args.url
	local wikidataurl = fetchWikidataUrl()
	local formattedUrl = renderUrl{
		url = url,
		wikidataurl = wikidataurl,
		display = args[2] or args.name or 'Official website'
	}
	return formattedUrl .. renderTrackingCategory(url, wikidataurl)
end

function p.main(frame)
	local args = require('Module:Arguments').getArgs(frame, {
		wrappers = 'Template:Official website'
	})
	return p._main(args)
end

return p</text>
      <sha1>4jzg7nbqawz513abbisnr4vyql6odjz</sha1>
    </revision>
  </page>
  <page>
    <title>Module:URL</title>
    <ns>828</ns>
    <id>185</id>
    <revision>
      <id>358</id>
      <parentid>357</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>357</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4153" sha1="gixxb57tc26pz8o8bkotc73wlgavvuj" xml:space="preserve">--
-- This module implements {{URL}}
--
-- See unit tests at [[Module:URL/testcases]]

local p = {}
 
local function safeUri(s)
	local success, uri = pcall(function()
		return mw.uri.new(s)
	end)
	if success then
		return uri
	end
end

local function extractUrl(args)
	for name, val in pairs(args) do
		if name ~= 2 and name ~= "msg" then
			local url = name .. "=" .. val;
			url = mw.ustring.gsub(url, '^[Hh][Tt][Tt][Pp]([Ss]?):(/?)([^/])', 'http%1://%3')
			local uri = safeUri(url);
			if uri and uri.host then
				return url
			end
		end
	end
end

function p._url(url, text, msg)
	url = mw.text.trim(url or '')
	text = mw.text.trim(text or '')
	local nomsg = (msg or ''):sub(1,1):lower() == "n" or msg == 'false' -- boolean: true if msg is "false" or starts with n or N

	if url == '' then
		if text == '' then
			if nomsg then
				return nil
			else
				return mw.getCurrentFrame():expandTemplate{ title = 'tlx', args = { 'URL', "''example.com''", "''optional display text''" } }
			end
		else
			return text
		end
	end

	-- If the URL contains any unencoded spaces, encode them, because MediaWiki will otherwise interpret a space as the end of the URL.
	url = mw.ustring.gsub(url, '%s', function(s) return mw.uri.encode(s, 'PATH') end)

	-- If there is an empty query string or fragment id, remove it as it will cause mw.uri.new to throw an error
	url = mw.ustring.gsub(url, '#$', '')
	url = mw.ustring.gsub(url, '%?$', '')

	-- If it's an HTTP[S] URL without the double slash, fix it.
	url = mw.ustring.gsub(url, '^[Hh][Tt][Tt][Pp]([Ss]?):(/?)([^/])', 'http%1://%3')

	local uri = safeUri(url)

	-- Handle URL's without a protocol and URL's that are protocol-relative, 
	-- e.g. www.example.com/foo or www.example.com:8080/foo, and //www.example.com/foo
	if uri and (not uri.protocol or (uri.protocol and not uri.host)) and url:sub(1, 2) ~= '//' then
		url = 'http://' .. url
		uri = safeUri(url)
	end

	if text == '' then
		if uri then
			if uri.path == '/' then uri.path = '' end

			local port = ''
			if uri.port then port = ':' .. uri.port end

			text = mw.ustring.lower(uri.host or '') .. port .. (uri.relativePath or '')

			-- Add &lt;wbr&gt; before _/.-# sequences
			text = mw.ustring.gsub(text,"(/+)","&lt;wbr/&gt;%1")      -- This entry MUST be the first. "&lt;wbr/&gt;" has a "/" in it, you know.
			text = mw.ustring.gsub(text,"(%.+)","&lt;wbr/&gt;%1")
			-- text = mw.ustring.gsub(text,"(%-+)","&lt;wbr/&gt;%1") 	-- DISABLED for now
			text = mw.ustring.gsub(text,"(%#+)","&lt;wbr/&gt;%1")
			text = mw.ustring.gsub(text,"(_+)","&lt;wbr/&gt;%1")
		else -- URL is badly-formed, so just display whatever was passed in
			text = url
		end
	end

	return mw.ustring.format('&lt;span class="url"&gt;[%s %s]&lt;/span&gt;', url, text)
end

--[[
The main entry point for calling from Template:URL.
--]]
function p.url(frame)
	local templateArgs = frame.args
	local parentArgs = frame:getParent().args
	local url = templateArgs[1] or parentArgs[1]
	local text = templateArgs[2] or parentArgs[2] or ''
	local msg = templateArgs.msg or parentArgs.msg or ''
	url = url or extractUrl(templateArgs) or extractUrl(parentArgs) or ''
	return p._url(url, text, msg)
end

--[[
The entry point for calling from the forked Template:URL2.
This function returns no message by default.
It strips out wiki-link markup, html tags, and everything after a space.
--]]
function p.url2(frame)
	local templateArgs = frame.args
	local parentArgs = frame:getParent().args
	local url = templateArgs[1] or parentArgs[1]
	local text = templateArgs[2] or parentArgs[2] or ''
	-- default to no message
	local msg = templateArgs.msg or parentArgs.msg or 'no'
	url = url or extractUrl(templateArgs) or extractUrl(parentArgs) or ''
	-- if the url came from a Wikidata call, it might have a pen icon appended
	-- we want to keep that and add it back at the end.
	local u1, penicon = mw.ustring.match( url, "(.*)(&amp;nbsp;&lt;span class='penicon.*)" )
	if penicon then url = u1 end
	-- strip out html tags and [ ] from url
	url = (url or ''):gsub("&lt;[^&gt;]*&gt;", ""):gsub("[%[%]]", "")
	-- truncate anything after a space
	url = url:gsub("%%20", " "):gsub(" .*", "")
	return (p._url(url, text, msg) or "") .. (penicon or "")
end

return p</text>
      <sha1>gixxb57tc26pz8o8bkotc73wlgavvuj</sha1>
    </revision>
  </page>
  <page>
    <title>Template:'</title>
    <ns>10</ns>
    <id>186</id>
    <redirect title="Template:Apostrophe" />
    <revision>
      <id>360</id>
      <parentid>359</parentid>
      <timestamp>2025-07-09T04:31:41Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>359</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="80" sha1="rw40h4f5laoj6qqc97p6qc2r0482lz8" xml:space="preserve">#REDIRECT [[Template:Apostrophe]]

{{Redirect category shell|
{{R from move}}
}}</text>
      <sha1>rw40h4f5laoj6qqc97p6qc2r0482lz8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Italic title</title>
    <ns>10</ns>
    <id>187</id>
    <revision>
      <id>362</id>
      <parentid>361</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>361</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="312" sha1="85lglhnzpitlfglkbzrzq17vmxf9v8m" xml:space="preserve">&lt;includeonly&gt;&lt;nowiki/&gt;&lt;!--This nowiki helps to prevent whitespace at the top of articles ([[phab:T369520]]). This template is empty, produces no output.--&gt;{{#invoke:Italic title|main}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add categories to the /doc subpage and interwikis to Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>85lglhnzpitlfglkbzrzq17vmxf9v8m</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Italic title</title>
    <ns>828</ns>
    <id>188</id>
    <revision>
      <id>364</id>
      <parentid>363</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>363</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="8913" sha1="i5073gly55g6ltjgvutoqvgvumtx9fc" xml:space="preserve">-- This module implements {{italic title}}.

require('strict')
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local checkTypeForNamedArg = libraryUtil.checkTypeForNamedArg
local yesno = require('Module:Yesno')

--------------------------------------------------------------------------------
-- ItalicTitle class
--------------------------------------------------------------------------------

local ItalicTitle = {}

do
	----------------------------------------------------------------------------
	-- Class attributes and functions
	-- Things that belong to the class are here. Things that belong to each
	-- object are in the constructor.
	----------------------------------------------------------------------------

	-- Keys of title parts that can be italicized.
	local italicizableKeys = {
		namespace = true,
		title = true,
		dab = true,
	}

	----------------------------------------------------------------------------
	-- ItalicTitle constructor
	-- This contains all the dynamic attributes and methods.
	----------------------------------------------------------------------------

	function ItalicTitle.new()
		local obj = {}

		-- Function for checking self variable in methods.
		local checkSelf = libraryUtil.makeCheckSelfFunction(
			'ItalicTitle',
			'obj',
			obj,
			'ItalicTitle object'
		)

		-- Checks a key is present in a lookup table.
		-- Param: name - the function name.
		-- Param: argId - integer position of the key in the argument list.
		-- Param: key - the key.
		-- Param: lookupTable - the table to look the key up in.
		local function checkKey(name, argId, key, lookupTable)
			if not lookupTable[key] then
				error(string.format(
					"bad argument #%d to '%s' ('%s' is not a valid key)",
					argId,
					name,
					key
				), 3)
			end
		end

		-- Set up object structure.
		local parsed = false
		local categories = {}
		local italicizedKeys = {}
		local italicizedSubstrings = {}

		-- Parses a title object into its namespace text, title, and
		-- disambiguation text.
		-- Param: options - a table of options with the following keys:
		--     title - the title object to parse
		--     ignoreDab - ignore any disambiguation parentheses
		-- Returns the current object.
		function obj:parseTitle(options)
			checkSelf(self, 'parseTitle')
			checkType('parseTitle', 1, options, 'table')
			checkTypeForNamedArg('parseTitle', 'title', options.title, 'table')
			local title = options.title
		
			-- Title and dab text
			local prefix, parentheses
			if not options.ignoreDab then
				prefix, parentheses = mw.ustring.match(
					title.text,
					'^(.+) %(([^%(%)]+)%)$'
				)
			end
			if prefix and parentheses then
				self.title = prefix
				self.dab = parentheses
			else
				self.title = title.text
			end
		
			-- Namespace
			local namespace = mw.site.namespaces[title.namespace].name
			if namespace and #namespace &gt;= 1 then
				self.namespace = namespace
			end

			-- Register the object as having parsed a title.
			parsed = true
		
			return self
		end

		-- Italicizes part of the title.
		-- Param: key - the key of the title part to be italicized. Possible
		-- keys are contained in the italicizableKeys table.
		-- Returns the current object.
		function obj:italicize(key)
			checkSelf(self, 'italicize')
			checkType('italicize', 1, key, 'string')
			checkKey('italicize', 1, key, italicizableKeys)
			italicizedKeys[key] = true
			return self
		end

		-- Un-italicizes part of the title.
		-- Param: key - the key of the title part to be un-italicized. Possible
		-- keys are contained in the italicizableKeys table.
		-- Returns the current object.
		function obj:unitalicize(key)
			checkSelf(self, 'unitalicize')
			checkType('unitalicize', 1, key, 'string')
			checkKey('unitalicize', 1, key, italicizableKeys)
			italicizedKeys[key] = nil
			return self
		end

		-- Italicizes a substring in the title. This only affects the main part
		-- of the title, not the namespace or the disambiguation text.
		-- Param: s - the substring to be italicized.
		-- Returns the current object.
		function obj:italicizeSubstring(s)
			checkSelf(self, 'italicizeSubstring')
			checkType('italicizeSubstring', 1, s, 'string')
			italicizedSubstrings[s] = true
			return self
		end

		-- Un-italicizes a substring in the title. This only affects the main
		-- part of the title, not the namespace or the disambiguation text.
		-- Param: s - the substring to be un-italicized.
		-- Returns the current object.
		function obj:unitalicizeSubstring(s)
			checkSelf(self, 'unitalicizeSubstring')
			checkType('unitalicizeSubstring', 1, s, 'string')
			italicizedSubstrings[s] = nil
			return self
		end

		-- Renders the object into a page name. If no title has yet been parsed,
		-- the current title is used.
		-- Returns string
		function obj:renderTitle()
			checkSelf(self, 'renderTitle')

			-- Italicizes a string
			-- Param: s - the string to italicize
			-- Returns string.
			local function italicize(s)
				assert(type(s) == 'string', 's was not a string')
				assert(s ~= '', 's was the empty string')
				return string.format('&lt;i&gt;%s&lt;/i&gt;', s)
			end
		
			-- Escape characters in a string that are magic in Lua patterns.
			-- Param: pattern - the pattern to escape
			-- Returns string.
			local function escapeMagicCharacters(s)
				assert(type(s) == 'string', 's was not a string')
				return s:gsub('%p', '%%%0')
			end

			-- If a title hasn't been parsed yet, parse the current title.
			if not parsed then
				self:parseTitle{title = mw.title.getCurrentTitle()}
			end

			-- Italicize the different parts of the title and store them in a
			-- titleParts table to be joined together later.
			local titleParts = {}

			-- Italicize the italicizable keys.
			for key in pairs(italicizableKeys) do
				if self[key] then
					if italicizedKeys[key] then
						titleParts[key] = italicize(self[key])
					else
						titleParts[key] = self[key]
					end
				end
			end

			-- Italicize substrings. If there are any substrings to be
			-- italicized then start from the raw title, as this overrides any
			-- italicization of the main part of the title.
			if next(italicizedSubstrings) then
				titleParts.title = self.title
				for s in pairs(italicizedSubstrings) do
					local pattern = escapeMagicCharacters(s)
					local italicizedTitle, nReplacements = titleParts.title:gsub(
						pattern,
						italicize
					)
					titleParts.title = italicizedTitle

					-- If we didn't make any replacements then it means that we
					-- have been passed a bad substring or that the page has
					-- been moved to a bad title, so add a tracking category.
					if nReplacements &lt; 1 then
						categories['Pages using italic title with no matching string'] = true
					end
				end
			end

			-- Assemble the title together from the parts.
			local ret = ''
			if titleParts.namespace then
				ret = ret .. titleParts.namespace .. ':'
			end
			ret = ret .. titleParts.title
			if titleParts.dab then
				ret = ret .. ' (' .. titleParts.dab .. ')'
			end

			return ret
		end

		-- Returns an expanded DISPLAYTITLE parser function called with the
		-- result of obj:renderTitle, plus any other optional arguments.
		-- Returns string
		function obj:renderDisplayTitle(...)
			checkSelf(self, 'renderDisplayTitle')
			return mw.getCurrentFrame():callParserFunction(
				'DISPLAYTITLE',
				self:renderTitle(),
				...
			)
		end

		-- Returns an expanded DISPLAYTITLE parser function called with the
		-- result of obj:renderTitle, plus any other optional arguments, plus
		-- any tracking categories.
		-- Returns string
		function obj:render(...)
			checkSelf(self, 'render')
			local ret = self:renderDisplayTitle(...)
			for cat in pairs(categories) do
				ret = ret .. string.format(
					'[[Category:%s]]',
					cat
				)
			end
			return ret
		end

		return obj
	end
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p = {}

local function getArgs(frame, wrapper)
	assert(type(wrapper) == 'string', 'wrapper was not a string')
	return require('Module:Arguments').getArgs(frame, {
		wrappers = wrapper
	})
end

-- Main function for {{italic title}}
function p._main(args)
	checkType('_main', 1, args, 'table')
	local italicTitle = ItalicTitle.new()
	italicTitle:parseTitle{
		title = mw.title.getCurrentTitle(),
		ignoreDab = yesno(args.all, false)
	}
	if args.string then
		italicTitle:italicizeSubstring(args.string)
	else
		italicTitle:italicize('title')
	end
	return italicTitle:render(args[1])
end

function p.main(frame)
	return p._main(getArgs(frame, 'Template:Italic title'))
end

function p._dabonly(args)
	return ItalicTitle.new()
		:italicize('dab')
		:render(args[1])
end

function p.dabonly(frame)
	return p._dabonly(getArgs(frame, 'Template:Italic dab'))
end


return p</text>
      <sha1>i5073gly55g6ltjgvutoqvgvumtx9fc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikiquote</title>
    <ns>10</ns>
    <id>189</id>
    <revision>
      <id>366</id>
      <parentid>365</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>365</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="213" sha1="d1kzzp068azwudbm2xzpevvrctt9tlw" xml:space="preserve">{{Sister project
|project=wikiquote
|text=Wikiquote has {{{3|quotations related to}}} '''''[[q:{{{1|Special:Search/{{PAGENAME}}}}}|{{{2|{{{1|{{PAGENAME}}}}}}}}]]'''''. 
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>d1kzzp068azwudbm2xzpevvrctt9tlw</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Country data Japan</title>
    <ns>10</ns>
    <id>190</id>
    <revision>
      <id>368</id>
      <parentid>367</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>367</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1903" sha1="tfs7kx3untc5s4onfe3ba7rga6hl1hi" xml:space="preserve">{{ {{{1&lt;noinclude&gt;|country showdata&lt;/noinclude&gt;}}}
| alias = Japan
| flag alias = Flag of Japan.svg
| flag alias-1870 = Flag of Japan (1870-1999).svg
| link alias-1870 = Empire of Japan
| flag alias-1945 = Flag of Allied Occupied Japan.svg
| border-1945 =
| flag alias-1947 = Flag of Japan (1870-1999).svg
| flag alias-ryukyu = Civil ensign of the Ryukyu Islands (1952–1967).svg
| border-ryukyu =
| flag alias-naval = Naval Ensign of Japan.svg
| flag alias-coast guard = Ensign of the Japanese Coast Guard.svg
| link alias-coast guard = Japan Coast Guard
| link alias-naval = Japan Maritime Self-Defense Force
| flag alias-army = Flag of JSDF.svg
| link alias-army  = Japan Ground Self-Defense Force
| flag alias-air force = Flag of the Japan Air Self-Defense Force.svg
| link alias-air force = Japan Air Self-Defense Force
| flag alias-air force-1955 = Flag of the Japan Air Self-Defense Force (1955-1957).png
| link alias-air force-1955 = Japan Air Self-Defense Force
| flag alias-air force-1957 = Flag of the Japan Air Self-Defense Force (1957-1972).png
| link alias-air force-1957 = Japan Air Self-Defense Force
| flag alias-air force-1972 = Flag of the Japan Air Self-Defense Force (1972-2001).png
| link alias-air force-1972 = Japan Air Self-Defense Force
| flag alias-military=Flag of the Japan Self-Defense Forces.svg
| link alias-military=Japan Self-Defense Forces
| flag alias-marines=Flag of JSDF.svg
| link alias-marines=Japanese Amphibious Rapid Deployment Brigade
| flag alias-navy = Naval Ensign of Japan.svg
| link alias-navy = Japan Maritime Self-Defense Force
| {{#ifeq:{{{altlink}}}|A national rugby union team|link alias-rugby union|empty}} = Junior Japan
| size = {{{size|}}}
| name = {{{name|}}}
| altlink = {{{altlink|}}}
| variant = {{{variant|}}}
&lt;noinclude&gt;
| var1 = 1870
| var2 = 1945
| var3 = 1947
| var4 = ryukyu
| redir1 = JPN
| related1 = Empire of Japan
&lt;/noinclude&gt;
}}</text>
      <sha1>tfs7kx3untc5s4onfe3ba7rga6hl1hi</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal/images/v</title>
    <ns>828</ns>
    <id>191</id>
    <revision>
      <id>370</id>
      <parentid>369</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>369</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3942" sha1="97coxx0dew3bv621h7cxgbkn812nk35" xml:space="preserve">--[==[ This is the "V" list of portal image names. It contains a list of portal images for use with [[Module:Portal]]
-- for portal names that start with the letter "V". For aliases to existing portal names, and for portal names that
-- start with other letters, please use the appropriate page from the following list:
 
-- [[Module:Portal/images/a]]       - for portal names beginning with "A".
-- [[Module:Portal/images/b]]       - for portal names beginning with "B".
-- [[Module:Portal/images/c]]       - for portal names beginning with "C".
-- [[Module:Portal/images/d]]       - for portal names beginning with "D".
-- [[Module:Portal/images/e]]       - for portal names beginning with "E".
-- [[Module:Portal/images/f]]       - for portal names beginning with "F".
-- [[Module:Portal/images/g]]       - for portal names beginning with "G".
-- [[Module:Portal/images/h]]       - for portal names beginning with "H".
-- [[Module:Portal/images/i]]       - for portal names beginning with "I".
-- [[Module:Portal/images/j]]       - for portal names beginning with "J".
-- [[Module:Portal/images/k]]       - for portal names beginning with "K".
-- [[Module:Portal/images/l]]       - for portal names beginning with "L".
-- [[Module:Portal/images/m]]       - for portal names beginning with "M".
-- [[Module:Portal/images/n]]       - for portal names beginning with "N".
-- [[Module:Portal/images/o]]       - for portal names beginning with "O".
-- [[Module:Portal/images/p]]       - for portal names beginning with "P".
-- [[Module:Portal/images/q]]       - for portal names beginning with "Q".
-- [[Module:Portal/images/r]]       - for portal names beginning with "R".
-- [[Module:Portal/images/s]]       - for portal names beginning with "S".
-- [[Module:Portal/images/t]]       - for portal names beginning with "T".
-- [[Module:Portal/images/u]]       - for portal names beginning with "U".
-- [[Module:Portal/images/w]]       - for portal names beginning with "W".
-- [[Module:Portal/images/x]]       - for portal names beginning with "X".
-- [[Module:Portal/images/y]]       - for portal names beginning with "Y".
-- [[Module:Portal/images/z]]       - for portal names beginning with "Z".
-- [[Module:Portal/images/other]]   - for portal names beginning with any other letters. This includes numbers,
--                                    letters with diacritics, and letters in non-Latin alphabets.
-- [[Module:Portal/images/aliases]] - for adding aliases for existing portal names. Use this page for variations
--                                    in spelling and diacritics, etc., no matter what letter the portal begins with.
 
-- When adding entries, please use alphabetical order. The format of the images table entries is as follows:
--          ["portal name"] = "image.svg",
-- The portal name should be the name of your portal, in lower case. For example, the portal name for 
-- "Portal:United Kingdom" would be "united kingdom". The image name should be capitalised normally, and the "File:"
-- namespace prefix should be omitted.
]==]
 
return {
	["vanuatu"] = "Flag of Vanuatu.svg|border|link=|alt=flag",
	["vatican city"] = "Flag of the Vatican City.svg|border|link=|alt=flag",
	["venezuela"] = "Flag of Venezuela.svg|border|link=|alt=flag",
	["vermont"] = "Flag of Vermont.svg|border|link=|alt=flag",
	["victoria"] = "Flag of Victoria (Australia).svg|border|link=|alt=flag",
	["video games"] = "WPVG icon 2016.svg|link=|alt=",
	["vietnam"] = "Flag of Vietnam.svg|border|link=|alt=flag",
	["virginia"] = "Flag of Virginia.svg|border|link=|alt=flag",
	["viruses"] = "Sida-aids.png|alt=icon",
	["visual arts"] = "WPVA-khamsa.svg|alt=icon",
	["vital articles"] = "Círculos Concéntricos.svg|link=|alt=",
	["volcanism of canada"] = "Volcanism of Canada flag.png|border|alt=icon",
	["volcanoes"] = "Spaccato vulcano.svg|alt=icon",
	["volleyball"] = "Volleyball icon by Arthur Shlain.svg|alt=icon|class=skin-invert-image"
}</text>
      <sha1>97coxx0dew3bv621h7cxgbkn812nk35</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal/images/j</title>
    <ns>828</ns>
    <id>192</id>
    <revision>
      <id>372</id>
      <parentid>371</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>371</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3922" sha1="o3i5c9qz9tqwqwj4tq815nmorkzs9e8" xml:space="preserve">--[==[ This is the "J" list of portal image names. It contains a list of portal images for use with [[Module:Portal]]
-- for portal names that start with the letter "J". For aliases to existing portal names, and for portal names that
-- start with other letters, please use the appropriate page from the following list:
 
-- [[Module:Portal/images/a]]       - for portal names beginning with "A".
-- [[Module:Portal/images/b]]       - for portal names beginning with "B".
-- [[Module:Portal/images/c]]       - for portal names beginning with "C".
-- [[Module:Portal/images/d]]       - for portal names beginning with "D".
-- [[Module:Portal/images/e]]       - for portal names beginning with "E".
-- [[Module:Portal/images/f]]       - for portal names beginning with "F".
-- [[Module:Portal/images/g]]       - for portal names beginning with "G".
-- [[Module:Portal/images/h]]       - for portal names beginning with "H".
-- [[Module:Portal/images/i]]       - for portal names beginning with "I".
-- [[Module:Portal/images/k]]       - for portal names beginning with "K".
-- [[Module:Portal/images/l]]       - for portal names beginning with "L".
-- [[Module:Portal/images/m]]       - for portal names beginning with "M".
-- [[Module:Portal/images/n]]       - for portal names beginning with "N".
-- [[Module:Portal/images/o]]       - for portal names beginning with "O".
-- [[Module:Portal/images/p]]       - for portal names beginning with "P".
-- [[Module:Portal/images/q]]       - for portal names beginning with "Q".
-- [[Module:Portal/images/r]]       - for portal names beginning with "R".
-- [[Module:Portal/images/s]]       - for portal names beginning with "S".
-- [[Module:Portal/images/t]]       - for portal names beginning with "T".
-- [[Module:Portal/images/u]]       - for portal names beginning with "U".
-- [[Module:Portal/images/v]]       - for portal names beginning with "V".
-- [[Module:Portal/images/w]]       - for portal names beginning with "W".
-- [[Module:Portal/images/x]]       - for portal names beginning with "X".
-- [[Module:Portal/images/y]]       - for portal names beginning with "Y".
-- [[Module:Portal/images/z]]       - for portal names beginning with "Z".
-- [[Module:Portal/images/other]]   - for portal names beginning with any other letters. This includes numbers,
--                                    letters with diacritics, and letters in non-Latin alphabets.
-- [[Module:Portal/images/aliases]] - for adding aliases for existing portal names. Use this page for variations
--                                    in spelling and diacritics, etc., no matter what letter the portal begins with.
 
-- When adding entries, please use alphabetical order. The format of the images table entries is as follows:
--          ["portal name"] = "image.svg",
-- The portal name should be the name of your portal, in lower case. For example, the portal name for 
-- "Portal:United Kingdom" would be "united kingdom". The image name should be capitalised normally, and the "File:"
-- namespace prefix should be omitted.
]==]
 
return {
	["jainism"] = "In-jain.svg|alt=icon",
	["jakarta"] = "Coat of arms of Jakarta.svg|alt=",
	["jamaica"] = "Flag of Jamaica.svg|border|link=|alt=flag",
	["jammu and kashmir"] = "India Jammu and Kashmir locator map.svg|border|link=|alt=map",
	["japan"] = "Flag of Japan.svg|border|link=|alt=flag",
	["jazz"] = "Saxo Boca1.JPG|border|alt=icon",
	["jersey"] = "Flag of Jersey.svg|border|link=|alt=flag",
	["jerusalem"] = "Jerusalem emblem.png|link=|alt=",
	["jharkhand"] = "India Jharkhand locator map.svg|border|link=|alt=map",
	["johnston atoll"] = "Flag of the United States (DoS ECA Color Standard).svg|border|link=|alt=flag",
	["jordan"] = "Flag of Jordan.svg|border|link=|alt=flag",
	["journalism"] = "Newspaper nicu buculei 01.svg|link=|alt=",
	["judaism"] = "Star of David.svg|link=|alt=",
	["jupiter"] = "Jupiter by Cassini-Huygens.jpg|link=|alt=",
}</text>
      <sha1>o3i5c9qz9tqwqwj4tq815nmorkzs9e8</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Nihongo</title>
    <ns>828</ns>
    <id>193</id>
    <revision>
      <id>374</id>
      <parentid>373</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>373</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="23796" sha1="9j0e03l8qw3wgdriip8pcmbf1gssnwu" xml:space="preserve">require('strict');

--[[--------------------------&lt; E R R O R _ M E S S A G E S &gt;--------------------------------------------------

error messaging; keys to this table are the template base names:
	'nihongo', 'nihongo3', 'nihongo krt', 'nihongo foot' → 'nihongo' etc

]]

local err_msg = {
	['nihongo'] = 'Japanese or romaji text required',
	}

local err_cat = {
	['nihongo'] = '[[Category:Nihongo template errors]]',
	}


--[[--------------------------&lt; C O N F I G U R A T I O N &gt;----------------------------------------------------

configuration setting for the various templates.  keys to this table are the template names without capitalization

]]

local cfg = {
	['nihongo'] = {
		tag = 'ja',
		system = 'hepburn',
		system_link = '[[Hepburn romanization|Hepburn]]',
		err_msg = err_msg.nihongo,
		err_cat = err_cat.nihongo,
		},
	['nihongo3'] = {
		tag = 'ja',
		system = 'hepburn',
		err_msg = err_msg.nihongo,
		err_cat = err_cat.nihongo,
		},
	['nihongo krt'] = {
		tag = 'ja',
		system = 'hepburn',
		err_msg = err_msg.nihongo,
		err_cat = err_cat.nihongo,
		},
	['nihongo foot'] = {
		tag = 'ja',
		system = 'hepburn',
		system_link = '[[Hepburn romanization|Hepburn]]',
		err_msg = err_msg.nihongo,
		err_cat = err_cat.nihongo,
		},
	}


--[[--------------------------&lt; E R R O R _ M E S S A G E &gt;----------------------------------------------------

Creates an error message for {{nihongo}}, {{nihongo3}}, {{nihongo krt}}, and {{nihongo foot}} when these template are missing &lt;japanese&gt;
or &lt;romaji&gt; inputs; names the offending template, links to template page, and adds article to Category:Nihongo template errors

]]

local function error_message (template)
	local msg = {'&lt;span class="error" style="font-size:100%"&gt;error: {{'};
	table.insert (msg, template);
	table.insert (msg, '}}: ');
	table.insert (msg, cfg[template].err_msg);
	table.insert (msg, ' ([[Template:');
	table.insert (msg, template);
	table.insert (msg, '|help]])&lt;/span&gt;');
	if 0 == mw.title.getCurrentTitle().namespace then
		table.insert (msg, cfg[template].err_cat);
	end

	return table.concat (msg);	
end


--[[--------------------------&lt; R E N D E R E R &gt;--------------------------------------------------------------

Shared support function for nihingo(), nihongo3(), and nihongo_foot().  Calculates an index into formatting{}
from set/unset parameters:
	args[1] (english text) has a value of 8 (set) or 0 (unset)
	args[2] (native text) has a value of 4
	args[3] (romanized text) has a value of 2
	args[4] (extra) has a value of 1
index, the sum of these values, gets the appropriate format string from formatting{} table with associated values
from the formatting[index][2] table

]]

local function renderer (args, formatting, extra2)
	local output;
	local index = 0;															-- index into formatting{}
	local param_weight = {8, 4, 2, 1};											-- binary parameter weights: [1] = english (8), [2] = japanese (4), [3] = romaji (2), [4] = extra (1)

	for i=1, 5 do																-- spin through args[1] – args[4]
		index = index + (args[i] and param_weight[i] or 0);						-- calculate an index into formatting{}
	end

	output = (0 ~= index) and string.format (formatting[index][1] and formatting[index][1], formatting[index][2][1], formatting[index][2][2], formatting[index][2][3], formatting[index][2][4]) or nil;

	if extra2 then																-- always just attached to the end (if there is an end) so not part of formatting{}
		output = output and (output .. ' ' .. extra2) or '&lt;5p4n&gt;' .. extra2;	-- &lt;5p4n&gt; and &lt;/5p4n&gt;: place holders for font-weight style spans; akin to stripmarkers, to be replaced
	end																			-- (nihongo and nihongo3) or removed (nihongo foot)

	return output and (output .. '&lt;/5p4n&gt;') or '';								-- where there is output, add secret tag close
end


--[[--------------------------&lt; R O M A N I Z E D _ K E R N &gt;--------------------------------------------------

Add kerning when first or last character of romanized text contacts adjacent opening or closing parenthesis

In this example, without kerning, the romanized characters 'j' and 'V' are italicized so will contact the parentheses
	(&lt;i lang=\"ja-Latn\" title=\"Hepburn transliteration\"&gt;jV&lt;/i&gt;)

&lt;ret_string&gt; is the formatted template output (except that the magic string '&lt;5p4n&gt;' has not yet been replaced)
&lt;romanized&gt; is the return from lang_module._xlit() so is not wrapped in parentheses

]]

local function romanized_kern (ret_string, romanized)
	if not romanized or ('' == romanized) then									-- if romanized not set
		return ret_string;														-- then we're done
	end

	local romanized_text = romanized:gsub ('%b&lt;&gt;', ''):gsub ('\'\'+', ''):gsub ('%[%[', ''):gsub ('%]%]', '');	-- strip HTML tags

	romanized = romanized:gsub ('([%(%)%.%%%+%-%*%?%[%^%$%]])', '%%%1');				-- escape lua pattern characters

	local romanized_has_leading_paren = ret_string:match ('%(' .. romanized);			-- has a value if (&lt;romanized&gt;; nil else
	local romanized_has_trailing_paren = ret_string:match (romanized .. '%)');		-- has a value if &lt;romanized&gt;); nil else

	local kern_lead_pattern = '^[jpy]';											-- list of characters that when italicized contact unitalicized leading parenthesis
	local kern_tail_pattern = '[dfijkltCEFHIJKMNPR-Z\'"%?!%]]$';				-- list of characters that when italicized contact unitalicized trailing parenthesis

	local kern_right = '&lt;span style="margin-right:.09em"&gt;(&lt;/span&gt;%1';			-- %1 is &lt;romanized&gt; capture
	local kern_left = '%1&lt;span style="margin-left:.09em"&gt;)&lt;/span&gt;';				-- %1 is &lt;romanized&gt; capture

	if romanized_has_leading_paren and romanized_text:match (kern_lead_pattern) then
		ret_string = ret_string:gsub ('%((' .. romanized .. ')', kern_right);		-- replace plain '(' with kerned '('; &lt;romanized&gt; included here to ensure that the correct '(' is kerned
	end
	if romanized_has_trailing_paren and romanized_text:match (kern_tail_pattern) then
		ret_string = ret_string:gsub ('(' .. romanized .. ')%)', kern_left);		-- replace plain ')' with kerned ')'; &lt;romanized&gt; included here to ensure that the correct ')' is kerned
	end

	return ret_string;															-- done
end


--[[--------------------------&lt; C O M M O N &gt;------------------------------------------------------------------

Common support for {{nihongo}}

render order: is translated (English), native, romanized

&lt;template&gt; is used to select the appropriate cfg table

]]

local function common (frame, template)
	local lang_module = require ('Module:Lang' .. (frame:getTitle():match ('/sandbox') or ''));	-- if this module is the sandbox, use Module:lang/sandbox; Module:Lang else

	local args = require ('Module:Arguments').getArgs (frame);
	
	local english, native, romanized, extra, extra2 = args[1], args[2], args[3], args.extra or args[4], args.extra2 or args[5];	-- meaningful names
	args[4] = extra or args[4];													-- ensure that extra is 'positional' for use by renderer()

	local lead = require ('Module:yesno')(args.lead);							-- make boolean

	if not (native or romanized) then											-- not present, return an error message
		return error_message (template);
	end
	if native then
		native = lead and lang_module._langx ({['code']=cfg[template].tag, ['text']=native, ['template']=template}) or
			lang_module._lang ({cfg[template].tag, native, ['template']=template});	-- add ja script with/without language prefix
	end
	if romanized then
		romanized = (lead and english and (cfg[template].system_link .. ': ') or '') .. lang_module._xlit ({'ja', cfg[template].system, romanized, ['template']=template}) or nil;
	end

	local formatting = {														-- &lt;5p4n&gt; and &lt;/5p4n&gt;: place holders for font-weight style spans; akin to stripmarkers, replaced  before function returns
		{'&lt;5p4n&gt;(%s)', {extra}}, 												-- 1 - (extra)
		{'%s&lt;5p4n&gt;', {romanized}},												-- 2 - romanized
		{'%s&lt;5p4n&gt; (%s)', {romanized, extra}},									-- 3 - romanized (extra)
		{'&lt;5p4n&gt;(%s)', {native}},												-- 4 - native
		{'&lt;5p4n&gt;(%s; %s)', {native, extra}},									-- 5 - (native; extra)
		{'%s&lt;5p4n&gt; (%s)', {romanized, native}},									-- 6 - romanized (native)
		{'%s&lt;5p4n&gt; (%s; %s)', {romanized, native, extra}},						-- 7 - romanized (native; extra)
		{'%s&lt;5p4n&gt;', {english}},												-- 8 - english
		{'%s&lt;5p4n&gt; (%s)', {english, extra}},									-- 9 - english (extra)
		{'%s&lt;5p4n&gt; (%s)', {english, romanized}},								-- 10 - english (romanized)
		{'%s&lt;5p4n&gt; (%s; %s)', {english, romanized, extra}},						-- 11 - english (romanized; extra)
		{'%s&lt;5p4n&gt; (%s)', {english, native}},									-- 12 - english (native)
		{'%s&lt;5p4n&gt; (%s; %s)', {english, native, extra}},						-- 13 - english (native; extra)
		{'%s&lt;5p4n&gt; (%s, %s)', {english, native, romanized}},					-- 14 - english (native, romanized)
		{'%s&lt;5p4n&gt; (%s, %s; %s)', {english, native, romanized, extra}},			-- 15 - english (native, romanized; extra)
		}

	local ret_string = renderer (args, formatting, extra2)
	ret_string = romanized_kern (ret_string, romanized);						-- kern romanized text when appropriate
	ret_string = ret_string:gsub ('&lt;5p4n&gt;', '&lt;span style="font-weight: normal"&gt;'):gsub ('&lt;/5p4n&gt;', '&lt;/span&gt;');	-- replace 'secret' tags with proper tags

	return ret_string;															-- because gsub returns the number of replacements made as second return value
end


--[[--------------------------&lt; C O M M O N _ R O M A N I Z E D _ N A T I V E _ T R A N S L A T E D &gt;----------

Common support for {{nihongo3}}

render order: is romanized, native, translated (English)

&lt;template&gt; is used to select the appropriate cfg table

]]

local function common_romanized_native_translated (frame, template)
	local lang_module = require ('Module:Lang' .. (frame:getTitle():match ('/sandbox') or ''));	-- if this module is the sandbox, use Module:lang/sandbox; Module:Lang else
	local args = require ('Module:Arguments').getArgs (frame);
	
	local english, native, romanized, extra, extra2 = args[1], args[2], args[3], args.extra or args[4], args.extra2 or args[5];	-- meaningful names
	args[4] = extra or args[4];													-- ensure that extra is 'positional' for use by renderer()

	if not (native or romanized) then											-- not present, return an error message
		return error_message (template);
	end
	native = native and lang_module._lang ({cfg[template].tag, native, ['template']=template}) or nil;
	romanized = romanized and lang_module._xlit ({cfg[template].tag, cfg[template].system, romanized, ['template']=template}) or nil;
	
	local formatting = {														-- &lt;5p4n&gt; and &lt;/5p4n&gt;: place holders for font-weight style spans; akin to stripmarkers, replaced  before function returns
		{'&lt;5p4n&gt;(%s)', {extra}}, 												-- 1 - (extra)
		{'%s&lt;5p4n&gt;', {romanized}},												-- 2 - romanized
		{'%s&lt;5p4n&gt; (%s)', {romanized, extra}},									-- 3 - romanized (extra)
		{'&lt;5p4n&gt;(%s)', {native}},												-- 4 - native
		{'&lt;5p4n&gt;(%s; %s)', {native, extra}},									-- 5 - (native; extra)
		{'%s&lt;5p4n&gt; (%s)', {romanized, native}},									-- 6 - romanized (native)
		{'%s&lt;5p4n&gt; (%s; %s)', {romanized, native, extra}},						-- 7 - romanized (native; extra)
		{'%s&lt;5p4n&gt;', {english}},												-- 8 - english
		{'%s&lt;5p4n&gt; (%s)', {english, extra}},									-- 9 - english (extra)
		{'%s&lt;5p4n&gt; (%s)', {romanized, english}},								-- 10 - romanized (english)
		{'%s&lt;5p4n&gt; (%s; %s)', {romanized, english, extra}},						-- 11 - romanized (english; extra)
		{'%s&lt;5p4n&gt; (%s)', {english, native}},									-- 12 - english (native)
		{'%s&lt;5p4n&gt; (%s; %s)', {english, native, extra}},						-- 13 - english (native; extra)
		{'%s&lt;5p4n&gt; (%s, %s)', {romanized, native, english}},					-- 14 - romanized (native, english)
		{'%s&lt;5p4n&gt; (%s, %s; %s)', {romanized, native, english, extra}},			-- 15 - romanized (native, english; extra)
		}

	local ret_string = renderer (args, formatting, extra2)
	ret_string = ret_string:gsub ('&lt;5p4n&gt;', '&lt;span style="font-weight: normal"&gt;'):gsub ('&lt;/5p4n&gt;', '&lt;/span&gt;');	-- replace 'secret' tags with proper tags
	return ret_string;															-- because gsub returns the number of replacements made as second return value
end

--[[--------------------------&lt; C O M M O N _ N A T I V E _ R O M A N I Z E D _ T R A N S L A T E D &gt;----------

Common support for {{nihongo krt}}

render order: is native, romanized, translated (English)

&lt;template&gt; is used to select the appropriate cfg table

]]

local function common_native_romanized_translated (frame, template)
	local lang_module = require ('Module:Lang' .. (frame:getTitle():match ('/sandbox') or ''));	-- if this module is the sandbox, use Module:lang/sandbox; Module:Lang else
	local args = require ('Module:Arguments').getArgs (frame);
	
	local english, native, romanized, extra, extra2 = args[1], args[2], args[3], args.extra or args[4], args.extra2 or args[5];	-- meaningful names
	args[4] = extra or args[4];													-- ensure that extra is 'positional' for use by renderer()

	if not (native or romanized) then											-- not present, return an error message
		return error_message (template);
	end
	native = native and lang_module._lang ({cfg[template].tag, native, ['template']=template}) or nil;
	romanized = romanized and lang_module._xlit ({cfg[template].tag, cfg[template].system, romanized, ['template']=template}) or nil;
	
	local formatting = {														-- &lt;5p4n&gt; and &lt;/5p4n&gt;: place holders for font-weight style spans; akin to stripmarkers, replaced  before function returns
		{'&lt;5p4n&gt;(%s)', {extra}}, 												-- 1 - (extra)
		{'%s&lt;5p4n&gt;', {romanized}},												-- 2 - romanized
		{'%s&lt;5p4n&gt; (%s)', {romanized, extra}},									-- 3 - romanized (extra)
		{'&lt;5p4n&gt;%s', {native}},													-- 4 - native
		{'&lt;5p4n&gt;%s (%s)', {native, extra}},										-- 5 - native (extra)
		{'&lt;5p4n&gt;%s (%s)', {native, romanized}},									-- 6 - native (romanized)
		{'&lt;5p4n&gt;%s (%s; %s)', {native, romanized, extra}},						-- 7 - native (romanized; extra)
		{'%s&lt;5p4n&gt;', {english}},												-- 8 - english
		{'%s&lt;5p4n&gt; (%s)', {english, extra}},									-- 9 - english (extra)
		{'%s&lt;5p4n&gt; (%s)', {romanized, english}},								-- 10 - romanized (english)
		{'%s&lt;5p4n&gt; (%s; %s)', {romanized, english, extra}},						-- 11 - romanized (english; extra)
		{'&lt;5p4n&gt;%s (%s)', {native, english}},									-- 12 - native (english)
		{'&lt;5p4n&gt;%s (%s; %s)', {native, english, extra}},						-- 13 - native (english; extra)
		{'&lt;5p4n&gt;%s (%s, %s)', {native, romanized, english}},						-- 14 - native (romanized, english)
		{'&lt;5p4n&gt;%s (%s, %s; %s)', {native, romanized, english, extra}},			-- 15 - native (romanized, english; extra)
		}

	local ret_string = renderer (args, formatting, extra2)
	ret_string = romanized_kern (ret_string, romanized);						-- kern romanized text when appropriate
	ret_string = ret_string:gsub ('&lt;5p4n&gt;', '&lt;span style="font-weight: normal"&gt;'):gsub ('&lt;/5p4n&gt;', '&lt;/span&gt;');	-- replace 'secret' tags with proper tags
	return ret_string;															-- because gsub returns the number of replacements made as second return value
end


--[[--------------------------&lt; C O M M O N _ F O O T &gt;--------------------------------------------------------

Common support for {{nihongo foot}}

render order: is English&lt;ref&gt;native, romanized&lt;/ref&gt;

&lt;template&gt; is used to select the appropriate cfg table

]]

local function common_foot (frame, template)
	local lang_module = require ('Module:Lang' .. (frame:getTitle():match ('/sandbox') or ''));	-- if this module is the sandbox, use Module:lang/sandbox; Module:Lang else
	local args = require ('Module:Arguments').getArgs (frame);
	
	local english, native, romanized, extra, extra2 = args[1], args[2], args[3], args.extra or args[4], args.extra2 or args[5];	-- meaningful names
	args[4] = extra or args[4];													-- ensure that extra is 'positional' for use by renderer()
	local post = args[6] or args.post;
	local group = args.group;
	local ref_name = args.ref_name
	local lead = require ('Module:yesno')(args.lead);							-- make boolean

	if not (native or romanized) then											-- not present, return an error message
		return error_message (template);
	end
	if native then
		native = lead and lang_module._langx ({['code']=cfg[template].tag, ['text']=native, ['template']=template}) or
			lang_module._lang ({cfg[template].tag, native, ['template']=template});	-- add ja script with/without language prefix
	end
	if romanized then
		romanized = (lead and (cfg[template].system_link .. ': ') or '') .. lang_module._xlit ({'ja', cfg[template].system, romanized, ['template']=template}) or nil;
	end
	
	local formatting = {
		{'%s', {extra}}, 														-- 1 - extra
		{'%s', {romanized}},													-- 2 - romanized
		{'%s; %s', {romanized, extra}},											-- 3 - romanized; extra
		{'%s', {native}},														-- 4 - native
		{'%s; %s', {native, extra}},											-- 5 - native; extra
		{'%s, %s', {native, romanized}},										-- 6 - native romanized
		{'%s, %s; %s', {native, romanized, extra}},								-- 7 - native romanized; extra
																				-- from here english is used in the mapping but not rendered by renderer so not included in the table
		{'', {''}},																-- 8 - english
		{'%s', {extra}},														-- 9 - extra
		{'%s', {romanized}},													-- 10 - romanized
		{'%s; %s', {romanized, extra}},											-- 11 - romanized; extra
		{'%s', {native}},														-- 12 - native
		{'%s; %s', {native, extra}},											-- 13 - native; extra
		{'%s, %s', {native, romanized}},										-- 14 - native romanized
		{'%s, %s; %s', {native, romanized, extra}},								-- 15 - native romanized; extra
		}

	if english and post then													-- rewrite english to include |post=
		english = english .. post;												-- if english has a value append post else just post
	elseif post then
		english = post;															-- english not set, use post
	elseif not english then														-- neither are set
		english = '';															-- make english an empty string for concatenation
	end

	if native or romanized or extra or extra2 then								-- no ref tag when none of these are set (it would be empty)
		local content = renderer (args, formatting, extra2);
		content = content:gsub ('&lt;5p4n&gt;', ''):gsub ('&lt;/5p4n&gt;$', '', 1);			-- strip secret &lt;5p4n&gt; and &lt;/5p4n&gt; tags added by renderer(); spans not used by this template

		if english:match ('\'\'+$') then										-- if &lt;english&gt; is italic, bold, or both
			local text = english:gsub ('%b&lt;&gt;', ''):gsub ('\'\'+', ''):gsub ('%[%[', ''):gsub ('%]%]', '');	-- strip markup
			if text:match ('[dfijkltCEFHIJKMNPR-Z\'"%?!%]]$') then				-- when &lt;english&gt; ends with one of these characters
				english =  '&lt;span style="margin-right:.09em"&gt;' .. english .. '&lt;/span&gt;';	-- add kerning
			end
		end

		return english .. frame:extensionTag ({name='ref', args={group=group, name=ref_name}, content=content});	-- english with attached reference tag
	else
		return english;															-- nothing to be inside ref tag so just return english
	end
end


--[=[-------------------------&lt; N I H O N G O &gt;----------------------------------------------------------------

Implement {{nihongo}} using Module:Lang for language and transliteration markup

{{Nihongo|&lt;English&gt;|&lt;japanese&gt;|&lt;romaji&gt;|&lt;extra&gt;|&lt;extra2&gt;|lead=yes}}

&lt;English&gt;, &lt;japanese&gt;, and &lt;romaji&gt; are positional parameters
	&lt;English&gt;: rendered as presented; purports to be English translation of &lt;kanji/kana&gt;
	&lt;japanese&gt;: Japanese language text using Japanese script; TODO: require?
	&lt;romaji&gt;: Hepburn romanization (transliteration); TODO: in Module:Lang/data change tooltip text to 'Hepburn romanization'?
&lt;extra&gt; and &lt;extra2&gt; are positional or named: |extra= and |extra2=; mixing can be problematic
	&lt;extra&gt; is rendered as presented preceeded with &lt;comma&gt;&lt;space&gt;
	&lt;extra2&gt; is rendered as presented preceeded with &lt;space&gt;
|lead=: takes one value 'yes'; renders language name same as {{langx|ja}} but also adds [[Hepburn romanization|Hepburn]]:&lt;space&gt; ahead of the romanization; TODO: in Module:Lang, turnoff tooltip for transl when |lead=yes

]=]

local function nihongo (frame)
	return common (frame, 'nihongo')
end


--[=[-------------------------&lt; N I H O N G O 3 &gt;--------------------------------------------------------------

Implement {{nihongo3}} using Module:Lang for language and transliteration markup

Similar to {{nihongo}} but changes rendered order and does not support |lead=

{{Nihongo3|&lt;English&gt;|&lt;japanese&gt;|&lt;romaji&gt;|&lt;extra&gt;|&lt;extra2&gt;}}

&lt;English&gt;, &lt;japanese&gt;, and &lt;romaji&gt; are positional parameters
	&lt;English&gt;: rendered as presented; purports to be English translation of &lt;kanji/kana&gt;
	&lt;japanese&gt;: Japanese language text using Japanese script; TODO: require?
	&lt;romaji&gt;: Hepburn romanization (transliteration); TODO: in Module:Lang/data change tooltip text to 'Hepburn romanization'?
&lt;extra&gt; and &lt;extra2&gt; are positional or named: |extra= and |extra2=; mixing can be problematic
	&lt;extra&gt; is rendered as presented preceded with &lt;comma&gt;&lt;space&gt;
	&lt;extra2&gt; is rendered as presented preceded with &lt;space&gt;

]=]

local function nihongo3 (frame)
	return common_romanized_native_translated (frame, 'nihongo3')
end


--[=[-------------------------&lt; N I H O N G O _ K R T &gt;--------------------------------------------------------

Implement {{nihongo krt}} using Module:Lang for language and transliteration markup

Similar to {{nihongo}} but changes rendered order and does not support |lead=

{{Nihongo krt|&lt;English&gt;|&lt;japanese&gt;|&lt;romaji&gt;|&lt;extra&gt;|&lt;extra2&gt;}}

&lt;English&gt;, &lt;japanese&gt;, and &lt;romaji&gt; are positional parameters
	&lt;English&gt;: rendered as presented; purports to be English translation of &lt;kanji/kana&gt;
	&lt;japanese&gt;: Japanese language text using Japanese script; TODO: require?
	&lt;romaji&gt;: Hepburn romanization (transliteration); TODO: in Module:Lang/data change tooltip text to 'Hepburn romanization'?
	&lt;extra&gt; and &lt;extra2&gt; are positional or named: |extra= and |extra2=; mixing can be problematic
	&lt;extra&gt; is rendered as presented preceded with &lt;comma&gt;&lt;space&gt;
	&lt;extra2&gt; is rendered as presented preceded with &lt;space&gt;

]=]

local function nihongo_krt (frame)
	return common_native_romanized_translated (frame, 'nihongo krt')
end


--[=[-------------------------&lt; N I H O N G O _ F O O T &gt;------------------------------------------------------

Implement {{nihongo_foot}} using Module:Lang for language and transliteration markup

{{Nihongo foot|&lt;English&gt;|&lt;japanese&gt;|&lt;romaji&gt;|&lt;extra&gt;|&lt;extra2&gt;|&lt;post&gt;|lead=yes|group}}

&lt;English&gt;, &lt;japanese&gt;, and &lt;romaji&gt; are positional parameters
	&lt;English&gt;: rendered as presented; purports to be English translation of &lt;kanji/kana&gt;
	&lt;japanese&gt;: Japanese language text using Japanese script; TODO: require?
	&lt;romaji&gt;: Hepburn romanization (transliteration); TODO: in Module:Lang/data change tooltip text to 'Hepburn romanization'?
&lt;extra&gt; and &lt;extra2&gt; are positional or named: |extra= and |extra2=; mixing can be problematic
	&lt;extra&gt; is rendered as presented preceded with &lt;comma&gt;&lt;space&gt;
	&lt;extra2&gt; is rendered as presented preceded with &lt;space&gt;
&lt;post&gt; is positional or named: |post= is a postscript character preceding the &lt;ref&gt;..&lt;/ref&gt; tag (after &lt;English&gt;)
|lead=: takes one value 'yes'; renders language name same as {{langx|ja}} but also adds [[Hepburn romanization|Hepburn]]:&lt;space&gt; ahead of the romanization;
	TODO: in Module:Lang, turnoff tooltip for transl when |lead=yes
	in the live template |lead= also adds the Help:Installing Japanese character sets link; this is not supported in this code (nihongo nor nihongo3 have this support)
|group=: the group attribute in &lt;ref group="..."&gt; and in {{reflist}}

]=]

local function nihongo_foot (frame)
	return common_foot (frame, 'nihongo foot')
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	nihongo = nihongo,
	nihongo3 = nihongo3,
	nihongo_krt = nihongo_krt,
	nihongo_foot = nihongo_foot,
	}</text>
      <sha1>9j0e03l8qw3wgdriip8pcmbf1gssnwu</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Country data JP</title>
    <ns>10</ns>
    <id>194</id>
    <redirect title="Template:Country data Japan" />
    <revision>
      <id>376</id>
      <parentid>375</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>375</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="80" sha1="i98zzd8tdsjr2d0ujyjuzl0n0yct2du" xml:space="preserve">#REDIRECT [[Template:Country data Japan]]
[[category:country data redirects|JP]]</text>
      <sha1>i98zzd8tdsjr2d0ujyjuzl0n0yct2du</sha1>
    </revision>
  </page>
  <page>
    <title>Template:EditOnWikidata</title>
    <ns>10</ns>
    <id>195</id>
    <redirect title="Template:Edit on Wikidata" />
    <revision>
      <id>378</id>
      <parentid>377</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>377</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="86" sha1="pimpdr86kml6nk0wht8dw6tw3fxgjhi" xml:space="preserve">#REDIRECT [[Template:Edit on Wikidata]]

{{Redirect category shell|
{{R from move}}
}}</text>
      <sha1>pimpdr86kml6nk0wht8dw6tw3fxgjhi</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Edit on Wikidata</title>
    <ns>10</ns>
    <id>196</id>
    <revision>
      <id>380</id>
      <parentid>379</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>379</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="246" sha1="2wps67xa89j8bjz19byov0w36zuumd7" xml:space="preserve">{{#switch: {{{noicon|}}}
 | no = 
 | false = 
 | #default = &lt;div class="metadata" style="text-align: right;"&gt;&amp;#91;[[d:{{#if:{{{qid|}}}|{{{qid}}}|{{#invoke:WikidataIB|pageId}}}}|edit on Wikidata]]]&lt;/div&gt;
}}&lt;noinclude&gt;
{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>2wps67xa89j8bjz19byov0w36zuumd7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:If first display both</title>
    <ns>10</ns>
    <id>197</id>
    <revision>
      <id>382</id>
      <parentid>381</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>381</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="75" sha1="9144vhrpj4pngln15i3ano34eo8mb1r" xml:space="preserve">{{#if:{{{1|}}}|{{{1|}}}{{{2|}}}}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>9144vhrpj4pngln15i3ano34eo8mb1r</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Infobox video game</title>
    <ns>10</ns>
    <id>198</id>
    <revision>
      <id>384</id>
      <parentid>383</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>383</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9496" sha1="0pcmr9q0oywq5rvw4setu3zzpnft1zp" xml:space="preserve">{{main other|{{short description|2=noreplace|{{if both|{{{released|{{{release|}}}}}}|{{#invoke:String|match|{{{released|{{{release|}}}}}}|[12]%d%d%d|match=1|nomatch=}}|{{#invoke:String|match|{{{released|{{{release|}}}}}}|[12]%d%d%d|match=1|nomatch=}} video game|Video game}}}}}}{{#invoke:infobox|infoboxTemplate
&lt;!-- Start and styling --&gt;
| child          = {{{child|}}}
| subbox         = {{{subbox|}}}
| bodyclass      = ib-video-game hproduct {{#ifeq:{{{collapsible|}}}|yes|collapsible {{#if:{{{state|}}}|{{{state}}}|autocollapse}}}}
| templatestyles = Infobox video game/styles.css
| aboveclass     = fn
| italic title   = {{{italic title|&lt;noinclude&gt;no&lt;/noinclude&gt;}}}

&lt;!-- Title --&gt;
| above          = &lt;includeonly&gt;{{{title|{{#if:{{#invoke:WikidataIB|label}}|{{#invoke:WikidataIB|label}}|{{PAGENAMEBASE}}}}}}}&lt;/includeonly&gt;

&lt;!-- Image --&gt;
| image          = {{#invoke:InfoboxImage|InfoboxImage|image={{#invoke:WikidataIB |getValue|rank=best|P18 |name=image |qid={{{qid|}}} |suppressfields={{{suppressfields|}}} |fetchwikidata={{{fetchwikidata|ALL}}} |onlysourced=no |noicon=yes|{{{image|}}}}}|size={{{image size|{{{image_size|{{{imagesize|}}}}}}}}}|sizedefault=frameless|upright={{{image_upright|1}}}|alt={{{alt|}}}|border={{{border|}}}|suppressplaceholder=yes}}

| caption        = {{#if:{{{image|}}}|{{{caption|}}}|{{{caption|{{#invoke:WikidataIB|getValue|P18|qual=P2096|qualsonly=y|fwd=ALL}}}}}}}

&lt;!-- Start of content --&gt;
| label2  = [[Video game developer|Developer(s)]]
| data2   = {{{developer|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P178|qid={{{qid|}}}|name=developer|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{developer|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P178}}}}}}}}}

| label3  = [[Video game publisher|Publisher(s)]]
| data3   = {{{publisher|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P123|qid={{{qid|}}}|name=publisher|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{publisher|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P123}}}}}}}}}

| label4  = [[Video game creative director|Director(s)]]
| data4   = {{{director|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P57|qid={{{qid|}}}|name=director|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{director|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P57}}}}}}}}}

| label5  = [[Video game producer|Producer(s)]]
| data5   = {{{producer|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P162|qid={{{qid|}}}|name=producer|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{producer|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P162}}}}}}}}}

| label6  = [[Video game designer|Designer(s)]]
| data6   = {{{designer|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P287|qid={{{qid|}}}|name=designer|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{designer|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P287}}}}}}}}}

| label7  = [[Video game programmer|Programmer(s)]]
| data7   = {{{programmer|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P943|qid={{{qid|}}}|name=programmer|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{programmer|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P943}}}}}}}}}

| label8  = [[Video game artist|Artist(s)]]
| data8   = {{{artist|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P3080|qid={{{qid|}}}|name=artist|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{artist|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P3080}}}}}}}}}

| label9  = [[Video game writer|Writer(s)]]
| data9   = {{{writer|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P50|qid={{{qid|}}}|name=writer|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{writer|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P50}}}}}}}}}

| label10 = [[Video game composer|Composer(s)]]
| data10  = {{{composer|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P86|qid={{{qid|}}}|name=composer|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{composer|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P86}}}}}}}}}

| label11 = Series
| data11  = {{{series|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P179|qid={{{qid|}}}|name=series|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|prefix=''|postfix=''|{{{series|}}}}}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P179}}}}}}}}}

| label12 = [[Game engine|Engine]]
| data12  = {{{engine|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P408|qid={{{qid|}}}|name=engine|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{engine|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P408}}}}}}}}}

| label13 = [[Computing platform|Platform(s)]]
| data13  = {{{platform|{{{platforms|{{If first display both|{{#invoke:WikidataIB|getValue|rank=best|P400|qid={{{qid|}}}|name=platform|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{platform|{{{platforms|}}}}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P400}}}}}}}}}}}}

| label14 = Release
| data14  = {{{released|{{{release|}}}}}}

| label15 = [[Video game genre|Genre(s)]]
| data15  = {{{genre|{{If first display both|{{#invoke:String2 |ucfirst |{{#invoke:WikidataIB|getValue|rank=best|P136|qid={{{qid|}}}|name=genre|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|shortname=yes|{{{genre|}}} }} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P136}}}}}}}}}

| label16 = Mode(s)
| data16  = {{{modes|{{If first display both|{{#invoke:String2 |ucfirst |{{#invoke:WikidataIB|getValue|rank=best|P404|qid={{{qid|}}}|name=modes|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|shortname=yes|{{{modes|}}} }} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P404}}}}}}}}}

| label17 = [[Arcade system board|Arcade system]]
| data17  = {{{arcade system|{{If first display both|{{#invoke:WikidataIB|getQualifierValue|P2670|pval=Q631229|qual=P31|qid={{{qid|}}}|name=arcade_system|suppressfields={{{suppressfields|}}}|fetchwikidata={{{fetchwikidata|ALL}}}|onlysourced={{{onlysourced|yes}}}|noicon={{{noicon|no}}}|list=ubl|sorted=yes|{{{arcade system|}}} }}|{{#ifeq:{{{refs|no}}}|yes|{{wikidata|references|normal+|{{{qid|}}}|P2670|Q631229}}}}}}}}}

&lt;!-- For embedded infoboxes --&gt;
| data30  = {{{embedded|}}}

| below     = &lt;includeonly&gt;{{EditOnWikidata|noicon={{{noicon|no}}}|qid={{{qid|}}}}}&lt;/includeonly&gt;

&lt;!-- Checking code and closing --&gt;
}}{{main other|{{#ifeq:{{lc:{{{italic title|}}}}}|no||{{italic title|force={{#ifeq:{{lc:{{{italic title|}}}}}|force|true}}}}}}
}}{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using infobox video game with unknown parameters|_VALUE_{{PAGENAME}}]]}}|ignoreblank=1|preview=Page using [[Template:Infobox video game]] with unknown parameter "_VALUE_"| alt | arcade system | artist | caption | border | child | collapsible | commons | composer | designer | developer | director | embedded | engine | fetchwikidata | genre | image | image_size | image_upright | italic title | modes | noicon | onlysourced | platform | platforms | producer | programmer | publisher | qid | refs | release | released | series | state | subbox | suppressfields | title | writer }}&lt;includeonly&gt;{{main other|{{#if:{{safesubst:#invoke:Check for unknown parameters|check|unknown=1|preview=1|embedded|image}}|[[Category:Articles using Infobox video game using locally defined parameters]]|[[Category:Articles with infoboxes completely from Wikidata]]}}}}{{#if:{{{image|}}}|[[Category:Articles using Wikidata infoboxes with locally defined images]]}}&lt;/includeonly&gt;&lt;noinclude&gt;&lt;!-- NOTE: The {{#if:1| ... }} syntax allows for list markup to be included in the data fields --&gt;
{{documentation}}&lt;!-- Add cats and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>0pcmr9q0oywq5rvw4setu3zzpnft1zp</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Video game release</title>
    <ns>10</ns>
    <id>199</id>
    <revision>
      <id>386</id>
      <parentid>385</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>385</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="77" sha1="kwskzj87ebtpz9s7v2hxkxlcpe48mnx" xml:space="preserve">{{#invoke:Video game release|main}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>kwskzj87ebtpz9s7v2hxkxlcpe48mnx</sha1>
    </revision>
  </page>
  <page>
    <title>Module:CountryData</title>
    <ns>828</ns>
    <id>200</id>
    <revision>
      <id>388</id>
      <parentid>387</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>387</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2330" sha1="cceq9gf8ovsa0t1xy826rbloh46yv3o" xml:space="preserve">local p = {}
local mostUsed = mw.loadData('Module:CountryData/summary')

local function getcontents(frame,country,params)
  return frame:expandTemplate({title="Country data "..country;args=params})
end

function p.getcachedtable(frame, country, params)
	country = mostUsed.redirects[country] or country
	if params and next(params) then return p.gettable(frame, country, params) end
	-- Uses mw.loadData to cache data for the most-used templates
	if mostUsed.pages[country] then
		local cache = mw.loadData('Module:CountryData/cache' .. mostUsed.pages[country])
		if cache.data[country] then return cache.data[country] end
	end
	-- if not in cache
	return p.gettable(frame, country, params)
end

function p.gettable(frame,country,params)
--Returns the parameters of a country data template as a Lua table
  --If not a valid data template, return empty table
  local bool, s = pcall(getcontents,frame,country,params or {})
  if bool and (string.find(s,"^%{%{ *%{%{%{1") or string.find(s,"^%{%{safesubst: *%{%{%{1"))
  then
    --Replace parameter delimiters with arbitrary control characters
    --to avoid clashes if param values contain equals/pipe signs
    s = string.gsub(s,"|([^|=]-)=","\1\1%1\2")
    s = string.gsub(s,"}}%s*$","\1")
    --Loop over string and add params to table
    local part = {}
    for par in string.gmatch(s,"\1[^\1\2]-\2[^\1\2]-\1") do
      local k = string.match(par,"\1%s*(.-)%s*\2")
      local v = string.match(par,"\2%s*(.-)%s*\1")
      if v and not (v=="" and string.find(k,"^flag alias")) then
        part[k] = v
      end
    end
    return part
  else
  	return {}
  end
end

function p.getalias(frame)
--Returns a single parameter value from a data template
  local part = p.gettable(frame,frame.args[1])
  if frame.args.variant
    then return tostring(part[frame.args[2].."-"..frame.args.variant]
                         or part[frame.args[2]] or frame.args.def)
    else return tostring(part[frame.args[2]] or frame.args.def)
  end
end

function p.gettemplate(frame)
--For testing, recreates the country data from the created Lua table
  --Get data table
  local data = p.gettable(frame,frame.args[1])
  --Concatenate fields into a template-like string
  local out = "{{ {{{1}}}"
  for k,v in pairs(data) do
    out = out.."\n| "..k.." = "..v
  end
  return out.."\n}}"
end

return p</text>
      <sha1>cceq9gf8ovsa0t1xy826rbloh46yv3o</sha1>
    </revision>
  </page>
  <page>
    <title>Module:CountryData/summary</title>
    <ns>828</ns>
    <id>201</id>
    <revision>
      <id>390</id>
      <parentid>389</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>389</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6470" sha1="0ymib7yb210s3i6vqfqrmfh8nkkjhgw" xml:space="preserve">local p = {}
p.pages = {Afghanistan='K', Albania='H', Algeria='F', Angola='K', Argentina='B', Armenia='G', Australia='A', Austria='B', Azerbaijan='F', Bahrain='K', Bangladesh='I', Belarus='D', Belgium='B', Bolivia='J', Bosnia_and_Herzegovina='F', Brazil='B', Bulgaria='D', Cameroon='I', Canada='A', Chile='D', China='B', Chinese_Taipei='H', Colombia='D', Costa_Rica='I', Croatia='D', Cuba='G', Cyprus='G', Czech_Republic='B', Czechoslovakia='H', Democratic_Republic_of_the_Congo='K', Denmark='C', Dominican_Republic='H', East_Germany='K', Ecuador='G', Egypt='E', El_Salvador='J', England='B', Estonia='E', Ethiopia='J', Fiji='K', Finland='C', France='A', Germany='A', Ghana='G', Great_Britain='C', Greece='D', Guatemala='J', Honduras='K', Hong_Kong='F', Hungary='C', Iceland='G', India='A', Indonesia='E', Iran='B', Iraq='J', Ireland='E', Israel='D', Italy='A', Ivory_Coast='I', Jamaica='G', Japan='A', Jordan='K', Kazakhstan='E', Kenya='H', Kuwait='K', Latvia='F', Lebanon='J', Lithuania='F', Luxembourg='G', Malaysia='E', Mali='K', Malta='I', Mexico='C', Moldova='I', Montenegro='H', Morocco='F', Myanmar='J', Nepal='I', Netherlands='A', New_Zealand='C', Nigeria='E', North_Korea='J', North_Macedonia='I', Northern_Ireland='J', Norway='C', Pakistan='F', Panama='I', Paraguay='G', Peru='E', Philippines='E', Poland='A', Portugal='C', Puerto_Rico='H', Qatar='I', Republic_of_Ireland='F', Romania='C', Russia='A', Saudi_Arabia='H', Scotland='D', Senegal='I', Serbia='D', Singapore='F', Slovakia='D', Slovenia='D', South_Africa='C', South_Korea='C', Soviet_Union='E', Spain='A', Sri_Lanka='H', Sweden='B', Switzerland='B', Syria='J', Taiwan='K', Tanzania='K', Thailand='D', Trinidad_and_Tobago='J', Tunisia='G', Turkey='B', Uganda='J', Ukraine='C', United_Arab_Emirates='H', United_Kingdom='B', United_States='A', Uruguay='F', Uzbekistan='H', Venezuela='E', Vietnam='G', Wales='E', West_Germany='G', Yugoslavia='H', Zimbabwe='I', ['Georgia_(country)']='F'}
p.redirects = {AFG='Afghanistan', ALB='Albania', ALG='Algeria', AND='Andorra', ANG='Angola', ARG='Argentina', ARM='Armenia', ARU='Aruba', ATG='Antigua and Barbuda', AUS='Australia', AUT='Austria', AZE='Azerbaijan', BAH='Bahamas', BAN='Bangladesh', BAR='Barbados', BDI='Burundi', BEL='Belgium', BEN='Benin', BER='Bermuda', BFA='Burkina Faso', BHR='Bahrain', BIH='Bosnia and Herzegovina', BLR='Belarus', BOL='Bolivia', BOT='Botswana', BRA='Brazil', BRU='Brunei', BUL='Bulgaria', BWA='Botswana', CAM='Cambodia', CAN='Canada', CAY='Cayman Islands', CGO='Republic of the Congo', CHE='Switzerland', CHI='Chile', CHL='Chile', CHN='China', CIS='Commonwealth of Independent States', CIV='Ivory Coast', CMR='Cameroon', COD='Democratic Republic of the Congo', COK='Cook Islands', COL='Colombia', CPV='Cape Verde', CRC='Costa Rica', CRO='Croatia', CSA='Confederate States of America', CSK='Czechoslovakia', CUB='Cuba', CUR='Curaçao', CYP='Cyprus', CZE='Czech Republic', Congo='Republic of the Congo', DEN='Denmark', DEU='Germany', DNK='Denmark', DOM='Dominican Republic', DRC='Democratic Republic of the Congo', ECU='Ecuador', EGY='Egypt', ENG='England', ESA='El Salvador', ESP='Spain', EST='Estonia', ETH='Ethiopia', EU='European Union', FIJ='Fiji', FIN='Finland', FJI='Fiji', FRA='France', FRG='West Germany', FRO='Faroe Islands', GAB='Gabon', GAM='Gambia', GBR='Great Britain', GDR='East Germany', GEO='Georgia (country)', GER='Germany', GHA='Ghana', GIB='Gibraltar', GRC='Greece', GRE='Greece', GRN='Grenada', GUA='Guatemala', GUI='Guinea', GUM='Guam', GUY='Guyana', Georgia='Georgia (country)', HAI='Haiti', HKG='Hong Kong', HON='Honduras', HRV='Croatia', HUN='Hungary', IDN='Indonesia', INA='Indonesia', IND='India', IRE='Ireland', IRI='Iran', IRL='Republic of Ireland', IRN='Iran', IRQ='Iraq', ISL='Iceland', ISR='Israel', ITA='Italy', JAM='Jamaica', JOR='Jordan', JP='Japan', JPN='Japan', KAZ='Kazakhstan', KEN='Kenya', KGZ='Kyrgyzstan', KOR='South Korea', KOS='Kosovo', KSA='Saudi Arabia', KUW='Kuwait', LAO='Laos', LAT='Latvia', LBN='Lebanon', LBR='Liberia', LBY='Libya', LCA='Saint Lucia', LIB='Lebanon', LIE='Liechtenstein', LIT='Lithuania', LTU='Lithuania', LUX='Luxembourg', LVA='Latvia', MAC='Macau', MAD='Madagascar', MAR='Morocco', MAS='Malaysia', MCO='Monaco', MDA='Moldova', MDV='Maldives', MEX='Mexico', MGL='Mongolia', MKD='North Macedonia', MLI='Mali', MLT='Malta', MNE='Montenegro', MON='Monaco', MOZ='Mozambique', MRI='Mauritius', MYA='Myanmar', MYS='Malaysia', NAM='Namibia', NCA='Nicaragua', NCL='New Caledonia', NED='Netherlands', NEP='Nepal', NGA='Nigeria', NGR='Nigeria', NIC='Nicaragua', NIG='Niger', NIR='Northern Ireland', NLD='Netherlands', NOR='Norway', NZ='New Zealand', NZL='New Zealand', OMA='Oman', PAK='Pakistan', PAN='Panama', PAR='Paraguay', PER='Peru', PHI='Philippines', PHL='Philippines', PLE='Palestine', PNG='Papua New Guinea', POL='Poland', POR='Portugal', PRC='China', PRI='Puerto Rico', PRK='North Korea', PRT='Portugal', PUR='Puerto Rico', QAT='Qatar', ROC='Republic of China', ROM='Romania', ROU='Romania', RSA='South Africa', RUS='Russia', RWA='Rwanda', SAM='Samoa', SCG='Serbia and Montenegro', SCO='Scotland', SEN='Senegal', SER='Serbia', SGP='Singapore', SIN='Singapore', SKN='Saint Kitts and Nevis', SLE='Sierra Leone', SLO='Slovenia', SLV='El Salvador', SMR='San Marino', SPA='Spain', SRB='Serbia', SRI='Sri Lanka', SUD='Sudan', SUI='Switzerland', SUR='Suriname', SVK='Slovakia', SVN='Slovenia', SWE='Sweden', SWI='Switzerland', SYR='Syria', TAN='Tanzania', TCH='Czechoslovakia', THA='Thailand', TJK='Tajikistan', TKM='Turkmenistan', TOG='Togo', TON='Tonga', TPE='Chinese Taipei', TRI='Trinidad and Tobago', TTO='Trinidad and Tobago', TUN='Tunisia', TUR='Turkey', TWN='Taiwan', UAE='United Arab Emirates', UGA='Uganda', UK='United Kingdom', UKGBI='United Kingdom of Great Britain and Ireland', UKR='Ukraine', UN='United Nations', URS='Soviet Union', URU='Uruguay', US='United States', USA='United States', USSR='Soviet Union', UZB='Uzbekistan', VAN='Vanuatu', VEN='Venezuela', VIE='Vietnam', WAL='Wales', WIN='West Indies', Washington='Washington (state)', YEM='Yemen', YUG='Yugoslavia', ZAF='South Africa', ZAM='Zambia', ZIM='Zimbabwe', ['Côte d\'Ivoire']='Ivory Coast', ['DR Congo']='Democratic Republic of the Congo', ['New York']='New York (state)', ['People\'s Republic of China']='China', ['SFR Yugoslavia']='Yugoslavia', ['Timor-Leste']='East Timor', ['United States Virgin Islands']='U.S. Virgin Islands', ['United States of America']='United States'}
return p</text>
      <sha1>0ymib7yb210s3i6vqfqrmfh8nkkjhgw</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Video game release</title>
    <ns>828</ns>
    <id>202</id>
    <revision>
      <id>392</id>
      <parentid>391</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>391</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4041" sha1="m0epto4y1jh9htl95wzug9hsreq9k7x" xml:space="preserve">require('strict')

local getArgs = require('Module:Arguments').getArgs
local cd = require('Module:CountryData')
local list = require('Module:List');
local p = {}

local knownargs = {
	['format'] = true,
	['class'] = true,
	['style'] = true,
	['list_style'] = true,
	['item_style'] = true,
	['item1_style'] = true,
	['indent'] = true
}

local labels = {
	['NA'] = "[[North America|NA]]",
	['EU'] = "[[Europe|EU]]",
	['EUR'] = "[[Europe|EU]]",
	['AU'] = "[[Australasia|AU]]",
	['AUS'] = "[[Australasia|AU]]",
	['PAL'] = "[[PAL region|PAL]]",
	['SEA'] = "[[Southeast Asia|SEA]]",
	['AS'] = "[[Asia|AS]]",
	['SA'] = "[[South America|SA]]",
	['OC'] = "[[Oceania|OC]]",
	['WW'] = "&lt;abbr title=\"Worldwide\"&gt;WW&lt;/abbr&gt;"
}

local function getLocalLabel(alias)
	local label = labels[string.upper(alias)]

	return label
end

local countryData = {}; -- Used to store country data to avoid the need of repeated calls to Module:CountryData. This saves a little time if the same abbreviation appears multiple times in the template.

local function getCountryData(frame, alias)
	local ualias = string.upper(alias)

	if (countryData[ualias] == nil) then
		local cdtable = cd.gettable(frame, alias, {})
		countryData[ualias] = cdtable['alias']
	end

	return countryData[ualias]
end

local function splitLabel(s)
	local islist = true
	local res = {}
	for k,v in ipairs(mw.text.split(s or '', '%s*/%s*')) do
		local v1 = v:match('^%s*([A-Z][A-Z][A-Z]?)%s*$')
		if v1 then
			table.insert(res,v1)
		else
			local v2 = v:match('^%s*(%[%[[^%[%]|]*|[A-Z][A-Z][A-Z]?%]%])%s*$')
			if v2 then
				table.insert(res,v2)
			else
				islist = false
			end
		end
	end
	return islist and res or {s}
end

function p.main(frame)
	local args = getArgs(frame)
	local listformat = args['format']
	if (listformat == nil or listformat == "") then
		listformat = "unbulleted"
	end
	local items = {}

	-- Old syntax "Two parameter region" use case, where param 1 is an article, param 2 is a label, and param 3 is the date. We assume this case if argument 4 is nil.
	if (args[3] ~= nil and args[4] == nil) then
		local item = "&lt;span style=\"font-size:97%;\"&gt;[["
		if (args[1] ~= nil) then
			item = item .. args[1]
		end
		item = item .. "|"
		if (args[2] ~= nil) then
			item = item .. args[2]
		end
		item = item .. "]]:&lt;/span&gt; " .. args[3] .. "[[Category:Pages using vgrelease with two parameter region]]"
		table.insert(items, item)
		-- Old syntax "Blank region" use case, where param 1 is empty, and param 2 is the date.
	elseif (args[1] == nil and args[2] ~= nil) then
		local item = args[2] .. "[[Category:Pages using vgrelease without a region]]"
		table.insert(items, item)
		-- Normal use cases, region/date pairs in 1/2, 3/4, 5/6, etc.
	else
		local i = 1
		local j = 2
		while (args[i] and args[j]) do
			local labels = {}
			for k,v in ipairs(splitLabel(args[i])) do
				local label = getLocalLabel(v);

				-- Didn't find a local label? Check for country data.
				if (label == nil) then
					if not v:match('^%s*%[') then
						label = getCountryData(frame, v)
					end

					-- Found something? Build a sitelink with it.
					if (label ~= nil) then
						label = "[[" .. label .. "|" .. v .. "]]"
					else
						label = v
					end
				end
				table.insert(labels, label)
			end
			local item = "&lt;span style=\"font-size:97%;\"&gt;" .. table.concat(labels,'/') .. ":&lt;/span&gt; " .. args[j]
			table.insert(items, item)

			i = i + 2
			j = j + 2
		end
	end

	-- Add known parameters of Module:List to the table
	for k, v in pairs(args) do
		if (knownargs[k] == true) then
			items[k] = v
		end
	end

	local out = list.makeList(listformat, items)

	-- Preview message and category
	local parameterMsg = require('Module:If preview')._warning({
		'Unknown parameter "_VALUE_".'
	}) .. "[[Category:Pages using vgrelease with named parameters|_VALUE_]]"

	-- Check for invalid parameters	
	for k, v in pairs(args) do
		if (type(k) ~= 'number' and knownargs[k] ~= true) then
			local msg = parameterMsg:gsub('_VALUE_', k)
			out = out .. msg
		end
	end

	return out
end

return p</text>
      <sha1>m0epto4y1jh9htl95wzug9hsreq9k7x</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Nihongo foot</title>
    <ns>10</ns>
    <id>203</id>
    <revision>
      <id>394</id>
      <parentid>393</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>393</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="173" sha1="5ptrqffye7wo8hdd9070vlh68yjhzae" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Nihongo|nihongo_foot}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories to the /doc subpage and interwikis to Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>5ptrqffye7wo8hdd9070vlh68yjhzae</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Plural</title>
    <ns>10</ns>
    <id>204</id>
    <revision>
      <id>396</id>
      <parentid>395</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>395</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="280" sha1="g3xji8o0lnb3d51dnczana8udz5r3qs" xml:space="preserve">{{{1}}}{{{{{|safesubst:}}}#if:{{{{{|safesubst:}}}yesno|{{{nb|no}}}|no=}}|&amp;nbsp;|&amp;#32;}}{{{{{|safesubst:}}}plural:{{{1}}}|{{{2}}}|{{{3|{{{2}}}s}}}|{{{4}}}}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories to the /doc subpage; interwikis go to Wikidata, thank you! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>g3xji8o0lnb3d51dnczana8udz5r3qs</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite video game</title>
    <ns>10</ns>
    <id>205</id>
    <revision>
      <id>398</id>
      <parentid>397</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>397</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="836" sha1="70yrnzp4c1vqlk4munixcfja2o7o44r" xml:space="preserve">&lt;includeonly&gt;{{#if:{{#if:{{{developer|}}}|{{{title|}}}|{{{developer|}}}}}
  |{{Cite book
| title = {{{title|}}}
| trans-title = {{{trans-title|}}}
| author = {{{developer|}}}
| author2 = {{{developer2|}}}
| author3 = {{{developer3|}}}
| author4 = {{{developer4|}}}
| author5 = {{{developer5|}}}
| author6 = {{{developer6|}}}
| author7 = {{{developer7|}}}
| publisher = {{{publisher|}}}
| date = {{{date|}}}
| medium = {{{platform|}}}
| edition = {{#if:{{{version|}}}|{{{version|}}}}}
| at = {{#if:{{{scene|}}}|Scene: {{{scene|}}}|}}{{#if:{{{level|}}}|{{#if:{{{scene|}}}|.&amp;#32;}}Level/area: {{{level|}}}}}
| language = {{{language|}}}
| quote = {{{quote|}}}
| ref = {{{ref|}}}
  }}
  |{{Citation error|{{tl|Cite video game}} requires '''title''' and '''developer''' parameters}}
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>70yrnzp4c1vqlk4munixcfja2o7o44r</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Loop</title>
    <ns>10</ns>
    <id>206</id>
    <revision>
      <id>400</id>
      <parentid>399</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>399</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="221" sha1="lxh6e7ed0zazp8ayy2fedthuqn2m9m4" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:String|rep|1={{{2|}}}|2={{{1|&lt;noinclude&gt;1&lt;/noinclude&gt;}}}}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go in Wikidata --&gt;
&lt;/noinclude&gt;</text>
      <sha1>lxh6e7ed0zazp8ayy2fedthuqn2m9m4</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Rating</title>
    <ns>10</ns>
    <id>207</id>
    <revision>
      <id>402</id>
      <parentid>401</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>401</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1781" sha1="9nbuj51yqrx0s1ngihzhtp6ju97hw4x" xml:space="preserve">{{#if:{{{1|}}}
 |&lt;span role="img" style="white-space:nowrap" title="{{{score|{{#if:{{{2|}}}|{{{1}}}/}}{{plural|{{#if:{{{2|}}}|{{{2}}}|{{{1}}}}}|{{{rating|star}}}|{{{rating-plural|{{{rating|star}}}s}}}}}}}}"&gt;{{#ifexpr:{{{1}}}&gt;=1
  |[[File:{{{full|Star full.svg}}}|{{{size|{{#ifexpr:{{{2|{{{1}}}}}}&gt;6|7|11}}px}}}|link=|{{{score|{{#if:{{{2|}}}|{{{1}}}/}}{{plural|{{#if:{{{2|}}}|{{{2}}}|{{{1}}}}}|{{{rating|star}}}|{{{rating-plural|{{{rating|star}}}s}}}}}}}}|alt=]]{{Loop
   |{{#expr:floor{{{1}}}-1}}
   |[[File:{{{full|Star full.svg}}}|{{{size|{{#ifexpr:{{{2|{{{1}}}}}}&gt;6|7|11}}px}}}|link=|alt=]]
   }}
  |{{#ifexpr:{{{1}}}&gt;0
   |[[File:{{{half|Star half.svg}}}|{{{size|{{#ifexpr:{{{2|{{{1}}}}}}&gt;6|7|11}}px}}}|link=|{{{score|{{#if:{{{2|}}}|{{{1}}}/}}{{plural|{{#if:{{{2|}}}|{{{2}}}|{{{1}}}}}|{{{rating|star}}}|{{{rating-plural|{{{rating|star}}}s}}}}}}}}|alt=]]
   |[[File:{{{empty|Star empty.svg}}}|{{{size|{{#ifexpr:{{{2|{{{1}}}}}}&gt;6|7|11}}px}}}|link=|{{{score|{{#if:{{{2|}}}|{{{1}}}/}}{{plural|{{#if:{{{2|}}}|{{{2}}}|{{{1}}}}}|{{{rating|star}}}|{{{rating-plural|{{{rating|star}}}s}}}}}}}}|alt=]]
   }}
  }}{{#ifexpr:{{{1}}}&gt;1and{{{1}}}&lt;&gt;ceil{{{1}}}
  |[[File:{{{half|Star half.svg}}}|{{{size|{{#ifexpr:{{{2|{{{1}}}}}}&gt;6|7|11}}px}}}|link=|alt=]]
  }}{{#ifexpr:{{{2|-1}}}&gt;ceil{{{1}}}
  |{{Loop
   |{{#expr:{{{2}}}-ceil{{{1}}}{{#ifexpr:{{{1}}}=0|-1}}}}
   |[[File:{{{empty|Star empty.svg}}}|{{{size|{{#ifexpr:{{{2|{{{1}}}}}}&gt;6|7|11}}px}}}|link=|alt=]]
   }}
  }}&lt;/span&gt;{{#ifexpr:{{{1}}}-floor{{{1}}}&lt;&gt;0and{{{1}}}-floor{{{1}}}&lt;&gt;.5
  |{{main other|[[Category:Pages with incorrect use of Rating template]]}}
  }}
 |&lt;span class="error"&gt;Please specify a '''rating'''.&lt;/span&gt;{{main other|[[Category:Pages with incorrect use of Rating template]]}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>9nbuj51yqrx0s1ngihzhtp6ju97hw4x</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Video game reviews</title>
    <ns>10</ns>
    <id>208</id>
    <revision>
      <id>404</id>
      <parentid>403</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>403</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="152" sha1="8vsg4ddh2a0ob4u43iw64svw9yotrhx" xml:space="preserve">{{#invoke:Video game reviews|reviewbox }}&lt;noinclude&gt;{{template doc}}&lt;!-- Add categories to the /doc sub-page and interwikis to Wikidata. --&gt;&lt;/noinclude&gt;</text>
      <sha1>8vsg4ddh2a0ob4u43iw64svw9yotrhx</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Video game reviews</title>
    <ns>828</ns>
    <id>209</id>
    <revision>
      <id>406</id>
      <parentid>405</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>405</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12321" sha1="gthnuulwfntw94m1ccx96gi0236juqw" xml:space="preserve">require('strict')

local p = {}
local data = require('Module:Video game reviews/data')
local yesno = require('Module:Yesno')
local vgwd = require('Module:Video game wikidata')
local getArgs

local function getActiveSystems(args)
	local activeSystems = {}
	for k, v in pairs(args) do
		if data.systems[k] and yesno(v) then
			table.insert(activeSystems, k)
		end
	end
	table.sort(activeSystems, function(a, b)
		return data.systems[a].sortkey &lt; data.systems[b].sortkey
	end)
	return activeSystems
end

local function getArgKeyTables(args)
	local reviewers, aggregators, awards = {}, {}, {}
	for k in pairs(args) do
		if string.match(k, data.i18n.pattern.reviewer) then
			table.insert(reviewers, k)
		elseif string.match(k, data.i18n.pattern.aggregator) then
			table.insert(aggregators, k)
		elseif string.match(k, data.i18n.pattern.award) then
			table.insert(awards, k)
		end
	end
	local function comparator(a, b)
		return tonumber(a:match('%d+')) &lt; tonumber(b:match('%d+'))
	end
	table.sort(reviewers, comparator)
	table.sort(aggregators, comparator)
	table.sort(awards, comparator)
	return reviewers, aggregators, awards
end

local function getProvidedReviewersAndAggregators(args, usePlatforms)
	local providedReviewers, providedAggregators = {}, {}
	if usePlatforms then
		local seen = {}
		for k in pairs(args) do
			local splitPos = string.find(k, '_')
			if splitPos then
				local halfarg = string.sub(k, 1, splitPos - 1)
				if not seen[halfarg] then
					seen[halfarg] = true
					if data.reviewers[halfarg] then
						table.insert(providedReviewers, halfarg)
					elseif data.aggregators[halfarg] then
						table.insert(providedAggregators, halfarg)
					end
				end
			end
		end
	else
		for k in pairs(args) do
			if not string.find(k, '_') then
				if data.reviewers[k] then
					table.insert(providedReviewers, k)
				elseif data.aggregators[k] then
					table.insert(providedAggregators, k)
				end
			end
		end
	end
	table.sort(providedReviewers, function(a, b)
		return data.reviewers[a].sortkey &lt; data.reviewers[b].sortkey
	end)
	table.sort(providedAggregators, function(a, b)
		return data.aggregators[a].sortkey &lt; data.aggregators[b].sortkey
	end)
	return providedReviewers, providedAggregators
end

local function renderHeadingRowWithSystems(builder, activeSystems, headingText)
	builder:tag('tr')
		:addClass(data.i18n.class.headerrow)
		:tag('th')
			:attr('scope', 'col')
			:attr('rowspan', '2')
			:wikitext(headingText)
			:done()
		:tag('th')
			:attr('scope', 'colgroup')
			:attr('colspan', #activeSystems)
			:wikitext(data.i18n.display.score)
			:done()
	builder = builder:tag('tr')
	for _, v in ipairs(activeSystems) do
		builder:tag('th')
			:wikitext(data.systems[v].name)
			:attr('scope', 'col')
			:done()
	end
end

local function renderHeadingRow(builder, nameHeading)
	builder:tag('tr')
		:addClass(data.i18n.class.headerrow)
		:tag('th')
			:attr('scope', 'col')
			:wikitext(nameHeading)
			:done()
		:tag('th')
			:attr('scope', 'col')
			:wikitext(data.i18n.display.score)
			:done()
end

local function renderRatingsBySystem(builder, code, name, activeSystems, args, na)
	builder = builder:tag('tr')
	builder:tag('td')
		:wikitext(name)

	for _, v in ipairs(activeSystems) do
		local combinedCode = code .. '_' .. v
		local cell = builder:tag('td')
		if args[combinedCode] then
			cell
				:wikitext(args[combinedCode])
				:done()
		elseif na then
			cell
				:addClass(data.i18n.class.na)
				:wikitext(data.i18n.display.na)
				:done()
		end
	end
end

local function renderRating(builder, name, rating)
	builder:tag('tr')
		:tag('td')
			:addClass(data.i18n.class.centeredpub)
			:wikitext(name)
			:done()
		:tag('td')
			:wikitext(rating)
			:done()
end

local function renderAggregators(builder, providedAggregators, activeSystems, customAggregatorKeys, args)
	
	local aggregatorCount = #providedAggregators + #customAggregatorKeys
	if aggregatorCount == 0 then return end
	
	builder = builder:tag('table')
		:addClass(data.i18n.class.aggregators)
		:addClass(data.i18n.class.wikitable)
		:addClass(args.state and 'mw-collapsible-content' or nil)
		:tag('caption')
			:wikitext(data.i18n.display[aggregatorCount == 1 and 'aggregateScore' or 'aggregateScores'])
			:done()

	if #activeSystems ~= 0 then
		local na = yesno(args.na)
		local showplatforms = #activeSystems ~= 1 or yesno(args.showplatforms)
		if showplatforms then
			renderHeadingRowWithSystems(builder, activeSystems, data.i18n.display.aggregator)
		else
			renderHeadingRow(builder, data.i18n.display.aggregator)
		end

		for _, v in ipairs(providedAggregators) do
			renderRatingsBySystem(builder, v, data.aggregators[v].name, activeSystems, args, na)
		end
		for _, v in ipairs(customAggregatorKeys) do
			renderRatingsBySystem(builder, v, args[v], activeSystems, args, na)
		end
	else
		renderHeadingRow(builder, data.i18n.display.aggregator)
		for _, v in ipairs(providedAggregators) do
			renderRating(builder, data.aggregators[v].name, args[v])
		end
		for _, v in ipairs(customAggregatorKeys) do
			renderRating(builder, args[v], args[v .. 'Score'])
		end
	end
end

local function renderReviews(builder, providedReviewers, activeSystems,
	customReviewerKeys, args, reviewerCount, priorReviewCount)
	
	if reviewerCount == 0 then return end
	
	builder = builder:tag('table')
		:addClass(data.i18n.class.reviews)
		:addClass(data.i18n.class.wikitable)
		:addClass(args.state and 'mw-collapsible-content' or nil)
		:tag('caption')
			:wikitext(data.i18n.display[reviewerCount == 1 and 'reviewScore' or 'reviewScores'])
			:addClass(priorReviewCount &gt; 0 and data.i18n.class.stacked or nil)
			:done()
	
	if #activeSystems ~= 0 then
		local na = yesno(args.na)
		local showplatforms = #activeSystems ~= 1 or yesno(args.showplatforms)
		if showplatforms then
			renderHeadingRowWithSystems(builder, activeSystems, data.i18n.display.publication)
		else
			renderHeadingRow(builder, data.i18n.display.publication)
		end

		for _, v in ipairs(providedReviewers) do
			renderRatingsBySystem(builder, v, data.reviewers[v].name, activeSystems, args, na)
		end
		for _, v in ipairs(customReviewerKeys) do
			renderRatingsBySystem(builder, v, args[v], activeSystems, args, na)
		end
	else
		renderHeadingRow(builder, data.i18n.display.publication)
		for _, v in ipairs(providedReviewers) do
			renderRating(builder, data.reviewers[v].name, args[v])
		end
		for _, v in ipairs(customReviewerKeys) do
			renderRating(builder, args[v], args[v .. 'Score'])
		end
	end
end

local function renderAwards(builder, args, awardKeys, priorReviewCount)
	if #awardKeys == 0 then return end
	
	builder = builder:tag('table')
		:addClass(data.i18n.class.awards)
		:addClass(data.i18n.class.wikitable)
		:addClass(args.state and 'mw-collapsible-content' or nil)
		:tag('caption')
			:wikitext(data.i18n.display[#awardKeys == 1 and 'award' or 'awards'])
			:addClass(priorReviewCount &gt; 0 and data.i18n.class.stacked or nil)
			:done()
		:tag('tr')
			:tag('th')
				:attr('scope', 'col')
				:wikitext(data.i18n.display.publication)
				:done()
			:tag('th')
				:attr('scope', 'col')
				:wikitext(data.i18n.display.award)
				:done()

	for _, v in ipairs(awardKeys) do
		builder:tag('tr')
			:tag('td')
				:wikitext(args[v .. 'Pub'])
				:done()
			:tag('td')
				:wikitext(args[v])
				:done()
	end
	builder:done()
	builder:done()
end

local function renderEditOnWikidata(builder, wikidata, state)
	if not wikidata then return end
	
	builder:tag('div')
		:addClass(data.i18n.class.wikidata)
		:addClass('skin-nightmode-reset-color')
		:addClass(state and 'mw-collapsible-content' or nil)
		:wikitext(vgwd.getUpdateLink())
		:done()
end

local function categorizePlatformCount(builder, platformCount)
	if platformCount ~= 0 then
		builder:wikitext(data.i18n.category.multiplatform)
	else
		builder:wikitext(data.i18n.category.singleplatform)
	end
end

local function renderTitles(builder, title, subtitle)
	builder:tag('div')
		:addClass(data.i18n.class.title)
		:wikitext(title or data.i18n.display.reception)
		:done()

	if subtitle then
		builder:tag('div')
			:addClass(data.i18n.class.subtitle)
			 -- The only reason to use the subtitle is collapsible content
			 -- So always add the related class.
			:addClass('mw-collapsible-content')
			:wikitext(subtitle)
			:done()
	end
end

local function render(providedReviewers, providedAggregators, awardKeys,
	activeSystems, customAggregatorKeys, customReviewerKeys, args, wikidata)
	local is_collapsible = args.title and args.state and
		(args.state == data.i18n.state.autocollapse or
			args.state == data.i18n.state.collapsed or
			args.state == data.i18n.state.expanded
		)
	local div = mw.html.create('div')
		:attr('role', 'complementary')
		:addClass(data.i18n.class.container)
		:addClass(data.i18n.class.dark)
		:addClass(#activeSystems == 0 and data.i18n.class.containersingle or nil)
		:addClass(args.align == data.i18n.align.left and data.i18n.class.containerleft or nil)
		:addClass(args.align == data.i18n.align.none and data.i18n.class.containernone or nil)
		:addClass(is_collapsible and 'mw-collapsible' or nil)
		:addClass(is_collapsible and args.state == data.i18n.state.collapsed and 'mw-collapsed' or nil)
		:addClass(is_collapsible and args.state == data.i18n.state.autocollapse and args.state or nil)

	renderTitles(div, args.title, args.subtitle)

	local aggregatorCount = #providedAggregators + #customAggregatorKeys
	renderAggregators(
		div,
		providedAggregators,
		activeSystems,
		customAggregatorKeys,
		args,
		aggregatorCount
	)
	local reviewerCount = #customReviewerKeys + #providedReviewers
	renderReviews(
		div,
		providedReviewers,
		activeSystems,
		customReviewerKeys,
		args,
		reviewerCount,
		aggregatorCount
	)
	renderAwards(
		div,
		args,
		awardKeys,
		reviewerCount + aggregatorCount
	)
	renderEditOnWikidata(div, wikidata, args.state)
	categorizePlatformCount(div, #activeSystems)
		
	return div
end

local function checkForWikidata(frame, args, activeSystems, providedAggregators)
	local wikidata = false
	
	if args.qid == 'none' then
		return wikidata
	end

	vgwd.setDateFormat(args.df)
	vgwd.setGame(args.qid)
	vgwd.setSystem(nil)
	vgwd.setGenerateReferences(true)
	vgwd.setShowUpdateLink(false)
	vgwd.setUpdateLinkStyle("text and pen")
	vgwd.setSystemFormat(args.systemFormat)

	-- Loop through aggregators if we have any.
	if #providedAggregators ~= 0 then
		for _, aggr in ipairs(providedAggregators) do
			-- Check if vgwd knows this aggregator.
			if vgwd.setReviewer(aggr) == nil then
				-- Loop through active systems
				if #activeSystems ~= 0 then
					for _, sys in ipairs(activeSystems) do
						local combinedCode = aggr .. '_' .. sys
						if args[combinedCode] == 'wikidata' then
							vgwd.setSystem(sys)
							vgwd.setShowSystem(false)
							local vgwdScore = vgwd.printReviewScores(frame)
							if vgwdScore then
								args[combinedCode] = vgwdScore
							end
							wikidata = true
						end
					end
				else
					vgwd.setShowSystem(true)
					if args[aggr] == 'wikidata' then
						local vgwdScore = vgwd.printReviewScores(frame)
						if vgwdScore then
							args[aggr] = vgwdScore
						end
						wikidata = true
					end
				end
			end
		end
	end

	return wikidata
end

function p._reviewbox(frame, args)
	local activeSystems = getActiveSystems(args)
	local customReviewerKeys, customAggregatorKeys, awardKeys = getArgKeyTables(args)
	local providedReviewers, providedAggregators = getProvidedReviewersAndAggregators(args, #activeSystems ~= 0)
	local wikidata = checkForWikidata(frame, args, activeSystems, providedAggregators)
	if #customAggregatorKeys ~= 0 or #customReviewerKeys ~= 0 or
		#providedAggregators ~= 0 or #providedReviewers ~= 0 or #awardKeys ~= 0 then
		return frame:extensionTag{
			name='templatestyles', args = { src = data.i18n.templatestyles }
		} ..  tostring(render(
				providedReviewers,
				providedAggregators,
				awardKeys,
				activeSystems,
				customAggregatorKeys,
				customReviewerKeys,
				args,
				wikidata
		))
	elseif mw.title.getCurrentTitle().namespace == 0 then
		return data.i18n.category.empty
	end
end

function p.reviewbox(frame)
	if not getArgs then
		getArgs = require('Module:Arguments').getArgs
	end
	return p._reviewbox(frame, getArgs(frame,
		{ wrappers = data.i18n.wrapper, trim = false, translate = data.argi18n }
	))
end

return p</text>
      <sha1>gthnuulwfntw94m1ccx96gi0236juqw</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Video game reviews/data</title>
    <ns>828</ns>
    <id>210</id>
    <revision>
      <id>408</id>
      <parentid>407</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>407</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="9754" sha1="5tlhiyuwcbml9xn62obwbo2al0dka4w" xml:space="preserve">local reviewers = {
	{ "''[[1Up.com]]''", '1UP' },
	{ "''[[4Players]]''", '4P' },
	{ "''[[ACE (magazine)|ACE]]''", 'ACE' },
	{ "''[[Adventure Gamers]]''", 'AdvGamers' },
	{ "''[[AllGame]]''", 'Allgame' },
	{ "''[[Aktueller Software Markt]]''", 'ASM' },
	{ "''[[Amiga Action]]''", 'AmAction' },
	{ "''[[Amiga Computing]]''", 'AmComputing' },
	{ "''[[Amiga Force]]''", 'AmForce' },
	{ "''[[Amiga Format]]''", 'AmFormat' },
	{ "''[[Amiga Power]]''", 'AmPower' },
	{ "''[[Amiga User International]]''", 'AmUI' },
	{ "''[[Amstrad Action]]''", 'AAction' },
	{ "''[[Amtix]]''", 'Amtix' },
	{ "''[[The A.V. Club]]''", 'AVC' },	
	{ "''[[Gemaga|Beep! MegaDrive]]''", 'BMD' },
	{ "''[[CNET Gamecenter]]''", 'CNG' },
	{ "''[[Computer Game Review]]''", 'CGR' },
	{ "''[[Computer Games Magazine]]''", 'CGM' },
	{ "''[[Computer Games Magazine|Computer Games Strategy Plus]]''", 'CGSP' },
	{ "''[[Computer Gaming World]]''", 'CGW' },
	{ "''Consoles +''", 'CP' },
	{ "''[[Crash (magazine)|Crash]]''", 'CRASH' },
	{ "''[[Computer and Video Games]]''", 'CVG' },
	{ "''[[Destructoid]]''", 'Destruct' },
	{ "''[[Digital Trends]]''", 'DT' },
	{ "''[[Dragon (magazine)|Dragon]]''", 'Dragon' },
	{ "''[[Easy Allies]]''", 'EZA' },
	{ "''[[Edge (magazine)|Edge]]''", 'Edge' },
	{ "''[[Electronic Gaming Monthly]]''", 'EGM' },
	{ "''[[EP Daily]]''", 'EPD' },
	{ "''[[Eurogamer]]''", 'EuroG' },
	{ "''[[Famitsu]]''", 'Fam' },
	{ "''[[G4 (American TV network)|G4]]''", 'G4' },
	{ "''[[Game Informer]]''", 'GI' },
	{ "''[[Game Players]]''", 'GP' },
	{ "''[[GameDaily]]''", 'GD' },
	{ "''[[GameFan]]''", 'GameFan' },
	{ "''[[Gamekult]]''", 'Gamekult' },
	{ "''[[GamePro]]''", 'GamePro' },
	{ "''[[GameRevolution]]''", 'GameRev' },
	{ "''[[GamesMaster (magazine)|GamesMaster]]''", 'GMaster' },
	{ "''[[GameSpot]]''", 'GSpot' },
	{ "''[[GameSpy]]''", 'GSpy' },
	{ "''[[GamesRadar+]]''", 'GRadar' },
	{ "''[[GameStar]]''", 'GStar' },
	{ "''[[GamesTM]]''", 'GTM' },
	{ "''[[Games-X]]''", 'GX' },
	{ "''[[GameTrailers]]''", 'GT' },
	{ "''[[Gamezebo]]''", 'Gamezebo' },
	{ "''GameZone''", 'GameZone' },
	{ "''Gekkan PC Engine''", 'GPCE' },
	{ "''Génération 4''", 'Gen4' },
	{ "''[[Giant Bomb]]''", 'GB' },
	{ "''Hardcore Gamer''", 'HCG' },
	{ "''[[HobbyConsolas]]''", 'HC' },
	{ "''[[Hyper (magazine)|Hyper]]''", 'Hyper' },
	{ "''[[IGN]]''", 'IGN' },
	{ "''Impress Watch''", 'IW' },
	{ "''[[Jeuxvideo.com]]''", 'JXV' },
	{ "''Joypad''", 'JP' },
	{ "''[[Joystick (magazine)|Joystick]]''", 'JS' },
	{ "''[[Joystiq]]''", 'Joystiq' },
	{ "''[[Kill Screen]]''", 'KS' },
	{ "''M! Games''", 'MG' },
	{ "''[[MacLife]]''", 'ML' },
	{ "''[[Macworld]]''", 'MW' },
	{ "''Marukatsu PC Engine''", 'MPCE' },
	{ "''[[Maximum PC]]''", 'MaxPC' },
	{ "''[[Mean Machines]]''", 'MM' },
	{ "''[[Mean Machines#Mean Machines Sega and Nintendo Magazine System|Mean Machines Sega]]''", 'MMS' },
	{ "''Mega Fun''", 'MF' },
	{ "''MeriStation''", 'MS' },
	{ "''[[Micromanía]]''", 'MIC' },
	{ "''[[NGC Magazine|N64 Magazine]]''", 'N64' },
	{ "''[[Next Generation (magazine)|Next Generation]]''", 'NGen' },
	{ "''[[Nintendo Gamer|NGamer]]''", 'NG' },
	{ "''[[NGC Magazine]]''", 'NGC' },
	{ "''[[Nintendo Life]]''", 'NLife' },
	{ "''[[Nintendo Power]]''", 'NP' },
	{ "''Nintendo World Report''", 'NWR' },
	{ "''[[NME]]''", 'NME' },
	{ "''[[Official Nintendo Magazine]]''", 'ONM' },
	{ "''[[PlayStation Official Magazine – Australia]]''", 'OPMAU' },
	{ "''[[PlayStation Official Magazine – UK]]''", 'OPMUK' },
	{ "''[[Official U.S. PlayStation Magazine]]''", 'OPM' },
	{ "[[Official Xbox Magazine|''Official Xbox Magazine'' (UK)]]", 'OXMUK' },
	{ "[[Official Xbox Magazine|''Official Xbox Magazine'' (US)]]", 'OXM' },
	{ "''PALGN''", 'PALGN' },
	{ "''[[PC Accelerator]]''", 'PCA' },
	{ "''PC Engine Fan''", 'PCEF' },
	{ "''[[PC Format]]''", 'PCF' },
	{ "[[PC Gamer|''PC Gamer'' (UK)]]", 'PCGUK' },
	{ "[[PC Gamer|''PC Gamer'' (US)]]", 'PCGUS' },
	{ "[[PC Games|''PC Games'' (DE)]]", 'PCG' },
	{ "[[GamePro#PC Games|''PC Games'' (US)]]", 'GPPCG' },
	{ "''[[PC PowerPlay]]''", 'PCPP' },
	{ "''[[PC Zone]]''", 'PCZone' },
	{ "''[[PCGamesN]]''", 'PCGN' },
	{ "''[[PCMag]]''", 'PCM' },
	{ "''[[Play (UK magazine)|Play]]''", 'Play' },
	{ "''[[Pocket Gamer]]''", 'PG' },
	{ "''[[Polygon (website)|Polygon]]''", 'Poly' },
	{ "''Player One''", 'PO' },
	{ "''[[PlayStation: The Official Magazine]]''", 'PSM' },
	{ "''[[PSM3]]''", 'PSM3' },
	{ "''[[Push Square]]''", 'PSQ' },
	{ "''[[Newsfield#Raze|Raze]]''", 'Raze' },
	{ "''[[Retro Gamer]]''", 'Retro' },
	{ "''RPGamer''", 'RPG' },
	{ "''RPGFan''", 'RPGFan' },
	{ "''[[Shacknews]]''", 'SN' },
	{ "''[[Sinclair User]]''", 'SUser' },
	{ "''[[ST Action]]''", 'STAction' },
	{ "''[[ST Format]]''", 'STFormat' },
	{ "''[[ST Review]]''", 'STRev' },
	{ "''Superjuegos''", 'SJ' },
	{ "''Super Game Power''", 'SGP' },
	{ "''[[Super Play]]''", 'SP' },
	{ "''[[TeamXbox]]''", 'TX' },
	{ "''[[TechRadar]]''", 'TR' },
	{ "''[[The Daily Telegraph|The Telegraph]]''", 'TELE' },
	{ "[[The Games Machine|''The Games Machine'' (UK)]]", 'TGM' },
	{ "[[The Games Machine (Italy)|''The Games Machine'' (Italy)]]", 'TGMIt' },
	{ "''[[The Guardian]]''", 'TG' },
	{ "''[[Tilt (French magazine)|Tilt]]''", 'TILT' },
	{ "''[[Total!]]''", 'TOT' },
	{ "''[[TouchArcade]]''", 'TA' },
	{ "''[[USgamer]]''", 'USG' },
	{ "''[[VentureBeat]]''", 'VB' },
	{ "''[[Video Games Chronicle]]''", 'VGC' },
	{ "''[[VG247]]''", 'VG247' },
	{ "''Video Games'' (DE)", 'VGS' },
	{ "''VideoGamer.com''", 'VG' },
	{ "''[[VideoGames &amp; Computer Entertainment]]''", 'VGCE' },
	{ "''[[X-Play]]''", 'XPlay' },
	{ "''[[Your Sinclair]]''", 'YSinclair' },
	{ "''[[Zero (video game magazine)|Zero]]''", 'Zero' },
	{ "''[[Zzap!64]]''", 'Z64' },
}

local aggregators = {
	{ '[[GameRankings]]', 'GR' },
	{ '[[Metacritic]]', 'MC' },
	{ '[[OpenCritic]]', 'OC' },
}

local systems = {
	{ '[[3DO Interactive Multiplayer|3DO]]', '3DO' },
	{ '[[Nintendo 3DS|3DS]]', '3DS' },
	{ '[[Amiga]]', 'AMI' },
	{ '[[Arcade game|Arcade]]', 'ARC' },
	{ '[[Atari 2600]]', 'A2600' },
	{ '[[Atari Jaguar]]', 'JAG' },
	{ '[[Atari Lynx]]', 'LYNX' },
	{ '[[Atari ST]]', 'AST' },
	{ '[[Commodore 64|C64]]', 'C64' },
	{ '[[Amiga CD32|CD32]]', 'CD32' },
	{ '[[ColecoVision]]', 'CV' },
	{ '[[MS-DOS|DOS]]', 'DOS' },
	{ '[[Dreamcast]]', 'SDC' },
	{ '[[Nintendo DS|DS]]', 'DS' },
	{ '[[Game Boy]]', 'GB' },
	{ '[[Game Boy Advance|GBA]]', 'GBA' },
	{ '[[Game Boy Color|GBC]]', 'GBC' },
	{ '[[GameCube|GC]]', 'NGC' },
	{ '[[List of video game consoles|General]]', 'GEN' },
	{ '[[Intellivision]]', 'INT' },
	{ '[[iOS]]', 'iOS' },
	{ '[[Macintosh]]', 'MAC' },
	{ '[[Master System]]', 'SMS' },
	{ '[[Mobile phone|mobile]]', 'MOB' },
	{ '[[N-Gage (device)|N-Gage]]', 'N-G' },
	{ '[[Nintendo 64|N64]]', 'N64' },
	{ '[[Nintendo Entertainment System|NES]]', 'NES' },
	{ '[[Nintendo Switch|NS]]', 'NS' },
	{ '[[Nintendo Switch 2|NS2]]', 'NS2' },
	{ '[[Personal computer|PC]]', 'PC' },
	{ '[[PlayStation Vita|PS Vita]]', 'VITA' },
	{ '[[PlayStation (console)|PS]]', 'PS' },
	{ '[[PlayStation 2|PS2]]', 'PS2' },
	{ '[[PlayStation 3|PS3]]', 'PS3' },
	{ '[[PlayStation 4|PS4]]', 'PS4' },
	{ '[[PlayStation 5|PS5]]', 'PS5' },
	{ '[[PlayStation Portable|PSP]]', 'PSP' },
	{ '[[Sega Saturn|Saturn]]', 'SSAT' },
	{ '[[Sega Genesis]]', 'SMD' },
	{ '[[Sega Game Gear|SGG]]', 'SGG' },
	{ '[[Nvidia Shield|Shield]]', 'NSHI' },
	{ '[[Super Nintendo Entertainment System|SNES]]', 'SNES' },
	{ '[[TurboGrafx-16]]', 'TG16' },
    { '[[VIC-20]]', 'VIC' },
	{ '[[Wii]]', 'WII' },
	{ '[[Wii U]]', 'WIIU' },
	{ '[[Xbox (console)|Xbox]]', 'XBOX' },
	{ '[[Xbox 360]]', 'X360' },
	{ '[[Xbox One]]', 'XONE' },
	{ '[[Xbox Series X and Series S|Xbox Series X/S]]', 'XSXS' },
	{ '[[ZX Spectrum|ZX]]', 'ZX' },
}

local function setupSortkeys(t)
	local retval = {}
	for k, v in ipairs(t) do
		retval[v[2]] = { name = v[1], sortkey = k }
	end
	return retval
end

return {
	reviewers = setupSortkeys(reviewers),
	aggregators = setupSortkeys(aggregators),
	systems = setupSortkeys(systems),
	i18n = {
		wrapper = 'Template:Video game reviews',
		templatestyles = 'Module:Video game reviews/styles.css',
		pattern = {
			reviewer = '^rev%d+$',
			aggregator = '^agg%d+$',
			award = '^award%d+$',
		},
		class = {
			aggregators = 'vgr-aggregators',
			awards = 'vgr-awards',
			centeredpub = 'vgr-center',
			container = 'video-game-reviews',
			containerleft = 'vgr-left',
			containernone = 'vgr-none',
			containersingle = 'vgr-single',
			dark = 'skin-invert',
			headerrow = 'vgr-hrow',
			na = 'table-na', -- same as Template:n/a
			reviews = 'vgr-reviews',
			stacked = 'vgr-stacked',
			subtitle = 'vgr-subtitle',
			title = 'vgr-title',
			wikidata = 'vgr-edit-on-wikidata',
			-- we keep wikitable around even though all the styles are overriden
			-- because it helps some scripts to know to look for a real data table
			wikitable = 'wikitable',
		},
		state = {
			autocollapse = 'autocollapse', -- you may not have this on your wiki
			collapsed = 'collapsed',
			expanded = 'expanded',
		},
		align = {
			left = 'left',
			none = 'none',
		},
		category = {
			empty = '[[Category:Empty templates on articles]]',
			multiplatform = '[[Category:Articles using Video game reviews template in multiple platform mode]]',
			singleplatform = '[[Category:Articles using Video game reviews template in single platform mode]]',
		},
		display = {
			aggregateScore = 'Aggregate score',
			aggregateScores = 'Aggregate scores',
			aggregator = 'Aggregator',
			award = 'Award',
			awards = 'Awards',
			na = 'N/A',
			publication = 'Publication',
			reception = 'Reception',
			reviewScore = 'Review score',
			reviewScores = 'Review scores',
			score = 'Score',
		},
	},
	argi18n = {
		-- For non-English wikis, add translations of argument keys here.
		-- Example:
		-- subtitle = 'untertitel'
	},
}</text>
      <sha1>5tlhiyuwcbml9xn62obwbo2al0dka4w</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Video game reviews/styles.css</title>
    <ns>828</ns>
    <id>211</id>
    <revision>
      <id>410</id>
      <parentid>409</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>409</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="2346" sha1="cu2m13sgvoagxznomjh0g7hwd5ahife" xml:space="preserve">/* {{pp|small=yes}} */
.video-game-reviews {
	float: right;
	clear: right;
	margin: 0 1em 1em;
	text-align: center;
	padding: 0;
}

/* As with width below, .vgr-left and .vgr-none maybe shouldn't exist. Someone
   who really needs this to be left rather than right can always plop it
   in its own div... */
.vgr-left {
	float: left;
	clear: left;
	margin: 0 1em 1em 0;
}

.vgr-none {
	float: none;
	clear: left;
	margin: 0 1em 1em 0;
}

.vgr-single {
	width: 23em;
}

.vgr-edit-on-wikidata {
	border: 1px solid #a2a9b1;
	border-top: none;
	padding: 0.2em;
	/* Revisit background color because Wikidata link is only about 4.0 contrast.
	   Something for the talk page. */
	background: #d1dbdf;
    color: #333;
	font-size: 88%;
	font-weight: bold;
}

.video-game-reviews table {
	border: 1px solid #a2a9b1;
	/* @noflip */
	margin: 0;
	font-size: 88%;
	width: 100%;
}

.video-game-reviews td,
.video-game-reviews th,
.video-game-reviews caption {
	border: 1px solid #a2a9b1;
	vertical-align: middle;
}

.video-game-reviews caption {
	border-bottom: none;
	background: #d1dbdf;
    color: #333;
	text-align: center;
	padding: 0.2em 0.4em;
}

.video-game-reviews th {
	background: #eaecf0;
	color: #333;
}

.vgr-awards td {
	background: #f2f2f2;
	color: #333;
}

.vgr-hrow th {
	background: #e8f4f8;
	color: #333;
}

.video-game-reviews .table-na {
	color: #707070
}

.vgr-reviews,
.vgr-reviews tr:last-child td,
.vgr-reviews tr:last-child th {
	border-bottom: none;
}

.vgr-title,
.vgr-subtitle,
.vgr-awards tr td:first-child {
	font-weight: bold;
}

.mw-collapsed .vgr-title {
	display: inline; /* so that it doesn't "wrap" to the next line */
}

.video-game-reviews table tr td:first-child,
.vgr-awards td {
	text-align: left;
}

.video-game-reviews table tr td.vgr-center {
	/* Needed to override text-align left above	in one particular case where 
	   it looks prettier. Usually it would make more sense to make a semantic name */
	text-align: center;
}

.video-game-reviews .vgr-stacked {
	border-top: none;
}

@media (max-width: 720px) {
	.video-game-reviews {
		width: 100%;
		float: none; /* set float/clear explicitly to override earlier */
		clear: both;
		margin: 0;
	}
	
	.video-game-reviews table {
		display: table; /* Minerva is silly */
	}
	
	.video-game-reviews caption {
		display: table-caption; /* Minerva is still silly */
	}
}</text>
      <sha1>cu2m13sgvoagxznomjh0g7hwd5ahife</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Video game wikidata</title>
    <ns>828</ns>
    <id>212</id>
    <revision>
      <id>412</id>
      <parentid>411</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>411</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="16568" sha1="s3f0g00c55widaq455r6yf3ec5qxi2d" xml:space="preserve">local Date = require('Module:Date')._Date
local yesno = require('Module:Yesno')

local p = {}

-- Local variables.
local reviewer = nil;
local df = "mdy";
local entity = nil;
local genRefs = true;
local showSystem = true;
local showUpdateLink = true;
local system = nil;
local systemId = nil;
local systemFormat = "colon";
local updateLinkStyle = nil;
local entities = {};

-- Translation table for converting numeric-IDs to shorthand aliases.
local systemAliases = {
	[10677] = 'PS1',
	[1323662] = 'PS1', -- Placeholder, this is actually the series but could be mistakenly used for PS1.
	[10680] = 'PS2',
	[10683] = 'PS3',
	[5014725] = 'PS4',
	[16338] = 'PC',
	[8079] = 'Wii',
	[56942] = 'WiiU',
	[132020] = 'XBOX',
	[48263] = 'X360',
	[13361286] = 'XONE',
	[203597] = '3DS',
	[188808] = 'PSV',
	[170323] = 'DS', -- Sometimes has been NDS
	[170325] = 'PSP',
	[48493] = 'IOS', -- iOS, iPhone, iPad
	[94] = 'AND', -- Android
	[186437] = 'GB',
	[188642] = 'GBA',
	[203992] = 'GBC',
	[184198] = 'DC',
	[200912] = 'SAT',
	[172742] = 'NES',
	[183259] = 'SNES',
	[184839] = 'N64',
	[182172] = 'GC', -- Sometimes has been NGC
	[19610114] = 'NS', -- Nintendo Switch
	[98973368] = 'XSX/S', -- Xbox Series X and Series S (Output label differs from the input parameter, XSXS, per RFC)
	[63184502] = 'PS5'
}

-- Translation table for converting system aliases to QIDs
local systemIDs = {
	['PS1'] = 10677,
	['PS2'] = 10680,
	['PS3'] = 10683,
	['PS4'] = 5014725,
	['PC'] = 16338,
	['WII'] = 8079,
	['WIIU'] = 56942,
	['XBOX'] = 132020,
	['X360'] = 48263,
	['XONE'] = 13361286,
	['3DS'] = 203597,
	['PSV'] = 188808,
	['DS'] = 170323,
	['NDS'] = 170323,
	['PSP'] = 170325,
	['IOS'] = 48493,
	['AND'] = 94,
	['GB'] = 186437,
	['GBA'] = 188642,
	['GBC'] = 203992,
	['DC'] = 184198,
	['SAT'] = 200912,
	['NES'] = 172742,
	['SNES'] = 183259,
	['N64'] = 184839,
	['GC'] = 182172,
	['NGC'] = 182172,
	['NS'] = 19610114,
	['XSXS'] = 98973368, -- This is the template parameter, which cannot contain a / or | character.
	['PS5'] = 63184502
}

-- List of accepted aggregator arguments and their related QID.
local aggregatorAliases = {
    [150248] = 'MC',
    [40160] = 'GR',
    [21039459] = 'OC'
}   

-- List of accepted aggregator arguments and their related QID.
local aggregatorIDs = {
    ['MC'] = 150248,
    ['GR'] = 40160,
    ['OC'] = 21039459
}   

-- List of accepted reviewer arguments and their related QID.
local reviewerAliases = {
	[591573] = 'FAM',
	[207708] = 'IGN'
}   

-- List of accepted reviewer arguments and their related QID.
local reviewerIDs = {
	['FAM'] = 591573,
	['IGN'] = 207708
} 

local function sortByPlatform(a,b) 
	local platformA = "";
	local platformB = "";
	if(a['qualifiers']['P400'] ~= nil and a['qualifiers']['P400'][1] ~= nil) then
		platformA = p.getSystemAlias(a['qualifiers']['P400'][1]['datavalue']['value']['numeric-id']);
		if(platformA == nil) then
			platformA = mw.wikibase.label('Q'..a['qualifiers']['P400'][1]['datavalue']['value']['numeric-id']);
		end;
	end;
	if(b['qualifiers']['P400'] ~= nil and b['qualifiers']['P400'][1] ~= nil) then
		platformB = p.getSystemAlias(b['qualifiers']['P400'][1]['datavalue']['value']['numeric-id']);
		if(platformB == nil) then
			platformB = mw.wikibase.label('Q'..b['qualifiers']['P400'][1]['datavalue']['value']['numeric-id']);
		end;
	end;		
		
	return platformA &lt; platformB
end;

local function buildCite(reference) 
	local referenceUrl = nil;
	local cite = nil;
	
	if(reference['snaks']['P854'] ~= nil and reference['snaks']['P854'][1] ~= nil) then
		referenceUrl = reference['snaks']['P854'][1]['datavalue']['value'];	
	end;

	if(referenceUrl ~= nil and referenceUrl ~= "") then
		cite = "{{cite web|url="..referenceUrl;
			
		local pubdate = nil;
		local accessdate = nil;
		local publisher = nil;
		local work = nil;
		local title = nil;
		local archiveUrl = nil;
		local archiveDate = nil;
		local authors = {};

		if(reference['snaks']['P577'] ~= nil and reference['snaks']['P577'][1] ~= nil) then
			pubdate = reference['snaks']['P577'][1]['datavalue']['value']['time'];
		end;
		if(reference['snaks']['P813'] ~= nil and reference['snaks']['P813'][1] ~= nil) then
			accessdate = reference['snaks']['P813'][1]['datavalue']['value']['time'];
		end;
		if(reference['snaks']['P123'] ~= nil and reference['snaks']['P123'][1] ~= nil) then
			publisher = mw.wikibase.label('Q'..reference['snaks']['P123'][1]['datavalue']['value']['numeric-id']);
		end;
		if(reference['snaks']['P1433'] ~= nil and reference['snaks']['P1433'][1] ~= nil) then
			work = mw.wikibase.label('Q'..reference['snaks']['P1433'][1]['datavalue']['value']['numeric-id']);
		end;			
		if(reference['snaks']['P1476'] ~= nil and reference['snaks']['P1476'][1] ~= nil) then
			title = reference['snaks']['P1476'][1]['datavalue']['value']['text'];
		end;
		if(reference['snaks']['P1065'] ~= nil and reference['snaks']['P1065'][1] ~= nil) then
			archiveUrl = reference['snaks']['P1065'][1]['datavalue']['value'];
		end;
		if(reference['snaks']['P2960'] ~= nil and reference['snaks']['P2960'][1] ~= nil) then
			archiveDate = reference['snaks']['P2960'][1]['datavalue']['value']['time'];
		end;	
		if(reference['snaks']['P50'] ~= nil and #reference['snaks']['P50'] &gt; 0) then
			for i,authorDat in pairs(reference['snaks']['P50']) do
				local authorQid = 'Q'..authorDat['datavalue']['value']['numeric-id'];
				if(entities[authorQid] == nil) then
					entities[authorQid] = mw.wikibase.getEntity(authorQid);
				end;
				
				local author = {};
				author['fullname'] = mw.wikibase.label(authorQid); -- Default to label
				author['first'] = nil;
				author['last'] = nil;
				
				if(entities[authorQid]['claims']['P735'] ~= nil and entities[authorQid]['claims']['P735'][1] ~= nil) then
					author['first'] = mw.wikibase.label('Q'..entities[authorQid]['claims']['P735'][1]['mainsnak']['datavalue']['value']['numeric-id']);
				end;
				if(entities[authorQid]['claims']['P734'] ~= nil and entities[authorQid]['claims']['P734'][1] ~= nil) then
					author['last'] = mw.wikibase.label('Q'..entities[authorQid]['claims']['P734'][1]['mainsnak']['datavalue']['value']['numeric-id']);
				end;
				
				table.insert(authors, author);
			end;
		end;			
		
		if(title ~= nil and title ~= "") then
			cite = cite .. "|title="..title;
		end;
		if(publisher ~= nil and publisher ~= "") then
			cite = cite .. "|publisher="..publisher;
		end;
		if(work ~= nil and work ~= "") then
			cite = cite .. "|work="..work;
		end;		
		if(pubdate ~= nil and pubdate ~= "") then
			local pubdateText = Date(pubdate):text(df);

			cite = cite .. "|date="..pubdateText;
		end;		
		if(accessdate ~= nil and accessdate ~= "") then
			local accessdateText = Date(accessdate):text(df);

			cite = cite .. "|accessdate="..accessdateText;
		end;
		if(archiveUrl ~= nil and archiveUrl ~= "" and archiveDate ~= nil and archiveDate ~= "") then
		    local archivedateText = Date(archiveDate):text(df);
			cite = cite .. "|archiveurl="..archiveUrl;
			cite = cite .. "|archivedate="..archivedateText;
		end;		
		if(#authors &gt; 0) then
			for i,author in pairs(authors) do
				if(author['first'] ~= nil and author['last'] ~= nil and author['first'] ~= "" and author['last'] ~= "") then
					if(#authors == 1) then
						cite = cite .."|last="..author['last'].."|first="..author['first'];
					else
						cite = cite .."|last"..i.."="..author['last'].."|first"..i.."="..author['first'];
					end;
				else
					if(#authors == 1) then
						cite = cite .."|author="..author['fullname'];
					else
						cite = cite .."|author"..i.."="..author['fullname'];
					end;					
				end;
			end;			
		end;
		
		
		cite = cite..'}}';	
	end;
	
	return cite;
end;

local function printReviewRow(frame, reviewscore)
	local score = nil;

	if(reviewscore['mainsnak']['datavalue'] ~= nil and reviewscore['mainsnak']['datavalue']['value'] ~= nil) then
		score = reviewscore['mainsnak']['datavalue']['value'];
	else
		return "";
	end;
	
	local ret = ""
	local system = nil;
	local reference = nil;	

	if(reviewscore['qualifiers']['P400'] ~= nil and reviewscore['qualifiers']['P400'][1] ~= nil) then
		system = p.getSystemAlias(reviewscore['qualifiers']['P400'][1]['datavalue']['value']['numeric-id']);
	end	
	if(system ~= nil and system ~= "" and showSystem) then
		if(systemFormat == "para") then
			ret = ret.."("..system..") ";
		else
			ret = ret..system..": ";
		end;
	end;

	ret = ret..score;

	if(reviewscore['references'] ~= nil and reviewscore['references'][1] ~= nil and genRefs) then
		local cite = buildCite(reviewscore['references'][1]);
		
		if(cite ~= nil) then
			local scoreBy = p.getAggregatorAlias(reviewscore['qualifiers']['P447'][1]['datavalue']['value']['numeric-id']);
			if(scoreBy == nil) then
				scoreBy = p.getReviewerAlias(reviewscore['qualifiers']['P447'][1]['datavalue']['value']['numeric-id']);
			end;

			local name = entity:getLabel()..'-'..scoreBy;
			if(system ~= nil and system ~= "") then
				name = name..system;
			end;

			cite = frame:extensionTag{ name = "ref", args = {name=name}, content=cite };
			ret = ret..cite;
		end;
	end;

	return ret.."&lt;br /&gt;";
end

function p.getSystemAlias(numericId)
	return systemAliases[numericId];
end

function p.getSystemID(system)
	return systemIDs[system];
end

function p.getAggregatorAlias(numericId)
	return aggregatorAliases[numericId];
end

function p.getAggregatorID(system)
	return aggregatorIDs[system];
end

function p.getReviewerAlias(numericId)
	return reviewerAliases[numericId];
end

function p.getReviewerID(system)
	return reviewerIDs[system];
end

function p.setReviewer(iReviewer)
	-- No reviewer, stop. Must have reviewer at least.
	if(iReviewer == nil or iReviewer == "") then
		return "Missing reviewer";
	end;
	
	-- See if supplied reviewer is in the aggregator table.
	iReviewer = string.upper(iReviewer)
	reviewer = p.getAggregatorID(iReviewer);
	if(reviewer == nil or reviewer == "") then
		-- No? Maybe in the reviewer table.
		reviewer = p.getReviewerID(iReviewer);
		if(reviewer == nil or reviewer == "") then
			return "Invalid reviewer";
		end;
	end;	

	return nil;
end;

function p.setDateFormat(iDf)
	-- Check for a date format parameter. Default to mdy if missing.
	if(iDf ~= nil and iDf ~= "") then
		df = string.lower(iDf);
	end;
end;

function p.setSystemFormat(iSf)
	if(iSf ~= nil and iSf ~= "") then
		systemFormat = string.lower(iSf);
	end;
end;

function p.setUpdateLinkStyle(iStyle)
	if(iStyle ~= nil and iStyle ~= "") then
		updateLinkStyle = string.lower(iStyle);
	end;
end;

function p.setGame(iGame)
	-- Check for a game parameter. If missing, default to current article.
	if(iGame ~= nil and iGame ~= "") then
		if(entities[iGame] == nil and mw.wikibase ~= nil) then
 			entities[iGame] = mw.wikibase.getEntity(iGame);
		end;
		
		entity = entities[iGame]
	else
		-- Need to research if we can determine the entity's ID before retrieving it.
		if(mw.wikibase ~= nil) then
			entity = mw.wikibase.getEntity();
			if(entity ~= nil) then
				entities[entity['id']] = entity;
			end;
		end;
	end;
	
	if(entity == nil) then
		return "No matching wikidata entity found";
	end;
	
	return nil;
end;

function p.setSystem(iSystem)
	-- Check for system parameter, and resolve it's QID if possible.
	if(iSystem ~= nil and iSystem ~= "") then
		system = string.upper(iSystem);
		systemId = p.getSystemID(system);
	elseif(not showSystem) then
		-- If no system was specified, force showSystem on.
		showSystem = true;
	end;
end;

function p.setGenerateReferences(iGenRefs)
	-- Reference suppression.
	if(iGenRefs ~= nil and iGenRefs ~= "") then
		genRefs = yesno(iGenRefs, true);
	end;
end;

function p.setShowSystem(iShowSystem)
	-- Suppression of system aliases in front of score, i.e. (XBOX) xx/100.
	if(iShowSystem ~= nil and iShowSystem ~= "") then
		showSystem = yesno(iShowSystem, false);
	end;
	if(system == nil or system == '') then
		-- If no system was specified, force showSystem on.
		showSystem = true;
	end;
end;

function p.setShowUpdateLink(iShowUpdateLink)
	-- Suppression of update link to Wikidata at the end of the score, i.e. (XBOX) xx/100[+].
	if(iShowUpdateLink ~= nil and iShowUpdateLink ~= "") then
		showUpdateLink = yesno(iShowUpdateLink, false);
	end;
end;

function p.getUpdateLink()
	if(updateLinkStyle == "pen") then
		return "[[File:Blue pencil.svg|frameless|text-top|10px|alt=Edit this on Wikidata|link=https://www.wikidata.org/wiki/"..entity['id'].."?uselang="..mw.language.getContentLanguage().code.."#P444|Edit this on Wikidata]]";
	elseif(updateLinkStyle == "noSub") then
		return '[[d:'..entity['id']..'#P444|&amp;#91;±&amp;#93;]]';
	elseif(updateLinkStyle == "text and pen") then
		return '&lt;span style="position: relative;"&gt;&lt;span style="position: absolute; right: 0;"&gt;[[File:Blue pencil.svg|10px|baseline|link=|alt=]]&lt;/span&gt;[[d:'..entity['id']..'#P444|&lt;span style="position: relative; padding-right: 14px;"&gt;Edit on Wikidata&lt;/span&gt;]]&lt;/span&gt;'
	end;
	
	return '&lt;sub&gt;[[d:'..entity['id']..'#P444|&amp;#91;±&amp;#93;]]&lt;/sub&gt;';
end;

function p.getSitelink()
	return mw.wikibase.sitelink(entity['id']);
end;

function p.getLabel()
	return mw.wikibase.label(entity['id']);
end;

function p.getParts()
	local ret = {};	
	
	-- Loop all of "has Part" for this title
	local parts = entity['claims']['P527'];	
	if(parts) then
		for i,part in pairs(parts) do
			table.insert(ret,"Q"..part['mainsnak']['datavalue']['value']['numeric-id']);
		end;		
	end;

	return ret;	
end;

function p.getEarliestPublicationDate()
	local ret = {};
	
	local pubDates = entity['claims']['P577'];	
	if(pubDates) then
		for i,pubDate in pairs(pubDates) do
			if(pubDate['mainsnak']['datavalue']) then
				local timestamp = pubDate['mainsnak']['datavalue']['value']['time'];
				local accessdate = Date(timestamp);	
				table.insert(ret,accessdate);
			end;
		end;		
	end;

	if(#ret &lt; 1) then
		return nil;
	end;

	table.sort(ret);
	
	return ret[1];
end;

function p.printReviewScores(frame)
	local ret = "";	
	
	-- Loop all of "review scores" for this title
	local reviewscores = entity['claims']['P444'];	
	if(reviewscores) then
		-- Find reviews that qualify for printing and insert into array.
		local reviewsToPrint = {}
    	for i,review in pairs(reviewscores) do
    		if(review['qualifiers'] ~= nil) then
				local scoreBy = nil 
				if(review['qualifiers']['P447'] ~= nil and review['qualifiers']['P447'][1] ~= nil) then
					scoreBy = review['qualifiers']['P447'][1]['datavalue']['value']['numeric-id'];
				end;
				if(scoreBy == reviewer) then
					-- If template specified a system, we need to check for the specific system and only output that one.
					if(system == nil or system == "") then
						-- No system specified, so output each one found.
						table.insert(reviewsToPrint,review);
					else
						-- Get platform if it exists.
						if(review['qualifiers']['P400'] ~= nil and review['qualifiers']['P400'][1] ~= nil) then
							-- Try to match based on QID.
							local reviewSysId = review['qualifiers']['P400'][1]['datavalue']['value']['numeric-id'];
							if(systemId == reviewSysId) then
								table.insert(reviewsToPrint,review);
							else 
								-- If that failed, try to match based on label.
								local systemName = mw.wikibase.label('Q'..reviewSysId);
								if(systemName ~= nil and string.upper(systemName) == system) then
									table.insert(reviewsToPrint,review);
								end;
							end;
						end;
					end;
				end;
			end;    		
		end;
	
		-- Sort the array by platform label.
    	table.sort(reviewsToPrint, sortByPlatform);
    	
    	-- If a system was not specified, showSystem has defaulted to true. If this title only has one platform and one review, we will turn it off.
    	-- Note: If the title has zero or more platforms defined, we leave showSystem on. We are unable to determine if this is a single-platform game.
    	--if((system == nil or system == "") and #reviewsToPrint == 1 and entity['claims']['P400'] ~= nil and #entity['claims']['P400'] == 1) then
    	-- Simplifying this based on discussion at [Template:Video game reviews]. If there's only one review, don't display system unless explicitly requested.
    	if((system == nil or system == "") and #reviewsToPrint == 1) then
    		showSystem = false;
    	end;

		-- Print the reviews
    	for i,review in ipairs(reviewsToPrint) do
    		ret = ret .. printReviewRow(frame, review);
		end;
	end;

	if(ret ~= "") then
		ret = string.sub(ret, 1, -7);
	elseif(not showUpdateLink) then
		ret = nil;
	end;
	
	-- Add edit link at end if showUpdateLink is on.
	if(showUpdateLink) then 
		ret = ret .. p.getUpdateLink();
	end;	

	return ret;
end;

return p</text>
      <sha1>s3f0g00c55widaq455r6yf3ec5qxi2d</sha1>
    </revision>
  </page>
  <page>
    <title>Template:MobyGames</title>
    <ns>10</ns>
    <id>213</id>
    <revision>
      <id>414</id>
      <parentid>413</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>413</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="156" sha1="5dqi6na3f2x62v66910flan7vcwx5bi" xml:space="preserve">[https://www.mobygames.com/game{{Trim|{{{1|{{{id}}}}}}}} {{{2|{{{name|''{{PAGENAMEBASE}}''}}}}}}] at [[MobyGames]]&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>5dqi6na3f2x62v66910flan7vcwx5bi</sha1>
    </revision>
  </page>
  <page>
    <title>Template:The Legend of Zelda</title>
    <ns>10</ns>
    <id>214</id>
    <revision>
      <id>416</id>
      <parentid>415</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>415</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5845" sha1="dhq00obn7794t3dmhp6ve4gxemfanxv" xml:space="preserve">{{Navbox
| name      = The Legend of Zelda
| title     = ''[[The Legend of Zelda]]''
| bodyclass = hlist
| state     = {{{state|autocollapse}}}
| group1    = Main series
| list1     = {{Navbox|subgroup

| group1    = 2D
| list1     =
* ''[[The Legend of Zelda (video game)|The Legend of Zelda]]''
* ''[[Zelda II: The Adventure of Link|The Adventure of Link]]''
* ''[[The Legend of Zelda: A Link to the Past|A Link to the Past]]''
* ''[[The Legend of Zelda: Link's Awakening|Link's Awakening]]''
** ''[[The Legend of Zelda: Link's Awakening DX|DX]]''
** [[The Legend of Zelda: Link's Awakening (2019 video game)|2019]]
* [[The Legend of Zelda: Oracle of Seasons and Oracle of Ages|''Oracle of Seasons'' and ''Oracle of Ages'']]
* ''[[The Legend of Zelda: A Link to the Past and Four Swords|Four Swords]]''
* ''[[The Legend of Zelda: Four Swords Adventures|Four Swords Adventures]]''
* ''[[The Legend of Zelda: The Minish Cap|The Minish Cap]]''
* ''[[The Legend of Zelda: Phantom Hourglass|Phantom Hourglass]]''
* ''[[The Legend of Zelda: Spirit Tracks|Spirit Tracks]]''
* ''[[The Legend of Zelda: A Link Between Worlds|A Link Between Worlds]]''
* ''[[The Legend of Zelda: Tri Force Heroes|Tri Force Heroes]]''
* ''[[The Legend of Zelda: Echoes of Wisdom|Echoes of Wisdom]]''
| group2    = 3D
| list2     =
* ''[[The Legend of Zelda: Ocarina of Time|Ocarina of Time]]''
** ''[[The Legend of Zelda: Ocarina of Time 3D|3D]]''
* ''[[The Legend of Zelda: Majora's Mask|Majora's Mask]]''
** ''[[The Legend of Zelda: Majora's Mask 3D|3D]]''
* ''[[The Legend of Zelda: The Wind Waker|The Wind Waker]]''
* ''[[The Legend of Zelda: Twilight Princess|Twilight Princess]]''
* ''[[The Legend of Zelda: Skyward Sword|Skyward Sword]]''
* ''[[The Legend of Zelda: Breath of the Wild|Breath of the Wild]]''
* ''[[The Legend of Zelda: Tears of the Kingdom|Tears of the Kingdom]]''

}}

| group3    = Spin-offs
| list3     = {{Navbox|subgroup
 | group1   = [[The Legend of Zelda CD-i games|CD-i games]]
 | list1    =
* [[Link: The Faces of Evil and Zelda: The Wand of Gamelon|''Link: The Faces of Evil'' and ''Zelda: The Wand of Gamelon'']]
* ''[[Zelda's Adventure]]''
 | group2   = ''Tingle''
 | list2    =
* ''[[Freshly-Picked Tingle's Rosy Rupeeland]]''
* ''[[Ripened Tingle's Balloon Trip of Love|Irozuki Tingle no Koi no Balloon Trip]]''
 | group3   = ''Hyrule Warriors''
 | list3    =
* ''[[Hyrule Warriors]]''
* ''[[Hyrule Warriors: Age of Calamity|Age of Calamity]]''
* ''[[Hyrule Warriors: Age of Imprisonment|Age of Imprisonment]]''
 | group4   = Others
 | list4    =
* [[The Legend of Zelda LCD games|LCD games]]
* [[Satellaview games from The Legend of Zelda series|Satellaview games]]
* ''[[Link's Crossbow Training]]''
* ''[[My Nintendo Picross: The Legend of Zelda: Twilight Princess|My Nintendo Picross: Twilight Princess]]''
* ''[[Cadence of Hyrule]]''
* ''[[Heroes of Hyrule]]'' (rejected pitch)
}}

| group4    = [[Universe of The Legend of Zelda|Universe]]
| list4     = {{Navbox|subgroup
 | group1   = [[List of The Legend of Zelda characters|Characters]]
 | list1    =
* [[Link (The Legend of Zelda)|Link]]
* [[Princess Zelda]]
* [[Ganon|Ganon / Ganondorf]]
* [[Characters of The Legend of Zelda: Ocarina of Time|''Ocarina of Time'' characters]]
** [[Navi (The Legend of Zelda)|Navi]]
* [[Tingle (The Legend of Zelda)|Tingle]]
* [[Anju and Kafei]]
* [[Midna]]
* [[Linkle]]
* [[Urbosa]]
* [[Sidon (The Legend of Zelda)|Sidon]]
* [[Purah]]
 | group2   = Elements
 | list2    =
* [[Triforce]]
* [[Master Sword]]
* [[Gerudo]]
* [[Water Temple (Ocarina of Time)|Water Temple]]
 | group3   = Quotes
 | list3    =
* "[[It's dangerous to go alone!]]"
* "[[I am Error]]"
}}
| group5    = [[List of The Legend of Zelda media|Other media]]
| list5     =
* [[The Legend of Zelda (TV series)|Cartoon]] ([[List of Mario television episodes#The Legend of Zelda|episodes]])
* [[List of The Legend of Zelda manga|Manga]]
** [[The Legend of Zelda: Twilight Princess (manga)|''Twilight Princess'']]
* [[Nintendo gamebooks|Gamebooks]]
* [[The Legend of Zelda: Symphony of the Goddesses|Symphony of the Goddesses]]
 {{Navbox|subgroup
 | group1   = Books
 | list1    =
* ''Goddess Trilogy''
** ''[[The Legend of Zelda: Hyrule Historia|Hyrule Historia]]''
** ''[[The Legend of Zelda: Art &amp; Artifacts|Art &amp; Artifacts]]''
** ''[[The Legend of Zelda Encyclopedia|Encyclopedia]]''
* ''[[The Legend of Zelda: Breath of the Wild – Creating a Champion|Creating a Champion]]''
}}
| group6    = People
| list6     =
* [[Eiji Aonuma]]
* [[Hidemaro Fujibayashi]]
* [[Yoshiaki Koizumi]]
* [[Koji Kondo]]
* [[Yōichi Kotabe]]
* [[Toru Minegishi]]
* [[Shigeru Miyamoto]]
* [[Tadashi Sugiyama]]
* [[Kensuke Tanabe]]
* [[Takashi Tezuka]]
* [[Yasuhisa Yamamura]]

| group7    = Companies
| list7     =
* [[Nintendo]]
**[[Nintendo Entertainment Analysis &amp; Development|Nintendo EAD]]
**[[Nintendo Entertainment Planning &amp; Development|Nintendo EPD]]
* [[Animation Magic]]
* [[Capcom]]
** [[Flagship (company)|Flagship]]
* [[DIC Entertainment]]
* [[Grezzo]]
* [[Koei Tecmo]]
** [[Omega Force]]
** [[Team Ninja]]
* [[Tantalus Media]]
* [[Vanpool (company)|Vanpool]]

| group8    = Fan works
| list8     =
* ''[[The Legend of Neil]]''
* ''[[Ben Drowned]]''
* ''[[Ship of Harkinian]]''
* ''[[Legend Maker]]''
* [[Zeldathon]]

| group9    = Related
| list9     =
* ''[[Super Smash Bros.]]''
* ''[[Soulcalibur II]]''
* ''[[Tetris DS]]''
* ''[[Nintendo Land]]''
* ''[[NES Remix]]''
* ''[[Sonic Lost World]]''
* ''[[Mario Kart 8]]''
* ''[[Super Mario Maker 2]]''
* ''[[Nintendo World Championships: NES Edition]]''

| below     =
* {{Icon|Category}} [[:Category:The Legend of Zelda|'''Category''']]

}}&lt;noinclude&gt;
{{navbox documentation}}{{DEFAULTSORT:Legend of Zelda, The}}
[[Category:Nintendo game series navigational boxes]]
[[Category:Video game navigational boxes by series]]&lt;/noinclude&gt;</text>
      <sha1>dhq00obn7794t3dmhp6ve4gxemfanxv</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Apostrophe</title>
    <ns>10</ns>
    <id>215</id>
    <revision>
      <id>418</id>
      <parentid>417</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>417</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="177" sha1="ey7sacklsawhwpz5k5ytshi6df53r90" xml:space="preserve">&lt;span class="nowrap" style="padding-left:0.1em;"&gt;&amp;#39;&lt;/span&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>ey7sacklsawhwpz5k5ytshi6df53r90</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Side box/styles.css</title>
    <ns>828</ns>
    <id>216</id>
    <revision>
      <id>420</id>
      <parentid>419</parentid>
      <timestamp>2025-07-09T04:31:42Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>419</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1177" sha1="a8iddu42qgjj6mffnouwiq1k3qb6388" xml:space="preserve">/* {{pp|small=y}} */
.side-box {
	margin: 4px 0;
	box-sizing: border-box;
	border: 1px solid #aaa;
	font-size: 88%;
	line-height: 1.25em;
	background-color: var(--background-color-interactive-subtle, #f8f9fa);
    display: flow-root;
}
/* embedded side boxes need larger font */
.infobox .side-box {
	font-size: 100%;
}

.side-box-abovebelow,
.side-box-text {
	padding: 0.25em 0.9em;
}

.side-box-image {
	/* @noflip */
	padding: 2px 0 2px 0.9em;
	text-align: center;
}

.side-box-imageright {
	/* @noflip */
	padding: 2px 0.9em 2px 0;
	text-align: center;
}

/* roughly the skin's sidebar + size of side box */
@media (min-width: 500px) {
	.side-box-flex {
		display: flex;
		align-items: center;
	}
	
	.side-box-text {
		flex: 1;
		min-width: 0;
	}
}

@media (min-width: 720px) {
	.side-box {
		width: 238px;
	}
	
	.side-box-right {
		/* @noflip */
		clear: right;
		/* @noflip */
		float: right;
		/* @noflip */
		margin-left: 1em;
	}
	
	/* derives from mbox classes, which do not float left in mbox-small-left
	 * so far as I can tell, that was a deliberate decision, since only .ambox
	 * supports mbox-left
	 */
	.side-box-left {
		/* @noflip */
		margin-right: 1em;
	}
}</text>
      <sha1>a8iddu42qgjj6mffnouwiq1k3qb6388</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Zelda</title>
    <ns>10</ns>
    <id>217</id>
    <redirect title="Template:The Legend of Zelda" />
    <revision>
      <id>422</id>
      <parentid>421</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>421</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="42" sha1="7o7t7ckuu807g27t7urauu01wrs5te8" xml:space="preserve">#REDIRECT [[Template:The Legend of Zelda]]</text>
      <sha1>7o7t7ckuu807g27t7urauu01wrs5te8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Infobox video game/styles.css</title>
    <ns>10</ns>
    <id>218</id>
    <revision>
      <id>424</id>
      <parentid>423</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>423</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="273" sha1="2e8amrx751b9rsi16b9v7n7zci1zxpi" xml:space="preserve">/* {{pp-template|small=yes}} */
.ib-video-game .infobox-label {
	white-space: nowrap;
	/* to ensure gap between any long/nonwrapped label and subsequent data on same line */
	padding-right: 0.65em; 
}

.ib-video-game .infobox-above {
	font-style: italic; font-size: 125%;
}</text>
      <sha1>2e8amrx751b9rsi16b9v7n7zci1zxpi</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Authority control/config</title>
    <ns>828</ns>
    <id>219</id>
    <revision>
      <id>426</id>
      <parentid>425</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>425</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="35925" sha1="6se1e5aecfh61ob7ladi11u4lncsryu" xml:space="preserve">require('strict')
local p = {}
p.auxiliary = 'Module:Authority control/auxiliary'
p.i18n = {
	aclink = '[[Help:Authority control|Authority control databases]]',
	ACmodule = 'Module:Authority control',
	attentioncat = 'Pages with authority control identifiers needing attention',
	All_articles = 'All articles',
	allfaultycat = 'Articles with faulty authority control information',
	Appears_as = 'Appears as', -- used on documentation table to show example
	Articles = 'Articles',
	autocollapse = 'autocollapse', -- Navbox state parameter
	cat = 'Articles with %s identifiers',
	category = 'Category',
	Code = 'Code',
	collapsed = 'collapsed', -- Navbox state parameter
	Description = 'Description',
	errortemplate = 'Error', -- e.g. [[Template:Error]],
	expanded = 'expanded', -- Navbox state parameter
	faultcat = 'Articles with faulty authority control information',
	Faults = 'Faults',
	faulty = 'faulty',
	identifier = 'identifier',
	identifiers = 'identifiers',
	idnotvalid = 'The %s identifier %s is not valid.',
	linktemplate = 'Wikidata property link', -- refers to [[Template:Wikidata property link]]
	maincat = 'Articles with authority control information',
	name = 'Authority control',
	navbox = 'Module:Navbox',
	pages = 'pages',
	pageswithparams = 'Pages using authority control with unknown parameters', -- name of category for tracking uses with parameters
	previewwarning = 'page using [[Template:Authority control]] with unexpected local parameter "_VALUE_". All identifiers should be stored on Wikidata.', -- preview message when local parameters are used
	sandbox = 'sandbox',
	Section = 'Section',
	suppressedcat = 'Articles with suppressed authority control identifiers',
	testcases = 'testcases',
	Topic = 'Topic',
	Totals = 'Totals',
	Tracking_category = 'Tracking category',
	warningicon = '345-409 Ambox warning centered.svg', -- icon used for faulty ids
	WDproperty = 'Wikidata property',
}
p.config = {{
	property = 213,
	section = 1,
	label = 'ISNI',
	valid = 'validateIsni',
	link = 'https://isni.org/isni/$1',
	remark = 'ISNI is a method for uniquely identifying the public identities of contributors to media content such as books, TV programmes, and newspaper articles. Please take care not to confuse ISNI and ORCID identifiers.'
}, {
	property = 214,
	section = 1,
	label = 'VIAF',
	patterns = {'[1-9]%d%d?%d?%d?%d?%d?%d?%d?', '[1-9]%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d?%d?%d?'},
	link = 'https://viaf.org/viaf/$1',
	remark = 'International authority data from the Online Computer Library Center (OCLC)'
}, {
	property = 227,
	section = 2,
	patterns = {'1[0123]?%d%d%d%d%d%d%d[0-9X]', '[47]%d%d%d%d%d%d%-%d', '[1-9]%d?%d?%d?%d?%d?%d?%d?%-[0-9X]', '3%d%d%d%d%d%d%d[0-9X]'},
	link = 'https://d-nb.info/gnd/$1',
	label = 'Germany',
	remark = 'Authority data on people, corporations and subjects from the [[German National Library]] (DNB)'
}, {
	property = 244,
	section = 2,
	pattern = '%l%l?%d%d%d%d%d%d%d%d%d?%d?',
	link = 'https://id.loc.gov/authorities/$1',
	label = 'United States',
	remark = 'See [[Wikipedia:Authority control#LCCN]] for formatting instructions'
}, {
	property = 245,
	section = 5,
	pattern = '500%d%d%d%d%d%d',
	link = 'https://www.getty.edu/vow/ULANFullDisplay?find=&amp;role=&amp;nation=&amp;subjectid=$1',
	label = 'ULAN',
	remark = 'ULAN is an online database using a controlled vocabulary currently containing around 293,000 names and other information about artists. Names in ULAN may include given names, pseudonyms, variant spellings, names in multiple languages, and names that have changed over time (e.g., married names).'
}, {
	property = 268,
	section = 2,
	valid = 'validateBNF',
	link = 'https://catalogue.bnf.fr/ark:/12148/cb$1',
	label = 'France',
	remark = 'Authority data of people listed in the general catalogue of the National Library of France'
}, {
	property = 268,
	section = 2,
	valid = 'validateBNF',
	link = 'https://data.bnf.fr/ark:/12148/cb$1',
	label = 'BnF data'
}, {
	property = 269,
	section = 7,
	label = 'IdRef',
	pattern = '%d%d%d%d%d%d%d%d[%dxX]',
	link = 'https://www.idref.fr/$1',
	remark = 'Authority data of people listed in the general catalogue of the University Documentation System of France. Also available from [http://www.sudoc.abes.fr/xslt//DB=2.1/SET=2/TTL=1/LNG=EN/ English-speaking catalog] (search author, click one book, click author name, take PPN= value of the URL)'
}, {
	property = 271,
	section = 4,
	pattern = 'D[AB]%d%d%d%d%d%d%d[%dX]',
	link = 'https://ci.nii.ac.jp/author/$1?l=en',
	label = 'CiNii',
	remark = 'CiNii is a bibliographic database service for material in Japanese academic libraries. It is maintained by the [[National Institute of Informatics]].'
}, {
	property = 347,
	section = 7,
	pattern = ''..string.rep('[%-0-9A-Za-z]', 11)..'',
	link = 'https://www.pop.culture.gouv.fr/notice/joconde/$1',
	label = 'Joconde',
}, {
	property = 349,
	section = 2,
	link = 'https://id.ndl.go.jp/auth/ndlna/$1',
	patterns = {'a1%d?%d%d%d%d%d%d%d%d', 's?%d?%d%d%d%d%d%d%d%d'},
	label = 'Japan',
	remark = 'Authority data listed in the catalog of the national library of Japan. Search also available via [http://viaf.org/ VIAF].'
}, {
	property = 350,
	section = 7,
	pattern = '[1-9]%d?%d?%d?%d?%d?',
	link = 'https://rkd.nl/nl/explore/images/$1',
	label = 'RKD ID',
}, {
	property = 380,
	section = 3,
	link = 'https://www.pop.culture.gouv.fr/notice/merimee/$1',
	label = 'Mérimée',
	patterns = {'[PEI]A%d[0-9AB]%d%d%d%d%d%d','ACR%d%d%d%d%d%d%d', 'MI%d%d%dB?', 'JAR%d%d%d%d%d%d%d', 'SPR%d%d%d%d%d%d%d'}
}, {
	property = 396,
	section = 2,
	pattern = '%u%u[%u0-3]V%d%d%d%d%d%d',
	link = 'https://opac.sbn.it/nome/$1',
	label = 'Italy',
	remark = 'Central Institute for the Union Catalogue (ICCU: {{lang|it|Istituto Centrale per il Catalogo Unico}}) is an Italian government agency created to build a single catalog of all the libraries in the nation. It manages National Library Service ({{lang|it|Servizio bibliotecario nazionale}}).'
}, {
	property = 409,
	section = 2,
	pattern = '[1-9]%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?',
	link = 'https://nla.gov.au/anbd.aut-an$1',
	label = 'Australia',
	remark = "NLA Trove's People and Organisation view allows the discovery of biographical and other contextual information about people and organisations. Search also available via [http://viaf.org/ VIAF]."
}, {
	property = 428,
	section = 4,
	valid = 'botanistV',
	link = 'https://www.ipni.org/ipni/advAuthorSearch.do?find_abbreviation=$1',
	label = 'International Plant Names Index',
	remark = 'Author citation (botany): standard form (official abbreviation) of a personal name for use in an author citation (only for names of algae, fungi and plants). Links to page at [[International Plant Names Index]] (IPNI).'
}, {
	property = 434,
	section = 5,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	link = 'https://musicbrainz.org/artist/$1',
	label = 'MusicBrainz',
	remark = 'MusicBrainz is an open music encyclopedia that collects music metadata and makes it available to the public.'
}, {
	property = 435,
	section = 7,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	link = 'https://musicbrainz.org/work/$1',
	label = 'MusicBrainz work',
}, {
	property = 436,
	section = 7,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	link = 'https://musicbrainz.org/release-group/$1',
	label = 'MusicBrainz release group',
}, {
	property = 454,
	section = 3,
	pattern = '[12]0%d%d%d%d%d%d',
	label = 'Structurae',
	link = 'https://structurae.net/structures/$1',
}, {
	property = 496,
	section = 4,
	label = 'ORCID',
	valid = 'orcidV',
	link = 'https://orcid.org/$1',
	remark = 'Authority data on researchers, academics, etc. The ID range is a subset of the [[ISNI]] range. For free text links (for example when mentioning a person on page which is not about them), it is also possible to use {{tl|ORCID}}. Authors—including Wikipedia editors—may obtain an ORCID by signing up at [https://orcid.org/register orcid.org/register]. Please take care not to confuse ORCID and ISNI identifiers.'
}, {
	property = 549,
	section = 4,
	pattern = '%d%d?%d?%d?%d?%d?',
	link = 'https://www.mathgenealogy.org/id.php?id=$1',
	label = 'Mathematics Genealogy Project',
	remark = 'Mathematics Genealogy Project is a web-based database for the academic genealogy of mathematicians.'
}, {
	property = 650,
	section = 5,
	pattern = '[1-9]%d?%d?%d?%d?%d?',
	link = 'https://rkd.nl/en/explore/artists/$1',
	label = 'RKD Artists',
	remark = 'RKDartists is an online database using a controlled vocabulary currently containing around 200,000+ names and other information about artists. Names in RKDartists may include given names, pseudonyms, variant spellings, names in multiple languages, and names that have changed over time (e.g., married names).'
}, {
	property = 651,
	section = 6,
	patterns = {'%d%d%d%d%d%d%d%d', '0?%d%d%d%d%d%d%d', '0?0?%d%d%d%d%d%d'},
	link = 'http://www.biografischportaal.nl/en/persoon/$1',
	label = 'Netherlands',
	remark = 'Dutch project with material for 40,000 digitized biographies, including former colonies of the Netherlands.'
}, {
	property = 691,
	section = 2,
	pattern = '[a-z][a-z][a-z]?[a-z]?%d%d%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?',
	link = 'https://aleph.nkp.cz/F/?func=find-c&amp;local_base=aut&amp;ccl_term=ica=$1&amp;CON_LNG=ENG',
	label = 'Czech Republic',
	remark = 'National Library of the Czech Republic ({{lang|cs|Národní knihovna České republiky}}) is the central library of the Czech Republic.'
}, {
	property = 716,
	section = 7,
	patterns = { '[1-3]%d%d%d%d%d%d%d?', '54%d%d%d%d%d%d' },
	link = 'https://ssd.jpl.nasa.gov/sbdb.cgi?sstr=$1',
	label = 'JPL SBDB',
}, {
	property = 781,
	section = 5,
	pattern = '%d%d%d%d%d%d%d%d?%d?',
	link = 'http://www.sikart.ch/KuenstlerInnen.aspx?id=$1&amp;lng=en',
	label = 'SIKART',
	remark = 'SIKART is a biographical dictionary and a database on visual art in Switzerland and Liechtenstein. It is published online by the Swiss Institute for Art Research (SIAR).'
}, {
	property = 791,
	section = 6,
	customlink = 'ISILlink',
	remark = 'Libraries, museums and archives, decentralized national databases.'
}, {
	property = 864,
	section = 4,
	pattern = '%d%d%d%d%d%d%d%d%d%d%d',
	link = 'https://dl.acm.org/profile/$1',
	label = 'Association for Computing Machinery',
}, {
	property = 865,
	section = 6,
	link = 'https://bmlo.de/$1',
	label = 'BMLO',
	pattern = '[a-z][0-9][0-9][0-9][0-9]'
}, {
	property = 886,
	section = 7,
	pattern = '%d+',
	link = 'http://www.e-lir.ch/e-LIR___Lexicon.$1.450.0.html',
	label = 'Lexicon Istoric Retic',
	remark = '{{lang|rm|Lexicon Istoric Retic}} (LIR) is a two volume version with a selection of articles published in Romansh.'
}, {
	property = 902,
	section = 7,
	pattern = '%d%d%d%d%d%d',
	label = 'Historical Dictionary of Switzerland',
	link = 'https://hls-dhs-dss.ch/fr/articles/$1',
	remark = 'Historical Dictionary of Switzerland is an encyclopedia on the history of Switzerland.'
}, {
	property = 947,
	section = 2,
	pattern = '%d%d?%d?%d?%d?%d?%d?%d?%d?',
	link = 'http://aleph.rsl.ru/F?func=find-b&amp;find_code=SYS&amp;adjacent=Y&amp;local_base=RSL11&amp;request=$1&amp;CON_LNG=ENG',
	label = 'Russia',
	remark = 'Russian State Library ({{lang|ru|Российская государственная библиотека}}) is the national library of Russia.'
}, {
	property = 950,
	section = 2,
	patterns = {'[XF][XF]%d%d%d%d%d?%d?%d?', 'a%d%d%d%d%d?%d?%d?', 'bi[mcsv][aoei]%d%d%d%d%d%d%d%d%d%d', 'Mi[sm][eoa]%d%d%d%d%d%d%d%d%d%d'},
	link = 'https://datos.bne.es/resource/$1',
	label = 'Spain',
	remark = "National Library of Spain (BNE: ''Biblioteca Nacional de España'') is a major public library, the largest in Spain."
}, {
	property = 966,
	section = 7,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	label = 'MusicBrainz label',
	link = 'https://musicbrainz.org/label/$1',
}, {
	property = 982,
	section = 3,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	link = 'https://musicbrainz.org/area/$1',
	label = 'MusicBrainz area',
}, {
	property = 1003,
	section = 2,
	pattern = '%d%d%d%d%d%d%d%d%d',
	link = 'http://aleph.bibnat.ro:8991/F/?func=direct&amp;local_base=NLR10&amp;doc_number=$1',
	label = 'Romania',
}, {
	property = 1004,
	section = 3,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	link = 'https://musicbrainz.org/place/$1',
	label = 'MusicBrainz place',
}, {
	property = 1005,
	section = 2,
	pattern = '[1-9]%d*',
	link = 'http://id.bnportugal.gov.pt/aut/catbnp/$1',
	label = 'Portugal',
}, {
	property = 1006,
	section = 2,
	pattern = '%d%d%d%d%d%d%d%d[%dX]',
	link = 'http://data.bibliotheken.nl/id/thes/p$1',
	label = 'Netherlands',
}, {
	property = 1015,
	section = 2,
	patterns = {'[1-9]%d?%d?%d?%d?%d?%d?%d?%d?', '[1-9]%d%d%d%d%d%d%d%d%d%d%d%d'},
	link = 'https://authority.bibsys.no/authority/rest/authorities/html/$1',
	label = 'Norway',
	remark = 'BIBSYS is a supplier of library and information systems for all Norwegian university Libraries, the National Library of Norway, college libraries, and a number of research libraries and institutions.'
}, {
	property = 1045,
	section = 6,
	link = 'https://www2.assemblee-nationale.fr/sycomore/fiche/(num_dept)/$1',
	label = 'Sycomore',
	pattern = '[1-9]%d?%d?%d?%d?'
}, {
	property = 1048,
	section = 2,
	pattern = '%d+',
	link = 'http://aleweb.ncl.edu.tw/F/?func=accref&amp;acc_sequence=$1&amp;CON_LNG=ENG',
	label = 'Taiwan',
	remark = 'National Central Library is the national library of Taiwan, Republic of China.'
}, {
	property = 1053,
	section = 4,
	patterns = {'[A-Z][A-Z]?[A-Z]?%-%d%d%d%d%-19%d%d', '[A-Z][A-Z]?[A-Z]?%-%d%d%d%d%-20%d%d'},
	link = 'https://www.researcherid.com/rid/$1',
	label = 'ResearcherID',
	remark = 'An identifying system for scientific authors. The system was introduced in January 2008 by [[Thomson Reuters]]. The combined use of the [[digital object identifier]] with the ResearcherID allows for a unique association of authors and scientific articles.'
}, {
	property = 1146,
	section = 6,
	pattern = '%d+',
	link = 'https://www.iaaf.org/athletes/_/$1',
	label = 'World Athletics',
	remark = 'The IAAF athlete database lists information about [[sport of athletics]] competitors.'
}, {
	property = 1153,
	section = 4,
	pattern = '[1-9]%d%d%d%d%d%d%d%d%d%d?',
	link = 'https://www.scopus.com/authid/detail.uri?authorId=$1',
	label = 'Scopus',
	remark = 'SciVerse Scopus is a bibliographic database containing abstracts and citations for academic journal articles. It covers nearly 19,500 titles from over 5,000 international publishers, of which 16,500 are peer-reviewed journals in the scientific, technical, medical, and social sciences (including arts and humanities).'
}, {
	property = 1157,
	section = 6,
	pattern = '[A-Z]00[01]%d%d%d',
	link = 'http://bioguide.congress.gov/scripts/biodisplay.pl?index=$1',
	label = 'US Congress',
	remark = 'Biographical Directory of the United States Congress is a biographical dictionary of all present and former members of the United States Congress and its predecessor, the Continental Congress. Also included are Delegates from territories and the District of Columbia and Resident Commissioners from the Philippines and Puerto Rico.'
}, {
	property = 1186,
	section = 6,
	label = 'MEP directory', 
	link = 'https://www.europarl.europa.eu/meps/en/$1',
    pattern = '[1-9]%d?%d?%d?%d?%d?',
}, {
	property = 1225,
	section = 7,
	pattern = '[1-9]%d?%d?%d?%d?%d?%d?%d?%d?',
	link = 'https://catalog.archives.gov/id/$1',
	label = 'NARA',
	remark = 'National Archives and Records Administration (NARA) is an independent agency of the United States government charged with preserving and documenting government and historical records.'
}, {
	property = 1248,
	section = 5,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	link = 'http://kulturnav.org/$1',
	label = 'KulturNav',
	remark = 'KulturNav is a Norwegian cloud-based software service, allowing users to create, manage and distribute name authorities and terminology, focusing on the needs of museums and other cultural heritage institutions. The software is developed by KulturIT ANS and the development project is funded by the [[Arts Council Norway]].'
}, {
	property = 1315,
	section = 6,
	label = 'Trove',
	pattern = '[1-9]%d%d%d%d%d%d?%d?',
	link = 'https://trove.nla.gov.au/people/$1',
}, {
	property = 1323,
	section = 7,
	pattern = 'A%d%d%.%d%.%d%d%.%d%d%d[FM]?',
	link = 'http://tools.wmflabs.org/wikidata-externalid-url/?p=1323&amp;url_prefix=https:%2F%2Fwww.unifr.ch%2Fifaa%2FPublic%2FEntryPage%2FTA98%20Tree%2FEntity%20TA98%20EN%2F&amp;url_suffix=%20Entity%20TA98%20EN.htm&amp;id=$1',
	label = 'Terminologia Anatomica',
}, {
	property = 1330,
	section = 7,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	link = 'https://musicbrainz.org/instrument/$1',
	label = 'MusicBrainz instrument',
}, {
	property = 1362,
	section = 7,
	valid = 'tlsV',
	link = 'http://tls.theaterwissenschaft.ch/wiki/$1',
	label = 'Theaterlexikon',
	remark = '{{lang|de|Theaterlexikon der Schweiz}} (TLS) is an encyclopedia about theatre in Switzerland. It was developed by the Institute of Theatre Studies of the [[University of Berne]].'
}, {
	property = 1368,
	section = 2,
	pattern = '%d%d%d%d%d%d%d%d%d',
	link = 'https://kopkatalogs.lv/F?func=direct&amp;local_base=lnc10&amp;doc_number=$1&amp;P_CON_LNG=ENG',
	label = 'Latvia',
}, {
	property = 1375,
	section = 2,
	pattern = '%d%d%d%d%d%d%d%d%d',
	link = 'http://katalog.nsk.hr/F/?func=direct&amp;doc_number=$1&amp;local_base=nsk10',
	label = 'Croatia',
}, {
	property = 1407,
	section = 7,
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
	link = 'https://musicbrainz.org/series/$1',
	label = 'MusicBrainz series',
}, {
	property = 1556,
	section = 4,
	patterns = {'%l[%l%-]*','%l[%l%-]*%.%l[%l%-]*','%l[%l%-]*.%d*','%l[%l%-]*%.%l[%l%-]*%.%d*'},
	link = 'https://zbmath.org/authors/?q=ai:$1',
	label = 'zbMATH',
}, {
	property = 1584,
	section = 3,
	label = 'Pleiades',
	link = 'https://pleiades.stoa.org/places/$1',
	pattern = '[1-9]%d*',
	remark = "Pleiades is a joint project of the Institute for the Study of the Ancient World at [[New York University]] and the Ancient World Mapping Center at the [[University of North Carolina]] at Chapel Hill."
}, {
	property = 1707,
	section = 5,
	pattern = '[a-z%-]+%d*',
	link = 'https://www.daao.org.au/bio/$1',
	label = 'Australian Artists',
}, {
	property = 1736,
	section = 5,
	pattern = '%d+',
	link = 'https://www.imj.org.il/artcenter/newsite/en/?artist=$1',
	label = 'ICIA (Israel)',
}, {
	property = 1886,
	section = 3,
	link = 'https://volcano.si.edu/volcano.cfm?vn=$1',
	label = 'Global Volcanism Program',
	pattern = '%d%d%d%d%d%d'
}, {
	property = 1890,
	section = 2,
	pattern = '%d%d%d%d%d%d%d%d%d',
	link = 'http://www.bncatalogo.cl/F?func=direct&amp;local_base=red10&amp;doc_number=$1',
	label = 'Chile',
}, {
	property = 1907,
	section = 6,
	patterns = {'[a-z][-a-z]+-[1-3]%d%d?%d?%d?', '[a-z][-a-z]+-[1-9]%d?%d?%d?'},
	link = 'http://adb.anu.edu.au/biography/$1',
	label = 'Australia',
}, {
	property = 1908,
	section = 6,
	pattern = '[1-9]%d*',
	link = 'https://www.cwgc.org/find-war-dead/casualty/$1/',
	label = 'Commonwealth War Graves Commission',
}, {
	property = 1960,
	section = 4,
	pattern = '[%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u]',
	link = 'https://scholar.google.com/citations?user=$1',
	label = 'Google Scholar',
}, {
	property = 1986,
	section = 6,
	link = 'https://www.treccani.it/enciclopedia/$1_(Dizionario-Biografico)',
	label = 'Italian People',
}, {
	property = 2041,
	section = 5,
	pattern = '%d+',
	link = 'https://www.ngv.vic.gov.au/explore/collection/artist/$1/',
	label = 'Victoria',
}, {
	property = 2163, 
	section = 1,
	pattern = '[1-9]%d?%d?%d?%d?%d?%d?%d?',
	link = 'https://id.worldcat.org/fast/$1',
	label = 'FAST',
}, {
	property = 2174,
	section = 5,
	link = 'https://www.moma.org/artists/$1',
	label = 'Museum of Modern Art',
	pattern = '%d+'
}, {
	property = 2268,
	section = 5,
	link = 'https://www.musee-orsay.fr/en/ressources/repertoire-artistes-personnalites/$1',
	label = 'Musée d\'Orsay',
	pattern = '[1-9]%d?%d?%d?%d?%d?'
}, {
	property = 2349,
	section = 5,
	pattern = '[1-9]%d*',
	link = 'http://www.uni-stuttgart.de/hi/gnt/dsi2/index.php?table_name=dsi&amp;function=details&amp;where_field=id&amp;where_value=$1',
	label = 'Scientific illustrators',
}, {
	property = 2418,
	section = 6,
	pattern = '10%d%d%d%d%d',
	label = 'Structurae',
	link = 'https://structurae.net/persons/$1',
}, {
	property = 2456,
	section = 4,
	patterns = {'%d%d%d?%/%d+-?[%d]*[%a]*-?[%d]*', '[%a]+%/[%w]*-?[%d]*'},
	link = 'https://dblp.org/pid/$1',
	label = 'DBLP',
}, {
	property = 2484,
	section = 3,
	link = 'https://nces.ed.gov/ccd/schoolsearch/school_detail.asp?ID=$1',
	label = 'NCES',
	pattern = '%d+'
}, {
	property = 2558,
	section = 6,
	pattern = '[1-9]%d?%d?%d?%d?',
	link = 'https://autores.uy/autor/$1',
	label = 'Uruguay',
	remark = "autores.uy is an author's database, that focus on [[Uruguay]]an authors. It was created and maintained by the Uruguayan chapter of Creative Commons. It also provides access to digitized works of the authors in public domain."
}, {
	property = 2750,
	section = 5,
	pattern = '[1-9]%d*',
	link = 'https://pic.nypl.org/constituents/$1',
	label = 'Photographers\' Identities',
	remark = "PIC is a photographer's database. It is maintained by the New York Public Library."
}, {
	property = 2980,
	section = 3,
	pattern = '[A-Z][A-Z][A-Z]%d%d%d%d?[A-Z]?',
	link = 'http://wlol.arlhs.com/lighthouse/$1.html',
	label = 'ARLHS',
}, {
	property = 3223, 
	section = 3,
	pattern = '[1-9]%d*',
	label = 'OLL',
	link = 'http://listoflights.org/leuchtfeuer/detail?id=$1.aspx'
}, {
	property = 3233,
	section = 4,
	link = 'https://philpeople.org/profiles/$1',
	label = 'PhilPeople',
	patterns = {'[a-z%-]+', '[a-z%-]+%-%d'}
}, {
	property = 3326,
	section = 3,
	link = 'https://www.worldwaterfalldatabase.com/index.php/waterfall/$1',
	label = 'World Waterfall',
	pattern = '%d+'
}, {
	property = 3348,
	section = 2,
	pattern = '[1-9]%d*',
	link = 'https://catalogue.nlg.gr/cgi-bin/koha/opac-authoritiesdetail.pl?authid=$1',
	label = 'Greece',
}, {
	property = 3372,
	section = 5,
	link = 'https://www.aucklandartgallery.com/explore-art-and-ideas/artist/$1/',
	label = 'Auckland',
	pattern = '%d+',
}, {
	property = 3407,
	section = 3,
	link = 'http://klosterdatenbank.germania-sacra.de/gsn/$1',
	label = 'Klosterdatenbank',
	pattern = '[1-9]%d?%d?%d?%d?'
}, {
	property = 3430,
	section = 7,
	pattern = '%d*[A-Za-z][0-9A-Za-z]*',
	link = 'https://snaccooperative.org/ark:/99166/$1',
	label = 'SNAC',
}, {
	property = 3544,
	section = 7,
	pattern = '%d+',
	link = 'https://collections.tepapa.govt.nz/agent/$1',
	label = 'Te Papa (New Zealand)'
}, {
	property = 3562,
	patterns = {'[A-Q]%d%d%d%d', '[A-Q]%d%d%d%d%.%d+'},
	section = 3,
	prefix = '[[Admiralty (identifier)|Admiralty]]'
}, {
	property = 3563,
	section = 3,
	pattern = '11[0-6]%-%d+%.?%d*',
	link = 'https://wikidata-externalid-url.toolforge.org/?url=https%3A%2F%2Fmsi.nga.mil%2FqueryResults%3Fpublications%2Fngalol%2Flights-buoys%3Fvolume%3D%251%26featureNumber%3D%252%26includeRemovals%3Dfalse%26output%3Dhtml&amp;exp=(%5Cd%7B3%7D)-(.*)&amp;id=$1',
	label = 'NGA',
}, {
	property = 3601,
	section = 3,
	pattern = '%d%d%d%d%d%d%d%d%d%d',
	link = 'https://www.marinetraffic.com/en/ais/details/lights/$1',
	label = 'MarineTraffic',
}, {
	property = 3723,
	section = 3,
	prefix = '[[USCG (identifier)|USCG]]',
	customlink = 'uscgLink'
}, {
	property = 3788,
	section = 2,
	pattern = '%d%d%d%d%d%d%d%d%d',
	link = 'https://catalogo.bn.gov.ar/F/?func=direct&amp;local_base=BNA10&amp;doc_number=$1',
	label = 'Argentina',
}, {
	property = 3829,
	section = 4,
	pattern = '%d+',
	link = 'https://publons.com/author/$1/',
	label = 'Publons'
}, {
	property = 3863,
	section = 3,
	pattern = '[1-9]%d*',
	link = 'http://www.marina.difesa.it/cosa-facciamo/per-la-difesa-sicurezza/fari/Pagine/$1.aspx',
	label = 'Italy',
}, {
	property = 3920,
	section = 3,
	customlink = 'ccg',
	remark = 'Identifier from one of 4 volumes of List of Lights, Buoys and Fog Signals issued by the Canadian Coast Guard.'
}, {
	property = 3993, 
	section = 3,
	pattern = '[1-9]%d*',
	prefix = 'Iceland'
}, {
	property = 4038, 
	section = 3,
	pattern = '[1-9]%d*[A-Za-z]?',
	prefix = 'Denmark',
}, {
	property = 4055, 
	section = 3,
	pattern = '%d+',
	prefix = 'Norway',
}, {
	property = 4114,
	section = 5,
	link = 'https://www.adk.de/de/akademie/mitglieder/?we_objectID=$1',
	label = 'ADK',
	patterns = {'4999[6-9]', '5[0-4]%d%d%d', '55[0-6]%d%d', '5570%d', '5571[0-8]', '6[0-7]%d%d%d'}
}, {
	property = 4143, 
	section = 3,
	pattern = '%d+',
	prefix = 'Finland',
}, {
	property = 4186,
	section = 6,
	patterns = {'[A-Z][A-Z][A-Z]%d%d%d%d[a-z]', '[A-Z][A-Z]%d%d%d%d%d[a-z]'},
	link = 'http://www.womenaustralia.info/biogs/$1.htm',
	label = 'Australian Women\'s Register',
}, {
	property = 4423, 
	section = 3,
	patterns = {'[1-9]%d*', '[1-9]%d*.%d+'},
	prefix = 'Portugal',
}, {
	property = 4457,
	section = 5,
	link = 'https://adp.library.ucsb.edu/names/$1',
	label = 'Discography of American Historical Recordings',
	pattern = '%d+'
}, {
	property = 4534,
	section = 6,
	label = 'EUTA',
	link = 'http://www.theatre-architecture.eu/db.html?personId=$1',
	pattern = '[1-9]%d?%d?%d?%d?%d?%d?'
}, {
	property = 4535,
	section = 3,
	label = 'EUTA theatre',
	link = 'http://www.theatre-architecture.eu/db/?theatreId=$1',
	pattern = '[1-9]%d*'
}, {
	property = 4581,
	section = 5,
	label = 'Städel',
	link = 'https://sammlung.staedelmuseum.de/en/person/$1',
	pattern = '%C+'
}, {
	property = 4613,
	section = 7,
	pattern = '%d%d?%d?%d?%d?%d?',
	link = 'http://esu.com.ua/search_articles.php?id=$1',
	label = 'Encyclopedia of Modern Ukraine',
}, {
	property = 4955,
	section = 4,
	pattern = '[1-9]%d%d%d%d%d?%d?',
	link = 'https://mathscinet.ams.org/mathscinet/MRAuthorID/$1',
	label = 'MathSciNet',
}, {
	property = 5034,
	section = 2,
	link = 'https://lod.nl.go.kr/resource/$1',
	label = 'Korea',
	patterns = {'%u%u%u%d%d%d%d%a?%d%d%d%d%d?%d?', 'CNTS%-%d%d%d%d%d%d%d%d%d%d%d'}
}, {
	property = 5226,
	section = 5,
	link = 'http://brahms.ircam.fr/$1',
	label = 'BRAHMS',
	pattern = '[a-z%-\\]+',
	remark = 'Identifier of an artist in the B.R.A.H.M.S. (Base Relationnelle d\'Articles Hypertextes sur la Musique du 20e Siècle database), by the IRCAM'
}, {
	property = 5288,
	section = 3,
	label = 'StadiumDB',
	link = 'http://stadiumdb.com/stadiums/$1',
	pattern = '%l%l%l/[_%w]+'
}, {
	property = 5302,
	section = 7,
	link = 'https://brahms.ircam.fr/works/work/$1/',
	label = 'BRAHMS',
	pattern = '[1-9]%d*',
	remark = "Identifier for a musical work in the B.R.A.H.M.S. (Base Relationnelle d\'Articles Hypertextes sur la Musique du 20e Siècle database) database, by the IRCAM"
}, {
	property = 5321,
	section = 5,
	link = 'https://www.museodelprado.es/en/the-collection/artist/wd/$1',
	label = 'Prado',
	pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x'
}, {
	property = 5368,
	section = 5,
	label = 'National Gallery of Canada',
	link = 'https://www.gallery.ca/collection/artist/$1',
	pattern = '%C+'
}, {
	property = 5504,
	section = 7,
	label = 'RISM',
	patterns = {'people/%d+', 'institutions/%d+', 'sources/%d+'},
	link = 'https://rism.online/$1',
}, {
	property = 5587,
	section = 2,
	pattern = '%w+',
	link = 'https://libris.kb.se/$1',
	label = 'Sweden'
}, {
	property = 906,
	section = 2,
	pattern = '[1-9]%d%d%d%d%d?',
	link = 'https://libris.kb.se/auth/$1',
	label = 'Sweden',
	remark = 'Authority data from the [[National Library of Sweden]]',
	suppressedbyproperty = {5587}
}, {
	property = 5736,
	section = 7,
	pattern = '[A-Z0-9][A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?[A-Z0-9/ ()-]?',
	link = 'https://www.minorplanetcenter.net/db_search/show_object?object_id=$1',
	label = 'MPC',
}, {
	property = 5818,
	section = 3,
	link = 'https://www.bgci.org/garden.php?id=$1',
	label = 'BGCI garden',
	pattern = '%d+'
}, {
	property = 6213,
	section = 6,
	pattern = '[a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d]',
	link = 'https://id.parliament.uk/$1',
	label = 'UK Parliament',
	remark = 'UK parliament member data'
}, {
	property = 6734,
	section = 6,
	pattern = '[1-9]%d*',
	link = 'https://archaeologydataservice.ac.uk/library/browse/personDetails.xhtml?personId=$1',
	label = 'Archaeology Data Service',
}, {
	property = 6792,
	section = 5,
	pattern = '[1-9]%d*',
	link = 'https://findnzartists.org.nz/artist/$1/',
	label = 'New Zealand Artists',
}, {
	property = 6804,
	section = 5,
	pattern = '[1-9]%d*',
	link = 'https://www.agsa.sa.gov.au/collection-publications/collection/creators/_/$1/',
	label = 'South Australia',
}, {
	property = 6829,
	section = 6,
	pattern = '0[01]%d%d%d%d%.?[A-D]?',
	link = 'https://doi.org/10.3318/dib.$1.v1',
	label = 'Ireland',
}, {
	property = 7293,
	section = 2,
	pattern = '981%d%d%d%d%d%d%d%d05606*',
	link = 'https://dbn.bn.org.pl/descriptor-details/$1',
	label = 'Poland',
}, {
	property = 1695,
	section = 2,
	pattern  = 'a%d%d%d%d%d%d%d%d%d%d%d%d%d',
	link = 'https://dbn.bn.org.pl/descriptor-details/$1',
	label = 'Poland',
	suppressedbyproperty = {7293}
}, {
	property = 7303,
	section = 5,
	pattern = '%w[%w-]+%/%d+',
	link = 'https://www.grammy.com/artists/$1',
	label = 'Grammy Awards',
}, {
	property = 7314,
	section = 7,
	pattern = '[%d%l/-]+',
	link = 'https://islamansiklopedisi.org.tr/$1',
	label = 'İslâm Ansiklopedisi',
}, {
	property = 7902,
	section = 6,
	pattern = '1[0-9]%d%d%d%d%d%d%d?[0-9X]',
	link = 'https://www.deutsche-biographie.de/$1.html?language=en',
	label = 'Deutsche Biographie',
}, {
	property = 8034,
	section = 2,
	pattern = '49[0-9]%/[1-9][0-9]?[0-9]?[0-9]?[0-9]?[0-9]?',
	link = 'https://wikidata-externalid-url.toolforge.org/?p=8034&amp;url_prefix=https://opac.vatlib.it/auth/detail/&amp;id=$1',
	label = 'Vatican',
	remark = 'Vatican Library document data'
}, {
	property = 8189,
	section = 2,
	pattern = '9870[0-1]%d%d%d%d%d%d%d%d05171',
	link = 'https://www.nli.org.il/en/authorities/$1',
	label = 'Israel',
}, {
	property = 8381,
	section = 5,
	link = 'https://www.emmys.com/bios/$1',
	label = 'Emmy Awards'
}, {
	property = 8671,
	section = 7,
	label = 'Deutsche Bahn',
	link = 'https://iris.noncd.db.de/wbt/js/index.html?bhf=$1&amp;zeilen=50&amp;seclang=en',
	remark = 'Deutsche Bahn station code, identifier for train stations and other operating points used by Deutsche Bahn',
	pattern = '[ABCDEFHIJKLMNOPQRSTUVWXYZ][A-Z0-9%s][A-Z0-9%s]?[A-Z0-9%s]?[A-Z0-9%s]?'
}, {
	property = 8980,
	section = 2,
	pattern = '%d%d%d%d%d%d%d%d%d',
	link = 'https://urn.fi/URN:NBN:fi:au:finaf:$1',
	label = 'Finland',
}, {
	property = 9070,
	section = 7,
	pattern = '[A-Z]\\[A-Z]\\%w+',
	link = 'http://www.encyclopediaofukraine.com/display.asp?linkpath=pages\\$1',
	label = 'Internet Encyclopedia of Ukraine',
}, {
	property = 9692,
	section = 5,
	link = 'https://www.lexm.uni-hamburg.de/object/lexm_lexmperson_$1',
	label = 'LexM',
	remark = 'Identifier for a musician in the Lexikon verfolgter Musiker und Musikerinnen der NS-Zeit',
	pattern = '%d%d%d%d%d%d%d%d'
}, {
	property = 9725,
	section = 3,
	label = 'EBIDAT',
	link = 'https://www.ebidat.de/cgi-bin/ebidat.pl?id=$1',
	remark = 'Identifier for an entry in the castles inventory database EBIDAT',
	pattern = '[1-9]%d?%d?%d?%d?'
}, {
	property = 9984,
	section = 2,
	pattern = '981[0-1]%d%d%d%d%d%d%d%d%d06706',
	link = 'https://cantic.bnc.cat/registre/$1',
	label = 'Catalonia',
}, {
	property = 10020,
	section = 6,
	pattern = '[0-9A-Z]+',
	link = 'https://handbook.aph.gov.au/Parliamentarian/$1',
	label = 'Australian Parliament',
}, {
	property = 10299,
	section = 4,
	link = 'https://www.leopoldina.org/mitgliederverzeichnis/mitglieder/member/Member/show/$1/',
	label = 'Leopoldina',
	pattern = '[%-a-z]+%d?'
}, {
	property = 10608,
	section = 5,
	link = 'https://www.performing-arts.eu/discovery/$1',
	label = 'FID',
	remark = 'FID performing arts',
}, {
	property = 10832,
	section = 1,
	link = 'https://id.oclc.org/worldcat/entity/$1',
	label = 'WorldCat',
	patterns = {'%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w', '[QP][1-9]%d*'},
	remark = 'WorldCat Entities for persons and works, by [[OCLC]]',
}, {
	property = 11249,
	section = 2,
	pattern = '%d%d%d%d%d%d%d%d',
	link = 'https://opac.kbr.be/LIBRARY/doc/AUTHORITY/$1',
	label = 'Belgium',
}, {
	property = 11646,
	section = 6,
	label = 'Deutsche Synchronkartei',
	link = 'https://www.synchronkartei.de/person/$1',
	remark = 'Online database of voice actors in film and television productions',
	pattern = string.rep('[0-9a-zA-Z_-]',9)
}, {
	property = 11729,
	section = 7,
	label = 'Kulturenvanteri monument',
	link = 'https://kulturenvanteri.com/yer/?p=$1',
	pattern = '%d+'
}, {
	property = 12204,
	section = 7,
	label = 'ELMCIP',
	link = 'https://elmcip.net/node/$1',
	remark = 'Identifier for an entry in the Electronic Literature as a Model of Creativity and Innovation in Practice (ELNCIP) Knowledge Base',
	pattern = '[1-9]%d*'
}, {
	property = 12362,
	section = 6,
	pattern = '[a-z]+[a-z%-]*%d?',
	link = 'https://parliament.vic.gov.au/members/$1',
	label = 'Victorian Parliament',
}, {
	property = 12754,
	section = 7,
	pattern = '000%d%d%d%d%d%d%d',
	link = 'https://id.bildindex.de/thing/$1',
	label = 'Bildindex',
}, {
	property = 13049,
	section = 6,
	patterns = {'1[0123]?%d%d%d%d%d%d%d[0-9X]', '[47]%d%d%d%d%d%d%-%d', '[1-9]%d?%d?%d?%d?%d?%d?%d?%-[0-9X]', '3%d%d%d%d%d%d%d[0-9X]'},
	link = 'https://www.deutsche-digitale-bibliothek.de/person/gnd/$1',
	label = 'DDB',
	remark = 'Deutsche Digitale Bibliothek', 
}}
p.sections = {
	[1] = {name = 'International', hidelabelwhenalone = true},
	[2] = {name = 'National'},
	[3] = {name = 'Geographic'},
	[4] = {name = 'Academics'},
	[5] = {name = 'Artists'},
	[6] = {name = 'People'},
	[7] = {name = 'Other', hidelabelwhenalone = true}
}
p.whitelists = {
	arts = {
		topic = 2018526,
		properties = {268, 214, 3372, 6804, 1907, 4186, 12754, 1908, 1707, 6829, 2349, 6792, 227, 1960, 347, 1248, 244, 1225, 2041, 409, 2750, 650, 350, 781, 3430, 3544, 1315, 245, 1986, 7902, 651, 791, 7303}
	},
	lighthouse = {
		topic = 39715,
		properties = {3563, 4055, 3223, 4423, 3723, 3993, 3562, 2980, 4038, 3920, 4143, 3863, 3601}
	},
	ch = {
		topic = 39,
		properties = {902, 886, 781, 1362},
	},
	cz = {topic = 213, properties = {691}},
	cl = {topic = 298, properties = {1890}},
	es = {topic = 29, properties = {950, 9984}},
	gr = {topic = 41, properties = {3348}},
	hr = {topic = 224, properties = {1375}},
	il = {topic = 801, properties = {8189, 1736}},
	it = {topic = 38, properties = {396, 3863, 1986, 8034}},
	ja = {topic = 17, properties = {349, 271}},
	kr = {topic = 884, properties = {5034}},
	lv = {topic = 211, properties = {1368}},
	nl = {topic = 55, properties = {651, 1006, 650, 350}},
	pl = {topic = 36, properties = {1695, 7293}},
	ro = {topic = 218, properties = {1003}},
	ru = {topic = 159, properties = {947}},
	sv = {topic = 34, properties = {906, 5587}},
	tr = {topic = 43, properties = {7314}},
	tw = {topic = 865, properties = {1048}},
	uy = {topic = 77, properties = {2558}}
}
p.property_items = {-- look at these properties to find relevant item to property
	1629, -- P1629: Wikidata item of this property
	10726,-- P10726: class of non-item property value
	9073, -- P9073: applicable 'stated in' value
	2378  -- P2378: issued by
}
p.auto_additional = {-- defines properties to check when additional=auto
	527,  -- P527: has part(s)
	150,  -- P150: contains the administrative territorial entity
	355,  -- P355: has subsidiary
}
return p</text>
      <sha1>6se1e5aecfh61ob7ladi11u4lncsryu</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Hlist/styles.css</title>
    <ns>10</ns>
    <id>220</id>
    <revision>
      <id>428</id>
      <parentid>427</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>427</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="2922" sha1="gfbk8cwecy39b1u1zxq4sqqxyf84d2r" xml:space="preserve">/* {{pp-protected|reason=match parent|small=yes}} */
/* 
 * hlist styles are defined in core and Minerva and differ in Minerva. The
 * current definitions here (2023-01-01) are sufficient to override Minerva
 * without use of the hlist-separated class. The most problematic styles were
 * related to margin, padding, and the bullet. Check files listed at
 * [[MediaWiki talk:Common.css/to do#hlist-separated]]
 */
/*
 * TODO: When the majority of readership supports it (or some beautiful world
 * in which grade C support is above the minimum threshold), use :is()
 */
.hlist dl,
.hlist ol,
.hlist ul {
	margin: 0;
	padding: 0;
}

/* Display list items inline */
.hlist dd,
.hlist dt,
.hlist li {
	/*
	 * don't trust the note that says margin doesn't work with inline
	 * removing margin: 0 makes dds have margins again
	 * We also want to reset margin-right in Minerva
	 */
	margin: 0; 
	display: inline;
}

/* Display requested top-level lists inline */
.hlist.inline,
.hlist.inline dl,
.hlist.inline ol,
.hlist.inline ul,
/* Display nested lists inline */
.hlist dl dl,
.hlist dl ol,
.hlist dl ul,
.hlist ol dl,
.hlist ol ol,
.hlist ol ul,
.hlist ul dl,
.hlist ul ol,
.hlist ul ul {
	display: inline;
}

/* Hide empty list items */
.hlist .mw-empty-li {
	display: none;
}

/* TODO: :not() can maybe be used here to remove the later rule. naive test
 * seems to work. more testing needed. like so:
 *.hlist dt:not(:last-child)::after {
 *	content: ": ";
 *}
 *.hlist dd:not(:last-child)::after,
 *.hlist li:not(:last-child)::after {
 *	content: " · ";
 *	font-weight: bold;
 *}
 */
/* Generate interpuncts */
.hlist dt::after {
	content: ": ";
}

.hlist dd::after,
.hlist li::after {
	content: " · ";
	font-weight: bold;
}

.hlist dd:last-child::after,
.hlist dt:last-child::after,
.hlist li:last-child::after {
	content: none;
}

/* Add parentheses around nested lists */
.hlist dd dd:first-child::before,
.hlist dd dt:first-child::before,
.hlist dd li:first-child::before,
.hlist dt dd:first-child::before,
.hlist dt dt:first-child::before,
.hlist dt li:first-child::before,
.hlist li dd:first-child::before,
.hlist li dt:first-child::before,
.hlist li li:first-child::before {
	content: " (";
	font-weight: normal;
}

.hlist dd dd:last-child::after,
.hlist dd dt:last-child::after,
.hlist dd li:last-child::after,
.hlist dt dd:last-child::after,
.hlist dt dt:last-child::after,
.hlist dt li:last-child::after,
.hlist li dd:last-child::after,
.hlist li dt:last-child::after,
.hlist li li:last-child::after {
	content: ")";
	font-weight: normal;
}

/* Put ordinals in front of ordered list items */
.hlist ol {
	counter-reset: listitem;
}

.hlist ol &gt; li {
	counter-increment: listitem;
}

.hlist ol &gt; li::before {
	content: " " counter(listitem) "\a0";
}

.hlist dd ol &gt; li:first-child::before,
.hlist dt ol &gt; li:first-child::before,
.hlist li ol &gt; li:first-child::before {
	content: " (" counter(listitem) "\a0";
}</text>
      <sha1>gfbk8cwecy39b1u1zxq4sqqxyf84d2r</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Authority control/auxiliary</title>
    <ns>828</ns>
    <id>221</id>
    <revision>
      <id>430</id>
      <parentid>429</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>429</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7149" sha1="mgku9gzaar8u6cdkjptv9kfkm0wsqrc" xml:space="preserve">require('strict')
local p = {}
--[[======================================================]]
--[[            Format validation functions               ]]
--[[======================================================]]
function p.botanistV(id)
	return mw.ustring.match(id,"^[%u%l%d%. '-]+$")
end

-- NCDA: NOID Check Digit Algorithm; see [[wikipedia:Check digit#NCDA]]
local ncda -- leave this as a local since NCDA is commonly used among ARK identifiers and could be useful for validating other identifiers later
do -- initialize these constants only once but scope them in a block so local namespace doesn't get cluttered with these
	local r29s = [[0123456789bcdfghjkmnpqrstvwxz]] -- radix 29 "betanumeric" digit string
	local r29n = r29s:len()
	local r29v2d, r29d2v = {}, {}
	for i = 1, r29n do
		local v, d = i-1, r29s:sub(i, i)
		r29v2d[v], r29d2v[d] = d, v
	end
	function ncda(sid)
		local n, sum = sid:len(), 0
		for i = 1, n do
			sum = sum + i * (r29d2v[sid:sub(i, i)] or 0)
		end
		return r29v2d[sum % r29n]
	end
end
function p.validateBNF(id)
	local FRBNF = id:sub(1, -2)
	return FRBNF:match('^%d%d%d%d%d%d%d%d$') ~= nil and ncda('cb'..FRBNF) == id:sub(-1) and id
end

function p.validateIsni(id) --Validate ISNI (and ORCID) and returns it as a 16 characters string or returns false if it's invalid. See http://support.orcid.org/knowledgebase/articles/116780-structure-of-the-orcid-identifier
	id = id:gsub( '[ %-]', '' ):upper()
	if not id:match( '^%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d[%dX]$' ) then
		return false
	end
	local total = 0
	for i = 1, 15 do
		local digit = id:byte( i ) - 48 --Get integer value
		total = (total + digit) * 2
	end
	local remainder = total % 11
	local result = (12 - remainder) % 11
	local checkdigit
	if result == 10 then
		checkdigit = 'X'
	else
		checkdigit=tostring( result )
	end
	if checkdigit ~= string.char( id:byte( 16 ) ) then
		return false
	end
	return id
end

function p.orcidV(id)
	id = p.validateIsni(id)
	if not id then
		return false
	end
	return id:sub( 1, 4 )..'-'..id:sub( 5, 8 )..'-'..id:sub( 9, 12 )..'-'..id:sub( 13, 16 )
end

function p.tlsV(id)
	id = id:gsub(' +', '_')
	local idlen = mw.ustring.len(id)
	if idlen &lt; 4 or idlen &gt; 90 then
		return false
	end
	local regex = '^%u'..string.rep("[%w_',%.%-%(%)%*%/–&amp;]", idlen - 1)..'$'
	if not mw.ustring.match(id,regex ) then
		return false
	end
	return id
end

--[[======================================================]]
--[[                Custom link functions                 ]]
--[[======================================================]]
function p.ISILlink(id,label)
	if not id:match('^%D%D?%D?%D?%-.+$') then
		return false
	end
	for _, prefix in ipairs({'AT', 'AU', 'BE', 'CA', 'CH', 'DE', 'FI', 'FR', 'IT', 'KR', 'NZ', 'US', 'ZDB'}) do
		if id:match('^'..prefix..'%-') then
			return '[https://w3id.org/isil/'..id..' ' .. (label or 'ISIL') .. ']'
		end
	end
	return '[[International Standard Identifier for Libraries and Related Organizations|ISIL]]: ' .. id
end

function p.uscgLink(id)
	local id2 = id:match( '^[1-7]%-%d%d?%d?%d?%d?$' ) or id:match( '^[1-7]%-%d%d?%d?%d?%d?%.%d*[1-9]$' )
	if id2 then
		return '[https://www.navcen.uscg.gov/pdf/lightlists/LightList%20V'..mw.ustring.sub(id2,1,1)..'.pdf '..id2..']'
	else
		return false
	end
end

function p.ccg(id)
	id = id:match('^[NAIP]?[1-9]%d*$') or id:match('^[NAIP]?[1-9]%d*%.%d+$')
	if not id then return false end
	local link = 'https://www.notmar.gc.ca/'
	local prefix = string.sub(id, 1, 1) -- get first character of id
	local suffix = string.sub(id, 2) -- remove first character of id
	local interval = require('Module:Interval')._main
	local v
	if prefix=='N' then
		local int = interval({1, 7.5, 14.4, 100, 121, 173, 211, 235, 269.99, 326, 396, 450.1, 471.7, 499, n=suffix})
		if int=='1-2' then v = 1
		elseif int=='2-3' then v = 75
		elseif int=='3-4' then v = 144
		elseif int=='4-5' then v = 100
		elseif int=='5-6' then v = 121
		elseif int=='6-7' then v = 173
		elseif int=='7-8' then v = 211
		elseif int=='8-9' then v = 235
		elseif int=='9-10' then v = 26999
		elseif int=='10-11' then v = 326
		elseif int=='11-12' then v = 396
		elseif int=='12-13' then v = 4501
		elseif int=='13-14' then v = 4717
		elseif int=='14-15' then v = 499
		end
		link = link .. 'publications/list-lights/newfoundland/n' .. v .. '-en'
	elseif prefix=='A' then
		local int = interval({5, 114.5, 145, 163, 268, 271, 301.5, 327, 686.5, 704.85, 883.2, 942, 1085, 1169.1, 1584.5, 1773, 1823.55, 2190, 2369, 2389, n=suffix})
		if int=='1-2' then v = 5
		elseif int=='2-3' then v = 1145
		elseif int=='3-4' then v = 145
		elseif int=='4-5' then v = 162
		elseif int=='5-6' then v = 268
		elseif int=='6-7' then v = 271
		elseif int=='7-8' then v = 3015
		elseif int=='8-9' then v = 327
		elseif int=='9-10' then v = 6865
		elseif int=='10-11' then v = 7048
		elseif int=='11-12' then v = 883
		elseif int=='12-13' then v = 942
		elseif int=='13-14' then v = 1085
		elseif int=='14-15' then v = 11691
		elseif int=='15-16' then v = 15845
		elseif int=='16-17' then v = 1773
		elseif int=='17-18' then v = 182355
		elseif int=='18-19' then v = 2190
		elseif int=='19-20' then v = 2369
		elseif int=='20-21' then v = 2389
		end
		link = link .. 'publications/list-lights/atl/a' .. v .. '-en'
	elseif prefix=='I' then
		local int = interval({0.05, 401.1, 403.4, 551.06, 552, 624, 708, 731.2, 768, 814, 983, 1046, 1059.6, 1082, 1162, 1204.7, 1233.3, 1328, 1330, 1346.2, 1377.8, 1408, 1410, 1420, 1445, 1470, 1520, 1534, 1540.6, 1554, 1557.7, 1558.8, 1563.1, 1625.5, 1671.7, 1716.96, 2545, n=suffix})
		if int=='1-2' then v = '01'
		elseif int=='2-3' then v = 4011
		elseif int=='3-4' then v = 4034
		elseif int=='4-5' then v = 55106
		elseif int=='5-6' then v = 552
		elseif int=='6-7' then v = 624
		elseif int=='7-8' then v = 708
		elseif int=='8-9' then v = 7312
		elseif int=='9-10' then v = 768
		elseif int=='10-11' then v = 814
		elseif int=='11-12' then v = 983
		elseif int=='12-13' then v = 1046
		elseif int=='13-14' then v = 10596
		elseif int=='14-15' then v = 1082
		elseif int=='15-16' then v = 1162
		elseif int=='16-17' then v = 12047
		elseif int=='17-18' then v = 12333
		elseif int=='18-19' then v = 1328
		elseif int=='19-20' then v = 1330
		elseif int=='20-21' then v = 13462
		elseif int=='21-22' then v = 13778
		elseif int=='22-23' then v = 1408
		elseif int=='23-24' then v = 1410
		elseif int=='24-25' then v = 1420
		elseif int=='25-26' then v = 1445
		elseif int=='26-27' then v = 1470
		elseif int=='27-28' then v = 1520
		elseif int=='28-29' then v = 1534
		elseif int=='29-30' then v = 15406
		elseif int=='30-31' then v = 1554
		elseif int=='31-32' then v = 15577
		elseif int=='32-33' then v = 15588
		elseif int=='33-34' then v = 1562
		elseif int=='34-35' then v = 16255
		elseif int=='35-36' then v = 16717
		elseif int=='36-37' then v = 171696
		elseif int=='37-38' then v = 2545
		end
		link = link .. 'publications/list-lights/inland-waters/i' .. v .. '-en'
	elseif prefix=='P' then
		link = link .. 'publications/list-lights/pac/p'
	else
		link = link .. 'list-lights'
	end
	return '[[CCG (identifier)|CCG]]: [' .. link .. ' ' .. id .. ']'
end

return p</text>
      <sha1>mgku9gzaar8u6cdkjptv9kfkm0wsqrc</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Wikitext Parsing</title>
    <ns>828</ns>
    <id>222</id>
    <revision>
      <id>432</id>
      <parentid>431</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>431</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="17908" sha1="1pc5nwfjm9r5mkdrg3s2ci608uixfb7" xml:space="preserve">require("strict")

--Helper functions
local function startswith(text, subtext)
	return string.sub(text, 1, #subtext) == subtext
end
local function endswith(text, subtext)
	return string.sub(text, -#subtext, -1) == subtext
end
local function allcases(s)
	return s:gsub("%a", function(c) 
		return "["..c:upper()..c:lower().."]"
	end)
end
local trimcache = {}
local whitespace = {[" "]=1, ["\n"]=1, ["\t"]=1, ["\r"]=1}
local function cheaptrim(str) --mw.text.trim is surprisingly expensive, so here's an alternative approach
	local quick = trimcache[str]
	if quick then
		return quick
	else
		-- local out = string.gsub(str, "^%s*(.-)%s*$", "%1")
		local lowEnd
		local strlen = #str
		for i = 1,strlen do
			if not whitespace[string.sub(str, i, i)] then
				lowEnd = i
				break
			end
		end
		if not lowEnd then
			trimcache[str] = ""
			return ""
		end
		for i = strlen,1,-1 do
			if not whitespace[string.sub(str, i, i)] then
				local out = string.sub(str, lowEnd, i)
				trimcache[str] = out
				return out
			end
		end
	end
end

--[=[ Implementation notes
---- NORMAL HTML TAGS ----
Tags are very strict on how they want to start, but loose on how they end.
The start must strictly follow &lt;[tAgNaMe](%s|&gt;) with no room for whitespace in
the tag's name, but may then flow as they want afterwards, making
&lt;div\nclass\n=\n"\nerror\n"\n&gt; valid

There's no sense of escaping &lt; or &gt;
E.g.
 &lt;div class="error\&gt;"&gt; will end at \&gt; despite it being inside a quote
 &lt;div class="&lt;span class="error"&gt;error&lt;/span&gt;"&gt; will not process the larger div

If a tag has no end, it will consume all text instead of not processing

---- NOPROCESSING TAGS (nowiki, pre, syntaxhighlight, source, etc.) ----
(In most comments, &lt;source&gt; will not be mentioned. This is because it is the
deprecated version of &lt;syntaxhighlight&gt;)

No-Processing tags have some interesting differences to the above rules.
For example, their syntax is a lot stricter. While an opening tag appears to
follow the same set of rules, A closing tag can't have any sort of extra
formatting period. While &lt;/div a/a&gt; is valid, &lt;/nowiki a/a&gt; isn't - only
newlines and spaces/tabs are allowed in closing tags.
Note that, even though &lt;pre&gt; tags cause a visual change when the ending tag has
extra formatting, it won't cause the no-processing effects. For some reason, the
format must be strict for that to apply.

Both the content inside the tag pair and the content inside each side of the
pair is not processed. E.g. &lt;nowiki |}}&gt;|}}&lt;/nowiki&gt; would have both of the |}}
escaped in practice.

When something in the code is referenced to as a "Nowiki Tag", it means a tag
which causes wiki text to not be processed, which includes &lt;nowiki&gt;, &lt;pre&gt;,
and &lt;syntaxhighlight&gt;

Since we only care about these tags, we can ignore the idea of an intercepting
tag preventing processing, and just go straight for the first ending we can find
If there is no ending to find, the tag will NOT consume the rest of the text in
terms of processing behaviour (though &lt;pre&gt; will appear to have an effect).
Even if there is no end of the tag, the content inside the opening half will
still be unprocessed, meaning {{X20|&lt;nowiki }}&gt;}} wouldn't end at the first }}
despite there being no ending to the tag.

Note that there are some tags, like &lt;math&gt;, which also function like &lt;nowiki&gt;
which are included in this aswell. Some other tags, like &lt;ref&gt;, have far too
unpredictable behaviour to be handled currently (they'd have to be split and
processed as something seperate - its complicated, but maybe not impossible.)
I suspect that every tag listed in [[Special:Version]] may behave somewhat like
this, but that's far too many cases worth checking for rarely used tags that may
not even have a good reason to contain {{ or }} anyways, so we leave them alone.

---- HTML COMMENTS AND INCLUDEONLY ----
HTML Comments are about as basic as it could get for this
Start at &lt;!--, end at --&gt;, no extra conditions. Simple enough
If a comment has no end, it will eat all text instead of not being processed

includeonly tags function mostly like a regular nowiki tag, with the exception
that the tag will actually consume all future text if not given an ending as
opposed to simply giving up and not changing anything. Due to complications and
the fact that this is far less likely to be present on a page, aswell as being
something that may not want to be escaped, includeonly tags are ignored during
our processing
--]=]
local validtags = {nowiki=1, pre=1, syntaxhighlight=1, source=1, math=1}
--This function expects the string to start with the tag
local function TestForNowikiTag(text, scanPosition)
	local tagName = (string.match(text, "^&lt;([^\n /&gt;]+)", scanPosition) or ""):lower()
	if not validtags[tagName] then
		return nil
	end
	local nextOpener = string.find(text, "&lt;", scanPosition+1) or -1
	local nextCloser = string.find(text, "&gt;", scanPosition+1) or -1
	if nextCloser &gt; -1 and (nextOpener == -1 or nextCloser &lt; nextOpener) then
		local startingTag = string.sub(text, scanPosition, nextCloser)
		--We have our starting tag (E.g. '&lt;pre style="color:red"&gt;')
		--Now find our ending...
		if endswith(startingTag, "/&gt;") then --self-closing tag (we are our own ending)
			return {
				Tag = tagName,
				Start = startingTag,
				Content = "", End = "",
				Length = #startingTag
			}

		else
			local endingTagStart, endingTagEnd = string.find(text, "&lt;/"..allcases(tagName).."[ \t\n]*&gt;", scanPosition)
			if endingTagStart then --Regular tag formation
				local endingTag = string.sub(text, endingTagStart, endingTagEnd)
				local tagContent = string.sub(text, nextCloser+1, endingTagStart-1)
				return {
					Tag = tagName,
					Start = startingTag,
					Content = tagContent,
					End = endingTag,
					Length = #startingTag + #tagContent + #endingTag
				}

			else --Content inside still needs escaping (also linter error!)
				return {
					Tag = tagName,
					Start = startingTag,
					Content = "", End = "",
					Length = #startingTag
				}
			end
		end
	end
	return nil
end
local function TestForComment(text, scanPosition) --Like TestForNowikiTag but for &lt;!-- --&gt;
	if string.match(text, "^&lt;!%-%-", scanPosition) then
		local commentEnd = string.find(text, "--&gt;", scanPosition+4, true)
		if commentEnd then
			return {
				Start = "&lt;!--", End = "--&gt;",
				Content = string.sub(text, scanPosition+4, commentEnd-1),
				Length = commentEnd-scanPosition+3
			}
		else --Consumes all text if not given an ending
			return {
				Start = "&lt;!--", End = "",
				Content = string.sub(text, scanPosition+4),
				Length = #text-scanPosition+1
			}
		end
	end
	return nil
end

--[[ Implementation notes
The goal of this function is to escape all text that wouldn't be parsed if it
was preprocessed (see above implementation notes).

Using keepComments will keep all HTML comments instead of removing them. They
will still be escaped regardless to avoid processing errors
--]]
local function PrepareText(text, keepComments)
	local newtext = {}
	local scanPosition = 1
	while true do
		local NextCheck = string.find(text, "&lt;[NnSsPpMm!]", scanPosition) --Advance to the next potential tag we care about
		if not NextCheck then --Done
			newtext[#newtext+1] =  string.sub(text,scanPosition)
			break
		end
		newtext[#newtext+1] = string.sub(text,scanPosition,NextCheck-1)
		scanPosition = NextCheck
		local Comment = TestForComment(text, scanPosition)
		if Comment then
			if keepComments then
				newtext[#newtext+1] = Comment.Start .. mw.text.nowiki(Comment.Content) .. Comment.End
			end
			scanPosition = scanPosition + Comment.Length
		else
			local Tag = TestForNowikiTag(text, scanPosition)
			if Tag then
				local newTagStart = "&lt;" .. mw.text.nowiki(string.sub(Tag.Start,2,-2)) .. "&gt;"
				local newTagEnd = 
					Tag.End == "" and "" or --Respect no tag ending
					"&lt;/" .. mw.text.nowiki(string.sub(Tag.End,3,-2)) .. "&gt;"
				local newContent = mw.text.nowiki(Tag.Content)
				newtext[#newtext+1] = newTagStart .. newContent .. newTagEnd
				scanPosition = scanPosition + Tag.Length
			else --Nothing special, move on...
				newtext[#newtext+1] = string.sub(text, scanPosition, scanPosition)
				scanPosition = scanPosition + 1
			end
		end
	end
	return table.concat(newtext, "")
end

--[=[ Implementation notes
This function is an alternative to Transcluder's getParameters which considers
the potential for a singular { or } or other odd syntax that %b doesn't like to
be in a parameter's value.

When handling the difference between {{ and {{{, mediawiki will attempt to match
as many sequences of {{{ as possible before matching a {{
E.g.
 {{{{A}}}} -&gt; { {{{A}}} }
 {{{{{{{{Text|A}}}}}}}} -&gt; {{ {{{ {{{Text|A}}} }}} }}
If there aren't enough triple braces on both sides, the parser will compromise
for a template interpretation.
E.g.
 {{{{A}} }} -&gt; {{ {{ A }} }}

While there are technically concerns about things such as wikilinks breaking
template processing (E.g. {{[[}}]]}} doesn't stop at the first }}), it shouldn't
be our job to process inputs perfectly when the input has garbage ({ / } isn't
legal in titles anyways, so if something's unmatched in a wikilink, it's
guaranteed GIGO)

Setting dontEscape will prevent running the input text through EET. Avoid
setting this to true if you don't have to set it.

Returned values:
A table of all templates. Template data goes as follows:
 Text: The raw text of the template
 Name: The name of the template
 Args: A list of arguments
 Children: A list of immediate template children
--]=]
--Helper functions
local function boundlen(pair)
	return pair.End-pair.Start+1
end

--Main function
local function ParseTemplates(InputText, dontEscape)
	--Setup
	if not dontEscape then
		InputText = PrepareText(InputText)
	end
	local function finalise(text)
		if not dontEscape then
			return mw.text.decode(text)
		else
			return text
		end
	end
	local function CreateContainerObj(Container)
		Container.Text = {}
		Container.Args = {}
		Container.ArgOrder = {}
		Container.Children = {}
		-- Container.Name = nil
		-- Container.Value = nil
		-- Container.Key = nil
		Container.BeyondStart = false
		Container.LastIndex = 1
		Container.finalise = finalise
		function Container:HandleArgInput(character, internalcall)
			if not internalcall then
				self.Text[#self.Text+1] = character
			end
			if character == "=" then
				if self.Key then
					self.Value[#self.Value+1] = character
				else
					self.Key = cheaptrim(self.Value and table.concat(self.Value, "") or "")
					self.Value = {}
				end
			else --"|" or "}"
				if not self.Name then
					self.Name = cheaptrim(self.Value and table.concat(self.Value, "") or "")
					self.Value = nil
				else
					self.Value = self.finalise(self.Value and table.concat(self.Value, "") or "")
					if self.Key then
						self.Key = self.finalise(self.Key)
						self.Args[self.Key] = cheaptrim(self.Value)
						self.ArgOrder[#self.ArgOrder+1] = self.Key
					else
						local Key = tostring(self.LastIndex)
						self.Args[Key] = self.Value
						self.ArgOrder[#self.ArgOrder+1] = Key
						self.LastIndex = self.LastIndex + 1
					end
					self.Key = nil
					self.Value = nil
				end
			end
		end
		function Container:AppendText(text, ftext)
			self.Text[#self.Text+1] = (ftext or text)
			if not self.Value then
				self.Value = {}
			end
			self.BeyondStart = self.BeyondStart or (#table.concat(self.Text, "") &gt; 2)
			if self.BeyondStart then
				self.Value[#self.Value+1] = text
			end
		end
		function Container:Clean(IsTemplate)
			self.Text = table.concat(self.Text, "")
			if self.Value and IsTemplate then
				self.Value = {string.sub(table.concat(self.Value, ""), 1, -3)} --Trim ending }}
				self:HandleArgInput("|", true) --Simulate ending
			end
			self.Value = nil
			self.Key = nil
			self.BeyondStart = nil
			self.LastIndex = nil
			self.finalise = nil
			self.HandleArgInput = nil
			self.AppendText = nil
			self.Clean = nil
		end
		return Container
	end
	
	--Step 1: Find and escape the content of all wikilinks on the page, which are stronger than templates (see implementation notes)
	local scannerPosition = 1
	local wikilinks = {}
	local openWikilinks = {}
	while true do
		local Position, _, Character = string.find(InputText, "([%[%]])%1", scannerPosition)
		if not Position then --Done
			break
		end

		scannerPosition = Position+2 --+2 to pass the [[ / ]]
		if Character == "[" then --Add a [[ to the pending wikilink queue
			openWikilinks[#openWikilinks+1] = Position
		else --Pair up the ]] to any available [[
			if #openWikilinks &gt;= 1 then
				local start = table.remove(openWikilinks) --Pop the latest [[
				wikilinks[start] = {Start=start, End=Position+1, Type="Wikilink"} --Note the pair
			end
		end
	end
	
	--Step 2: Find the bounds of every valid template and variable ({{ and {{{)
	local scannerPosition = 1
	local templates = {}
	local variables = {}
	local openBrackets = {}
	while true do
		local Start, _, Character = string.find(InputText, "([{}])%1", scannerPosition)
		if not Start then --Done (both 9e9)
			break
		end
		local _, End = string.find(InputText, "^"..Character.."+", Start)

		scannerPosition = Start --Get to the {{ / }} set
		if Character == "{" then --Add the {{+ set to the queue
			openBrackets[#openBrackets+1] = {Start=Start, End=End}

		else --Pair up the }} to any available {{, accounting for {{{ / }}}
			local BracketCount = End-Start+1
			while BracketCount &gt;= 2 and #openBrackets &gt;= 1 do
				local OpenSet = table.remove(openBrackets)
				if boundlen(OpenSet) &gt;= 3 and BracketCount &gt;= 3 then --We have a {{{variable}}} (both sides have 3 spare)
					variables[OpenSet.End-2] = {Start=OpenSet.End-2, End=scannerPosition+2, Type="Variable"} --Done like this to ensure chronological order
					BracketCount = BracketCount - 3
					OpenSet.End = OpenSet.End - 3
					scannerPosition = scannerPosition + 3

				else --We have a {{template}} (both sides have 2 spare, but at least one side doesn't have 3 spare)
					templates[OpenSet.End-1] = {Start=OpenSet.End-1, End=scannerPosition+1, Type="Template"} --Done like this to ensure chronological order
					BracketCount = BracketCount - 2
					OpenSet.End = OpenSet.End - 2
					scannerPosition = scannerPosition + 2
				end

				if boundlen(OpenSet) &gt;= 2 then --Still has enough data left, leave it in
					openBrackets[#openBrackets+1] = OpenSet
				end
			end
		end
		scannerPosition = End --Now move past the bracket set
	end
	
	--Step 3: Re-trace every object using their known bounds, collecting our parameters with (slight) ease
	local scannerPosition = 1
	local activeObjects = {}
	local finalObjects = {}
	while true do
		local LatestObject = activeObjects[#activeObjects] --Commonly needed object
		local NNC, _, Character --NNC = NextNotableCharacter
		if LatestObject then
			NNC, _, Character = string.find(InputText, "([{}%[%]|=])", scannerPosition)
		else
			NNC, _, Character = string.find(InputText, "([{}])", scannerPosition) --We are only after templates right now
		end
		if not NNC then
			break
		end
		if NNC &gt; scannerPosition and LatestObject then
			local scannedContent = string.sub(InputText, scannerPosition, NNC-1)
			LatestObject:AppendText(scannedContent, finalise(scannedContent))
		end

		scannerPosition = NNC+1
		if Character == "{" or Character == "[" then
			local Container = templates[NNC] or variables[NNC] or wikilinks[NNC]
			if Container then
				CreateContainerObj(Container)
				if Container.Type == "Template" then
					Container:AppendText("{{")
					scannerPosition = NNC+2
				elseif Container.Type == "Variable" then
					Container:AppendText("{{{")
					scannerPosition = NNC+3
				else --Wikilink
					Container:AppendText("[[")
					scannerPosition = NNC+2
				end
				if LatestObject and Container.Type == "Template" then --Only templates count as children
					LatestObject.Children[#LatestObject.Children+1] = Container
				end
				activeObjects[#activeObjects+1] = Container
			elseif LatestObject then
				LatestObject:AppendText(Character)
			end

		elseif Character == "}" or Character == "]" then
			if LatestObject then
				LatestObject:AppendText(Character)
				if LatestObject.End == NNC then
					if LatestObject.Type == "Template" then
						LatestObject:Clean(true)
						finalObjects[#finalObjects+1] = LatestObject
					else
						LatestObject:Clean(false)
					end
					activeObjects[#activeObjects] = nil
					local NewLatest = activeObjects[#activeObjects]
					if NewLatest then
						NewLatest:AppendText(LatestObject.Text) --Append to new latest
					end
				end
			end

		else --| or =
			if LatestObject then
				LatestObject:HandleArgInput(Character)
			end
		end
	end
	
	--Step 4: Fix the order
	local FixedOrder = {}
	local SortableReference = {}
	for _,Object in next,finalObjects do
		SortableReference[#SortableReference+1] = Object.Start
	end
	table.sort(SortableReference)
	for i = 1,#SortableReference do
		local start = SortableReference[i]
		for n,Object in next,finalObjects do
			if Object.Start == start then
				finalObjects[n] = nil
				Object.Start = nil --Final cleanup
				Object.End = nil
				Object.Type = nil
				FixedOrder[#FixedOrder+1] = Object
				break
			end
		end
	end
	
	--Finished, return
	return FixedOrder
end

local p = {}
--Main entry points
p.PrepareText = PrepareText
p.ParseTemplates = ParseTemplates
--Extra entry points, not really required
p.TestForNowikiTag = TestForNowikiTag
p.TestForComment = TestForComment

return p

--[==[ console tests

local s = [=[Hey!{{Text|&lt;nowiki | ||&gt;
Hey! }}
A&lt;/nowiki&gt;|&lt;!--AAAAA|AAA--&gt;Should see|Shouldn't see}}]=]
local out = p.PrepareText(s)
mw.logObject(out)

local s = [=[B&lt;!--
Hey!
--&gt;A]=]
local out = p.TestForComment(s, 2)
mw.logObject(out); mw.log(string.sub(s, 2, out.Length))

local a = p.ParseTemplates([=[
{{User:Aidan9382/templates/dummy
|A|B|C {{{A|B}}} { } } {
|&lt;nowiki&gt;D&lt;/nowiki&gt;
|&lt;pre&gt;E
|F&lt;/pre&gt;
|G|=|a=|A  =  [[{{PAGENAME}}|A=B]]{{Text|1==&lt;nowiki&gt;}}&lt;/nowiki&gt;}}|A B=Success}}
]=])
mw.logObject(a)

]==]</text>
      <sha1>1pc5nwfjm9r5mkdrg3s2ci608uixfb7</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Disambiguation/templates</title>
    <ns>828</ns>
    <id>223</id>
    <revision>
      <id>434</id>
      <parentid>433</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>433</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4391" sha1="2vtbcvef4loa9m277godxia99m9nxj4" xml:space="preserve">-- This page contains a table of all disambiguation templates and their
-- redirects. Templates names are capitalized, and the Template: prefix is
-- removed. Templates are grouped with the main template first, followed by
-- its redirects.

return {
	["Disambiguation"] = true,
	["Begriffsklärung"] = true,
	["DAB"] = true,
	["Dab"] = true,
	["Dab page"] = true,
	["Dabpage"] = true,
	["Dbig"] = true,
	["Dis"] = true,
	["Disam"] = true,
	["Disamb"] = true,
	["Disambig"] = true,
	["Disambig misspelling"] = true,
	["Disambig-plants"] = true,
	["Disambiguation page"] = true,
	["Manual of Style disambiguation"] = true,
	["Meta disambig"] = true,
	["MOS disambiguation"] = true,
	["MoS disambiguation"] = true,
	["Portal disambig"] = true,
	["Portal disambiguation"] = true,
	["Project disambiguation"] = true,
	["Shortcut disambig"] = true,
	["Wikipedia disambiguation"] = true,
	["WP disambig"] = true,
	["WP-disambig"] = true,

	["Airport disambiguation"] = true,
	["Airport disambig"] = true,

	["Biology disambiguation"] = true,

	["Call sign disambiguation"] = true,
	["Callsigndis"] = true,

	["Caselaw disambiguation"] = true,
	["Case law disambiguation"] = true,

	["Chinese title disambiguation"] = true,
	["Chinese title disambig"] = true,
	["CJKVdab"] = true,
	["Disambig-Chinese-char-title"] = true,

	["Disambiguation cleanup"] = true,
	["Cleanup disambig"] = true,
	["Cleanup disambiguation"] = true,
	["CleanupDisambig"] = true,
	["Dab cleanup"] = true,
	["Dab-cleanup"] = true,
	["Dabclean"] = true,
	["Disamb-cleanup"] = true,
	["Disambcleanup"] = true,
	["Disambig cleanup"] = true,
	["Disambig-cleanup"] = true,
	["Disambig-CU"] = true,
	["Disambig-cu"] = true,
	["Disambigcleanup"] = true,
	["Disambiguate-cleanup"] = true,
	["Disambiguation-cleanup"] = true,
	["Geodis-cleanup"] = true,

	["Disambiguation with potential"] = true,
	["Disambiguation with possibilties"] = true,

	["Genus disambiguation"] = true,
	["Genus disambig"] = true,

	["Hangul title disambiguation"] = true,

	["Hospital disambiguation"] = true,
	["Hospitaldis"] = true,

	["Human name disambiguation"] = true,
	["Bio-dab"] = true,
	["Hndab"] = true,
	["HNDIS"] = true,
	["HnDis"] = true,
	["Hndis"] = true,
	["Hndisambig"] = true,
	["Human name dab"] = true,
	["Name list"] = true,
	["Personal name"] = true,
	["Personal name disambiguation"] = true,

	["Human name disambiguation cleanup"] = true,
	["Hndis-cleanup"] = true,
	["Personal name disambiguation cleanup"] = true,

	["Hurricane season disambiguation"] = true,

	["Letter–number combination disambiguation"] = true,
	["Letter-Number Combination Disambiguation"] = true,
	["Letter-Number combination disambiguation"] = true,
	["Letter-number combination disambiguation"] = true,
	["Letter-NumberCombDisambig"] = true,
	["Letter-NumberCombdisambig"] = true,
	["Letter-NumberCombinationDisambiguation"] = true,
	["LNCD"] = true,

	["Mathematical disambiguation"] = true,
	["Math dab"] = true,
	["Math disambiguation"] = true,
	["Math-dab"] = true,
	["Mathdab"] = true,
	["Mathematics disambiguation"] = true,
	["Maths disambiguation"] = true,

	["Military unit disambiguation"] = true,
	["Mil-unit-dis"] = true,
	["Mil-unit-disambig"] = true,

	["Music disambiguation"] = true,
	["Music disambig"] = true,

	["Number disambiguation"] = true,
	["Numberdis"] = true,
	["Numdab"] = true,
	["Numdisambig"] = true,

	["Opus number disambiguation"] = true,

	["Phonetics disambiguation"] = true,

	["Place name disambiguation"] = true,
	["DisambigG"] = true,
	["DisambigGeo"] = true,
	["Disambiggeo"] = true,
	["Geo-dis"] = true,
	["Geodab"] = true,
	["Geodis"] = true,
	["Geodisambig"] = true,
	["Geographic disambiguation"] = true,
	["Pnd"] = true,

	["Road disambiguation"] = true,
	["Roaddis"] = true,

	["School disambiguation"] = true,
	["School disambig"] = true,
	["Schooldab"] = true,
	["Schooldis"] = true,

	["Species Latin name abbreviation disambiguation"] = true,

	["Species Latin name disambiguation"] = true,
	["LatinNameDisambig"] = true,
	["Species disambiguation"] = true,
	["SpeciesLatinNameDisambig"] = true,

	["Station disambiguation"] = true,
	["Station dab"] = true,

	["Synagogue disambiguation"] = true,

	["Taxonomy disambiguation"] = true,

	["Template disambiguation"] = true,
	["Template ambiguous"] = true,
	["Template dab"] = true,
	["Template disambig"] = true,

	["WoO number disambiguation"] = true,
}</text>
      <sha1>2vtbcvef4loa9m277godxia99m9nxj4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype/disambiguation</title>
    <ns>828</ns>
    <id>224</id>
    <redirect title="Module:Disambiguation/templates" />
    <revision>
      <id>436</id>
      <parentid>435</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>435</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="50" sha1="i5ooe2bqffrglszpd82v0i3pqyp187b" xml:space="preserve">return require [[Module:Disambiguation/templates]]</text>
      <sha1>i5ooe2bqffrglszpd82v0i3pqyp187b</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype/softredirect</title>
    <ns>828</ns>
    <id>225</id>
    <revision>
      <id>438</id>
      <parentid>437</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>437</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2612" sha1="krad2do3vq17ck777hpwdoaxr3vo5yt" xml:space="preserve">-- This page contains a table of all soft redirect templates and their
-- redirects. Templates names are capitalized, and the Template: prefix is
-- removed. Templates are grouped with the main template first, followed by
-- its redirects.

return {
	["R from category navigation"] = true,
	["Redirect from category navigation"] = true,

	["Category redirect"] = true,
	["Cat move"] = true,
	["Cat red"] = true,
	["Cat redir"] = true,
	["Cat redirect"] = true,
	["Category move"] = true,
	["Category Redirect"] = true,
	["Categoryredirect"] = true,
	["Catr"] = true,
	["Catred"] = true,
	["Catredir"] = true,
	["Catredirect"] = true,

	["R from template-generated category"] = true,
	["Redirect from template-generated category"] = true,

	["Portal soft redirect"] = true,
	["Portal Redirect"] = true,
	["Portal redirect"] = true,
	["Portal Soft Redirect"] = true,
	["Portalredirect"] = true,
	["Portalsoftredirect"] = true,
	["PortRed"] = true,
	["Portred"] = true,
	["Portsoftred"] = true,
	["PSR"] = true,
	["Psr"] = true,
	["Soft portal redirect"] = true,
	["Soft redirect portal"] = true,
	["SPR"] = true,
	["Spr"] = true,
	["SRP"] = true,
	["Srp"] = true,

	["Salted redirect"] = true,

	["Soft redirect"] = true,
	["Interwiki redirect"] = true,
	["Plain soft redirect"] = true,
	["Soft"] = true,
	["Soft link"] = true,
	["Soft redir"] = true,
	["Soft Redirect"] = true,
	["Softr"] = true,
	["Softredir"] = true,
	["SoftRedirect"] = true,
	["Softredirect"] = true,

	["Userrename"] = true,

	["Wikibooks redirect"] = true,
	["WBOOK"] = true,
	["Wbook"] = true,
	["Wikibook redirect"] = true,
	["Wikibooks Redirect"] = true,
	["WikibooksRedirect"] = true,
	["Wikibooksredirect"] = true,

	["Wikimedia Commons redirect"] = true,
	["COMM"] = true,
	["Comm"] = true,
	["Commons Redirect"] = true,
	["Commons redirect"] = true,
	["CommonsRedirect"] = true,
	["Commonsredirect"] = true,
	["Wikimedia commons redirect"] = true,

	["Wikiquote redirect"] = true,
	["Wq"] = true,

	["Wikisource redirect"] = true,

	["Wikispecies redirect"] = true,
	["Wikispecies Redirect"] = true,
	["WikispeciesRedirect"] = true,
	["Wikispeciesredirect"] = true,
	["WSPEC"] = true,
	["Wspec"] = true,

	["Wikivoyage redirect"] = true,

	["Wiktionary redirect"] = true,
	["Moved to Wiktionary"] = true,
	["RedirecttoWiktionary"] = true,
	["Wi"] = true,
	["Wikt red"] = true,
	["Wikt redirect"] = true,
	["Wiktionary Redirect"] = true,
	["Wiktionary-redirect"] = true,
	["WiktionaryRedirect"] = true,
	["Wiktionaryredirect"] = true,
	["Wiktr"] = true,
	["Wiktred"] = true,
	["Wiktredir"] = true,
	["Wtr"] = true,
	["Wtsr"] = true,
}</text>
      <sha1>krad2do3vq17ck777hpwdoaxr3vo5yt</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype/setindex</title>
    <ns>828</ns>
    <id>226</id>
    <revision>
      <id>440</id>
      <parentid>439</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>439</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1489" sha1="nn9l9r1pmrobxspg0rm1qgng5nzu19x" xml:space="preserve">-- This page contains a table of all set index templates and their
-- redirects. Templates names are capitalized, and the Template: prefix is
-- removed. Templates are grouped with the main template first, followed by
-- its redirects.

return {
	["Set index article"] = true,
		["Sia"] = true,
		["Set index"] = true,
		["SIA"] = true,
		["Set-index"] = true,
		["Setindex"] = true,
		["Set-index article"] = true,
	["Animal common name"] = true,
	["Chemistry index"] = true,
		["Chemdisambig"] = true,
		["Chemistry disambiguation"] = true,
		["Chemistry set index"] = true,
		["Chemindex"] = true,
	["Enzyme index"] = true,
	["Fungus common name"] = true,
	["Given name"] = true,
		["First name"] = true,
		["Forename"] = true,
	["Greek myth index"] = true,
	["Lake index"] = true,
		["Lakeindex"] = true,
	["Locomotive index"] = true,
	["Media set index"] = true,
		["Media index"] = true,
	["Molecular formula index"] = true,
		["MolFormDisambig"] = true,
		["Molecular formula disambiguation"] = true,
		["MolFormIndex"] = true,
	["Mountain index"] = true,
		["Mountainindex"] = true,
	["Nickname"] = true,
	["Painting index"] = true,
	["Plant common name"] = true,
	["River index"] = true,
	["Road index"] = true,
		["Roadindex"] = true,
	["Ship index"] = true,
		["Shipindex"] = true,
	["Sport index"] = true,
		["Sportindex"] = true,
	["Storm index"] = true,
	["Surname"] = true,
		["Surnames"] = true,
		["DisambigName"] = true,
		["DisambigNm"] = true,
		["DisambigN"] = true,
}</text>
      <sha1>nn9l9r1pmrobxspg0rm1qgng5nzu19x</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype/rfd</title>
    <ns>828</ns>
    <id>227</id>
    <revision>
      <id>442</id>
      <parentid>441</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>441</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="640" sha1="9dx0g2c8g863kg6hcwx1wgsou16k45p" xml:space="preserve">-- This page contains a table of all RfD templates and their
-- redirects. Templates names are capitalized, and the Template: prefix is
-- removed. Templates are grouped with the main template first, followed by
-- its redirects.

return {
	-- Template forms (these should be substituted so we should rarely see these)
	["Redirect for discussion"] = true,
		["RFD"] = true,
		["RfD"] = true,
		["Rfd1"] = true,
		["Rfd-t"] = true,
		["Rfd"] = true,
		["Rfd-NPF"] = true,
		["Rfd-NPF/core"] = true,
	-- Module forms
	["#invoke:RfD"] = true,
	["&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:RfD"] = true, -- The form made by substituting RfD
}</text>
      <sha1>9dx0g2c8g863kg6hcwx1wgsou16k45p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/data/iana languages</title>
    <ns>828</ns>
    <id>228</id>
    <revision>
      <id>444</id>
      <parentid>443</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>443</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="222575" sha1="a37a7qn7q3pp5b1ubqv5ajmr80durdr" xml:space="preserve">-- File-Date: 2025-05-15
local active = {
	["aa"] = {"Afar"},
	["ab"] = {"Abkhazian"},
	["ae"] = {"Avestan"},
	["af"] = {"Afrikaans"},
	["ak"] = {"Akan"},
	["am"] = {"Amharic"},
	["an"] = {"Aragonese"},
	["ar"] = {"Arabic"},
	["as"] = {"Assamese"},
	["av"] = {"Avaric"},
	["ay"] = {"Aymara"},
	["az"] = {"Azerbaijani"},
	["ba"] = {"Bashkir"},
	["be"] = {"Belarusian"},
	["bg"] = {"Bulgarian"},
	["bh"] = {"Bihari languages"},
	["bi"] = {"Bislama"},
	["bm"] = {"Bambara"},
	["bn"] = {"Bengali", "Bangla"},
	["bo"] = {"Tibetan"},
	["br"] = {"Breton"},
	["bs"] = {"Bosnian"},
	["ca"] = {"Catalan", "Valencian"},
	["ce"] = {"Chechen"},
	["ch"] = {"Chamorro"},
	["co"] = {"Corsican"},
	["cr"] = {"Cree"},
	["cs"] = {"Czech"},
	["cu"] = {"Church Slavic", "Church Slavonic", "Old Bulgarian", "Old Church Slavonic", "Old Slavonic"},
	["cv"] = {"Chuvash"},
	["cy"] = {"Welsh"},
	["da"] = {"Danish"},
	["de"] = {"German"},
	["dv"] = {"Dhivehi", "Divehi", "Maldivian"},
	["dz"] = {"Dzongkha"},
	["ee"] = {"Ewe"},
	["el"] = {"Modern Greek (1453-)"},
	["en"] = {"English"},
	["eo"] = {"Esperanto"},
	["es"] = {"Spanish", "Castilian"},
	["et"] = {"Estonian"},
	["eu"] = {"Basque"},
	["fa"] = {"Persian"},
	["ff"] = {"Fulah"},
	["fi"] = {"Finnish"},
	["fj"] = {"Fijian"},
	["fo"] = {"Faroese"},
	["fr"] = {"French"},
	["fy"] = {"Western Frisian"},
	["ga"] = {"Irish"},
	["gd"] = {"Scottish Gaelic", "Gaelic"},
	["gl"] = {"Galician"},
	["gn"] = {"Guarani"},
	["gu"] = {"Gujarati"},
	["gv"] = {"Manx"},
	["ha"] = {"Hausa"},
	["he"] = {"Hebrew"},
	["hi"] = {"Hindi"},
	["ho"] = {"Hiri Motu"},
	["hr"] = {"Croatian"},
	["ht"] = {"Haitian", "Haitian Creole"},
	["hu"] = {"Hungarian"},
	["hy"] = {"Armenian"},
	["hz"] = {"Herero"},
	["ia"] = {"Interlingua (International Auxiliary Language Association)"},
	["id"] = {"Indonesian"},
	["ie"] = {"Interlingue", "Occidental"},
	["ig"] = {"Igbo"},
	["ii"] = {"Sichuan Yi", "Nuosu"},
	["ik"] = {"Inupiaq"},
	["io"] = {"Ido"},
	["is"] = {"Icelandic"},
	["it"] = {"Italian"},
	["iu"] = {"Inuktitut"},
	["ja"] = {"Japanese"},
	["jv"] = {"Javanese"},
	["ka"] = {"Georgian"},
	["kg"] = {"Kongo"},
	["ki"] = {"Kikuyu", "Gikuyu"},
	["kj"] = {"Kuanyama", "Kwanyama"},
	["kk"] = {"Kazakh"},
	["kl"] = {"Kalaallisut", "Greenlandic"},
	["km"] = {"Khmer", "Central Khmer"},
	["kn"] = {"Kannada"},
	["ko"] = {"Korean"},
	["kr"] = {"Kanuri"},
	["ks"] = {"Kashmiri"},
	["ku"] = {"Kurdish"},
	["kv"] = {"Komi"},
	["kw"] = {"Cornish"},
	["ky"] = {"Kirghiz", "Kyrgyz"},
	["la"] = {"Latin"},
	["lb"] = {"Luxembourgish", "Letzeburgesch"},
	["lg"] = {"Ganda", "Luganda"},
	["li"] = {"Limburgan", "Limburger", "Limburgish"},
	["ln"] = {"Lingala"},
	["lo"] = {"Lao"},
	["lt"] = {"Lithuanian"},
	["lu"] = {"Luba-Katanga"},
	["lv"] = {"Latvian"},
	["mg"] = {"Malagasy"},
	["mh"] = {"Marshallese"},
	["mi"] = {"Maori"},
	["mk"] = {"Macedonian"},
	["ml"] = {"Malayalam"},
	["mn"] = {"Mongolian"},
	["mr"] = {"Marathi"},
	["ms"] = {"Malay (macrolanguage)"},
	["mt"] = {"Maltese"},
	["my"] = {"Burmese"},
	["na"] = {"Nauru"},
	["nb"] = {"Norwegian Bokmål"},
	["nd"] = {"North Ndebele"},
	["ne"] = {"Nepali (macrolanguage)"},
	["ng"] = {"Ndonga"},
	["nl"] = {"Dutch", "Flemish"},
	["nn"] = {"Norwegian Nynorsk"},
	["no"] = {"Norwegian"},
	["nr"] = {"South Ndebele"},
	["nv"] = {"Navajo", "Navaho"},
	["ny"] = {"Nyanja", "Chewa", "Chichewa"},
	["oc"] = {"Occitan (post 1500)"},
	["oj"] = {"Ojibwa"},
	["om"] = {"Oromo"},
	["or"] = {"Oriya (macrolanguage)", "Odia (macrolanguage)"},
	["os"] = {"Ossetian", "Ossetic"},
	["pa"] = {"Panjabi", "Punjabi"},
	["pi"] = {"Pali"},
	["pl"] = {"Polish"},
	["ps"] = {"Pushto", "Pashto"},
	["pt"] = {"Portuguese"},
	["qu"] = {"Quechua"},
	["rm"] = {"Romansh"},
	["rn"] = {"Rundi"},
	["ro"] = {"Romanian", "Moldavian", "Moldovan"},
	["ru"] = {"Russian"},
	["rw"] = {"Kinyarwanda"},
	["sa"] = {"Sanskrit"},
	["sc"] = {"Sardinian"},
	["sd"] = {"Sindhi"},
	["se"] = {"Northern Sami"},
	["sg"] = {"Sango"},
	["sh"] = {"Serbo-Croatian"},
	["si"] = {"Sinhala", "Sinhalese"},
	["sk"] = {"Slovak"},
	["sl"] = {"Slovenian"},
	["sm"] = {"Samoan"},
	["sn"] = {"Shona"},
	["so"] = {"Somali"},
	["sq"] = {"Albanian"},
	["sr"] = {"Serbian"},
	["ss"] = {"Swati"},
	["st"] = {"Southern Sotho"},
	["su"] = {"Sundanese"},
	["sv"] = {"Swedish"},
	["sw"] = {"Swahili (macrolanguage)"},
	["ta"] = {"Tamil"},
	["te"] = {"Telugu"},
	["tg"] = {"Tajik"},
	["th"] = {"Thai"},
	["ti"] = {"Tigrinya"},
	["tk"] = {"Turkmen"},
	["tl"] = {"Tagalog"},
	["tn"] = {"Tswana"},
	["to"] = {"Tonga (Tonga Islands)"},
	["tr"] = {"Turkish"},
	["ts"] = {"Tsonga"},
	["tt"] = {"Tatar"},
	["tw"] = {"Twi"},
	["ty"] = {"Tahitian"},
	["ug"] = {"Uighur", "Uyghur"},
	["uk"] = {"Ukrainian"},
	["ur"] = {"Urdu"},
	["uz"] = {"Uzbek"},
	["ve"] = {"Venda"},
	["vi"] = {"Vietnamese"},
	["vo"] = {"Volapük"},
	["wa"] = {"Walloon"},
	["wo"] = {"Wolof"},
	["xh"] = {"Xhosa"},
	["yi"] = {"Yiddish"},
	["yo"] = {"Yoruba"},
	["za"] = {"Zhuang", "Chuang"},
	["zh"] = {"Chinese"},
	["zu"] = {"Zulu"},
	["aaa"] = {"Ghotuo"},
	["aab"] = {"Alumu-Tesu"},
	["aac"] = {"Ari"},
	["aad"] = {"Amal"},
	["aae"] = {"Arbëreshë Albanian"},
	["aaf"] = {"Aranadan"},
	["aag"] = {"Ambrak"},
	["aah"] = {"Abu' Arapesh"},
	["aai"] = {"Arifama-Miniafia"},
	["aak"] = {"Ankave"},
	["aal"] = {"Afade"},
	["aan"] = {"Anambé"},
	["aao"] = {"Algerian Saharan Arabic"},
	["aap"] = {"Pará Arára"},
	["aaq"] = {"Eastern Abnaki"},
	["aas"] = {"Aasáx"},
	["aat"] = {"Arvanitika Albanian"},
	["aau"] = {"Abau"},
	["aav"] = {"Austro-Asiatic languages"},
	["aaw"] = {"Solong"},
	["aax"] = {"Mandobo Atas"},
	["aaz"] = {"Amarasi"},
	["aba"] = {"Abé"},
	["abb"] = {"Bankon"},
	["abc"] = {"Ambala Ayta"},
	["abd"] = {"Manide"},
	["abe"] = {"Western Abnaki"},
	["abf"] = {"Abai Sungai"},
	["abg"] = {"Abaga"},
	["abh"] = {"Tajiki Arabic"},
	["abi"] = {"Abidji"},
	["abj"] = {"Aka-Bea"},
	["abl"] = {"Lampung Nyo"},
	["abm"] = {"Abanyom"},
	["abn"] = {"Abua"},
	["abo"] = {"Abon"},
	["abp"] = {"Abellen Ayta"},
	["abq"] = {"Abaza"},
	["abr"] = {"Abron"},
	["abs"] = {"Ambonese Malay"},
	["abt"] = {"Ambulas"},
	["abu"] = {"Abure"},
	["abv"] = {"Baharna Arabic"},
	["abw"] = {"Pal"},
	["abx"] = {"Inabaknon"},
	["aby"] = {"Aneme Wake"},
	["abz"] = {"Abui"},
	["aca"] = {"Achagua"},
	["acb"] = {"Áncá"},
	["acd"] = {"Gikyode"},
	["ace"] = {"Achinese"},
	["acf"] = {"Saint Lucian Creole French"},
	["ach"] = {"Acoli"},
	["aci"] = {"Aka-Cari"},
	["ack"] = {"Aka-Kora"},
	["acl"] = {"Akar-Bale"},
	["acm"] = {"Mesopotamian Arabic"},
	["acn"] = {"Achang"},
	["acp"] = {"Eastern Acipa"},
	["acq"] = {"Ta'izzi-Adeni Arabic"},
	["acr"] = {"Achi"},
	["acs"] = {"Acroá"},
	["act"] = {"Achterhoeks"},
	["acu"] = {"Achuar-Shiwiar"},
	["acv"] = {"Achumawi"},
	["acw"] = {"Hijazi Arabic"},
	["acx"] = {"Omani Arabic"},
	["acy"] = {"Cypriot Arabic"},
	["acz"] = {"Acheron"},
	["ada"] = {"Adangme"},
	["adb"] = {"Atauran"},
	["add"] = {"Lidzonka", "Dzodinka"},
	["ade"] = {"Adele"},
	["adf"] = {"Dhofari Arabic"},
	["adg"] = {"Andegerebinha"},
	["adh"] = {"Adhola"},
	["adi"] = {"Adi"},
	["adj"] = {"Adioukrou"},
	["adl"] = {"Galo"},
	["adn"] = {"Adang"},
	["ado"] = {"Abu"},
	["adq"] = {"Adangbe"},
	["adr"] = {"Adonara"},
	["ads"] = {"Adamorobe Sign Language"},
	["adt"] = {"Adnyamathanha"},
	["adu"] = {"Aduge"},
	["adw"] = {"Amundava"},
	["adx"] = {"Amdo Tibetan"},
	["ady"] = {"Adyghe", "Adygei"},
	["adz"] = {"Adzera"},
	["aea"] = {"Areba"},
	["aeb"] = {"Tunisian Arabic"},
	["aec"] = {"Saidi Arabic"},
	["aed"] = {"Argentine Sign Language"},
	["aee"] = {"Northeast Pashai", "Northeast Pashayi"},
	["aek"] = {"Haeke"},
	["ael"] = {"Ambele"},
	["aem"] = {"Arem"},
	["aen"] = {"Armenian Sign Language"},
	["aeq"] = {"Aer"},
	["aer"] = {"Eastern Arrernte"},
	["aes"] = {"Alsea"},
	["aeu"] = {"Akeu"},
	["aew"] = {"Ambakich"},
	["aey"] = {"Amele"},
	["aez"] = {"Aeka"},
	["afa"] = {"Afro-Asiatic languages"},
	["afb"] = {"Gulf Arabic"},
	["afd"] = {"Andai"},
	["afe"] = {"Putukwam"},
	["afg"] = {"Afghan Sign Language"},
	["afh"] = {"Afrihili"},
	["afi"] = {"Akrukay", "Chini"},
	["afk"] = {"Nanubae"},
	["afn"] = {"Defaka"},
	["afo"] = {"Eloyi"},
	["afp"] = {"Tapei"},
	["afs"] = {"Afro-Seminole Creole"},
	["aft"] = {"Afitti"},
	["afu"] = {"Awutu"},
	["afz"] = {"Obokuitai"},
	["aga"] = {"Aguano"},
	["agb"] = {"Legbo"},
	["agc"] = {"Agatu"},
	["agd"] = {"Agarabi"},
	["age"] = {"Angal"},
	["agf"] = {"Arguni"},
	["agg"] = {"Angor"},
	["agh"] = {"Ngelima"},
	["agi"] = {"Agariya"},
	["agj"] = {"Argobba"},
	["agk"] = {"Isarog Agta"},
	["agl"] = {"Fembe"},
	["agm"] = {"Angaataha"},
	["agn"] = {"Agutaynen"},
	["ago"] = {"Tainae"},
	["agq"] = {"Aghem"},
	["agr"] = {"Aguaruna"},
	["ags"] = {"Esimbi"},
	["agt"] = {"Central Cagayan Agta"},
	["agu"] = {"Aguacateco"},
	["agv"] = {"Remontado Dumagat"},
	["agw"] = {"Kahua"},
	["agx"] = {"Aghul"},
	["agy"] = {"Southern Alta"},
	["agz"] = {"Mt. Iriga Agta"},
	["aha"] = {"Ahanta"},
	["ahb"] = {"Axamb"},
	["ahg"] = {"Qimant"},
	["ahh"] = {"Aghu"},
	["ahi"] = {"Tiagbamrin Aizi"},
	["ahk"] = {"Akha"},
	["ahl"] = {"Igo"},
	["ahm"] = {"Mobumrin Aizi"},
	["ahn"] = {"Àhàn"},
	["aho"] = {"Ahom"},
	["ahp"] = {"Aproumu Aizi"},
	["ahr"] = {"Ahirani"},
	["ahs"] = {"Ashe"},
	["aht"] = {"Ahtena"},
	["aia"] = {"Arosi"},
	["aib"] = {"Ainu (China)"},
	["aic"] = {"Ainbai"},
	["aid"] = {"Alngith"},
	["aie"] = {"Amara"},
	["aif"] = {"Agi"},
	["aig"] = {"Antigua and Barbuda Creole English"},
	["aih"] = {"Ai-Cham"},
	["aii"] = {"Assyrian Neo-Aramaic"},
	["aij"] = {"Lishanid Noshan"},
	["aik"] = {"Ake"},
	["ail"] = {"Aimele"},
	["aim"] = {"Aimol"},
	["ain"] = {"Ainu (Japan)"},
	["aio"] = {"Aiton"},
	["aip"] = {"Burumakok"},
	["aiq"] = {"Aimaq"},
	["air"] = {"Airoran"},
	["ait"] = {"Arikem"},
	["aiw"] = {"Aari"},
	["aix"] = {"Aighon"},
	["aiy"] = {"Ali"},
	["aja"] = {"Aja (South Sudan)"},
	["ajg"] = {"Aja (Benin)"},
	["aji"] = {"Ajië"},
	["ajn"] = {"Andajin"},
	["ajs"] = {"Algerian Jewish Sign Language"},
	["aju"] = {"Judeo-Moroccan Arabic"},
	["ajw"] = {"Ajawa"},
	["ajz"] = {"Amri Karbi"},
	["akb"] = {"Batak Angkola"},
	["akc"] = {"Mpur"},
	["akd"] = {"Ukpet-Ehom"},
	["ake"] = {"Akawaio"},
	["akf"] = {"Akpa"},
	["akg"] = {"Anakalangu"},
	["akh"] = {"Angal Heneng"},
	["aki"] = {"Aiome"},
	["akj"] = {"Aka-Jeru"},
	["akk"] = {"Akkadian"},
	["akl"] = {"Aklanon"},
	["akm"] = {"Aka-Bo"},
	["ako"] = {"Akurio"},
	["akp"] = {"Siwu"},
	["akq"] = {"Ak"},
	["akr"] = {"Araki"},
	["aks"] = {"Akaselem"},
	["akt"] = {"Akolet"},
	["aku"] = {"Akum"},
	["akv"] = {"Akhvakh"},
	["akw"] = {"Akwa"},
	["akx"] = {"Aka-Kede"},
	["aky"] = {"Aka-Kol"},
	["akz"] = {"Alabama"},
	["ala"] = {"Alago"},
	["alc"] = {"Qawasqar"},
	["ald"] = {"Alladian"},
	["ale"] = {"Aleut"},
	["alf"] = {"Alege"},
	["alg"] = {"Algonquian languages"},
	["alh"] = {"Alawa"},
	["ali"] = {"Amaimon"},
	["alj"] = {"Alangan"},
	["alk"] = {"Alak"},
	["all"] = {"Allar"},
	["alm"] = {"Amblong"},
	["aln"] = {"Gheg Albanian"},
	["alo"] = {"Larike-Wakasihu"},
	["alp"] = {"Alune"},
	["alq"] = {"Algonquin"},
	["alr"] = {"Alutor"},
	["als"] = {"Tosk Albanian"},
	["alt"] = {"Southern Altai"},
	["alu"] = {"'Are'are"},
	["alv"] = {"Atlantic-Congo languages"},
	["alw"] = {"Alaba-K’abeena", "Wanbasana"},
	["alx"] = {"Amol"},
	["aly"] = {"Alyawarr"},
	["alz"] = {"Alur"},
	["ama"] = {"Amanayé"},
	["amb"] = {"Ambo"},
	["amc"] = {"Amahuaca"},
	["ame"] = {"Yanesha'"},
	["amf"] = {"Hamer-Banna"},
	["amg"] = {"Amurdak"},
	["ami"] = {"Amis"},
	["amj"] = {"Amdang"},
	["amk"] = {"Ambai"},
	["aml"] = {"War-Jaintia"},
	["amm"] = {"Ama (Papua New Guinea)"},
	["amn"] = {"Amanab"},
	["amo"] = {"Amo"},
	["amp"] = {"Alamblak"},
	["amq"] = {"Amahai"},
	["amr"] = {"Amarakaeri"},
	["ams"] = {"Southern Amami-Oshima"},
	["amt"] = {"Amto"},
	["amu"] = {"Guerrero Amuzgo"},
	["amv"] = {"Ambelau"},
	["amw"] = {"Western Neo-Aramaic"},
	["amx"] = {"Anmatyerre"},
	["amy"] = {"Ami"},
	["amz"] = {"Atampaya"},
	["ana"] = {"Andaqui"},
	["anb"] = {"Andoa"},
	["anc"] = {"Ngas"},
	["and"] = {"Ansus"},
	["ane"] = {"Xârâcùù"},
	["anf"] = {"Animere"},
	["ang"] = {"Old English (ca. 450-1100)"},
	["anh"] = {"Nend"},
	["ani"] = {"Andi"},
	["anj"] = {"Anor"},
	["ank"] = {"Goemai"},
	["anl"] = {"Anu-Hkongso Chin"},
	["anm"] = {"Anal"},
	["ann"] = {"Obolo"},
	["ano"] = {"Andoque"},
	["anp"] = {"Angika"},
	["anq"] = {"Jarawa (India)"},
	["anr"] = {"Andh"},
	["ans"] = {"Anserma"},
	["ant"] = {"Antakarinya", "Antikarinya"},
	["anu"] = {"Anuak"},
	["anv"] = {"Denya"},
	["anw"] = {"Anaang"},
	["anx"] = {"Andra-Hus"},
	["any"] = {"Anyin"},
	["anz"] = {"Anem"},
	["aoa"] = {"Angolar"},
	["aob"] = {"Abom"},
	["aoc"] = {"Pemon"},
	["aod"] = {"Andarum"},
	["aoe"] = {"Angal Enen"},
	["aof"] = {"Bragat"},
	["aog"] = {"Angoram"},
	["aoi"] = {"Anindilyakwa"},
	["aoj"] = {"Mufian"},
	["aok"] = {"Arhö"},
	["aol"] = {"Alor"},
	["aom"] = {"Ömie"},
	["aon"] = {"Bumbita Arapesh"},
	["aor"] = {"Aore"},
	["aos"] = {"Taikat"},
	["aot"] = {"Atong (India)", "A'tong"},
	["aou"] = {"A'ou"},
	["aox"] = {"Atorada"},
	["aoz"] = {"Uab Meto"},
	["apa"] = {"Apache languages"},
	["apb"] = {"Sa'a"},
	["apc"] = {"Levantine Arabic"},
	["apd"] = {"Sudanese Arabic"},
	["ape"] = {"Bukiyip"},
	["apf"] = {"Pahanan Agta"},
	["apg"] = {"Ampanang"},
	["aph"] = {"Athpariya"},
	["api"] = {"Apiaká"},
	["apj"] = {"Jicarilla Apache"},
	["apk"] = {"Kiowa Apache"},
	["apl"] = {"Lipan Apache"},
	["apm"] = {"Mescalero-Chiricahua Apache"},
	["apn"] = {"Apinayé"},
	["apo"] = {"Ambul"},
	["app"] = {"Apma"},
	["apq"] = {"A-Pucikwar"},
	["apr"] = {"Arop-Lokep"},
	["aps"] = {"Arop-Sissano"},
	["apt"] = {"Apatani"},
	["apu"] = {"Apurinã"},
	["apv"] = {"Alapmunte"},
	["apw"] = {"Western Apache"},
	["apx"] = {"Aputai"},
	["apy"] = {"Apalaí"},
	["apz"] = {"Safeyoka"},
	["aqa"] = {"Alacalufan languages"},
	["aqc"] = {"Archi"},
	["aqd"] = {"Ampari Dogon"},
	["aqg"] = {"Arigidi"},
	["aqk"] = {"Aninka"},
	["aql"] = {"Algic languages"},
	["aqm"] = {"Atohwaim"},
	["aqn"] = {"Northern Alta"},
	["aqp"] = {"Atakapa"},
	["aqr"] = {"Arhâ"},
	["aqt"] = {"Angaité"},
	["aqz"] = {"Akuntsu"},
	["arb"] = {"Standard Arabic"},
	["arc"] = {"Official Aramaic (700-300 BCE)", "Imperial Aramaic (700-300 BCE)"},
	["ard"] = {"Arabana"},
	["are"] = {"Western Arrarnta"},
	["arh"] = {"Arhuaco"},
	["ari"] = {"Arikara"},
	["arj"] = {"Arapaso"},
	["ark"] = {"Arikapú"},
	["arl"] = {"Arabela"},
	["arn"] = {"Mapudungun", "Mapuche"},
	["aro"] = {"Araona"},
	["arp"] = {"Arapaho"},
	["arq"] = {"Algerian Arabic"},
	["arr"] = {"Karo (Brazil)"},
	["ars"] = {"Najdi Arabic"},
	["art"] = {"Artificial languages"},
	["aru"] = {"Aruá (Amazonas State)", "Arawá"},
	["arv"] = {"Arbore"},
	["arw"] = {"Arawak"},
	["arx"] = {"Aruá (Rodonia State)"},
	["ary"] = {"Moroccan Arabic"},
	["arz"] = {"Egyptian Arabic"},
	["asa"] = {"Asu (Tanzania)"},
	["asb"] = {"Assiniboine"},
	["asc"] = {"Casuarina Coast Asmat"},
	["ase"] = {"American Sign Language"},
	["asf"] = {"Auslan", "Australian Sign Language"},
	["asg"] = {"Cishingini"},
	["ash"] = {"Abishira"},
	["asi"] = {"Buruwai"},
	["asj"] = {"Sari"},
	["ask"] = {"Ashkun"},
	["asl"] = {"Asilulu"},
	["asn"] = {"Xingú Asuriní"},
	["aso"] = {"Dano"},
	["asp"] = {"Algerian Sign Language"},
	["asq"] = {"Austrian Sign Language"},
	["asr"] = {"Asuri"},
	["ass"] = {"Ipulo"},
	["ast"] = {"Asturian", "Asturleonese", "Bable", "Leonese"},
	["asu"] = {"Tocantins Asurini"},
	["asv"] = {"Asoa"},
	["asw"] = {"Australian Aborigines Sign Language"},
	["asx"] = {"Muratayak"},
	["asy"] = {"Yaosakor Asmat"},
	["asz"] = {"As"},
	["ata"] = {"Pele-Ata"},
	["atb"] = {"Zaiwa"},
	["atc"] = {"Atsahuaca"},
	["atd"] = {"Ata Manobo"},
	["ate"] = {"Atemble"},
	["atg"] = {"Ivbie North-Okpela-Arhe"},
	["ath"] = {"Athapascan languages"},
	["ati"] = {"Attié"},
	["atj"] = {"Atikamekw"},
	["atk"] = {"Ati"},
	["atl"] = {"Mt. Iraya Agta"},
	["atm"] = {"Ata"},
	["atn"] = {"Ashtiani"},
	["ato"] = {"Atong (Cameroon)"},
	["atp"] = {"Pudtol Atta"},
	["atq"] = {"Aralle-Tabulahan"},
	["atr"] = {"Waimiri-Atroari"},
	["ats"] = {"Gros Ventre"},
	["att"] = {"Pamplona Atta"},
	["atu"] = {"Reel"},
	["atv"] = {"Northern Altai"},
	["atw"] = {"Atsugewi"},
	["atx"] = {"Arutani"},
	["aty"] = {"Aneityum"},
	["atz"] = {"Arta"},
	["aua"] = {"Asumboa"},
	["aub"] = {"Alugu"},
	["auc"] = {"Waorani"},
	["aud"] = {"Anuta"},
	["auf"] = {"Arauan languages"},
	["aug"] = {"Aguna"},
	["auh"] = {"Aushi"},
	["aui"] = {"Anuki"},
	["auj"] = {"Awjilah"},
	["auk"] = {"Heyo"},
	["aul"] = {"Aulua"},
	["aum"] = {"Asu (Nigeria)"},
	["aun"] = {"Molmo One"},
	["auo"] = {"Auyokawa"},
	["aup"] = {"Makayam"},
	["auq"] = {"Anus", "Korur"},
	["aur"] = {"Aruek"},
	["aus"] = {"Australian languages"},
	["aut"] = {"Austral"},
	["auu"] = {"Auye"},
	["auw"] = {"Awyi"},
	["aux"] = {"Aurá"},
	["auy"] = {"Awiyaana"},
	["auz"] = {"Uzbeki Arabic"},
	["avb"] = {"Avau"},
	["avd"] = {"Alviri-Vidari"},
	["avi"] = {"Avikam"},
	["avk"] = {"Kotava"},
	["avl"] = {"Eastern Egyptian Bedawi Arabic"},
	["avm"] = {"Angkamuthi"},
	["avn"] = {"Avatime"},
	["avo"] = {"Agavotaguerra"},
	["avs"] = {"Aushiri"},
	["avt"] = {"Au"},
	["avu"] = {"Avokaya"},
	["avv"] = {"Avá-Canoeiro"},
	["awa"] = {"Awadhi"},
	["awb"] = {"Awa (Papua New Guinea)"},
	["awc"] = {"Cicipu"},
	["awd"] = {"Arawakan languages"},
	["awe"] = {"Awetí"},
	["awg"] = {"Anguthimri"},
	["awh"] = {"Awbono"},
	["awi"] = {"Aekyom"},
	["awk"] = {"Awabakal"},
	["awm"] = {"Arawum"},
	["awn"] = {"Awngi"},
	["awo"] = {"Awak"},
	["awr"] = {"Awera"},
	["aws"] = {"South Awyu"},
	["awt"] = {"Araweté"},
	["awu"] = {"Central Awyu"},
	["awv"] = {"Jair Awyu"},
	["aww"] = {"Awun"},
	["awx"] = {"Awara"},
	["awy"] = {"Edera Awyu"},
	["axb"] = {"Abipon"},
	["axe"] = {"Ayerrerenge"},
	["axg"] = {"Mato Grosso Arára"},
	["axk"] = {"Yaka (Central African Republic)"},
	["axl"] = {"Lower Southern Aranda"},
	["axm"] = {"Middle Armenian"},
	["axx"] = {"Xârâgurè"},
	["aya"] = {"Awar"},
	["ayb"] = {"Ayizo Gbe"},
	["ayc"] = {"Southern Aymara"},
	["ayd"] = {"Ayabadhu"},
	["aye"] = {"Ayere"},
	["ayg"] = {"Ginyanga"},
	["ayh"] = {"Hadrami Arabic"},
	["ayi"] = {"Leyigha"},
	["ayk"] = {"Akuku"},
	["ayl"] = {"Libyan Arabic"},
	["ayn"] = {"Sanaani Arabic"},
	["ayo"] = {"Ayoreo"},
	["ayp"] = {"North Mesopotamian Arabic"},
	["ayq"] = {"Ayi (Papua New Guinea)"},
	["ayr"] = {"Central Aymara"},
	["ays"] = {"Sorsogon Ayta"},
	["ayt"] = {"Magbukun Ayta"},
	["ayu"] = {"Ayu"},
	["ayz"] = {"Mai Brat"},
	["aza"] = {"Azha"},
	["azb"] = {"South Azerbaijani"},
	["azc"] = {"Uto-Aztecan languages"},
	["azd"] = {"Eastern Durango Nahuatl"},
	["azg"] = {"San Pedro Amuzgos Amuzgo"},
	["azj"] = {"North Azerbaijani"},
	["azm"] = {"Ipalapa Amuzgo"},
	["azn"] = {"Western Durango Nahuatl"},
	["azo"] = {"Awing"},
	["azt"] = {"Faire Atta"},
	["azz"] = {"Highland Puebla Nahuatl"},
	["baa"] = {"Babatana"},
	["bab"] = {"Bainouk-Gunyuño"},
	["bac"] = {"Badui"},
	["bad"] = {"Banda languages"},
	["bae"] = {"Baré"},
	["baf"] = {"Nubaca"},
	["bag"] = {"Tuki"},
	["bah"] = {"Bahamas Creole English"},
	["bai"] = {"Bamileke languages"},
	["baj"] = {"Barakai"},
	["bal"] = {"Baluchi"},
	["ban"] = {"Balinese"},
	["bao"] = {"Waimaha"},
	["bap"] = {"Bantawa"},
	["bar"] = {"Bavarian"},
	["bas"] = {"Basa (Cameroon)"},
	["bat"] = {"Baltic languages"},
	["bau"] = {"Bada (Nigeria)"},
	["bav"] = {"Vengo"},
	["baw"] = {"Bambili-Bambui"},
	["bax"] = {"Bamun"},
	["bay"] = {"Batuley"},
	["bba"] = {"Baatonum"},
	["bbb"] = {"Barai"},
	["bbc"] = {"Batak Toba"},
	["bbd"] = {"Bau"},
	["bbe"] = {"Bangba"},
	["bbf"] = {"Baibai"},
	["bbg"] = {"Barama"},
	["bbh"] = {"Bugan"},
	["bbi"] = {"Barombi"},
	["bbj"] = {"Ghomálá'"},
	["bbk"] = {"Babanki"},
	["bbl"] = {"Bats"},
	["bbm"] = {"Babango"},
	["bbn"] = {"Uneapa"},
	["bbo"] = {"Northern Bobo Madaré", "Konabéré"},
	["bbp"] = {"West Central Banda"},
	["bbq"] = {"Bamali"},
	["bbr"] = {"Girawa"},
	["bbs"] = {"Bakpinka"},
	["bbt"] = {"Mburku"},
	["bbu"] = {"Kulung (Nigeria)"},
	["bbv"] = {"Karnai"},
	["bbw"] = {"Baba"},
	["bbx"] = {"Bubia"},
	["bby"] = {"Befang"},
	["bca"] = {"Central Bai"},
	["bcb"] = {"Bainouk-Samik"},
	["bcc"] = {"Southern Balochi"},
	["bcd"] = {"North Babar"},
	["bce"] = {"Bamenyam"},
	["bcf"] = {"Bamu"},
	["bcg"] = {"Baga Pokur"},
	["bch"] = {"Bariai"},
	["bci"] = {"Baoulé"},
	["bcj"] = {"Bardi"},
	["bck"] = {"Bunuba"},
	["bcl"] = {"Central Bikol"},
	["bcm"] = {"Bannoni"},
	["bcn"] = {"Bali (Nigeria)"},
	["bco"] = {"Kaluli"},
	["bcp"] = {"Bali (Democratic Republic of Congo)"},
	["bcq"] = {"Bench"},
	["bcr"] = {"Babine"},
	["bcs"] = {"Kohumono"},
	["bct"] = {"Bendi"},
	["bcu"] = {"Awad Bing"},
	["bcv"] = {"Shoo-Minda-Nye"},
	["bcw"] = {"Bana"},
	["bcy"] = {"Bacama"},
	["bcz"] = {"Bainouk-Gunyaamolo"},
	["bda"] = {"Bayot"},
	["bdb"] = {"Basap"},
	["bdc"] = {"Emberá-Baudó"},
	["bdd"] = {"Bunama"},
	["bde"] = {"Bade"},
	["bdf"] = {"Biage"},
	["bdg"] = {"Bonggi"},
	["bdh"] = {"Baka (South Sudan)"},
	["bdi"] = {"Burun"},
	["bdj"] = {"Bai (South Sudan)", "Bai"},
	["bdk"] = {"Budukh"},
	["bdl"] = {"Indonesian Bajau"},
	["bdm"] = {"Buduma"},
	["bdn"] = {"Baldemu"},
	["bdo"] = {"Morom"},
	["bdp"] = {"Bende"},
	["bdq"] = {"Bahnar"},
	["bdr"] = {"West Coast Bajau"},
	["bds"] = {"Burunge"},
	["bdt"] = {"Bokoto"},
	["bdu"] = {"Oroko"},
	["bdv"] = {"Bodo Parja"},
	["bdw"] = {"Baham"},
	["bdx"] = {"Budong-Budong"},
	["bdy"] = {"Bandjalang"},
	["bdz"] = {"Badeshi"},
	["bea"] = {"Beaver"},
	["beb"] = {"Bebele"},
	["bec"] = {"Iceve-Maci"},
	["bed"] = {"Bedoanas"},
	["bee"] = {"Byangsi"},
	["bef"] = {"Benabena"},
	["beg"] = {"Belait"},
	["beh"] = {"Biali"},
	["bei"] = {"Bekati'"},
	["bej"] = {"Beja", "Bedawiyet"},
	["bek"] = {"Bebeli"},
	["bem"] = {"Bemba (Zambia)"},
	["beo"] = {"Beami"},
	["bep"] = {"Besoa"},
	["beq"] = {"Beembe"},
	["ber"] = {"Berber languages"},
	["bes"] = {"Besme"},
	["bet"] = {"Guiberoua Béte"},
	["beu"] = {"Blagar"},
	["bev"] = {"Daloa Bété"},
	["bew"] = {"Betawi"},
	["bex"] = {"Jur Modo"},
	["bey"] = {"Beli (Papua New Guinea)"},
	["bez"] = {"Bena (Tanzania)"},
	["bfa"] = {"Bari"},
	["bfb"] = {"Pauri Bareli"},
	["bfc"] = {"Panyi Bai", "Northern Bai"},
	["bfd"] = {"Bafut"},
	["bfe"] = {"Betaf", "Tena"},
	["bff"] = {"Bofi"},
	["bfg"] = {"Busang Kayan"},
	["bfh"] = {"Blafe"},
	["bfi"] = {"British Sign Language"},
	["bfj"] = {"Bafanji"},
	["bfk"] = {"Ban Khor Sign Language"},
	["bfl"] = {"Banda-Ndélé"},
	["bfm"] = {"Mmen"},
	["bfn"] = {"Bunak"},
	["bfo"] = {"Malba Birifor"},
	["bfp"] = {"Beba"},
	["bfq"] = {"Badaga"},
	["bfr"] = {"Bazigar"},
	["bfs"] = {"Southern Bai"},
	["bft"] = {"Balti"},
	["bfu"] = {"Gahri"},
	["bfw"] = {"Bondo"},
	["bfx"] = {"Bantayanon"},
	["bfy"] = {"Bagheli"},
	["bfz"] = {"Mahasu Pahari"},
	["bga"] = {"Gwamhi-Wuri"},
	["bgb"] = {"Bobongko"},
	["bgc"] = {"Haryanvi"},
	["bgd"] = {"Rathwi Bareli"},
	["bge"] = {"Bauria"},
	["bgf"] = {"Bangandu"},
	["bgg"] = {"Bugun"},
	["bgi"] = {"Giangan"},
	["bgj"] = {"Bangolan"},
	["bgk"] = {"Bit", "Buxinhua"},
	["bgl"] = {"Bo (Laos)"},
	["bgn"] = {"Western Balochi"},
	["bgo"] = {"Baga Koga"},
	["bgp"] = {"Eastern Balochi"},
	["bgq"] = {"Bagri"},
	["bgr"] = {"Bawm Chin"},
	["bgs"] = {"Tagabawa"},
	["bgt"] = {"Bughotu"},
	["bgu"] = {"Mbongno"},
	["bgv"] = {"Warkay-Bipim"},
	["bgw"] = {"Bhatri"},
	["bgx"] = {"Balkan Gagauz Turkish"},
	["bgy"] = {"Benggoi"},
	["bgz"] = {"Banggai"},
	["bha"] = {"Bharia"},
	["bhb"] = {"Bhili"},
	["bhc"] = {"Biga"},
	["bhd"] = {"Bhadrawahi"},
	["bhe"] = {"Bhaya"},
	["bhf"] = {"Odiai"},
	["bhg"] = {"Binandere"},
	["bhh"] = {"Bukharic"},
	["bhi"] = {"Bhilali"},
	["bhj"] = {"Bahing"},
	["bhl"] = {"Bimin"},
	["bhm"] = {"Bathari"},
	["bhn"] = {"Bohtan Neo-Aramaic"},
	["bho"] = {"Bhojpuri"},
	["bhp"] = {"Bima"},
	["bhq"] = {"Tukang Besi South"},
	["bhr"] = {"Bara Malagasy"},
	["bhs"] = {"Buwal"},
	["bht"] = {"Bhattiyali"},
	["bhu"] = {"Bhunjia"},
	["bhv"] = {"Bahau"},
	["bhw"] = {"Biak"},
	["bhx"] = {"Bhalay"},
	["bhy"] = {"Bhele"},
	["bhz"] = {"Bada (Indonesia)"},
	["bia"] = {"Badimaya"},
	["bib"] = {"Bissa", "Bisa"},
	["bid"] = {"Bidiyo"},
	["bie"] = {"Bepour"},
	["bif"] = {"Biafada"},
	["big"] = {"Biangai"},
	["bik"] = {"Bikol"},
	["bil"] = {"Bile"},
	["bim"] = {"Bimoba"},
	["bin"] = {"Bini", "Edo"},
	["bio"] = {"Nai"},
	["bip"] = {"Bila"},
	["biq"] = {"Bipi"},
	["bir"] = {"Bisorio"},
	["bit"] = {"Berinomo"},
	["biu"] = {"Biete"},
	["biv"] = {"Southern Birifor"},
	["biw"] = {"Kol (Cameroon)"},
	["bix"] = {"Bijori"},
	["biy"] = {"Birhor"},
	["biz"] = {"Baloi"},
	["bja"] = {"Budza"},
	["bjb"] = {"Banggarla"},
	["bjc"] = {"Bariji"},
	["bje"] = {"Biao-Jiao Mien"},
	["bjf"] = {"Barzani Jewish Neo-Aramaic"},
	["bjg"] = {"Bidyogo"},
	["bjh"] = {"Bahinemo"},
	["bji"] = {"Burji"},
	["bjj"] = {"Kanauji"},
	["bjk"] = {"Barok"},
	["bjl"] = {"Bulu (Papua New Guinea)"},
	["bjm"] = {"Bajelani"},
	["bjn"] = {"Banjar"},
	["bjo"] = {"Mid-Southern Banda"},
	["bjp"] = {"Fanamaket"},
	["bjr"] = {"Binumarien"},
	["bjs"] = {"Bajan"},
	["bjt"] = {"Balanta-Ganja"},
	["bju"] = {"Busuu"},
	["bjv"] = {"Bedjond"},
	["bjw"] = {"Bakwé"},
	["bjx"] = {"Banao Itneg"},
	["bjy"] = {"Bayali"},
	["bjz"] = {"Baruga"},
	["bka"] = {"Kyak"},
	["bkc"] = {"Baka (Cameroon)"},
	["bkd"] = {"Binukid", "Talaandig"},
	["bkf"] = {"Beeke"},
	["bkg"] = {"Buraka"},
	["bkh"] = {"Bakoko"},
	["bki"] = {"Baki"},
	["bkj"] = {"Pande"},
	["bkk"] = {"Brokskat"},
	["bkl"] = {"Berik"},
	["bkm"] = {"Kom (Cameroon)"},
	["bkn"] = {"Bukitan"},
	["bko"] = {"Kwa'"},
	["bkp"] = {"Boko (Democratic Republic of Congo)"},
	["bkq"] = {"Bakairí"},
	["bkr"] = {"Bakumpai"},
	["bks"] = {"Northern Sorsoganon"},
	["bkt"] = {"Boloki"},
	["bku"] = {"Buhid"},
	["bkv"] = {"Bekwarra"},
	["bkw"] = {"Bekwel"},
	["bkx"] = {"Baikeno"},
	["bky"] = {"Bokyi"},
	["bkz"] = {"Bungku"},
	["bla"] = {"Siksika"},
	["blb"] = {"Bilua"},
	["blc"] = {"Bella Coola"},
	["bld"] = {"Bolango"},
	["ble"] = {"Balanta-Kentohe"},
	["blf"] = {"Buol"},
	["blh"] = {"Kuwaa"},
	["bli"] = {"Bolia"},
	["blj"] = {"Bolongan"},
	["blk"] = {"Pa'o Karen", "Pa'O"},
	["bll"] = {"Biloxi"},
	["blm"] = {"Beli (South Sudan)"},
	["bln"] = {"Southern Catanduanes Bikol"},
	["blo"] = {"Anii"},
	["blp"] = {"Blablanga"},
	["blq"] = {"Baluan-Pam"},
	["blr"] = {"Blang"},
	["bls"] = {"Balaesang"},
	["blt"] = {"Tai Dam"},
	["blv"] = {"Kibala", "Bolo"},
	["blw"] = {"Balangao"},
	["blx"] = {"Mag-Indi Ayta"},
	["bly"] = {"Notre"},
	["blz"] = {"Balantak"},
	["bma"] = {"Lame"},
	["bmb"] = {"Bembe"},
	["bmc"] = {"Biem"},
	["bmd"] = {"Baga Manduri"},
	["bme"] = {"Limassa"},
	["bmf"] = {"Bom-Kim"},
	["bmg"] = {"Bamwe"},
	["bmh"] = {"Kein"},
	["bmi"] = {"Bagirmi"},
	["bmj"] = {"Bote-Majhi"},
	["bmk"] = {"Ghayavi"},
	["bml"] = {"Bomboli"},
	["bmm"] = {"Northern Betsimisaraka Malagasy"},
	["bmn"] = {"Bina (Papua New Guinea)"},
	["bmo"] = {"Bambalang"},
	["bmp"] = {"Bulgebi"},
	["bmq"] = {"Bomu"},
	["bmr"] = {"Muinane"},
	["bms"] = {"Bilma Kanuri"},
	["bmt"] = {"Biao Mon"},
	["bmu"] = {"Somba-Siawari"},
	["bmv"] = {"Bum"},
	["bmw"] = {"Bomwali"},
	["bmx"] = {"Baimak"},
	["bmz"] = {"Baramu"},
	["bna"] = {"Bonerate"},
	["bnb"] = {"Bookan"},
	["bnc"] = {"Bontok"},
	["bnd"] = {"Banda (Indonesia)"},
	["bne"] = {"Bintauna"},
	["bnf"] = {"Masiwang"},
	["bng"] = {"Benga"},
	["bni"] = {"Bangi"},
	["bnj"] = {"Eastern Tawbuid"},
	["bnk"] = {"Bierebo"},
	["bnl"] = {"Boon"},
	["bnm"] = {"Batanga"},
	["bnn"] = {"Bunun"},
	["bno"] = {"Bantoanon"},
	["bnp"] = {"Bola"},
	["bnq"] = {"Bantik"},
	["bnr"] = {"Butmas-Tur"},
	["bns"] = {"Bundeli"},
	["bnt"] = {"Bantu languages"},
	["bnu"] = {"Bentong"},
	["bnv"] = {"Bonerif", "Beneraf", "Edwas"},
	["bnw"] = {"Bisis"},
	["bnx"] = {"Bangubangu"},
	["bny"] = {"Bintulu"},
	["bnz"] = {"Beezen"},
	["boa"] = {"Bora"},
	["bob"] = {"Aweer"},
	["boe"] = {"Mundabli"},
	["bof"] = {"Bolon"},
	["bog"] = {"Bamako Sign Language"},
	["boh"] = {"Boma"},
	["boi"] = {"Barbareño"},
	["boj"] = {"Anjam"},
	["bok"] = {"Bonjo"},
	["bol"] = {"Bole"},
	["bom"] = {"Berom"},
	["bon"] = {"Bine"},
	["boo"] = {"Tiemacèwè Bozo"},
	["bop"] = {"Bonkiman"},
	["boq"] = {"Bogaya"},
	["bor"] = {"Borôro"},
	["bot"] = {"Bongo"},
	["bou"] = {"Bondei"},
	["bov"] = {"Tuwuli"},
	["bow"] = {"Rema"},
	["box"] = {"Buamu"},
	["boy"] = {"Bodo (Central African Republic)"},
	["boz"] = {"Tiéyaxo Bozo"},
	["bpa"] = {"Daakaka"},
	["bpc"] = {"Mbuk"},
	["bpd"] = {"Banda-Banda"},
	["bpe"] = {"Bauni"},
	["bpg"] = {"Bonggo"},
	["bph"] = {"Botlikh"},
	["bpi"] = {"Bagupi"},
	["bpj"] = {"Binji"},
	["bpk"] = {"Orowe", "'Ôrôê"},
	["bpl"] = {"Broome Pearling Lugger Pidgin"},
	["bpm"] = {"Biyom"},
	["bpn"] = {"Dzao Min"},
	["bpo"] = {"Anasi"},
	["bpp"] = {"Kaure"},
	["bpq"] = {"Banda Malay"},
	["bpr"] = {"Koronadal Blaan"},
	["bps"] = {"Sarangani Blaan"},
	["bpt"] = {"Barrow Point"},
	["bpu"] = {"Bongu"},
	["bpv"] = {"Bian Marind"},
	["bpw"] = {"Bo (Papua New Guinea)"},
	["bpx"] = {"Palya Bareli"},
	["bpy"] = {"Bishnupriya"},
	["bpz"] = {"Bilba"},
	["bqa"] = {"Tchumbuli"},
	["bqb"] = {"Bagusa"},
	["bqc"] = {"Boko (Benin)", "Boo"},
	["bqd"] = {"Bung"},
	["bqf"] = {"Baga Kaloum"},
	["bqg"] = {"Bago-Kusuntu"},
	["bqh"] = {"Baima"},
	["bqi"] = {"Bakhtiari"},
	["bqj"] = {"Bandial"},
	["bqk"] = {"Banda-Mbrès"},
	["bql"] = {"Karian", "Bilakura"},
	["bqm"] = {"Wumboko"},
	["bqn"] = {"Bulgarian Sign Language"},
	["bqo"] = {"Balo"},
	["bqp"] = {"Busa"},
	["bqq"] = {"Biritai"},
	["bqr"] = {"Burusu"},
	["bqs"] = {"Bosngun"},
	["bqt"] = {"Bamukumbit"},
	["bqu"] = {"Boguru"},
	["bqv"] = {"Koro Wachi", "Begbere-Ejar"},
	["bqw"] = {"Buru (Nigeria)"},
	["bqx"] = {"Baangi"},
	["bqy"] = {"Bengkala Sign Language"},
	["bqz"] = {"Bakaka"},
	["bra"] = {"Braj"},
	["brb"] = {"Brao", "Lave"},
	["brc"] = {"Berbice Creole Dutch"},
	["brd"] = {"Baraamu"},
	["brf"] = {"Bira"},
	["brg"] = {"Baure"},
	["brh"] = {"Brahui"},
	["bri"] = {"Mokpwe"},
	["brj"] = {"Bieria"},
	["brk"] = {"Birked"},
	["brl"] = {"Birwa"},
	["brm"] = {"Barambu"},
	["brn"] = {"Boruca"},
	["bro"] = {"Brokkat"},
	["brp"] = {"Barapasi"},
	["brq"] = {"Breri"},
	["brr"] = {"Birao"},
	["brs"] = {"Baras"},
	["brt"] = {"Bitare"},
	["bru"] = {"Eastern Bru"},
	["brv"] = {"Western Bru"},
	["brw"] = {"Bellari"},
	["brx"] = {"Bodo (India)"},
	["bry"] = {"Burui"},
	["brz"] = {"Bilbil"},
	["bsa"] = {"Abinomn"},
	["bsb"] = {"Brunei Bisaya"},
	["bsc"] = {"Bassari", "Oniyan"},
	["bse"] = {"Wushi"},
	["bsf"] = {"Bauchi"},
	["bsg"] = {"Bashkardi"},
	["bsh"] = {"Kati"},
	["bsi"] = {"Bassossi"},
	["bsj"] = {"Bangwinji"},
	["bsk"] = {"Burushaski"},
	["bsl"] = {"Basa-Gumna"},
	["bsm"] = {"Busami"},
	["bsn"] = {"Barasana-Eduria"},
	["bso"] = {"Buso"},
	["bsp"] = {"Baga Sitemu"},
	["bsq"] = {"Bassa"},
	["bsr"] = {"Bassa-Kontagora"},
	["bss"] = {"Akoose"},
	["bst"] = {"Basketo"},
	["bsu"] = {"Bahonsuai"},
	["bsv"] = {"Baga Sobané"},
	["bsw"] = {"Baiso"},
	["bsx"] = {"Yangkam"},
	["bsy"] = {"Sabah Bisaya"},
	["bta"] = {"Bata"},
	["btc"] = {"Bati (Cameroon)"},
	["btd"] = {"Batak Dairi"},
	["bte"] = {"Gamo-Ningi"},
	["btf"] = {"Birgit"},
	["btg"] = {"Gagnoa Bété"},
	["bth"] = {"Biatah Bidayuh"},
	["bti"] = {"Burate"},
	["btj"] = {"Bacanese Malay"},
	["btk"] = {"Batak languages"},
	["btm"] = {"Batak Mandailing"},
	["btn"] = {"Ratagnon"},
	["bto"] = {"Rinconada Bikol"},
	["btp"] = {"Budibud"},
	["btq"] = {"Batek"},
	["btr"] = {"Baetora"},
	["bts"] = {"Batak Simalungun"},
	["btt"] = {"Bete-Bendi"},
	["btu"] = {"Batu"},
	["btv"] = {"Bateri"},
	["btw"] = {"Butuanon"},
	["btx"] = {"Batak Karo"},
	["bty"] = {"Bobot"},
	["btz"] = {"Batak Alas-Kluet"},
	["bua"] = {"Buriat"},
	["bub"] = {"Bua"},
	["buc"] = {"Bushi"},
	["bud"] = {"Ntcham"},
	["bue"] = {"Beothuk"},
	["buf"] = {"Bushoong"},
	["bug"] = {"Buginese"},
	["buh"] = {"Younuo Bunu"},
	["bui"] = {"Bongili"},
	["buj"] = {"Basa-Gurmana"},
	["buk"] = {"Bugawac"},
	["bum"] = {"Bulu (Cameroon)"},
	["bun"] = {"Sherbro"},
	["buo"] = {"Terei"},
	["bup"] = {"Busoa"},
	["buq"] = {"Brem"},
	["bus"] = {"Bokobaru"},
	["but"] = {"Bungain"},
	["buu"] = {"Budu"},
	["buv"] = {"Bun"},
	["buw"] = {"Bubi"},
	["bux"] = {"Boghom"},
	["buy"] = {"Bullom So"},
	["buz"] = {"Bukwen"},
	["bva"] = {"Barein"},
	["bvb"] = {"Bube"},
	["bvc"] = {"Baelelea"},
	["bvd"] = {"Baeggu"},
	["bve"] = {"Berau Malay"},
	["bvf"] = {"Boor"},
	["bvg"] = {"Bonkeng"},
	["bvh"] = {"Bure"},
	["bvi"] = {"Belanda Viri"},
	["bvj"] = {"Baan"},
	["bvk"] = {"Bukat"},
	["bvl"] = {"Bolivian Sign Language"},
	["bvm"] = {"Bamunka"},
	["bvn"] = {"Buna"},
	["bvo"] = {"Bolgo"},
	["bvp"] = {"Bumang"},
	["bvq"] = {"Birri"},
	["bvr"] = {"Burarra"},
	["bvt"] = {"Bati (Indonesia)"},
	["bvu"] = {"Bukit Malay"},
	["bvv"] = {"Baniva"},
	["bvw"] = {"Boga"},
	["bvx"] = {"Dibole"},
	["bvy"] = {"Baybayanon"},
	["bvz"] = {"Bauzi"},
	["bwa"] = {"Bwatoo"},
	["bwb"] = {"Namosi-Naitasiri-Serua"},
	["bwc"] = {"Bwile"},
	["bwd"] = {"Bwaidoka"},
	["bwe"] = {"Bwe Karen"},
	["bwf"] = {"Boselewa"},
	["bwg"] = {"Barwe"},
	["bwh"] = {"Bishuo"},
	["bwi"] = {"Baniwa"},
	["bwj"] = {"Láá Láá Bwamu"},
	["bwk"] = {"Bauwaki"},
	["bwl"] = {"Bwela"},
	["bwm"] = {"Biwat"},
	["bwn"] = {"Wunai Bunu"},
	["bwo"] = {"Boro (Ethiopia)", "Borna (Ethiopia)"},
	["bwp"] = {"Mandobo Bawah"},
	["bwq"] = {"Southern Bobo Madaré"},
	["bwr"] = {"Bura-Pabir"},
	["bws"] = {"Bomboma"},
	["bwt"] = {"Bafaw-Balong"},
	["bwu"] = {"Buli (Ghana)"},
	["bww"] = {"Bwa"},
	["bwx"] = {"Bu-Nao Bunu"},
	["bwy"] = {"Cwi Bwamu"},
	["bwz"] = {"Bwisi"},
	["bxa"] = {"Tairaha"},
	["bxb"] = {"Belanda Bor"},
	["bxc"] = {"Molengue"},
	["bxd"] = {"Pela"},
	["bxe"] = {"Birale"},
	["bxf"] = {"Bilur", "Minigir"},
	["bxg"] = {"Bangala"},
	["bxh"] = {"Buhutu"},
	["bxi"] = {"Pirlatapa"},
	["bxj"] = {"Bayungu"},
	["bxk"] = {"Bukusu", "Lubukusu"},
	["bxl"] = {"Jalkunan"},
	["bxm"] = {"Mongolia Buriat"},
	["bxn"] = {"Burduna"},
	["bxo"] = {"Barikanchi"},
	["bxp"] = {"Bebil"},
	["bxq"] = {"Beele"},
	["bxr"] = {"Russia Buriat"},
	["bxs"] = {"Busam"},
	["bxu"] = {"China Buriat"},
	["bxv"] = {"Berakou"},
	["bxw"] = {"Bankagooma"},
	["bxz"] = {"Binahari"},
	["bya"] = {"Batak"},
	["byb"] = {"Bikya"},
	["byc"] = {"Ubaghara"},
	["byd"] = {"Benyadu'"},
	["bye"] = {"Pouye"},
	["byf"] = {"Bete"},
	["byg"] = {"Baygo"},
	["byh"] = {"Bhujel"},
	["byi"] = {"Buyu"},
	["byj"] = {"Bina (Nigeria)"},
	["byk"] = {"Biao"},
	["byl"] = {"Bayono"},
	["bym"] = {"Bidjara"},
	["byn"] = {"Bilin", "Blin"},
	["byo"] = {"Biyo"},
	["byp"] = {"Bumaji"},
	["byq"] = {"Basay"},
	["byr"] = {"Baruya", "Yipma"},
	["bys"] = {"Burak"},
	["byt"] = {"Berti"},
	["byv"] = {"Medumba"},
	["byw"] = {"Belhariya"},
	["byx"] = {"Qaqet"},
	["byz"] = {"Banaro"},
	["bza"] = {"Bandi"},
	["bzb"] = {"Andio"},
	["bzc"] = {"Southern Betsimisaraka Malagasy"},
	["bzd"] = {"Bribri"},
	["bze"] = {"Jenaama Bozo"},
	["bzf"] = {"Boikin"},
	["bzg"] = {"Babuza"},
	["bzh"] = {"Mapos Buang"},
	["bzi"] = {"Bisu"},
	["bzj"] = {"Belize Kriol English"},
	["bzk"] = {"Nicaragua Creole English"},
	["bzl"] = {"Boano (Sulawesi)"},
	["bzm"] = {"Bolondo"},
	["bzn"] = {"Boano (Maluku)"},
	["bzo"] = {"Bozaba"},
	["bzp"] = {"Kemberano"},
	["bzq"] = {"Buli (Indonesia)"},
	["bzr"] = {"Biri"},
	["bzs"] = {"Brazilian Sign Language"},
	["bzt"] = {"Brithenig"},
	["bzu"] = {"Burmeso"},
	["bzv"] = {"Naami"},
	["bzw"] = {"Basa (Nigeria)"},
	["bzx"] = {"Kɛlɛngaxo Bozo"},
	["bzy"] = {"Obanliku"},
	["bzz"] = {"Evant"},
	["caa"] = {"Chortí"},
	["cab"] = {"Garifuna"},
	["cac"] = {"Chuj"},
	["cad"] = {"Caddo"},
	["cae"] = {"Lehar", "Laalaa"},
	["caf"] = {"Southern Carrier"},
	["cag"] = {"Nivaclé"},
	["cah"] = {"Cahuarano"},
	["cai"] = {"Central American Indian languages"},
	["caj"] = {"Chané"},
	["cak"] = {"Kaqchikel", "Cakchiquel"},
	["cal"] = {"Carolinian"},
	["cam"] = {"Cemuhî"},
	["can"] = {"Chambri"},
	["cao"] = {"Chácobo"},
	["cap"] = {"Chipaya"},
	["caq"] = {"Car Nicobarese"},
	["car"] = {"Galibi Carib"},
	["cas"] = {"Tsimané"},
	["cau"] = {"Caucasian languages"},
	["cav"] = {"Cavineña"},
	["caw"] = {"Callawalla"},
	["cax"] = {"Chiquitano"},
	["cay"] = {"Cayuga"},
	["caz"] = {"Canichana"},
	["cba"] = {"Chibchan languages"},
	["cbb"] = {"Cabiyarí"},
	["cbc"] = {"Carapana"},
	["cbd"] = {"Carijona"},
	["cbg"] = {"Chimila"},
	["cbi"] = {"Chachi"},
	["cbj"] = {"Ede Cabe"},
	["cbk"] = {"Chavacano"},
	["cbl"] = {"Bualkhaw Chin"},
	["cbn"] = {"Nyahkur"},
	["cbo"] = {"Izora"},
	["cbq"] = {"Tsucuba", "Cuba"},
	["cbr"] = {"Cashibo-Cacataibo"},
	["cbs"] = {"Cashinahua"},
	["cbt"] = {"Chayahuita"},
	["cbu"] = {"Candoshi-Shapra"},
	["cbv"] = {"Cacua"},
	["cbw"] = {"Kinabalian"},
	["cby"] = {"Carabayo"},
	["ccc"] = {"Chamicuro"},
	["ccd"] = {"Cafundo Creole"},
	["cce"] = {"Chopi"},
	["ccg"] = {"Samba Daka"},
	["cch"] = {"Atsam"},
	["ccj"] = {"Kasanga"},
	["ccl"] = {"Cutchi-Swahili"},
	["ccm"] = {"Malaccan Creole Malay"},
	["ccn"] = {"North Caucasian languages"},
	["cco"] = {"Comaltepec Chinantec"},
	["ccp"] = {"Chakma"},
	["ccr"] = {"Cacaopera"},
	["ccs"] = {"South Caucasian languages"},
	["cda"] = {"Choni"},
	["cdc"] = {"Chadic languages"},
	["cdd"] = {"Caddoan languages"},
	["cde"] = {"Chenchu"},
	["cdf"] = {"Chiru"},
	["cdh"] = {"Chambeali"},
	["cdi"] = {"Chodri"},
	["cdj"] = {"Churahi"},
	["cdm"] = {"Chepang"},
	["cdn"] = {"Chaudangsi"},
	["cdo"] = {"Min Dong Chinese"},
	["cdr"] = {"Cinda-Regi-Tiyal"},
	["cds"] = {"Chadian Sign Language"},
	["cdy"] = {"Chadong"},
	["cdz"] = {"Koda"},
	["cea"] = {"Lower Chehalis"},
	["ceb"] = {"Cebuano"},
	["ceg"] = {"Chamacoco"},
	["cek"] = {"Eastern Khumi Chin"},
	["cel"] = {"Celtic languages"},
	["cen"] = {"Cen"},
	["cet"] = {"Centúúm"},
	["cey"] = {"Ekai Chin"},
	["cfa"] = {"Dijim-Bwilim"},
	["cfd"] = {"Cara"},
	["cfg"] = {"Como Karim"},
	["cfm"] = {"Falam Chin"},
	["cga"] = {"Changriwa"},
	["cgc"] = {"Kagayanen"},
	["cgg"] = {"Chiga"},
	["cgk"] = {"Chocangacakha"},
	["chb"] = {"Chibcha"},
	["chc"] = {"Catawba"},
	["chd"] = {"Highland Oaxaca Chontal"},
	["chf"] = {"Tabasco Chontal"},
	["chg"] = {"Chagatai"},
	["chh"] = {"Chinook"},
	["chj"] = {"Ojitlán Chinantec"},
	["chk"] = {"Chuukese"},
	["chl"] = {"Cahuilla"},
	["chm"] = {"Mari (Russia)"},
	["chn"] = {"Chinook jargon"},
	["cho"] = {"Choctaw"},
	["chp"] = {"Chipewyan", "Dene Suline"},
	["chq"] = {"Quiotepec Chinantec"},
	["chr"] = {"Cherokee"},
	["cht"] = {"Cholón"},
	["chw"] = {"Chuwabu"},
	["chx"] = {"Chantyal"},
	["chy"] = {"Cheyenne"},
	["chz"] = {"Ozumacín Chinantec"},
	["cia"] = {"Cia-Cia"},
	["cib"] = {"Ci Gbe"},
	["cic"] = {"Chickasaw"},
	["cid"] = {"Chimariko"},
	["cie"] = {"Cineni"},
	["cih"] = {"Chinali"},
	["cik"] = {"Chitkuli Kinnauri"},
	["cim"] = {"Cimbrian"},
	["cin"] = {"Cinta Larga"},
	["cip"] = {"Chiapanec"},
	["cir"] = {"Tiri", "Haméa", "Méa"},
	["ciw"] = {"Chippewa"},
	["ciy"] = {"Chaima"},
	["cja"] = {"Western Cham"},
	["cje"] = {"Chru"},
	["cjh"] = {"Upper Chehalis"},
	["cji"] = {"Chamalal"},
	["cjk"] = {"Chokwe"},
	["cjm"] = {"Eastern Cham"},
	["cjn"] = {"Chenapian"},
	["cjo"] = {"Ashéninka Pajonal"},
	["cjp"] = {"Cabécar"},
	["cjs"] = {"Shor"},
	["cjv"] = {"Chuave"},
	["cjy"] = {"Jinyu Chinese"},
	["ckb"] = {"Central Kurdish"},
	["ckh"] = {"Chak"},
	["ckl"] = {"Cibak"},
	["ckm"] = {"Chakavian"},
	["ckn"] = {"Kaang Chin"},
	["cko"] = {"Anufo"},
	["ckq"] = {"Kajakse"},
	["ckr"] = {"Kairak"},
	["cks"] = {"Tayo"},
	["ckt"] = {"Chukot"},
	["cku"] = {"Koasati"},
	["ckv"] = {"Kavalan"},
	["ckx"] = {"Caka"},
	["cky"] = {"Cakfem-Mushere"},
	["ckz"] = {"Cakchiquel-Quiché Mixed Language"},
	["cla"] = {"Ron"},
	["clc"] = {"Chilcotin"},
	["cld"] = {"Chaldean Neo-Aramaic"},
	["cle"] = {"Lealao Chinantec"},
	["clh"] = {"Chilisso"},
	["cli"] = {"Chakali"},
	["clj"] = {"Laitu Chin"},
	["clk"] = {"Idu-Mishmi"},
	["cll"] = {"Chala"},
	["clm"] = {"Clallam"},
	["clo"] = {"Lowland Oaxaca Chontal"},
	["cls"] = {"Classical Sanskrit"},
	["clt"] = {"Lautu Chin"},
	["clu"] = {"Caluyanun"},
	["clw"] = {"Chulym"},
	["cly"] = {"Eastern Highland Chatino"},
	["cma"] = {"Maa"},
	["cmc"] = {"Chamic languages"},
	["cme"] = {"Cerma"},
	["cmg"] = {"Classical Mongolian"},
	["cmi"] = {"Emberá-Chamí"},
	["cml"] = {"Campalagian"},
	["cmm"] = {"Michigamea"},
	["cmn"] = {"Mandarin Chinese"},
	["cmo"] = {"Central Mnong"},
	["cmr"] = {"Mro-Khimi Chin"},
	["cms"] = {"Messapic"},
	["cmt"] = {"Camtho"},
	["cna"] = {"Changthang"},
	["cnb"] = {"Chinbon Chin"},
	["cnc"] = {"Côông"},
	["cng"] = {"Northern Qiang"},
	["cnh"] = {"Hakha Chin", "Haka Chin"},
	["cni"] = {"Asháninka"},
	["cnk"] = {"Khumi Chin"},
	["cnl"] = {"Lalana Chinantec"},
	["cno"] = {"Con"},
	["cnp"] = {"Northern Ping Chinese", "Northern Pinghua"},
	["cnq"] = {"Chung"},
	["cnr"] = {"Montenegrin"},
	["cns"] = {"Central Asmat"},
	["cnt"] = {"Tepetotutla Chinantec"},
	["cnu"] = {"Chenoua"},
	["cnw"] = {"Ngawn Chin"},
	["cnx"] = {"Middle Cornish"},
	["coa"] = {"Cocos Islands Malay"},
	["cob"] = {"Chicomuceltec"},
	["coc"] = {"Cocopa"},
	["cod"] = {"Cocama-Cocamilla"},
	["coe"] = {"Koreguaje"},
	["cof"] = {"Colorado"},
	["cog"] = {"Chong"},
	["coh"] = {"Chonyi-Dzihana-Kauma", "Chichonyi-Chidzihana-Chikauma"},
	["coj"] = {"Cochimi"},
	["cok"] = {"Santa Teresa Cora"},
	["col"] = {"Columbia-Wenatchi"},
	["com"] = {"Comanche"},
	["con"] = {"Cofán"},
	["coo"] = {"Comox"},
	["cop"] = {"Coptic"},
	["coq"] = {"Coquille"},
	["cot"] = {"Caquinte"},
	["cou"] = {"Wamey"},
	["cov"] = {"Cao Miao"},
	["cow"] = {"Cowlitz"},
	["cox"] = {"Nanti"},
	["coz"] = {"Chochotec"},
	["cpa"] = {"Palantla Chinantec"},
	["cpb"] = {"Ucayali-Yurúa Ashéninka"},
	["cpc"] = {"Ajyíninka Apurucayali"},
	["cpe"] = {"English-based creoles and pidgins"},
	["cpf"] = {"French-based creoles and pidgins"},
	["cpg"] = {"Cappadocian Greek"},
	["cpi"] = {"Chinese Pidgin English"},
	["cpn"] = {"Cherepon"},
	["cpo"] = {"Kpeego"},
	["cpp"] = {"Portuguese-based creoles and pidgins"},
	["cps"] = {"Capiznon"},
	["cpu"] = {"Pichis Ashéninka"},
	["cpx"] = {"Pu-Xian Chinese"},
	["cpy"] = {"South Ucayali Ashéninka"},
	["cqd"] = {"Chuanqiandian Cluster Miao"},
	["cra"] = {"Chara"},
	["crb"] = {"Island Carib"},
	["crc"] = {"Lonwolwol"},
	["crd"] = {"Coeur d'Alene"},
	["crf"] = {"Caramanta"},
	["crg"] = {"Michif"},
	["crh"] = {"Crimean Tatar", "Crimean Turkish"},
	["cri"] = {"Sãotomense"},
	["crj"] = {"Southern East Cree"},
	["crk"] = {"Plains Cree"},
	["crl"] = {"Northern East Cree"},
	["crm"] = {"Moose Cree"},
	["crn"] = {"El Nayar Cora"},
	["cro"] = {"Crow"},
	["crp"] = {"Creoles and pidgins"},
	["crq"] = {"Iyo'wujwa Chorote"},
	["crr"] = {"Carolina Algonquian"},
	["crs"] = {"Seselwa Creole French"},
	["crt"] = {"Iyojwa'ja Chorote"},
	["crv"] = {"Chaura"},
	["crw"] = {"Chrau"},
	["crx"] = {"Carrier"},
	["cry"] = {"Cori"},
	["crz"] = {"Cruzeño"},
	["csa"] = {"Chiltepec Chinantec"},
	["csb"] = {"Kashubian"},
	["csc"] = {"Catalan Sign Language", "Lengua de señas catalana", "Llengua de Signes Catalana"},
	["csd"] = {"Chiangmai Sign Language"},
	["cse"] = {"Czech Sign Language"},
	["csf"] = {"Cuba Sign Language"},
	["csg"] = {"Chilean Sign Language"},
	["csh"] = {"Asho Chin"},
	["csi"] = {"Coast Miwok"},
	["csj"] = {"Songlai Chin"},
	["csk"] = {"Jola-Kasa"},
	["csl"] = {"Chinese Sign Language"},
	["csm"] = {"Central Sierra Miwok"},
	["csn"] = {"Colombian Sign Language"},
	["cso"] = {"Sochiapam Chinantec", "Sochiapan Chinantec"},
	["csp"] = {"Southern Ping Chinese", "Southern Pinghua"},
	["csq"] = {"Croatia Sign Language"},
	["csr"] = {"Costa Rican Sign Language"},
	["css"] = {"Southern Ohlone"},
	["cst"] = {"Northern Ohlone"},
	["csu"] = {"Central Sudanic languages"},
	["csv"] = {"Sumtu Chin"},
	["csw"] = {"Swampy Cree"},
	["csx"] = {"Cambodian Sign Language"},
	["csy"] = {"Siyin Chin"},
	["csz"] = {"Coos"},
	["cta"] = {"Tataltepec Chatino"},
	["ctc"] = {"Chetco"},
	["ctd"] = {"Tedim Chin"},
	["cte"] = {"Tepinapa Chinantec"},
	["ctg"] = {"Chittagonian"},
	["cth"] = {"Thaiphum Chin"},
	["ctl"] = {"Tlacoatzintepec Chinantec"},
	["ctm"] = {"Chitimacha"},
	["ctn"] = {"Chhintange"},
	["cto"] = {"Emberá-Catío"},
	["ctp"] = {"Western Highland Chatino"},
	["cts"] = {"Northern Catanduanes Bikol"},
	["ctt"] = {"Wayanad Chetti"},
	["ctu"] = {"Chol"},
	["cty"] = {"Moundadan Chetty"},
	["ctz"] = {"Zacatepec Chatino"},
	["cua"] = {"Cua"},
	["cub"] = {"Cubeo"},
	["cuc"] = {"Usila Chinantec"},
	["cuh"] = {"Chuka", "Gichuka"},
	["cui"] = {"Cuiba"},
	["cuj"] = {"Mashco Piro"},
	["cuk"] = {"San Blas Kuna"},
	["cul"] = {"Culina", "Kulina"},
	["cuo"] = {"Cumanagoto"},
	["cup"] = {"Cupeño"},
	["cuq"] = {"Cun"},
	["cur"] = {"Chhulung"},
	["cus"] = {"Cushitic languages"},
	["cut"] = {"Teutila Cuicatec"},
	["cuu"] = {"Tai Ya"},
	["cuv"] = {"Cuvok"},
	["cuw"] = {"Chukwa"},
	["cux"] = {"Tepeuxila Cuicatec"},
	["cuy"] = {"Cuitlatec"},
	["cvg"] = {"Chug"},
	["cvn"] = {"Valle Nacional Chinantec"},
	["cwa"] = {"Kabwa"},
	["cwb"] = {"Maindo"},
	["cwd"] = {"Woods Cree"},
	["cwe"] = {"Kwere"},
	["cwg"] = {"Chewong", "Cheq Wong"},
	["cwt"] = {"Kuwaataay"},
	["cxh"] = {"Cha'ari"},
	["cya"] = {"Nopala Chatino"},
	["cyb"] = {"Cayubaba"},
	["cyo"] = {"Cuyonon"},
	["czh"] = {"Huizhou Chinese"},
	["czk"] = {"Knaanic"},
	["czn"] = {"Zenzontepec Chatino"},
	["czo"] = {"Min Zhong Chinese"},
	["czt"] = {"Zotung Chin"},
	["daa"] = {"Dangaléat"},
	["dac"] = {"Dambi"},
	["dad"] = {"Marik"},
	["dae"] = {"Duupa"},
	["dag"] = {"Dagbani"},
	["dah"] = {"Gwahatike"},
	["dai"] = {"Day"},
	["daj"] = {"Dar Fur Daju"},
	["dak"] = {"Dakota"},
	["dal"] = {"Dahalo"},
	["dam"] = {"Damakawa"},
	["dao"] = {"Daai Chin"},
	["daq"] = {"Dandami Maria"},
	["dar"] = {"Dargwa"},
	["das"] = {"Daho-Doo"},
	["dau"] = {"Dar Sila Daju"},
	["dav"] = {"Taita", "Dawida"},
	["daw"] = {"Davawenyo"},
	["dax"] = {"Dayi"},
	["day"] = {"Land Dayak languages"},
	["daz"] = {"Moi-Wadea", "Dao"},
	["dba"] = {"Bangime"},
	["dbb"] = {"Deno"},
	["dbd"] = {"Dadiya"},
	["dbe"] = {"Dabe"},
	["dbf"] = {"Edopi"},
	["dbg"] = {"Dogul Dom Dogon"},
	["dbi"] = {"Doka"},
	["dbj"] = {"Ida'an"},
	["dbl"] = {"Dyirbal"},
	["dbm"] = {"Duguri"},
	["dbn"] = {"Duriankere"},
	["dbo"] = {"Dulbu"},
	["dbp"] = {"Duwai"},
	["dbq"] = {"Daba"},
	["dbr"] = {"Dabarre"},
	["dbt"] = {"Ben Tey Dogon"},
	["dbu"] = {"Bondum Dom Dogon"},
	["dbv"] = {"Dungu"},
	["dbw"] = {"Bankan Tey Dogon"},
	["dby"] = {"Dibiyaso"},
	["dcc"] = {"Deccan"},
	["dcr"] = {"Negerhollands"},
	["dda"] = {"Dadi Dadi"},
	["ddd"] = {"Dongotono"},
	["dde"] = {"Doondo"},
	["ddg"] = {"Fataluku"},
	["ddi"] = {"West Goodenough"},
	["ddj"] = {"Jaru"},
	["ddn"] = {"Dendi (Benin)"},
	["ddo"] = {"Dido"},
	["ddr"] = {"Dhudhuroa"},
	["dds"] = {"Donno So Dogon"},
	["ddw"] = {"Dawera-Daweloor"},
	["dec"] = {"Dagik"},
	["ded"] = {"Dedua"},
	["dee"] = {"Dewoin"},
	["def"] = {"Dezfuli"},
	["deg"] = {"Degema"},
	["deh"] = {"Dehwari"},
	["dei"] = {"Demisa"},
	["del"] = {"Delaware"},
	["dem"] = {"Dem"},
	["den"] = {"Slave (Athapascan)"},
	["dep"] = {"Pidgin Delaware"},
	["deq"] = {"Dendi (Central African Republic)"},
	["der"] = {"Deori"},
	["des"] = {"Desano"},
	["dev"] = {"Domung"},
	["dez"] = {"Dengese"},
	["dga"] = {"Southern Dagaare"},
	["dgb"] = {"Bunoge Dogon"},
	["dgc"] = {"Casiguran Dumagat Agta"},
	["dgd"] = {"Dagaari Dioula"},
	["dge"] = {"Degenan"},
	["dgg"] = {"Doga"},
	["dgh"] = {"Dghwede"},
	["dgi"] = {"Northern Dagara"},
	["dgk"] = {"Dagba"},
	["dgl"] = {"Andaandi", "Dongolawi"},
	["dgn"] = {"Dagoman"},
	["dgo"] = {"Dogri (individual language)"},
	["dgr"] = {"Tlicho", "Dogrib", "Tłı̨chǫ"},
	["dgs"] = {"Dogoso"},
	["dgt"] = {"Ndra'ngith"},
	["dgw"] = {"Daungwurrung"},
	["dgx"] = {"Doghoro"},
	["dgz"] = {"Daga"},
	["dhd"] = {"Dhundari"},
	["dhg"] = {"Dhangu-Djangu", "Dhangu", "Djangu"},
	["dhi"] = {"Dhimal"},
	["dhl"] = {"Dhalandji"},
	["dhm"] = {"Zemba"},
	["dhn"] = {"Dhanki"},
	["dho"] = {"Dhodia"},
	["dhr"] = {"Dhargari"},
	["dhs"] = {"Dhaiso"},
	["dhu"] = {"Dhurga"},
	["dhv"] = {"Dehu", "Drehu"},
	["dhw"] = {"Dhanwar (Nepal)"},
	["dhx"] = {"Dhungaloo"},
	["dia"] = {"Dia"},
	["dib"] = {"South Central Dinka"},
	["dic"] = {"Lakota Dida"},
	["did"] = {"Didinga"},
	["dif"] = {"Dieri", "Diyari"},
	["dig"] = {"Digo", "Chidigo"},
	["dih"] = {"Kumiai"},
	["dii"] = {"Dimbong"},
	["dij"] = {"Dai"},
	["dik"] = {"Southwestern Dinka"},
	["dil"] = {"Dilling"},
	["dim"] = {"Dime"},
	["din"] = {"Dinka"},
	["dio"] = {"Dibo"},
	["dip"] = {"Northeastern Dinka"},
	["diq"] = {"Dimli (individual language)"},
	["dir"] = {"Dirim"},
	["dis"] = {"Dimasa"},
	["diu"] = {"Diriku"},
	["diw"] = {"Northwestern Dinka"},
	["dix"] = {"Dixon Reef"},
	["diy"] = {"Diuwe"},
	["diz"] = {"Ding"},
	["dja"] = {"Djadjawurrung"},
	["djb"] = {"Djinba"},
	["djc"] = {"Dar Daju Daju"},
	["djd"] = {"Djamindjung", "Ngaliwurru"},
	["dje"] = {"Zarma"},
	["djf"] = {"Djangun"},
	["dji"] = {"Djinang"},
	["djj"] = {"Djeebbana"},
	["djk"] = {"Eastern Maroon Creole", "Businenge Tongo", "Nenge"},
	["djm"] = {"Jamsay Dogon"},
	["djn"] = {"Jawoyn", "Djauan"},
	["djo"] = {"Jangkang"},
	["djr"] = {"Djambarrpuyngu"},
	["dju"] = {"Kapriman"},
	["djw"] = {"Djawi"},
	["dka"] = {"Dakpakha"},
	["dkg"] = {"Kadung"},
	["dkk"] = {"Dakka"},
	["dkr"] = {"Kuijau"},
	["dks"] = {"Southeastern Dinka"},
	["dkx"] = {"Mazagway"},
	["dlg"] = {"Dolgan"},
	["dlk"] = {"Dahalik"},
	["dlm"] = {"Dalmatian"},
	["dln"] = {"Darlong"},
	["dma"] = {"Duma"},
	["dmb"] = {"Mombo Dogon"},
	["dmc"] = {"Gavak"},
	["dmd"] = {"Madhi Madhi"},
	["dme"] = {"Dugwor"},
	["dmf"] = {"Medefaidrin"},
	["dmg"] = {"Upper Kinabatangan"},
	["dmk"] = {"Domaaki"},
	["dml"] = {"Dameli"},
	["dmm"] = {"Dama"},
	["dmn"] = {"Mande languages"},
	["dmo"] = {"Kemedzung"},
	["dmr"] = {"East Damar"},
	["dms"] = {"Dampelas"},
	["dmu"] = {"Dubu", "Tebi"},
	["dmv"] = {"Dumpas"},
	["dmw"] = {"Mudburra"},
	["dmx"] = {"Dema"},
	["dmy"] = {"Demta", "Sowari"},
	["dna"] = {"Upper Grand Valley Dani"},
	["dnd"] = {"Daonda"},
	["dne"] = {"Ndendeule"},
	["dng"] = {"Dungan"},
	["dni"] = {"Lower Grand Valley Dani"},
	["dnj"] = {"Dan"},
	["dnk"] = {"Dengka"},
	["dnn"] = {"Dzùùngoo"},
	["dno"] = {"Ndrulo", "Northern Lendu"},
	["dnr"] = {"Danaru"},
	["dnt"] = {"Mid Grand Valley Dani"},
	["dnu"] = {"Danau"},
	["dnv"] = {"Danu"},
	["dnw"] = {"Western Dani"},
	["dny"] = {"Dení"},
	["doa"] = {"Dom"},
	["dob"] = {"Dobu"},
	["doc"] = {"Northern Dong"},
	["doe"] = {"Doe"},
	["dof"] = {"Domu"},
	["doh"] = {"Dong"},
	["doi"] = {"Dogri (macrolanguage)"},
	["dok"] = {"Dondo"},
	["dol"] = {"Doso"},
	["don"] = {"Toura (Papua New Guinea)"},
	["doo"] = {"Dongo"},
	["dop"] = {"Lukpa"},
	["doq"] = {"Dominican Sign Language"},
	["dor"] = {"Dori'o"},
	["dos"] = {"Dogosé"},
	["dot"] = {"Dass"},
	["dov"] = {"Dombe"},
	["dow"] = {"Doyayo"},
	["dox"] = {"Bussa"},
	["doy"] = {"Dompo"},
	["doz"] = {"Dorze"},
	["dpp"] = {"Papar"},
	["dra"] = {"Dravidian languages"},
	["drb"] = {"Dair"},
	["drc"] = {"Minderico"},
	["drd"] = {"Darmiya"},
	["dre"] = {"Dolpo"},
	["drg"] = {"Rungus"},
	["dri"] = {"C'Lela"},
	["drl"] = {"Paakantyi"},
	["drn"] = {"West Damar"},
	["dro"] = {"Daro-Matu Melanau"},
	["drq"] = {"Dura"},
	["drs"] = {"Gedeo"},
	["drt"] = {"Drents"},
	["dru"] = {"Rukai"},
	["dry"] = {"Darai"},
	["dsb"] = {"Lower Sorbian"},
	["dse"] = {"Dutch Sign Language"},
	["dsh"] = {"Daasanach"},
	["dsi"] = {"Disa"},
	["dsk"] = {"Dokshi"},
	["dsl"] = {"Danish Sign Language"},
	["dsn"] = {"Dusner"},
	["dso"] = {"Desiya"},
	["dsq"] = {"Tadaksahak"},
	["dsz"] = {"Mardin Sign Language"},
	["dta"] = {"Daur"},
	["dtb"] = {"Labuk-Kinabatangan Kadazan"},
	["dtd"] = {"Ditidaht"},
	["dth"] = {"Adithinngithigh"},
	["dti"] = {"Ana Tinga Dogon"},
	["dtk"] = {"Tene Kan Dogon"},
	["dtm"] = {"Tomo Kan Dogon"},
	["dtn"] = {"Daatsʼíin"},
	["dto"] = {"Tommo So Dogon"},
	["dtp"] = {"Kadazan Dusun", "Central Dusun"},
	["dtr"] = {"Lotud"},
	["dts"] = {"Toro So Dogon"},
	["dtt"] = {"Toro Tegu Dogon"},
	["dtu"] = {"Tebul Ure Dogon"},
	["dty"] = {"Dotyali"},
	["dua"] = {"Duala"},
	["dub"] = {"Dubli"},
	["duc"] = {"Duna"},
	["due"] = {"Umiray Dumaget Agta"},
	["duf"] = {"Dumbea", "Drubea"},
	["dug"] = {"Duruma", "Chiduruma"},
	["duh"] = {"Dungra Bhil"},
	["dui"] = {"Dumun"},
	["duk"] = {"Uyajitaya"},
	["dul"] = {"Alabat Island Agta"},
	["dum"] = {"Middle Dutch (ca. 1050-1350)"},
	["dun"] = {"Dusun Deyah"},
	["duo"] = {"Dupaninan Agta"},
	["dup"] = {"Duano"},
	["duq"] = {"Dusun Malang"},
	["dur"] = {"Dii"},
	["dus"] = {"Dumi"},
	["duu"] = {"Drung"},
	["duv"] = {"Duvle"},
	["duw"] = {"Dusun Witu"},
	["dux"] = {"Duungooma"},
	["duy"] = {"Dicamay Agta"},
	["duz"] = {"Duli-Gey"},
	["dva"] = {"Duau"},
	["dwa"] = {"Diri"},
	["dwk"] = {"Dawik Kui"},
	["dwr"] = {"Dawro"},
	["dws"] = {"Dutton World Speedwords"},
	["dwu"] = {"Dhuwal"},
	["dww"] = {"Dawawa"},
	["dwy"] = {"Dhuwaya"},
	["dwz"] = {"Dewas Rai"},
	["dya"] = {"Dyan"},
	["dyb"] = {"Dyaberdyaber"},
	["dyd"] = {"Dyugun"},
	["dyg"] = {"Villa Viciosa Agta"},
	["dyi"] = {"Djimini Senoufo"},
	["dym"] = {"Yanda Dom Dogon"},
	["dyn"] = {"Dyangadi", "Dhanggatti"},
	["dyo"] = {"Jola-Fonyi"},
	["dyr"] = {"Dyarim"},
	["dyu"] = {"Dyula"},
	["dyy"] = {"Djabugay", "Dyaabugay"},
	["dza"] = {"Tunzu"},
	["dzd"] = {"Daza"},
	["dze"] = {"Djiwarli"},
	["dzg"] = {"Dazaga"},
	["dzl"] = {"Dzalakha"},
	["dzn"] = {"Dzando"},
	["eaa"] = {"Karenggapa"},
	["ebc"] = {"Beginci"},
	["ebg"] = {"Ebughu"},
	["ebk"] = {"Eastern Bontok"},
	["ebo"] = {"Teke-Ebo"},
	["ebr"] = {"Ebrié"},
	["ebu"] = {"Embu", "Kiembu"},
	["ecr"] = {"Eteocretan"},
	["ecs"] = {"Ecuadorian Sign Language"},
	["ecy"] = {"Eteocypriot"},
	["eee"] = {"E"},
	["efa"] = {"Efai"},
	["efe"] = {"Efe"},
	["efi"] = {"Efik"},
	["ega"] = {"Ega"},
	["egl"] = {"Emilian"},
	["egm"] = {"Benamanga"},
	["ego"] = {"Eggon"},
	["egx"] = {"Egyptian languages"},
	["egy"] = {"Egyptian (Ancient)"},
	["ehs"] = {"Miyakubo Sign Language"},
	["ehu"] = {"Ehueun"},
	["eip"] = {"Eipomek"},
	["eit"] = {"Eitiep"},
	["eiv"] = {"Askopan"},
	["eja"] = {"Ejamat"},
	["eka"] = {"Ekajuk"},
	["eke"] = {"Ekit"},
	["ekg"] = {"Ekari"},
	["eki"] = {"Eki"},
	["ekk"] = {"Standard Estonian"},
	["ekl"] = {"Kol (Bangladesh)", "Kol"},
	["ekm"] = {"Elip"},
	["eko"] = {"Koti"},
	["ekp"] = {"Ekpeye"},
	["ekr"] = {"Yace"},
	["eky"] = {"Eastern Kayah"},
	["ele"] = {"Elepi"},
	["elh"] = {"El Hugeirat"},
	["eli"] = {"Nding"},
	["elk"] = {"Elkei"},
	["elm"] = {"Eleme"},
	["elo"] = {"El Molo"},
	["elu"] = {"Elu"},
	["elx"] = {"Elamite"},
	["ema"] = {"Emai-Iuleha-Ora"},
	["emb"] = {"Embaloh"},
	["eme"] = {"Emerillon"},
	["emg"] = {"Eastern Meohang"},
	["emi"] = {"Mussau-Emira"},
	["emk"] = {"Eastern Maninkakan"},
	["emm"] = {"Mamulique"},
	["emn"] = {"Eman"},
	["emp"] = {"Northern Emberá"},
	["emq"] = {"Eastern Minyag"},
	["ems"] = {"Pacific Gulf Yupik"},
	["emu"] = {"Eastern Muria"},
	["emw"] = {"Emplawas"},
	["emx"] = {"Erromintxela"},
	["emy"] = {"Epigraphic Mayan"},
	["emz"] = {"Mbessa"},
	["ena"] = {"Apali"},
	["enb"] = {"Markweeta"},
	["enc"] = {"En"},
	["end"] = {"Ende"},
	["enf"] = {"Forest Enets"},
	["enh"] = {"Tundra Enets"},
	["enl"] = {"Enlhet"},
	["enm"] = {"Middle English (1100-1500)"},
	["enn"] = {"Engenni"},
	["eno"] = {"Enggano"},
	["enq"] = {"Enga"},
	["enr"] = {"Emumu", "Emem"},
	["enu"] = {"Enu"},
	["env"] = {"Enwan (Edo State)"},
	["enw"] = {"Enwan (Akwa Ibom State)"},
	["enx"] = {"Enxet"},
	["eot"] = {"Beti (Côte d'Ivoire)"},
	["epi"] = {"Epie"},
	["era"] = {"Eravallan"},
	["erg"] = {"Sie"},
	["erh"] = {"Eruwa"},
	["eri"] = {"Ogea"},
	["erk"] = {"South Efate"},
	["ero"] = {"Horpa"},
	["err"] = {"Erre"},
	["ers"] = {"Ersu"},
	["ert"] = {"Eritai"},
	["erw"] = {"Erokwanas"},
	["ese"] = {"Ese Ejja"},
	["esg"] = {"Aheri Gondi"},
	["esh"] = {"Eshtehardi"},
	["esi"] = {"North Alaskan Inupiatun"},
	["esk"] = {"Northwest Alaska Inupiatun"},
	["esl"] = {"Egypt Sign Language"},
	["esm"] = {"Esuma"},
	["esn"] = {"Salvadoran Sign Language"},
	["eso"] = {"Estonian Sign Language"},
	["esq"] = {"Esselen"},
	["ess"] = {"Central Siberian Yupik"},
	["esu"] = {"Central Yupik"},
	["esx"] = {"Eskimo-Aleut languages"},
	["esy"] = {"Eskayan"},
	["etb"] = {"Etebi"},
	["etc"] = {"Etchemin"},
	["eth"] = {"Ethiopian Sign Language"},
	["etn"] = {"Eton (Vanuatu)"},
	["eto"] = {"Eton (Cameroon)"},
	["etr"] = {"Edolo"},
	["ets"] = {"Yekhee"},
	["ett"] = {"Etruscan"},
	["etu"] = {"Ejagham"},
	["etx"] = {"Eten"},
	["etz"] = {"Semimi"},
	["eud"] = {"Eudeve"},
	["euq"] = {"Basque (family)"},
	["eve"] = {"Even"},
	["evh"] = {"Uvbie"},
	["evn"] = {"Evenki"},
	["ewo"] = {"Ewondo"},
	["ext"] = {"Extremaduran"},
	["eya"] = {"Eyak"},
	["eyo"] = {"Keiyo"},
	["eza"] = {"Ezaa"},
	["eze"] = {"Uzekwe"},
	["faa"] = {"Fasu"},
	["fab"] = {"Fa d'Ambu"},
	["fad"] = {"Wagi"},
	["faf"] = {"Fagani"},
	["fag"] = {"Finongan"},
	["fah"] = {"Baissa Fali"},
	["fai"] = {"Faiwol"},
	["faj"] = {"Faita"},
	["fak"] = {"Fang (Cameroon)"},
	["fal"] = {"South Fali"},
	["fam"] = {"Fam"},
	["fan"] = {"Fang (Equatorial Guinea)"},
	["fap"] = {"Paloor"},
	["far"] = {"Fataleka"},
	["fat"] = {"Fanti"},
	["fau"] = {"Fayu"},
	["fax"] = {"Fala"},
	["fay"] = {"Southwestern Fars"},
	["faz"] = {"Northwestern Fars"},
	["fbl"] = {"West Albay Bikol"},
	["fcs"] = {"Quebec Sign Language"},
	["fer"] = {"Feroge"},
	["ffi"] = {"Foia Foia"},
	["ffm"] = {"Maasina Fulfulde"},
	["fgr"] = {"Fongoro"},
	["fia"] = {"Nobiin"},
	["fie"] = {"Fyer"},
	["fif"] = {"Faifi"},
	["fil"] = {"Filipino", "Pilipino"},
	["fip"] = {"Fipa"},
	["fir"] = {"Firan"},
	["fit"] = {"Tornedalen Finnish", "Meänkieli"},
	["fiu"] = {"Finno-Ugrian languages"},
	["fiw"] = {"Fiwaga"},
	["fkk"] = {"Kirya-Konzəl"},
	["fkv"] = {"Kven Finnish"},
	["fla"] = {"Kalispel-Pend d'Oreille"},
	["flh"] = {"Foau"},
	["fli"] = {"Fali"},
	["fll"] = {"North Fali"},
	["fln"] = {"Flinders Island"},
	["flr"] = {"Fuliiru"},
	["fly"] = {"Flaaitaal", "Tsotsitaal"},
	["fmp"] = {"Fe'fe'"},
	["fmu"] = {"Far Western Muria"},
	["fnb"] = {"Fanbak"},
	["fng"] = {"Fanagalo"},
	["fni"] = {"Fania"},
	["fod"] = {"Foodo"},
	["foi"] = {"Foi"},
	["fom"] = {"Foma"},
	["fon"] = {"Fon"},
	["for"] = {"Fore"},
	["fos"] = {"Siraya"},
	["fox"] = {"Formosan languages"},
	["fpe"] = {"Fernando Po Creole English"},
	["fqs"] = {"Fas"},
	["frc"] = {"Cajun French"},
	["frd"] = {"Fordata"},
	["frk"] = {"Frankish"},
	["frm"] = {"Middle French (ca. 1400-1600)"},
	["fro"] = {"Old French (842-ca. 1400)"},
	["frp"] = {"Arpitan", "Francoprovençal"},
	["frq"] = {"Forak"},
	["frr"] = {"Northern Frisian"},
	["frs"] = {"Eastern Frisian"},
	["frt"] = {"Fortsenal"},
	["fse"] = {"Finnish Sign Language"},
	["fsl"] = {"French Sign Language"},
	["fss"] = {"Finland-Swedish Sign Language", "finlandssvenskt teckenspråk", "suomenruotsalainen viittomakieli"},
	["fub"] = {"Adamawa Fulfulde"},
	["fuc"] = {"Pulaar"},
	["fud"] = {"East Futuna"},
	["fue"] = {"Borgu Fulfulde"},
	["fuf"] = {"Pular"},
	["fuh"] = {"Western Niger Fulfulde"},
	["fui"] = {"Bagirmi Fulfulde"},
	["fuj"] = {"Ko"},
	["fum"] = {"Fum"},
	["fun"] = {"Fulniô"},
	["fuq"] = {"Central-Eastern Niger Fulfulde"},
	["fur"] = {"Friulian"},
	["fut"] = {"Futuna-Aniwa"},
	["fuu"] = {"Furu"},
	["fuv"] = {"Nigerian Fulfulde"},
	["fuy"] = {"Fuyug"},
	["fvr"] = {"Fur"},
	["fwa"] = {"Fwâi"},
	["fwe"] = {"Fwe"},
	["gaa"] = {"Ga"},
	["gab"] = {"Gabri"},
	["gac"] = {"Mixed Great Andamanese"},
	["gad"] = {"Gaddang"},
	["gae"] = {"Guarequena"},
	["gaf"] = {"Gende"},
	["gag"] = {"Gagauz"},
	["gah"] = {"Alekano"},
	["gai"] = {"Borei"},
	["gaj"] = {"Gadsup"},
	["gak"] = {"Gamkonora"},
	["gal"] = {"Galolen"},
	["gam"] = {"Kandawo"},
	["gan"] = {"Gan Chinese"},
	["gao"] = {"Gants"},
	["gap"] = {"Gal"},
	["gaq"] = {"Gata'"},
	["gar"] = {"Galeya"},
	["gas"] = {"Adiwasi Garasia"},
	["gat"] = {"Kenati"},
	["gau"] = {"Mudhili Gadaba"},
	["gaw"] = {"Nobonob"},
	["gax"] = {"Borana-Arsi-Guji Oromo"},
	["gay"] = {"Gayo"},
	["gaz"] = {"West Central Oromo"},
	["gba"] = {"Gbaya (Central African Republic)"},
	["gbb"] = {"Kaytetye"},
	["gbd"] = {"Karajarri"},
	["gbe"] = {"Niksek"},
	["gbf"] = {"Gaikundi"},
	["gbg"] = {"Gbanziri"},
	["gbh"] = {"Defi Gbe"},
	["gbi"] = {"Galela"},
	["gbj"] = {"Bodo Gadaba"},
	["gbk"] = {"Gaddi"},
	["gbl"] = {"Gamit"},
	["gbm"] = {"Garhwali"},
	["gbn"] = {"Mo'da"},
	["gbo"] = {"Northern Grebo"},
	["gbp"] = {"Gbaya-Bossangoa"},
	["gbq"] = {"Gbaya-Bozoum"},
	["gbr"] = {"Gbagyi"},
	["gbs"] = {"Gbesi Gbe"},
	["gbu"] = {"Gagadu"},
	["gbv"] = {"Gbanu"},
	["gbw"] = {"Gabi-Gabi"},
	["gbx"] = {"Eastern Xwla Gbe"},
	["gby"] = {"Gbari"},
	["gbz"] = {"Zoroastrian Dari"},
	["gcc"] = {"Mali"},
	["gcd"] = {"Ganggalida"},
	["gce"] = {"Galice"},
	["gcf"] = {"Guadeloupean Creole French"},
	["gcl"] = {"Grenadian Creole English"},
	["gcn"] = {"Gaina"},
	["gcr"] = {"Guianese Creole French"},
	["gct"] = {"Colonia Tovar German"},
	["gda"] = {"Gade Lohar"},
	["gdb"] = {"Pottangi Ollar Gadaba"},
	["gdc"] = {"Gugu Badhun"},
	["gdd"] = {"Gedaged"},
	["gde"] = {"Gude"},
	["gdf"] = {"Guduf-Gava"},
	["gdg"] = {"Ga'dang"},
	["gdh"] = {"Gadjerawang", "Gajirrabeng"},
	["gdi"] = {"Gundi"},
	["gdj"] = {"Gurdjar"},
	["gdk"] = {"Gadang"},
	["gdl"] = {"Dirasha"},
	["gdm"] = {"Laal"},
	["gdn"] = {"Umanakaina"},
	["gdo"] = {"Ghodoberi"},
	["gdq"] = {"Mehri"},
	["gdr"] = {"Wipi"},
	["gds"] = {"Ghandruk Sign Language"},
	["gdt"] = {"Kungardutyi"},
	["gdu"] = {"Gudu"},
	["gdx"] = {"Godwari"},
	["gea"] = {"Geruma"},
	["geb"] = {"Kire"},
	["gec"] = {"Gboloo Grebo"},
	["ged"] = {"Gade"},
	["gef"] = {"Gerai"},
	["geg"] = {"Gengle"},
	["geh"] = {"Hutterite German", "Hutterisch"},
	["gei"] = {"Gebe"},
	["gej"] = {"Gen"},
	["gek"] = {"Ywom"},
	["gel"] = {"ut-Ma'in"},
	["gem"] = {"Germanic languages"},
	["geq"] = {"Geme"},
	["ges"] = {"Geser-Gorom"},
	["gev"] = {"Eviya"},
	["gew"] = {"Gera"},
	["gex"] = {"Garre"},
	["gey"] = {"Enya"},
	["gez"] = {"Geez"},
	["gfk"] = {"Patpatar"},
	["gft"] = {"Gafat"},
	["gga"] = {"Gao"},
	["ggb"] = {"Gbii"},
	["ggd"] = {"Gugadj"},
	["gge"] = {"Gurr-goni"},
	["ggg"] = {"Gurgula"},
	["ggk"] = {"Kungarakany"},
	["ggl"] = {"Ganglau"},
	["ggt"] = {"Gitua"},
	["ggu"] = {"Gagu", "Gban"},
	["ggw"] = {"Gogodala"},
	["gha"] = {"Ghadamès"},
	["ghc"] = {"Hiberno-Scottish Gaelic"},
	["ghe"] = {"Southern Ghale"},
	["ghh"] = {"Northern Ghale"},
	["ghk"] = {"Geko Karen"},
	["ghl"] = {"Ghulfan"},
	["ghn"] = {"Ghanongga"},
	["gho"] = {"Ghomara"},
	["ghr"] = {"Ghera"},
	["ghs"] = {"Guhu-Samane"},
	["ght"] = {"Kuke", "Kutang Ghale"},
	["gia"] = {"Kija"},
	["gib"] = {"Gibanawa"},
	["gic"] = {"Gail"},
	["gid"] = {"Gidar"},
	["gie"] = {"Gaɓogbo", "Guébie"},
	["gig"] = {"Goaria"},
	["gih"] = {"Githabul"},
	["gii"] = {"Girirra"},
	["gil"] = {"Gilbertese"},
	["gim"] = {"Gimi (Eastern Highlands)"},
	["gin"] = {"Hinukh"},
	["gip"] = {"Gimi (West New Britain)"},
	["giq"] = {"Green Gelao"},
	["gir"] = {"Red Gelao"},
	["gis"] = {"North Giziga"},
	["git"] = {"Gitxsan"},
	["giu"] = {"Mulao"},
	["giw"] = {"White Gelao"},
	["gix"] = {"Gilima"},
	["giy"] = {"Giyug"},
	["giz"] = {"South Giziga"},
	["gjk"] = {"Kachi Koli"},
	["gjm"] = {"Gunditjmara"},
	["gjn"] = {"Gonja"},
	["gjr"] = {"Gurindji Kriol"},
	["gju"] = {"Gujari"},
	["gka"] = {"Guya"},
	["gkd"] = {"Magɨ (Madang Province)"},
	["gke"] = {"Ndai"},
	["gkn"] = {"Gokana"},
	["gko"] = {"Kok-Nar"},
	["gkp"] = {"Guinea Kpelle"},
	["gku"] = {"ǂUngkue"},
	["glb"] = {"Belning"},
	["glc"] = {"Bon Gula"},
	["gld"] = {"Nanai"},
	["glh"] = {"Northwest Pashai", "Northwest Pashayi"},
	["glj"] = {"Gula Iro"},
	["glk"] = {"Gilaki"},
	["gll"] = {"Garlali"},
	["glo"] = {"Galambu"},
	["glr"] = {"Glaro-Twabo"},
	["glu"] = {"Gula (Chad)"},
	["glw"] = {"Glavda"},
	["gly"] = {"Gule"},
	["gma"] = {"Gambera"},
	["gmb"] = {"Gula'alaa"},
	["gmd"] = {"Mághdì"},
	["gme"] = {"East Germanic languages"},
	["gmg"] = {"Magɨyi"},
	["gmh"] = {"Middle High German (ca. 1050-1500)"},
	["gml"] = {"Middle Low German"},
	["gmm"] = {"Gbaya-Mbodomo"},
	["gmn"] = {"Gimnime"},
	["gmq"] = {"North Germanic languages"},
	["gmr"] = {"Mirning", "Mirniny"},
	["gmu"] = {"Gumalu"},
	["gmv"] = {"Gamo"},
	["gmw"] = {"West Germanic languages"},
	["gmx"] = {"Magoma"},
	["gmy"] = {"Mycenaean Greek"},
	["gmz"] = {"Mgbolizhia"},
	["gna"] = {"Kaansa"},
	["gnb"] = {"Gangte"},
	["gnc"] = {"Guanche"},
	["gnd"] = {"Zulgo-Gemzek"},
	["gne"] = {"Ganang"},
	["gng"] = {"Ngangam"},
	["gnh"] = {"Lere"},
	["gni"] = {"Gooniyandi"},
	["gnj"] = {"Ngen"},
	["gnk"] = {"ǁGana"},
	["gnl"] = {"Gangulu"},
	["gnm"] = {"Ginuman"},
	["gnn"] = {"Gumatj"},
	["gno"] = {"Northern Gondi"},
	["gnq"] = {"Gana"},
	["gnr"] = {"Gureng Gureng"},
	["gnt"] = {"Guntai"},
	["gnu"] = {"Gnau"},
	["gnw"] = {"Western Bolivian Guaraní"},
	["gnz"] = {"Ganzi"},
	["goa"] = {"Guro"},
	["gob"] = {"Playero"},
	["goc"] = {"Gorakor"},
	["god"] = {"Godié"},
	["goe"] = {"Gongduk"},
	["gof"] = {"Gofa"},
	["gog"] = {"Gogo"},
	["goh"] = {"Old High German (ca. 750-1050)"},
	["goi"] = {"Gobasi"},
	["goj"] = {"Gowlan"},
	["gok"] = {"Gowli"},
	["gol"] = {"Gola"},
	["gom"] = {"Goan Konkani"},
	["gon"] = {"Gondi"},
	["goo"] = {"Gone Dau"},
	["gop"] = {"Yeretuar"},
	["goq"] = {"Gorap"},
	["gor"] = {"Gorontalo"},
	["gos"] = {"Gronings"},
	["got"] = {"Gothic"},
	["gou"] = {"Gavar"},
	["gov"] = {"Goo"},
	["gow"] = {"Gorowa"},
	["gox"] = {"Gobu"},
	["goy"] = {"Goundo"},
	["goz"] = {"Gozarkhani"},
	["gpa"] = {"Gupa-Abawa"},
	["gpe"] = {"Ghanaian Pidgin English"},
	["gpn"] = {"Taiap"},
	["gqa"] = {"Ga'anda"},
	["gqi"] = {"Guiqiong"},
	["gqn"] = {"Guana (Brazil)"},
	["gqr"] = {"Gor"},
	["gqu"] = {"Qau"},
	["gra"] = {"Rajput Garasia"},
	["grb"] = {"Grebo"},
	["grc"] = {"Ancient Greek (to 1453)"},
	["grd"] = {"Guruntum-Mbaaru"},
	["grg"] = {"Madi"},
	["grh"] = {"Gbiri-Niragu"},
	["gri"] = {"Ghari"},
	["grj"] = {"Southern Grebo"},
	["grk"] = {"Greek languages"},
	["grm"] = {"Kota Marudu Talantang"},
	["gro"] = {"Groma"},
	["grq"] = {"Gorovu"},
	["grr"] = {"Taznatit"},
	["grs"] = {"Gresi"},
	["grt"] = {"Garo"},
	["gru"] = {"Kistane"},
	["grv"] = {"Central Grebo"},
	["grw"] = {"Gweda"},
	["grx"] = {"Guriaso"},
	["gry"] = {"Barclayville Grebo"},
	["grz"] = {"Guramalum"},
	["gse"] = {"Ghanaian Sign Language"},
	["gsg"] = {"German Sign Language"},
	["gsl"] = {"Gusilay"},
	["gsm"] = {"Guatemalan Sign Language"},
	["gsn"] = {"Nema", "Gusan"},
	["gso"] = {"Southwest Gbaya"},
	["gsp"] = {"Wasembo"},
	["gss"] = {"Greek Sign Language"},
	["gsw"] = {"Swiss German", "Alemannic", "Alsatian"},
	["gta"] = {"Guató"},
	["gtu"] = {"Aghu-Tharnggala"},
	["gua"] = {"Shiki"},
	["gub"] = {"Guajajára"},
	["guc"] = {"Wayuu"},
	["gud"] = {"Yocoboué Dida"},
	["gue"] = {"Gurindji"},
	["guf"] = {"Gupapuyngu"},
	["gug"] = {"Paraguayan Guaraní"},
	["guh"] = {"Guahibo"},
	["gui"] = {"Eastern Bolivian Guaraní"},
	["guk"] = {"Gumuz"},
	["gul"] = {"Sea Island Creole English"},
	["gum"] = {"Guambiano"},
	["gun"] = {"Mbyá Guaraní"},
	["guo"] = {"Guayabero"},
	["gup"] = {"Gunwinggu"},
	["guq"] = {"Aché"},
	["gur"] = {"Farefare"},
	["gus"] = {"Guinean Sign Language"},
	["gut"] = {"Maléku Jaíka"},
	["guu"] = {"Yanomamö"},
	["guw"] = {"Gun"},
	["gux"] = {"Gourmanchéma"},
	["guz"] = {"Gusii", "Ekegusii"},
	["gva"] = {"Guana (Paraguay)"},
	["gvc"] = {"Guanano"},
	["gve"] = {"Duwet"},
	["gvf"] = {"Golin"},
	["gvj"] = {"Guajá"},
	["gvl"] = {"Gulay"},
	["gvm"] = {"Gurmana"},
	["gvn"] = {"Kuku-Yalanji"},
	["gvo"] = {"Gavião Do Jiparaná"},
	["gvp"] = {"Pará Gavião"},
	["gvr"] = {"Gurung"},
	["gvs"] = {"Gumawana"},
	["gvy"] = {"Guyani"},
	["gwa"] = {"Mbato"},
	["gwb"] = {"Gwa"},
	["gwc"] = {"Gawri", "Kalami"},
	["gwd"] = {"Gawwada"},
	["gwe"] = {"Gweno"},
	["gwf"] = {"Gowro"},
	["gwg"] = {"Moo"},
	["gwi"] = {"Gwichʼin"},
	["gwj"] = {"ǀGwi"},
	["gwm"] = {"Awngthim"},
	["gwn"] = {"Gwandara"},
	["gwr"] = {"Gwere"},
	["gwt"] = {"Gawar-Bati"},
	["gwu"] = {"Guwamu"},
	["gww"] = {"Kwini"},
	["gwx"] = {"Gua"},
	["gxx"] = {"Wè Southern"},
	["gya"] = {"Northwest Gbaya"},
	["gyb"] = {"Garus"},
	["gyd"] = {"Kayardild"},
	["gye"] = {"Gyem"},
	["gyf"] = {"Gungabula"},
	["gyg"] = {"Gbayi"},
	["gyi"] = {"Gyele"},
	["gyl"] = {"Gayil"},
	["gym"] = {"Ngäbere"},
	["gyn"] = {"Guyanese Creole English"},
	["gyo"] = {"Gyalsumdo"},
	["gyr"] = {"Guarayu"},
	["gyy"] = {"Gunya"},
	["gyz"] = {"Geji", "Gyaazi"},
	["gza"] = {"Ganza"},
	["gzi"] = {"Gazi"},
	["gzn"] = {"Gane"},
	["haa"] = {"Han"},
	["hab"] = {"Hanoi Sign Language"},
	["hac"] = {"Gurani"},
	["had"] = {"Hatam"},
	["hae"] = {"Eastern Oromo"},
	["haf"] = {"Haiphong Sign Language"},
	["hag"] = {"Hanga"},
	["hah"] = {"Hahon"},
	["hai"] = {"Haida"},
	["haj"] = {"Hajong"},
	["hak"] = {"Hakka Chinese"},
	["hal"] = {"Halang"},
	["ham"] = {"Hewa"},
	["han"] = {"Hangaza"},
	["hao"] = {"Hakö"},
	["hap"] = {"Hupla"},
	["haq"] = {"Ha"},
	["har"] = {"Harari"},
	["has"] = {"Haisla"},
	["hav"] = {"Havu"},
	["haw"] = {"Hawaiian"},
	["hax"] = {"Southern Haida"},
	["hay"] = {"Haya"},
	["haz"] = {"Hazaragi"},
	["hba"] = {"Hamba"},
	["hbb"] = {"Huba"},
	["hbn"] = {"Heiban"},
	["hbo"] = {"Ancient Hebrew"},
	["hbu"] = {"Habu"},
	["hca"] = {"Andaman Creole Hindi"},
	["hch"] = {"Huichol"},
	["hdn"] = {"Northern Haida"},
	["hds"] = {"Honduras Sign Language"},
	["hdy"] = {"Hadiyya"},
	["hea"] = {"Northern Qiandong Miao"},
	["hed"] = {"Herdé"},
	["heg"] = {"Helong"},
	["heh"] = {"Hehe"},
	["hei"] = {"Heiltsuk"},
	["hem"] = {"Hemba"},
	["hgm"] = {"Haiǁom"},
	["hgw"] = {"Haigwai"},
	["hhi"] = {"Hoia Hoia"},
	["hhr"] = {"Kerak"},
	["hhy"] = {"Hoyahoya"},
	["hia"] = {"Lamang"},
	["hib"] = {"Hibito"},
	["hid"] = {"Hidatsa"},
	["hif"] = {"Fiji Hindi"},
	["hig"] = {"Kamwe"},
	["hih"] = {"Pamosu"},
	["hii"] = {"Hinduri"},
	["hij"] = {"Hijuk"},
	["hik"] = {"Seit-Kaitetu"},
	["hil"] = {"Hiligaynon"},
	["him"] = {"Himachali languages", "Western Pahari languages"},
	["hio"] = {"Tsoa"},
	["hir"] = {"Himarimã"},
	["hit"] = {"Hittite"},
	["hiw"] = {"Hiw"},
	["hix"] = {"Hixkaryána"},
	["hji"] = {"Haji"},
	["hka"] = {"Kahe"},
	["hke"] = {"Hunde"},
	["hkh"] = {"Khah", "Poguli"},
	["hkk"] = {"Hunjara-Kaina Ke"},
	["hkn"] = {"Mel-Khaonh"},
	["hks"] = {"Hong Kong Sign Language", "Heung Kong Sau Yue"},
	["hla"] = {"Halia"},
	["hlb"] = {"Halbi"},
	["hld"] = {"Halang Doan"},
	["hle"] = {"Hlersu"},
	["hlt"] = {"Matu Chin"},
	["hlu"] = {"Hieroglyphic Luwian"},
	["hma"] = {"Southern Mashan Hmong", "Southern Mashan Miao"},
	["hmb"] = {"Humburi Senni Songhay"},
	["hmc"] = {"Central Huishui Hmong", "Central Huishui Miao"},
	["hmd"] = {"Large Flowery Miao", "A-hmaos", "Da-Hua Miao"},
	["hme"] = {"Eastern Huishui Hmong", "Eastern Huishui Miao"},
	["hmf"] = {"Hmong Don"},
	["hmg"] = {"Southwestern Guiyang Hmong"},
	["hmh"] = {"Southwestern Huishui Hmong", "Southwestern Huishui Miao"},
	["hmi"] = {"Northern Huishui Hmong", "Northern Huishui Miao"},
	["hmj"] = {"Ge", "Gejia"},
	["hmk"] = {"Maek"},
	["hml"] = {"Luopohe Hmong", "Luopohe Miao"},
	["hmm"] = {"Central Mashan Hmong", "Central Mashan Miao"},
	["hmn"] = {"Hmong", "Mong"},
	["hmp"] = {"Northern Mashan Hmong", "Northern Mashan Miao"},
	["hmq"] = {"Eastern Qiandong Miao"},
	["hmr"] = {"Hmar"},
	["hms"] = {"Southern Qiandong Miao"},
	["hmt"] = {"Hamtai"},
	["hmu"] = {"Hamap"},
	["hmv"] = {"Hmong Dô"},
	["hmw"] = {"Western Mashan Hmong", "Western Mashan Miao"},
	["hmx"] = {"Hmong-Mien languages"},
	["hmy"] = {"Southern Guiyang Hmong", "Southern Guiyang Miao"},
	["hmz"] = {"Hmong Shua", "Sinicized Miao"},
	["hna"] = {"Mina (Cameroon)"},
	["hnd"] = {"Southern Hindko"},
	["hne"] = {"Chhattisgarhi"},
	["hng"] = {"Hungu"},
	["hnh"] = {"ǁAni"},
	["hni"] = {"Hani"},
	["hnj"] = {"Hmong Njua", "Mong Leng", "Mong Njua"},
	["hnm"] = {"Hainanese"},
	["hnn"] = {"Hanunoo"},
	["hno"] = {"Northern Hindko"},
	["hns"] = {"Caribbean Hindustani"},
	["hnu"] = {"Hung"},
	["hoa"] = {"Hoava"},
	["hob"] = {"Mari (Madang Province)"},
	["hoc"] = {"Ho"},
	["hod"] = {"Holma"},
	["hoe"] = {"Horom"},
	["hoh"] = {"Hobyót"},
	["hoi"] = {"Holikachuk"},
	["hoj"] = {"Hadothi", "Haroti"},
	["hok"] = {"Hokan languages"},
	["hol"] = {"Holu"},
	["hom"] = {"Homa"},
	["hoo"] = {"Holoholo"},
	["hop"] = {"Hopi"},
	["hor"] = {"Horo"},
	["hos"] = {"Ho Chi Minh City Sign Language"},
	["hot"] = {"Hote", "Malê"},
	["hov"] = {"Hovongan"},
	["how"] = {"Honi"},
	["hoy"] = {"Holiya"},
	["hoz"] = {"Hozo"},
	["hpo"] = {"Hpon"},
	["hps"] = {"Hawai'i Sign Language (HSL)", "Hawai'i Pidgin Sign Language"},
	["hra"] = {"Hrangkhol"},
	["hrc"] = {"Niwer Mil"},
	["hre"] = {"Hre"},
	["hrk"] = {"Haruku"},
	["hrm"] = {"Horned Miao"},
	["hro"] = {"Haroi"},
	["hrp"] = {"Nhirrpi"},
	["hrt"] = {"Hértevin"},
	["hru"] = {"Hruso"},
	["hrw"] = {"Warwar Feni"},
	["hrx"] = {"Hunsrik"},
	["hrz"] = {"Harzani"},
	["hsb"] = {"Upper Sorbian"},
	["hsh"] = {"Hungarian Sign Language"},
	["hsl"] = {"Hausa Sign Language"},
	["hsn"] = {"Xiang Chinese"},
	["hss"] = {"Harsusi"},
	["hti"] = {"Hoti"},
	["hto"] = {"Minica Huitoto"},
	["hts"] = {"Hadza"},
	["htu"] = {"Hitu"},
	["htx"] = {"Middle Hittite"},
	["hub"] = {"Huambisa"},
	["huc"] = {"ǂHua", "ǂʼAmkhoe"},
	["hud"] = {"Huaulu"},
	["hue"] = {"San Francisco Del Mar Huave"},
	["huf"] = {"Humene"},
	["hug"] = {"Huachipaeri"},
	["huh"] = {"Huilliche"},
	["hui"] = {"Huli"},
	["huj"] = {"Northern Guiyang Hmong", "Northern Guiyang Miao"},
	["huk"] = {"Hulung"},
	["hul"] = {"Hula"},
	["hum"] = {"Hungana"},
	["huo"] = {"Hu"},
	["hup"] = {"Hupa"},
	["huq"] = {"Tsat"},
	["hur"] = {"Halkomelem"},
	["hus"] = {"Huastec"},
	["hut"] = {"Humla"},
	["huu"] = {"Murui Huitoto"},
	["huv"] = {"San Mateo Del Mar Huave"},
	["huw"] = {"Hukumina"},
	["hux"] = {"Nüpode Huitoto"},
	["huy"] = {"Hulaulá"},
	["huz"] = {"Hunzib"},
	["hvc"] = {"Haitian Vodoun Culture Language"},
	["hve"] = {"San Dionisio Del Mar Huave"},
	["hvk"] = {"Haveke"},
	["hvn"] = {"Sabu"},
	["hvv"] = {"Santa María Del Mar Huave"},
	["hwa"] = {"Wané"},
	["hwc"] = {"Hawai'i Creole English", "Hawai'i Pidgin"},
	["hwo"] = {"Hwana"},
	["hya"] = {"Hya"},
	["hyw"] = {"Western Armenian"},
	["hyx"] = {"Armenian (family)"},
	["iai"] = {"Iaai"},
	["ian"] = {"Iatmul"},
	["iar"] = {"Purari"},
	["iba"] = {"Iban"},
	["ibb"] = {"Ibibio"},
	["ibd"] = {"Iwaidja"},
	["ibe"] = {"Akpes"},
	["ibg"] = {"Ibanag"},
	["ibh"] = {"Bih"},
	["ibl"] = {"Ibaloi"},
	["ibm"] = {"Agoi"},
	["ibn"] = {"Ibino"},
	["ibr"] = {"Ibuoro"},
	["ibu"] = {"Ibu"},
	["iby"] = {"Ibani"},
	["ica"] = {"Ede Ica"},
	["ich"] = {"Etkywan"},
	["icl"] = {"Icelandic Sign Language"},
	["icr"] = {"Islander Creole English"},
	["ida"] = {"Idakho-Isukha-Tiriki", "Luidakho-Luisukha-Lutirichi"},
	["idb"] = {"Indo-Portuguese"},
	["idc"] = {"Idon", "Ajiya"},
	["idd"] = {"Ede Idaca"},
	["ide"] = {"Idere"},
	["idi"] = {"Idi"},
	["idr"] = {"Indri"},
	["ids"] = {"Idesa"},
	["idt"] = {"Idaté"},
	["idu"] = {"Idoma"},
	["ifa"] = {"Amganad Ifugao"},
	["ifb"] = {"Batad Ifugao", "Ayangan Ifugao"},
	["ife"] = {"Ifè"},
	["iff"] = {"Ifo"},
	["ifk"] = {"Tuwali Ifugao"},
	["ifm"] = {"Teke-Fuumu"},
	["ifu"] = {"Mayoyao Ifugao"},
	["ify"] = {"Keley-I Kallahan"},
	["igb"] = {"Ebira"},
	["ige"] = {"Igede"},
	["igg"] = {"Igana"},
	["igl"] = {"Igala"},
	["igm"] = {"Kanggape"},
	["ign"] = {"Ignaciano"},
	["igo"] = {"Isebe"},
	["igs"] = {"Interglossa"},
	["igw"] = {"Igwe"},
	["ihb"] = {"Iha Based Pidgin"},
	["ihi"] = {"Ihievbe"},
	["ihp"] = {"Iha"},
	["ihw"] = {"Bidhawal"},
	["iin"] = {"Thiin"},
	["iir"] = {"Indo-Iranian languages"},
	["ijc"] = {"Izon"},
	["ije"] = {"Biseni"},
	["ijj"] = {"Ede Ije"},
	["ijn"] = {"Kalabari"},
	["ijo"] = {"Ijo languages"},
	["ijs"] = {"Southeast Ijo"},
	["ike"] = {"Eastern Canadian Inuktitut"},
	["ikh"] = {"Ikhin-Arokho"},
	["iki"] = {"Iko"},
	["ikk"] = {"Ika"},
	["ikl"] = {"Ikulu"},
	["iko"] = {"Olulumo-Ikom"},
	["ikp"] = {"Ikpeshi"},
	["ikr"] = {"Ikaranggal"},
	["iks"] = {"Inuit Sign Language"},
	["ikt"] = {"Inuinnaqtun", "Western Canadian Inuktitut"},
	["ikv"] = {"Iku-Gora-Ankwa"},
	["ikw"] = {"Ikwere"},
	["ikx"] = {"Ik"},
	["ikz"] = {"Ikizu"},
	["ila"] = {"Ile Ape"},
	["ilb"] = {"Ila"},
	["ilg"] = {"Garig-Ilgar"},
	["ili"] = {"Ili Turki"},
	["ilk"] = {"Ilongot"},
	["ilm"] = {"Iranun (Malaysia)"},
	["ilo"] = {"Iloko"},
	["ilp"] = {"Iranun (Philippines)"},
	["ils"] = {"International Sign"},
	["ilu"] = {"Ili'uun"},
	["ilv"] = {"Ilue"},
	["ima"] = {"Mala Malasar"},
	["imi"] = {"Anamgura"},
	["iml"] = {"Miluk"},
	["imn"] = {"Imonda"},
	["imo"] = {"Imbongu"},
	["imr"] = {"Imroing"},
	["ims"] = {"Marsian"},
	["imt"] = {"Imotong"},
	["imy"] = {"Milyan"},
	["inb"] = {"Inga"},
	["inc"] = {"Indic languages"},
	["ine"] = {"Indo-European languages"},
	["ing"] = {"Degexit'an"},
	["inh"] = {"Ingush"},
	["inj"] = {"Jungle Inga"},
	["inl"] = {"Indonesian Sign Language"},
	["inm"] = {"Minaean"},
	["inn"] = {"Isinai"},
	["ino"] = {"Inoke-Yate"},
	["inp"] = {"Iñapari"},
	["ins"] = {"Indian Sign Language"},
	["int"] = {"Intha"},
	["inz"] = {"Ineseño"},
	["ior"] = {"Inor"},
	["iou"] = {"Tuma-Irumu"},
	["iow"] = {"Iowa-Oto"},
	["ipi"] = {"Ipili"},
	["ipo"] = {"Ipiko"},
	["iqu"] = {"Iquito"},
	["iqw"] = {"Ikwo"},
	["ira"] = {"Iranian languages"},
	["ire"] = {"Iresim"},
	["irh"] = {"Irarutu"},
	["iri"] = {"Rigwe", "Irigwe"},
	["irk"] = {"Iraqw"},
	["irn"] = {"Irántxe"},
	["iro"] = {"Iroquoian languages"},
	["irr"] = {"Ir"},
	["iru"] = {"Irula"},
	["irx"] = {"Kamberau"},
	["iry"] = {"Iraya"},
	["isa"] = {"Isabi"},
	["isc"] = {"Isconahua"},
	["isd"] = {"Isnag"},
	["ise"] = {"Italian Sign Language"},
	["isg"] = {"Irish Sign Language"},
	["ish"] = {"Esan"},
	["isi"] = {"Nkem-Nkum"},
	["isk"] = {"Ishkashimi"},
	["ism"] = {"Masimasi"},
	["isn"] = {"Isanzu"},
	["iso"] = {"Isoko"},
	["isr"] = {"Israeli Sign Language"},
	["ist"] = {"Istriot"},
	["isu"] = {"Isu (Menchum Division)"},
	["isv"] = {"Interslavic"},
	["itb"] = {"Binongan Itneg"},
	["itc"] = {"Italic languages"},
	["itd"] = {"Southern Tidung"},
	["ite"] = {"Itene"},
	["iti"] = {"Inlaod Itneg"},
	["itk"] = {"Judeo-Italian"},
	["itl"] = {"Itelmen"},
	["itm"] = {"Itu Mbon Uzo"},
	["ito"] = {"Itonama"},
	["itr"] = {"Iteri"},
	["its"] = {"Isekiri"},
	["itt"] = {"Maeng Itneg"},
	["itv"] = {"Itawit"},
	["itw"] = {"Ito"},
	["itx"] = {"Itik"},
	["ity"] = {"Moyadan Itneg"},
	["itz"] = {"Itzá"},
	["ium"] = {"Iu Mien"},
	["ivb"] = {"Ibatan"},
	["ivv"] = {"Ivatan"},
	["iwk"] = {"I-Wak"},
	["iwm"] = {"Iwam"},
	["iwo"] = {"Iwur"},
	["iws"] = {"Sepik Iwam"},
	["ixc"] = {"Ixcatec"},
	["ixl"] = {"Ixil"},
	["iya"] = {"Iyayu"},
	["iyo"] = {"Mesaka"},
	["iyx"] = {"Yaka (Congo)"},
	["izh"] = {"Ingrian"},
	["izm"] = {"Kizamani"},
	["izr"] = {"Izere"},
	["izz"] = {"Izii"},
	["jaa"] = {"Jamamadí"},
	["jab"] = {"Hyam"},
	["jac"] = {"Popti'", "Jakalteko"},
	["jad"] = {"Jahanka"},
	["jae"] = {"Yabem"},
	["jaf"] = {"Jara"},
	["jah"] = {"Jah Hut"},
	["jaj"] = {"Zazao"},
	["jak"] = {"Jakun"},
	["jal"] = {"Yalahatan"},
	["jam"] = {"Jamaican Creole English"},
	["jan"] = {"Jandai"},
	["jao"] = {"Yanyuwa"},
	["jaq"] = {"Yaqay"},
	["jas"] = {"New Caledonian Javanese"},
	["jat"] = {"Jakati"},
	["jau"] = {"Yaur"},
	["jax"] = {"Jambi Malay"},
	["jay"] = {"Yan-nhangu", "Nhangu"},
	["jaz"] = {"Jawe"},
	["jbe"] = {"Judeo-Berber"},
	["jbi"] = {"Badjiri"},
	["jbj"] = {"Arandai"},
	["jbk"] = {"Barikewa"},
	["jbm"] = {"Bijim"},
	["jbn"] = {"Nafusi"},
	["jbo"] = {"Lojban"},
	["jbr"] = {"Jofotek-Bromnya"},
	["jbt"] = {"Jabutí"},
	["jbu"] = {"Jukun Takum"},
	["jbw"] = {"Yawijibaya"},
	["jcs"] = {"Jamaican Country Sign Language"},
	["jct"] = {"Krymchak"},
	["jda"] = {"Jad"},
	["jdg"] = {"Jadgali"},
	["jdt"] = {"Judeo-Tat"},
	["jeb"] = {"Jebero"},
	["jee"] = {"Jerung"},
	["jeh"] = {"Jeh"},
	["jei"] = {"Yei"},
	["jek"] = {"Jeri Kuo"},
	["jel"] = {"Yelmek"},
	["jen"] = {"Dza"},
	["jer"] = {"Jere"},
	["jet"] = {"Manem"},
	["jeu"] = {"Jonkor Bourmataguil"},
	["jgb"] = {"Ngbee"},
	["jge"] = {"Judeo-Georgian"},
	["jgk"] = {"Gwak"},
	["jgo"] = {"Ngomba"},
	["jhi"] = {"Jehai"},
	["jhs"] = {"Jhankot Sign Language"},
	["jia"] = {"Jina"},
	["jib"] = {"Jibu"},
	["jic"] = {"Tol"},
	["jid"] = {"Bu (Kaduna State)"},
	["jie"] = {"Jilbe"},
	["jig"] = {"Jingulu", "Djingili"},
	["jih"] = {"sTodsde", "Shangzhai"},
	["jii"] = {"Jiiddu"},
	["jil"] = {"Jilim"},
	["jim"] = {"Jimi (Cameroon)"},
	["jio"] = {"Jiamao"},
	["jiq"] = {"Guanyinqiao", "Lavrung"},
	["jit"] = {"Jita"},
	["jiu"] = {"Youle Jinuo"},
	["jiv"] = {"Shuar"},
	["jiy"] = {"Buyuan Jinuo"},
	["jje"] = {"Jejueo"},
	["jjr"] = {"Bankal"},
	["jka"] = {"Kaera"},
	["jkm"] = {"Mobwa Karen"},
	["jko"] = {"Kubo"},
	["jkp"] = {"Paku Karen"},
	["jkr"] = {"Koro (India)"},
	["jks"] = {"Amami Koniya Sign Language"},
	["jku"] = {"Labir"},
	["jle"] = {"Ngile"},
	["jls"] = {"Jamaican Sign Language"},
	["jma"] = {"Dima"},
	["jmb"] = {"Zumbun"},
	["jmc"] = {"Machame"},
	["jmd"] = {"Yamdena"},
	["jmi"] = {"Jimi (Nigeria)"},
	["jml"] = {"Jumli"},
	["jmn"] = {"Makuri Naga"},
	["jmr"] = {"Kamara"},
	["jms"] = {"Mashi (Nigeria)"},
	["jmw"] = {"Mouwase"},
	["jmx"] = {"Western Juxtlahuaca Mixtec"},
	["jna"] = {"Jangshung"},
	["jnd"] = {"Jandavra"},
	["jng"] = {"Yangman"},
	["jni"] = {"Janji"},
	["jnj"] = {"Yemsa"},
	["jnl"] = {"Rawat"},
	["jns"] = {"Jaunsari"},
	["job"] = {"Joba"},
	["jod"] = {"Wojenaka"},
	["jog"] = {"Jogi"},
	["jor"] = {"Jorá"},
	["jos"] = {"Jordanian Sign Language"},
	["jow"] = {"Jowulu"},
	["jpa"] = {"Jewish Palestinian Aramaic"},
	["jpr"] = {"Judeo-Persian"},
	["jpx"] = {"Japanese (family)"},
	["jqr"] = {"Jaqaru"},
	["jra"] = {"Jarai"},
	["jrb"] = {"Judeo-Arabic"},
	["jrr"] = {"Jiru"},
	["jrt"] = {"Jakattoe"},
	["jru"] = {"Japrería"},
	["jsl"] = {"Japanese Sign Language"},
	["jua"] = {"Júma"},
	["jub"] = {"Wannu"},
	["juc"] = {"Jurchen"},
	["jud"] = {"Worodougou"},
	["juh"] = {"Hõne"},
	["jui"] = {"Ngadjuri"},
	["juk"] = {"Wapan"},
	["jul"] = {"Jirel"},
	["jum"] = {"Jumjum"},
	["jun"] = {"Juang"},
	["juo"] = {"Jiba"},
	["jup"] = {"Hupdë"},
	["jur"] = {"Jurúna"},
	["jus"] = {"Jumla Sign Language"},
	["jut"] = {"Jutish"},
	["juu"] = {"Ju"},
	["juw"] = {"Wãpha"},
	["juy"] = {"Juray"},
	["jvd"] = {"Javindo"},
	["jvn"] = {"Caribbean Javanese"},
	["jwi"] = {"Jwira-Pepesa"},
	["jya"] = {"Jiarong"},
	["jye"] = {"Judeo-Yemeni Arabic"},
	["jyy"] = {"Jaya"},
	["kaa"] = {"Kara-Kalpak", "Karakalpak"},
	["kab"] = {"Kabyle"},
	["kac"] = {"Kachin", "Jingpho"},
	["kad"] = {"Adara"},
	["kae"] = {"Ketangalan"},
	["kaf"] = {"Katso"},
	["kag"] = {"Kajaman"},
	["kah"] = {"Kara (Central African Republic)"},
	["kai"] = {"Karekare"},
	["kaj"] = {"Jju"},
	["kak"] = {"Kalanguya", "Kayapa Kallahan"},
	["kam"] = {"Kamba (Kenya)"},
	["kao"] = {"Xaasongaxango"},
	["kap"] = {"Bezhta"},
	["kaq"] = {"Capanahua"},
	["kar"] = {"Karen languages"},
	["kav"] = {"Katukína"},
	["kaw"] = {"Kawi"},
	["kax"] = {"Kao"},
	["kay"] = {"Kamayurá"},
	["kba"] = {"Kalarko"},
	["kbb"] = {"Kaxuiâna"},
	["kbc"] = {"Kadiwéu"},
	["kbd"] = {"Kabardian"},
	["kbe"] = {"Kanju"},
	["kbg"] = {"Khamba"},
	["kbh"] = {"Camsá"},
	["kbi"] = {"Kaptiau"},
	["kbj"] = {"Kari"},
	["kbk"] = {"Grass Koiari"},
	["kbl"] = {"Kanembu"},
	["kbm"] = {"Iwal"},
	["kbn"] = {"Kare (Central African Republic)"},
	["kbo"] = {"Keliko"},
	["kbp"] = {"Kabiyè"},
	["kbq"] = {"Kamano"},
	["kbr"] = {"Kafa"},
	["kbs"] = {"Kande"},
	["kbt"] = {"Abadi"},
	["kbu"] = {"Kabutra"},
	["kbv"] = {"Dera (Indonesia)"},
	["kbw"] = {"Kaiep"},
	["kbx"] = {"Ap Ma"},
	["kby"] = {"Manga Kanuri"},
	["kbz"] = {"Duhwa"},
	["kca"] = {"Khanty"},
	["kcb"] = {"Kawacha"},
	["kcc"] = {"Lubila"},
	["kcd"] = {"Ngkâlmpw Kanum"},
	["kce"] = {"Kaivi"},
	["kcf"] = {"Ukaan"},
	["kcg"] = {"Tyap"},
	["kch"] = {"Vono"},
	["kci"] = {"Ngyian", "Kamantan"},
	["kcj"] = {"Kobiana"},
	["kck"] = {"Kalanga"},
	["kcl"] = {"Kela (Papua New Guinea)", "Kala"},
	["kcm"] = {"Gula (Central African Republic)"},
	["kcn"] = {"Nubi"},
	["kco"] = {"Kinalakna"},
	["kcp"] = {"Kanga"},
	["kcq"] = {"Kamo"},
	["kcr"] = {"Katla"},
	["kcs"] = {"Koenoem"},
	["kct"] = {"Kaian"},
	["kcu"] = {"Kami (Tanzania)"},
	["kcv"] = {"Kete"},
	["kcw"] = {"Kabwari"},
	["kcx"] = {"Kachama-Ganjule"},
	["kcy"] = {"Korandje"},
	["kcz"] = {"Konongo"},
	["kda"] = {"Worimi"},
	["kdc"] = {"Kutu"},
	["kdd"] = {"Yankunytjatjara"},
	["kde"] = {"Makonde"},
	["kdf"] = {"Mamusi"},
	["kdg"] = {"Seba"},
	["kdh"] = {"Tem"},
	["kdi"] = {"Kumam"},
	["kdj"] = {"Karamojong"},
	["kdk"] = {"Numèè", "Kwényi"},
	["kdl"] = {"Tsikimba"},
	["kdm"] = {"Kagoma"},
	["kdn"] = {"Kunda"},
	["kdo"] = {"Kordofanian languages"},
	["kdp"] = {"Kaningdon-Nindem"},
	["kdq"] = {"Koch"},
	["kdr"] = {"Karaim"},
	["kdt"] = {"Kuy"},
	["kdu"] = {"Kadaru"},
	["kdw"] = {"Koneraw"},
	["kdx"] = {"Kam"},
	["kdy"] = {"Keder", "Keijar"},
	["kdz"] = {"Kwaja"},
	["kea"] = {"Kabuverdianu"},
	["keb"] = {"Kélé"},
	["kec"] = {"Keiga"},
	["ked"] = {"Kerewe"},
	["kee"] = {"Eastern Keres"},
	["kef"] = {"Kpessi"},
	["keg"] = {"Tese"},
	["keh"] = {"Keak"},
	["kei"] = {"Kei"},
	["kej"] = {"Kadar"},
	["kek"] = {"Kekchí"},
	["kel"] = {"Kela (Democratic Republic of Congo)"},
	["kem"] = {"Kemak"},
	["ken"] = {"Kenyang"},
	["keo"] = {"Kakwa"},
	["kep"] = {"Kaikadi"},
	["keq"] = {"Kamar"},
	["ker"] = {"Kera"},
	["kes"] = {"Kugbo"},
	["ket"] = {"Ket"},
	["keu"] = {"Akebu"},
	["kev"] = {"Kanikkaran"},
	["kew"] = {"West Kewa"},
	["kex"] = {"Kukna"},
	["key"] = {"Kupia"},
	["kez"] = {"Kukele"},
	["kfa"] = {"Kodava"},
	["kfb"] = {"Northwestern Kolami"},
	["kfc"] = {"Konda-Dora"},
	["kfd"] = {"Korra Koraga"},
	["kfe"] = {"Kota (India)"},
	["kff"] = {"Koya"},
	["kfg"] = {"Kudiya"},
	["kfh"] = {"Kurichiya"},
	["kfi"] = {"Kannada Kurumba"},
	["kfj"] = {"Kemiehua"},
	["kfk"] = {"Kinnauri"},
	["kfl"] = {"Kung"},
	["kfm"] = {"Khunsari"},
	["kfn"] = {"Kuk"},
	["kfo"] = {"Koro (Côte d'Ivoire)"},
	["kfp"] = {"Korwa"},
	["kfq"] = {"Korku"},
	["kfr"] = {"Kachhi", "Kutchi"},
	["kfs"] = {"Bilaspuri"},
	["kft"] = {"Kanjari"},
	["kfu"] = {"Katkari"},
	["kfv"] = {"Kurmukar"},
	["kfw"] = {"Kharam Naga"},
	["kfx"] = {"Kullu Pahari"},
	["kfy"] = {"Kumaoni"},
	["kfz"] = {"Koromfé"},
	["kga"] = {"Koyaga"},
	["kgb"] = {"Kawe"},
	["kge"] = {"Komering"},
	["kgf"] = {"Kube"},
	["kgg"] = {"Kusunda"},
	["kgi"] = {"Selangor Sign Language"},
	["kgj"] = {"Gamale Kham"},
	["kgk"] = {"Kaiwá"},
	["kgl"] = {"Kunggari"},
	["kgn"] = {"Karingani"},
	["kgo"] = {"Krongo"},
	["kgp"] = {"Kaingang"},
	["kgq"] = {"Kamoro"},
	["kgr"] = {"Abun"},
	["kgs"] = {"Kumbainggar"},
	["kgt"] = {"Somyev"},
	["kgu"] = {"Kobol"},
	["kgv"] = {"Karas"},
	["kgw"] = {"Karon Dori"},
	["kgx"] = {"Kamaru"},
	["kgy"] = {"Kyerung"},
	["kha"] = {"Khasi"},
	["khb"] = {"Lü"},
	["khc"] = {"Tukang Besi North"},
	["khd"] = {"Bädi Kanum"},
	["khe"] = {"Korowai"},
	["khf"] = {"Khuen"},
	["khg"] = {"Khams Tibetan"},
	["khh"] = {"Kehu"},
	["khi"] = {"Khoisan languages"},
	["khj"] = {"Kuturmi"},
	["khk"] = {"Halh Mongolian"},
	["khl"] = {"Lusi"},
	["khn"] = {"Khandesi"},
	["kho"] = {"Khotanese", "Sakan"},
	["khp"] = {"Kapori", "Kapauri"},
	["khq"] = {"Koyra Chiini Songhay"},
	["khr"] = {"Kharia"},
	["khs"] = {"Kasua"},
	["kht"] = {"Khamti"},
	["khu"] = {"Nkhumbi"},
	["khv"] = {"Khvarshi"},
	["khw"] = {"Khowar"},
	["khx"] = {"Kanu"},
	["khy"] = {"Kele (Democratic Republic of Congo)"},
	["khz"] = {"Keapara"},
	["kia"] = {"Kim"},
	["kib"] = {"Koalib"},
	["kic"] = {"Kickapoo"},
	["kid"] = {"Koshin"},
	["kie"] = {"Kibet"},
	["kif"] = {"Eastern Parbate Kham"},
	["kig"] = {"Kimaama", "Kimaghima"},
	["kih"] = {"Kilmeri"},
	["kii"] = {"Kitsai"},
	["kij"] = {"Kilivila"},
	["kil"] = {"Kariya"},
	["kim"] = {"Karagas"},
	["kio"] = {"Kiowa"},
	["kip"] = {"Sheshi Kham"},
	["kiq"] = {"Kosadle", "Kosare"},
	["kis"] = {"Kis"},
	["kit"] = {"Agob"},
	["kiu"] = {"Kirmanjki (individual language)"},
	["kiv"] = {"Kimbu"},
	["kiw"] = {"Northeast Kiwai"},
	["kix"] = {"Khiamniungan Naga"},
	["kiy"] = {"Kirikiri"},
	["kiz"] = {"Kisi"},
	["kja"] = {"Mlap"},
	["kjb"] = {"Q'anjob'al", "Kanjobal"},
	["kjc"] = {"Coastal Konjo"},
	["kjd"] = {"Southern Kiwai"},
	["kje"] = {"Kisar"},
	["kjg"] = {"Khmu"},
	["kjh"] = {"Khakas"},
	["kji"] = {"Zabana"},
	["kjj"] = {"Khinalugh"},
	["kjk"] = {"Highland Konjo"},
	["kjl"] = {"Western Parbate Kham"},
	["kjm"] = {"Kháng"},
	["kjn"] = {"Kunjen"},
	["kjo"] = {"Harijan Kinnauri"},
	["kjp"] = {"Pwo Eastern Karen"},
	["kjq"] = {"Western Keres"},
	["kjr"] = {"Kurudu"},
	["kjs"] = {"East Kewa"},
	["kjt"] = {"Phrae Pwo Karen"},
	["kju"] = {"Kashaya"},
	["kjv"] = {"Kaikavian Literary Language"},
	["kjx"] = {"Ramopa"},
	["kjy"] = {"Erave"},
	["kjz"] = {"Bumthangkha"},
	["kka"] = {"Kakanda"},
	["kkb"] = {"Kwerisa"},
	["kkc"] = {"Odoodee"},
	["kkd"] = {"Kinuku"},
	["kke"] = {"Kakabe"},
	["kkf"] = {"Kalaktang Monpa"},
	["kkg"] = {"Mabaka Valley Kalinga"},
	["kkh"] = {"Khün"},
	["kki"] = {"Kagulu"},
	["kkj"] = {"Kako"},
	["kkk"] = {"Kokota"},
	["kkl"] = {"Kosarek Yale"},
	["kkm"] = {"Kiong"},
	["kkn"] = {"Kon Keu"},
	["kko"] = {"Karko"},
	["kkp"] = {"Gugubera", "Koko-Bera"},
	["kkq"] = {"Kaeku"},
	["kkr"] = {"Kir-Balar"},
	["kks"] = {"Giiwo"},
	["kkt"] = {"Koi"},
	["kku"] = {"Tumi"},
	["kkv"] = {"Kangean"},
	["kkw"] = {"Teke-Kukuya"},
	["kkx"] = {"Kohin"},
	["kky"] = {"Guugu Yimidhirr", "Guguyimidjir"},
	["kkz"] = {"Kaska"},
	["kla"] = {"Klamath-Modoc"},
	["klb"] = {"Kiliwa"},
	["klc"] = {"Kolbila"},
	["kld"] = {"Gamilaraay"},
	["kle"] = {"Kulung (Nepal)"},
	["klf"] = {"Kendeje"},
	["klg"] = {"Tagakaulo"},
	["klh"] = {"Weliki"},
	["kli"] = {"Kalumpang"},
	["klj"] = {"Khalaj"},
	["klk"] = {"Kono (Nigeria)"},
	["kll"] = {"Kagan Kalagan"},
	["klm"] = {"Migum"},
	["kln"] = {"Kalenjin"},
	["klo"] = {"Kapya"},
	["klp"] = {"Kamasa"},
	["klq"] = {"Rumu"},
	["klr"] = {"Khaling"},
	["kls"] = {"Kalasha"},
	["klt"] = {"Nukna"},
	["klu"] = {"Klao"},
	["klv"] = {"Maskelynes"},
	["klw"] = {"Tado", "Lindu"},
	["klx"] = {"Koluwawa"},
	["kly"] = {"Kalao"},
	["klz"] = {"Kabola"},
	["kma"] = {"Konni"},
	["kmb"] = {"Kimbundu"},
	["kmc"] = {"Southern Dong"},
	["kmd"] = {"Majukayang Kalinga"},
	["kme"] = {"Bakole"},
	["kmf"] = {"Kare (Papua New Guinea)"},
	["kmg"] = {"Kâte"},
	["kmh"] = {"Kalam"},
	["kmi"] = {"Kami (Nigeria)"},
	["kmj"] = {"Kumarbhag Paharia"},
	["kmk"] = {"Limos Kalinga"},
	["kml"] = {"Tanudan Kalinga"},
	["kmm"] = {"Kom (India)"},
	["kmn"] = {"Awtuw"},
	["kmo"] = {"Kwoma"},
	["kmp"] = {"Gimme"},
	["kmq"] = {"Kwama"},
	["kmr"] = {"Northern Kurdish"},
	["kms"] = {"Kamasau"},
	["kmt"] = {"Kemtuik"},
	["kmu"] = {"Kanite"},
	["kmv"] = {"Karipúna Creole French"},
	["kmw"] = {"Komo (Democratic Republic of Congo)"},
	["kmx"] = {"Waboda"},
	["kmy"] = {"Koma"},
	["kmz"] = {"Khorasani Turkish"},
	["kna"] = {"Dera (Nigeria)"},
	["knb"] = {"Lubuagan Kalinga"},
	["knc"] = {"Central Kanuri"},
	["knd"] = {"Konda"},
	["kne"] = {"Kankanaey"},
	["knf"] = {"Mankanya"},
	["kng"] = {"Koongo"},
	["kni"] = {"Kanufi"},
	["knj"] = {"Western Kanjobal"},
	["knk"] = {"Kuranko"},
	["knl"] = {"Keninjal"},
	["knm"] = {"Kanamarí"},
	["knn"] = {"Konkani (individual language)"},
	["kno"] = {"Kono (Sierra Leone)"},
	["knp"] = {"Kwanja"},
	["knq"] = {"Kintaq"},
	["knr"] = {"Kaningra"},
	["kns"] = {"Kensiu"},
	["knt"] = {"Panoan Katukína"},
	["knu"] = {"Kono (Guinea)"},
	["knv"] = {"Tabo"},
	["knw"] = {"Kung-Ekoka"},
	["knx"] = {"Kendayan", "Salako"},
	["kny"] = {"Kanyok"},
	["knz"] = {"Kalamsé"},
	["koa"] = {"Konomala"},
	["koc"] = {"Kpati"},
	["kod"] = {"Kodi"},
	["koe"] = {"Kacipo-Bale Suri"},
	["kof"] = {"Kubi"},
	["kog"] = {"Cogui", "Kogi"},
	["koh"] = {"Koyo"},
	["koi"] = {"Komi-Permyak"},
	["kok"] = {"Konkani (macrolanguage)"},
	["kol"] = {"Kol (Papua New Guinea)"},
	["koo"] = {"Konzo"},
	["kop"] = {"Waube"},
	["koq"] = {"Kota (Gabon)"},
	["kos"] = {"Kosraean"},
	["kot"] = {"Lagwan"},
	["kou"] = {"Koke"},
	["kov"] = {"Kudu-Camo"},
	["kow"] = {"Kugama"},
	["koy"] = {"Koyukon"},
	["koz"] = {"Korak"},
	["kpa"] = {"Kutto"},
	["kpb"] = {"Mullu Kurumba"},
	["kpc"] = {"Curripaco"},
	["kpd"] = {"Koba"},
	["kpe"] = {"Kpelle"},
	["kpf"] = {"Komba"},
	["kpg"] = {"Kapingamarangi"},
	["kph"] = {"Kplang"},
	["kpi"] = {"Kofei"},
	["kpj"] = {"Karajá"},
	["kpk"] = {"Kpan"},
	["kpl"] = {"Kpala"},
	["kpm"] = {"Koho"},
	["kpn"] = {"Kepkiriwát"},
	["kpo"] = {"Ikposo"},
	["kpq"] = {"Korupun-Sela"},
	["kpr"] = {"Korafe-Yegha"},
	["kps"] = {"Tehit"},
	["kpt"] = {"Karata"},
	["kpu"] = {"Kafoa"},
	["kpv"] = {"Komi-Zyrian"},
	["kpw"] = {"Kobon"},
	["kpx"] = {"Mountain Koiali"},
	["kpy"] = {"Koryak"},
	["kpz"] = {"Kupsabiny"},
	["kqa"] = {"Mum"},
	["kqb"] = {"Kovai"},
	["kqc"] = {"Doromu-Koki"},
	["kqd"] = {"Koy Sanjaq Surat"},
	["kqe"] = {"Kalagan"},
	["kqf"] = {"Kakabai"},
	["kqg"] = {"Khe"},
	["kqh"] = {"Kisankasa"},
	["kqi"] = {"Koitabu"},
	["kqj"] = {"Koromira"},
	["kqk"] = {"Kotafon Gbe"},
	["kql"] = {"Kyenele"},
	["kqm"] = {"Khisa"},
	["kqn"] = {"Kaonde"},
	["kqo"] = {"Eastern Krahn"},
	["kqp"] = {"Kimré"},
	["kqq"] = {"Krenak"},
	["kqr"] = {"Kimaragang"},
	["kqs"] = {"Northern Kissi"},
	["kqt"] = {"Klias River Kadazan"},
	["kqu"] = {"Seroa"},
	["kqv"] = {"Okolod"},
	["kqw"] = {"Kandas"},
	["kqx"] = {"Mser"},
	["kqy"] = {"Koorete"},
	["kqz"] = {"Korana"},
	["kra"] = {"Kumhali"},
	["krb"] = {"Karkin"},
	["krc"] = {"Karachay-Balkar"},
	["krd"] = {"Kairui-Midiki"},
	["kre"] = {"Panará"},
	["krf"] = {"Koro (Vanuatu)"},
	["krh"] = {"Kurama"},
	["kri"] = {"Krio"},
	["krj"] = {"Kinaray-A"},
	["krk"] = {"Kerek"},
	["krl"] = {"Karelian"},
	["krn"] = {"Sapo"},
	["kro"] = {"Kru languages"},
	["krp"] = {"Durop"},
	["krr"] = {"Krung"},
	["krs"] = {"Gbaya (Sudan)"},
	["krt"] = {"Tumari Kanuri"},
	["kru"] = {"Kurukh"},
	["krv"] = {"Kavet"},
	["krw"] = {"Western Krahn"},
	["krx"] = {"Karon"},
	["kry"] = {"Kryts"},
	["krz"] = {"Sota Kanum"},
	["ksb"] = {"Shambala"},
	["ksc"] = {"Southern Kalinga"},
	["ksd"] = {"Kuanua"},
	["kse"] = {"Kuni"},
	["ksf"] = {"Bafia"},
	["ksg"] = {"Kusaghe"},
	["ksh"] = {"Kölsch"},
	["ksi"] = {"Krisa", "I'saka"},
	["ksj"] = {"Uare"},
	["ksk"] = {"Kansa"},
	["ksl"] = {"Kumalu"},
	["ksm"] = {"Kumba"},
	["ksn"] = {"Kasiguranin"},
	["kso"] = {"Kofa"},
	["ksp"] = {"Kaba"},
	["ksq"] = {"Kwaami"},
	["ksr"] = {"Borong"},
	["kss"] = {"Southern Kisi"},
	["kst"] = {"Winyé"},
	["ksu"] = {"Khamyang"},
	["ksv"] = {"Kusu"},
	["ksw"] = {"S'gaw Karen"},
	["ksx"] = {"Kedang"},
	["ksy"] = {"Kharia Thar"},
	["ksz"] = {"Kodaku"},
	["kta"] = {"Katua"},
	["ktb"] = {"Kambaata"},
	["ktc"] = {"Kholok"},
	["ktd"] = {"Kokata", "Kukatha"},
	["kte"] = {"Nubri"},
	["ktf"] = {"Kwami"},
	["ktg"] = {"Kalkutung"},
	["kth"] = {"Karanga"},
	["kti"] = {"North Muyu"},
	["ktj"] = {"Plapo Krumen"},
	["ktk"] = {"Kaniet"},
	["ktl"] = {"Koroshi"},
	["ktm"] = {"Kurti"},
	["ktn"] = {"Karitiâna"},
	["kto"] = {"Kuot"},
	["ktp"] = {"Kaduo"},
	["ktq"] = {"Katabaga"},
	["kts"] = {"South Muyu"},
	["ktt"] = {"Ketum"},
	["ktu"] = {"Kituba (Democratic Republic of Congo)"},
	["ktv"] = {"Eastern Katu"},
	["ktw"] = {"Kato"},
	["ktx"] = {"Kaxararí"},
	["kty"] = {"Kango (Bas-Uélé District)"},
	["ktz"] = {"Juǀʼhoan", "Juǀʼhoansi"},
	["kub"] = {"Kutep"},
	["kuc"] = {"Kwinsu"},
	["kud"] = {"'Auhelawa"},
	["kue"] = {"Kuman (Papua New Guinea)"},
	["kuf"] = {"Western Katu"},
	["kug"] = {"Kupa"},
	["kuh"] = {"Kushi"},
	["kui"] = {"Kuikúro-Kalapálo", "Kalapalo"},
	["kuj"] = {"Kuria"},
	["kuk"] = {"Kepo'"},
	["kul"] = {"Kulere"},
	["kum"] = {"Kumyk"},
	["kun"] = {"Kunama"},
	["kuo"] = {"Kumukio"},
	["kup"] = {"Kunimaipa"},
	["kuq"] = {"Karipuna"},
	["kus"] = {"Kusaal"},
	["kut"] = {"Kutenai"},
	["kuu"] = {"Upper Kuskokwim"},
	["kuv"] = {"Kur"},
	["kuw"] = {"Kpagua"},
	["kux"] = {"Kukatja"},
	["kuy"] = {"Kuuku-Ya'u"},
	["kuz"] = {"Kunza"},
	["kva"] = {"Bagvalal"},
	["kvb"] = {"Kubu"},
	["kvc"] = {"Kove"},
	["kvd"] = {"Kui (Indonesia)"},
	["kve"] = {"Kalabakan"},
	["kvf"] = {"Kabalai"},
	["kvg"] = {"Kuni-Boazi"},
	["kvh"] = {"Komodo"},
	["kvi"] = {"Kwang"},
	["kvj"] = {"Psikye"},
	["kvk"] = {"Korean Sign Language"},
	["kvl"] = {"Kayaw"},
	["kvm"] = {"Kendem"},
	["kvn"] = {"Border Kuna"},
	["kvo"] = {"Dobel"},
	["kvp"] = {"Kompane"},
	["kvq"] = {"Geba Karen"},
	["kvr"] = {"Kerinci"},
	["kvt"] = {"Lahta Karen", "Lahta"},
	["kvu"] = {"Yinbaw Karen"},
	["kvv"] = {"Kola"},
	["kvw"] = {"Wersing"},
	["kvx"] = {"Parkari Koli"},
	["kvy"] = {"Yintale Karen", "Yintale"},
	["kvz"] = {"Tsakwambo", "Tsaukambo"},
	["kwa"] = {"Dâw"},
	["kwb"] = {"Kwa"},
	["kwc"] = {"Likwala"},
	["kwd"] = {"Kwaio"},
	["kwe"] = {"Kwerba"},
	["kwf"] = {"Kwara'ae"},
	["kwg"] = {"Sara Kaba Deme"},
	["kwh"] = {"Kowiai"},
	["kwi"] = {"Awa-Cuaiquer"},
	["kwj"] = {"Kwanga"},
	["kwk"] = {"Kwakiutl"},
	["kwl"] = {"Kofyar"},
	["kwm"] = {"Kwambi"},
	["kwn"] = {"Kwangali"},
	["kwo"] = {"Kwomtari"},
	["kwp"] = {"Kodia"},
	["kwr"] = {"Kwer"},
	["kws"] = {"Kwese"},
	["kwt"] = {"Kwesten"},
	["kwu"] = {"Kwakum"},
	["kwv"] = {"Sara Kaba Náà"},
	["kww"] = {"Kwinti"},
	["kwx"] = {"Khirwar"},
	["kwy"] = {"San Salvador Kongo"},
	["kwz"] = {"Kwadi"},
	["kxa"] = {"Kairiru"},
	["kxb"] = {"Krobu"},
	["kxc"] = {"Konso", "Khonso"},
	["kxd"] = {"Brunei"},
	["kxf"] = {"Manumanaw Karen", "Manumanaw"},
	["kxh"] = {"Karo (Ethiopia)"},
	["kxi"] = {"Keningau Murut"},
	["kxj"] = {"Kulfa"},
	["kxk"] = {"Zayein Karen"},
	["kxm"] = {"Northern Khmer"},
	["kxn"] = {"Kanowit-Tanjong Melanau"},
	["kxo"] = {"Kanoé"},
	["kxp"] = {"Wadiyara Koli"},
	["kxq"] = {"Smärky Kanum"},
	["kxr"] = {"Koro (Papua New Guinea)"},
	["kxs"] = {"Kangjia"},
	["kxt"] = {"Koiwat"},
	["kxv"] = {"Kuvi"},
	["kxw"] = {"Konai"},
	["kxx"] = {"Likuba"},
	["kxy"] = {"Kayong"},
	["kxz"] = {"Kerewo"},
	["kya"] = {"Kwaya"},
	["kyb"] = {"Butbut Kalinga"},
	["kyc"] = {"Kyaka"},
	["kyd"] = {"Karey"},
	["kye"] = {"Krache"},
	["kyf"] = {"Kouya"},
	["kyg"] = {"Keyagana"},
	["kyh"] = {"Karok"},
	["kyi"] = {"Kiput"},
	["kyj"] = {"Karao"},
	["kyk"] = {"Kamayo"},
	["kyl"] = {"Kalapuya"},
	["kym"] = {"Kpatili"},
	["kyn"] = {"Northern Binukidnon"},
	["kyo"] = {"Kelon"},
	["kyp"] = {"Kang"},
	["kyq"] = {"Kenga"},
	["kyr"] = {"Kuruáya"},
	["kys"] = {"Baram Kayan"},
	["kyt"] = {"Kayagar"},
	["kyu"] = {"Western Kayah"},
	["kyv"] = {"Kayort"},
	["kyw"] = {"Kudmali"},
	["kyx"] = {"Rapoisi"},
	["kyy"] = {"Kambaira"},
	["kyz"] = {"Kayabí"},
	["kza"] = {"Western Karaboro"},
	["kzb"] = {"Kaibobo"},
	["kzc"] = {"Bondoukou Kulango"},
	["kzd"] = {"Kadai"},
	["kze"] = {"Kosena"},
	["kzf"] = {"Da'a Kaili"},
	["kzg"] = {"Kikai"},
	["kzi"] = {"Kelabit"},
	["kzk"] = {"Kazukuru"},
	["kzl"] = {"Kayeli"},
	["kzm"] = {"Kais"},
	["kzn"] = {"Kokola"},
	["kzo"] = {"Kaningi"},
	["kzp"] = {"Kaidipang"},
	["kzq"] = {"Kaike"},
	["kzr"] = {"Karang"},
	["kzs"] = {"Sugut Dusun"},
	["kzu"] = {"Kayupulau"},
	["kzv"] = {"Komyandaret"},
	["kzw"] = {"Karirí-Xocó"},
	["kzx"] = {"Kamarian"},
	["kzy"] = {"Kango (Tshopo District)"},
	["kzz"] = {"Kalabra"},
	["laa"] = {"Southern Subanen"},
	["lab"] = {"Linear A"},
	["lac"] = {"Lacandon"},
	["lad"] = {"Ladino"},
	["lae"] = {"Pattani"},
	["laf"] = {"Lafofa"},
	["lag"] = {"Rangi"},
	["lah"] = {"Lahnda"},
	["lai"] = {"Lambya"},
	["laj"] = {"Lango (Uganda)"},
	["lal"] = {"Lalia"},
	["lam"] = {"Lamba"},
	["lan"] = {"Laru"},
	["lap"] = {"Laka (Chad)"},
	["laq"] = {"Qabiao"},
	["lar"] = {"Larteh"},
	["las"] = {"Lama (Togo)"},
	["lau"] = {"Laba"},
	["law"] = {"Lauje"},
	["lax"] = {"Tiwa"},
	["lay"] = {"Lama Bai"},
	["laz"] = {"Aribwatsa"},
	["lbb"] = {"Label"},
	["lbc"] = {"Lakkia"},
	["lbe"] = {"Lak"},
	["lbf"] = {"Tinani"},
	["lbg"] = {"Laopang"},
	["lbi"] = {"La'bi"},
	["lbj"] = {"Ladakhi"},
	["lbk"] = {"Central Bontok"},
	["lbl"] = {"Libon Bikol"},
	["lbm"] = {"Lodhi"},
	["lbn"] = {"Rmeet"},
	["lbo"] = {"Laven"},
	["lbq"] = {"Wampar"},
	["lbr"] = {"Lohorung"},
	["lbs"] = {"Libyan Sign Language"},
	["lbt"] = {"Lachi"},
	["lbu"] = {"Labu"},
	["lbv"] = {"Lavatbura-Lamusong"},
	["lbw"] = {"Tolaki"},
	["lbx"] = {"Lawangan"},
	["lby"] = {"Lamalama", "Lamu-Lamu"},
	["lbz"] = {"Lardil"},
	["lcc"] = {"Legenyem"},
	["lcd"] = {"Lola"},
	["lce"] = {"Loncong", "Sekak"},
	["lcf"] = {"Lubu"},
	["lch"] = {"Luchazi"},
	["lcl"] = {"Lisela"},
	["lcm"] = {"Tungag"},
	["lcp"] = {"Western Lawa"},
	["lcq"] = {"Luhu"},
	["lcs"] = {"Lisabata-Nuniali"},
	["lda"] = {"Kla-Dan"},
	["ldb"] = {"Dũya"},
	["ldd"] = {"Luri"},
	["ldg"] = {"Lenyima"},
	["ldh"] = {"Lamja-Dengsa-Tola"},
	["ldi"] = {"Laari"},
	["ldj"] = {"Lemoro"},
	["ldk"] = {"Leelau"},
	["ldl"] = {"Kaan"},
	["ldm"] = {"Landoma"},
	["ldn"] = {"Láadan"},
	["ldo"] = {"Loo"},
	["ldp"] = {"Tso"},
	["ldq"] = {"Lufu"},
	["lea"] = {"Lega-Shabunda"},
	["leb"] = {"Lala-Bisa"},
	["lec"] = {"Leco"},
	["led"] = {"Lendu"},
	["lee"] = {"Lyélé"},
	["lef"] = {"Lelemi"},
	["leh"] = {"Lenje"},
	["lei"] = {"Lemio"},
	["lej"] = {"Lengola"},
	["lek"] = {"Leipon"},
	["lel"] = {"Lele (Democratic Republic of Congo)"},
	["lem"] = {"Nomaande"},
	["len"] = {"Lenca"},
	["leo"] = {"Leti (Cameroon)"},
	["lep"] = {"Lepcha"},
	["leq"] = {"Lembena"},
	["ler"] = {"Lenkau"},
	["les"] = {"Lese"},
	["let"] = {"Lesing-Gelimi", "Amio-Gelimi"},
	["leu"] = {"Kara (Papua New Guinea)"},
	["lev"] = {"Lamma"},
	["lew"] = {"Ledo Kaili"},
	["lex"] = {"Luang"},
	["ley"] = {"Lemolang"},
	["lez"] = {"Lezghian"},
	["lfa"] = {"Lefa"},
	["lfn"] = {"Lingua Franca Nova"},
	["lga"] = {"Lungga"},
	["lgb"] = {"Laghu"},
	["lgg"] = {"Lugbara"},
	["lgh"] = {"Laghuu"},
	["lgi"] = {"Lengilu"},
	["lgk"] = {"Lingarak", "Neverver"},
	["lgl"] = {"Wala"},
	["lgm"] = {"Lega-Mwenga"},
	["lgn"] = {"T'apo", "Opuuo"},
	["lgo"] = {"Lango (South Sudan)"},
	["lgq"] = {"Logba"},
	["lgr"] = {"Lengo"},
	["lgs"] = {"Guinea-Bissau Sign Language", "Língua Gestual Guineense"},
	["lgt"] = {"Pahi"},
	["lgu"] = {"Longgu"},
	["lgz"] = {"Ligenza"},
	["lha"] = {"Laha (Viet Nam)"},
	["lhh"] = {"Laha (Indonesia)"},
	["lhi"] = {"Lahu Shi"},
	["lhl"] = {"Lahul Lohar"},
	["lhm"] = {"Lhomi"},
	["lhn"] = {"Lahanan"},
	["lhp"] = {"Lhokpu"},
	["lhs"] = {"Mlahsö"},
	["lht"] = {"Lo-Toga"},
	["lhu"] = {"Lahu"},
	["lia"] = {"West-Central Limba"},
	["lib"] = {"Likum"},
	["lic"] = {"Hlai"},
	["lid"] = {"Nyindrou"},
	["lie"] = {"Likila"},
	["lif"] = {"Limbu"},
	["lig"] = {"Ligbi"},
	["lih"] = {"Lihir"},
	["lij"] = {"Ligurian"},
	["lik"] = {"Lika"},
	["lil"] = {"Lillooet"},
	["lio"] = {"Liki"},
	["lip"] = {"Sekpele"},
	["liq"] = {"Libido"},
	["lir"] = {"Liberian English"},
	["lis"] = {"Lisu"},
	["liu"] = {"Logorik"},
	["liv"] = {"Liv"},
	["liw"] = {"Col"},
	["lix"] = {"Liabuku"},
	["liy"] = {"Banda-Bambari"},
	["liz"] = {"Libinza"},
	["lja"] = {"Golpa"},
	["lje"] = {"Rampi"},
	["lji"] = {"Laiyolo"},
	["ljl"] = {"Li'o"},
	["ljp"] = {"Lampung Api"},
	["ljw"] = {"Yirandali"},
	["ljx"] = {"Yuru"},
	["lka"] = {"Lakalei"},
	["lkb"] = {"Kabras", "Lukabaras"},
	["lkc"] = {"Kucong"},
	["lkd"] = {"Lakondê"},
	["lke"] = {"Kenyi"},
	["lkh"] = {"Lakha"},
	["lki"] = {"Laki"},
	["lkj"] = {"Remun"},
	["lkl"] = {"Laeko-Libuat"},
	["lkm"] = {"Kalaamaya"},
	["lkn"] = {"Lakon", "Vure"},
	["lko"] = {"Khayo", "Olukhayo"},
	["lkr"] = {"Päri"},
	["lks"] = {"Kisa", "Olushisa"},
	["lkt"] = {"Lakota"},
	["lku"] = {"Kungkari"},
	["lky"] = {"Lokoya"},
	["lla"] = {"Lala-Roba"},
	["llb"] = {"Lolo"},
	["llc"] = {"Lele (Guinea)"},
	["lld"] = {"Ladin"},
	["lle"] = {"Lele (Papua New Guinea)"},
	["llf"] = {"Hermit"},
	["llg"] = {"Lole"},
	["llh"] = {"Lamu"},
	["lli"] = {"Teke-Laali"},
	["llj"] = {"Ladji Ladji"},
	["llk"] = {"Lelak"},
	["lll"] = {"Lilau"},
	["llm"] = {"Lasalimu"},
	["lln"] = {"Lele (Chad)"},
	["llp"] = {"North Efate"},
	["llq"] = {"Lolak"},
	["lls"] = {"Lithuanian Sign Language"},
	["llu"] = {"Lau"},
	["llx"] = {"Lauan"},
	["lma"] = {"East Limba"},
	["lmb"] = {"Merei"},
	["lmc"] = {"Limilngan"},
	["lmd"] = {"Lumun"},
	["lme"] = {"Pévé"},
	["lmf"] = {"South Lembata"},
	["lmg"] = {"Lamogai"},
	["lmh"] = {"Lambichhong"},
	["lmi"] = {"Lombi"},
	["lmj"] = {"West Lembata"},
	["lmk"] = {"Lamkang"},
	["lml"] = {"Hano"},
	["lmn"] = {"Lambadi"},
	["lmo"] = {"Lombard"},
	["lmp"] = {"Limbum"},
	["lmq"] = {"Lamatuka"},
	["lmr"] = {"Lamalera"},
	["lmu"] = {"Lamenu"},
	["lmv"] = {"Lomaiviti"},
	["lmw"] = {"Lake Miwok"},
	["lmx"] = {"Laimbue"},
	["lmy"] = {"Lamboya"},
	["lna"] = {"Langbashe"},
	["lnb"] = {"Mbalanhu"},
	["lnd"] = {"Lundayeh", "Lun Bawang"},
	["lng"] = {"Langobardic"},
	["lnh"] = {"Lanoh"},
	["lni"] = {"Daantanai'"},
	["lnj"] = {"Leningitij"},
	["lnl"] = {"South Central Banda"},
	["lnm"] = {"Langam"},
	["lnn"] = {"Lorediakarkar"},
	["lns"] = {"Lamnso'"},
	["lnu"] = {"Longuda"},
	["lnw"] = {"Lanima"},
	["lnz"] = {"Lonzo"},
	["loa"] = {"Loloda"},
	["lob"] = {"Lobi"},
	["loc"] = {"Inonhan"},
	["loe"] = {"Saluan"},
	["lof"] = {"Logol"},
	["log"] = {"Logo"},
	["loh"] = {"Laarim", "Narim"},
	["loi"] = {"Loma (Côte d'Ivoire)"},
	["loj"] = {"Lou"},
	["lok"] = {"Loko"},
	["lol"] = {"Mongo"},
	["lom"] = {"Loma (Liberia)"},
	["lon"] = {"Malawi Lomwe"},
	["loo"] = {"Lombo"},
	["lop"] = {"Lopa"},
	["loq"] = {"Lobala"},
	["lor"] = {"Téén"},
	["los"] = {"Loniu"},
	["lot"] = {"Otuho"},
	["lou"] = {"Louisiana Creole"},
	["lov"] = {"Lopi"},
	["low"] = {"Tampias Lobu"},
	["lox"] = {"Loun"},
	["loy"] = {"Loke"},
	["loz"] = {"Lozi"},
	["lpa"] = {"Lelepa"},
	["lpe"] = {"Lepki"},
	["lpn"] = {"Long Phuri Naga"},
	["lpo"] = {"Lipo"},
	["lpx"] = {"Lopit"},
	["lqr"] = {"Logir"},
	["lra"] = {"Rara Bakati'"},
	["lrc"] = {"Northern Luri"},
	["lre"] = {"Laurentian"},
	["lrg"] = {"Laragia"},
	["lri"] = {"Marachi", "Olumarachi"},
	["lrk"] = {"Loarki"},
	["lrl"] = {"Lari"},
	["lrm"] = {"Marama", "Olumarama"},
	["lrn"] = {"Lorang"},
	["lro"] = {"Laro"},
	["lrr"] = {"Southern Yamphu"},
	["lrt"] = {"Larantuka Malay"},
	["lrv"] = {"Larevat"},
	["lrz"] = {"Lemerig"},
	["lsa"] = {"Lasgerdi"},
	["lsb"] = {"Burundian Sign Language", "Langue des Signes Burundaise"},
	["lsc"] = {"Albarradas Sign Language", "Lengua de señas Albarradas"},
	["lsd"] = {"Lishana Deni"},
	["lse"] = {"Lusengo"},
	["lsh"] = {"Lish"},
	["lsi"] = {"Lashi"},
	["lsl"] = {"Latvian Sign Language"},
	["lsm"] = {"Saamia", "Olusamia"},
	["lsn"] = {"Tibetan Sign Language"},
	["lso"] = {"Laos Sign Language"},
	["lsp"] = {"Panamanian Sign Language", "Lengua de Señas Panameñas"},
	["lsr"] = {"Aruop"},
	["lss"] = {"Lasi"},
	["lst"] = {"Trinidad and Tobago Sign Language"},
	["lsv"] = {"Sivia Sign Language"},
	["lsw"] = {"Seychelles Sign Language", "Lalang Siny Seselwa", "Langue des Signes Seychelloise"},
	["lsy"] = {"Mauritian Sign Language"},
	["ltc"] = {"Late Middle Chinese"},
	["ltg"] = {"Latgalian"},
	["lth"] = {"Thur"},
	["lti"] = {"Leti (Indonesia)"},
	["ltn"] = {"Latundê"},
	["lto"] = {"Tsotso", "Olutsotso"},
	["lts"] = {"Tachoni", "Lutachoni"},
	["ltu"] = {"Latu"},
	["lua"] = {"Luba-Lulua"},
	["luc"] = {"Aringa"},
	["lud"] = {"Ludian"},
	["lue"] = {"Luvale"},
	["luf"] = {"Laua"},
	["luh"] = {"Leizhou Chinese"},
	["lui"] = {"Luiseno"},
	["luj"] = {"Luna"},
	["luk"] = {"Lunanakha"},
	["lul"] = {"Olu'bo"},
	["lum"] = {"Luimbi"},
	["lun"] = {"Lunda"},
	["luo"] = {"Luo (Kenya and Tanzania)", "Dholuo"},
	["lup"] = {"Lumbu"},
	["luq"] = {"Lucumi"},
	["lur"] = {"Laura"},
	["lus"] = {"Lushai"},
	["lut"] = {"Lushootseed"},
	["luu"] = {"Lumba-Yakkha"},
	["luv"] = {"Luwati"},
	["luw"] = {"Luo (Cameroon)"},
	["luy"] = {"Luyia", "Oluluyia"},
	["luz"] = {"Southern Luri"},
	["lva"] = {"Maku'a"},
	["lvi"] = {"Lavi"},
	["lvk"] = {"Lavukaleve"},
	["lvl"] = {"Lwel"},
	["lvs"] = {"Standard Latvian"},
	["lvu"] = {"Levuka"},
	["lwa"] = {"Lwalu"},
	["lwe"] = {"Lewo Eleng"},
	["lwg"] = {"Wanga", "Oluwanga"},
	["lwh"] = {"White Lachi"},
	["lwl"] = {"Eastern Lawa"},
	["lwm"] = {"Laomian"},
	["lwo"] = {"Luwo"},
	["lws"] = {"Malawian Sign Language"},
	["lwt"] = {"Lewotobi"},
	["lwu"] = {"Lawu"},
	["lww"] = {"Lewo"},
	["lxm"] = {"Lakurumau"},
	["lya"] = {"Layakha"},
	["lyg"] = {"Lyngngam"},
	["lyn"] = {"Luyana"},
	["lzh"] = {"Literary Chinese"},
	["lzl"] = {"Litzlitz"},
	["lzn"] = {"Leinong Naga"},
	["lzz"] = {"Laz"},
	["maa"] = {"San Jerónimo Tecóatl Mazatec"},
	["mab"] = {"Yutanduchi Mixtec"},
	["mad"] = {"Madurese"},
	["mae"] = {"Bo-Rukul"},
	["maf"] = {"Mafa"},
	["mag"] = {"Magahi"},
	["mai"] = {"Maithili"},
	["maj"] = {"Jalapa De Díaz Mazatec"},
	["mak"] = {"Makasar"},
	["mam"] = {"Mam"},
	["man"] = {"Mandingo", "Manding"},
	["map"] = {"Austronesian languages"},
	["maq"] = {"Chiquihuitlán Mazatec"},
	["mas"] = {"Masai"},
	["mat"] = {"San Francisco Matlatzinca"},
	["mau"] = {"Huautla Mazatec"},
	["mav"] = {"Sateré-Mawé"},
	["maw"] = {"Mampruli"},
	["max"] = {"North Moluccan Malay"},
	["maz"] = {"Central Mazahua"},
	["mba"] = {"Higaonon"},
	["mbb"] = {"Western Bukidnon Manobo"},
	["mbc"] = {"Macushi"},
	["mbd"] = {"Dibabawon Manobo"},
	["mbe"] = {"Molale"},
	["mbf"] = {"Baba Malay"},
	["mbh"] = {"Mangseng"},
	["mbi"] = {"Ilianen Manobo"},
	["mbj"] = {"Nadëb"},
	["mbk"] = {"Malol"},
	["mbl"] = {"Maxakalí"},
	["mbm"] = {"Ombamba"},
	["mbn"] = {"Macaguán"},
	["mbo"] = {"Mbo (Cameroon)"},
	["mbp"] = {"Malayo"},
	["mbq"] = {"Maisin"},
	["mbr"] = {"Nukak Makú"},
	["mbs"] = {"Sarangani Manobo"},
	["mbt"] = {"Matigsalug Manobo"},
	["mbu"] = {"Mbula-Bwazza"},
	["mbv"] = {"Mbulungish"},
	["mbw"] = {"Maring"},
	["mbx"] = {"Mari (East Sepik Province)"},
	["mby"] = {"Memoni"},
	["mbz"] = {"Amoltepec Mixtec"},
	["mca"] = {"Maca"},
	["mcb"] = {"Machiguenga"},
	["mcc"] = {"Bitur"},
	["mcd"] = {"Sharanahua"},
	["mce"] = {"Itundujia Mixtec"},
	["mcf"] = {"Matsés"},
	["mcg"] = {"Mapoyo"},
	["mch"] = {"Maquiritari"},
	["mci"] = {"Mese"},
	["mcj"] = {"Mvanip"},
	["mck"] = {"Mbunda"},
	["mcl"] = {"Macaguaje"},
	["mcm"] = {"Malaccan Creole Portuguese"},
	["mcn"] = {"Masana"},
	["mco"] = {"Coatlán Mixe"},
	["mcp"] = {"Makaa"},
	["mcq"] = {"Ese"},
	["mcr"] = {"Menya"},
	["mcs"] = {"Mambai"},
	["mct"] = {"Mengisa"},
	["mcu"] = {"Cameroon Mambila"},
	["mcv"] = {"Minanibai"},
	["mcw"] = {"Mawa (Chad)"},
	["mcx"] = {"Mpiemo"},
	["mcy"] = {"South Watut"},
	["mcz"] = {"Mawan"},
	["mda"] = {"Mada (Nigeria)"},
	["mdb"] = {"Morigi"},
	["mdc"] = {"Male (Papua New Guinea)"},
	["mdd"] = {"Mbum"},
	["mde"] = {"Maba (Chad)"},
	["mdf"] = {"Moksha"},
	["mdg"] = {"Massalat"},
	["mdh"] = {"Maguindanaon"},
	["mdi"] = {"Mamvu"},
	["mdj"] = {"Mangbetu"},
	["mdk"] = {"Mangbutu"},
	["mdl"] = {"Maltese Sign Language"},
	["mdm"] = {"Mayogo"},
	["mdn"] = {"Mbati"},
	["mdp"] = {"Mbala"},
	["mdq"] = {"Mbole"},
	["mdr"] = {"Mandar"},
	["mds"] = {"Maria (Papua New Guinea)"},
	["mdt"] = {"Mbere"},
	["mdu"] = {"Mboko"},
	["mdv"] = {"Santa Lucía Monteverde Mixtec"},
	["mdw"] = {"Mbosi"},
	["mdx"] = {"Dizin"},
	["mdy"] = {"Male (Ethiopia)"},
	["mdz"] = {"Suruí Do Pará"},
	["mea"] = {"Menka"},
	["meb"] = {"Ikobi"},
	["mec"] = {"Marra"},
	["med"] = {"Melpa"},
	["mee"] = {"Mengen"},
	["mef"] = {"Megam"},
	["meh"] = {"Southwestern Tlaxiaco Mixtec"},
	["mei"] = {"Midob"},
	["mej"] = {"Meyah"},
	["mek"] = {"Mekeo"},
	["mel"] = {"Central Melanau"},
	["mem"] = {"Mangala"},
	["men"] = {"Mende (Sierra Leone)"},
	["meo"] = {"Kedah Malay"},
	["mep"] = {"Miriwoong"},
	["meq"] = {"Merey"},
	["mer"] = {"Meru"},
	["mes"] = {"Masmaje"},
	["met"] = {"Mato"},
	["meu"] = {"Motu"},
	["mev"] = {"Mano"},
	["mew"] = {"Maaka"},
	["mey"] = {"Hassaniyya"},
	["mez"] = {"Menominee"},
	["mfa"] = {"Pattani Malay"},
	["mfb"] = {"Bangka"},
	["mfc"] = {"Mba"},
	["mfd"] = {"Mendankwe-Nkwen"},
	["mfe"] = {"Morisyen"},
	["mff"] = {"Naki"},
	["mfg"] = {"Mogofin"},
	["mfh"] = {"Matal"},
	["mfi"] = {"Wandala"},
	["mfj"] = {"Mefele"},
	["mfk"] = {"North Mofu"},
	["mfl"] = {"Putai"},
	["mfm"] = {"Marghi South"},
	["mfn"] = {"Cross River Mbembe"},
	["mfo"] = {"Mbe"},
	["mfp"] = {"Makassar Malay"},
	["mfq"] = {"Moba"},
	["mfr"] = {"Marrithiyel"},
	["mfs"] = {"Mexican Sign Language"},
	["mft"] = {"Mokerang"},
	["mfu"] = {"Mbwela"},
	["mfv"] = {"Mandjak"},
	["mfw"] = {"Mulaha"},
	["mfx"] = {"Melo"},
	["mfy"] = {"Mayo"},
	["mfz"] = {"Mabaan"},
	["mga"] = {"Middle Irish (900-1200)"},
	["mgb"] = {"Mararit"},
	["mgc"] = {"Morokodo"},
	["mgd"] = {"Moru"},
	["mge"] = {"Mango"},
	["mgf"] = {"Maklew"},
	["mgg"] = {"Mpumpong"},
	["mgh"] = {"Makhuwa-Meetto"},
	["mgi"] = {"Lijili"},
	["mgj"] = {"Abureni"},
	["mgk"] = {"Mawes"},
	["mgl"] = {"Maleu-Kilenge"},
	["mgm"] = {"Mambae"},
	["mgn"] = {"Mbangi"},
	["mgo"] = {"Meta'"},
	["mgp"] = {"Eastern Magar"},
	["mgq"] = {"Malila"},
	["mgr"] = {"Mambwe-Lungu"},
	["mgs"] = {"Manda (Tanzania)"},
	["mgt"] = {"Mongol"},
	["mgu"] = {"Mailu"},
	["mgv"] = {"Matengo"},
	["mgw"] = {"Matumbi"},
	["mgy"] = {"Mbunga"},
	["mgz"] = {"Mbugwe"},
	["mha"] = {"Manda (India)"},
	["mhb"] = {"Mahongwe"},
	["mhc"] = {"Mocho"},
	["mhd"] = {"Mbugu"},
	["mhe"] = {"Besisi", "Mah Meri"},
	["mhf"] = {"Mamaa"},
	["mhg"] = {"Margu"},
	["mhi"] = {"Ma'di"},
	["mhj"] = {"Mogholi"},
	["mhk"] = {"Mungaka"},
	["mhl"] = {"Mauwake"},
	["mhm"] = {"Makhuwa-Moniga"},
	["mhn"] = {"Mócheno"},
	["mho"] = {"Mashi (Zambia)"},
	["mhp"] = {"Balinese Malay"},
	["mhq"] = {"Mandan"},
	["mhr"] = {"Eastern Mari"},
	["mhs"] = {"Buru (Indonesia)"},
	["mht"] = {"Mandahuaca"},
	["mhu"] = {"Digaro-Mishmi", "Darang Deng"},
	["mhw"] = {"Mbukushu"},
	["mhx"] = {"Maru", "Lhaovo"},
	["mhy"] = {"Ma'anyan"},
	["mhz"] = {"Mor (Mor Islands)"},
	["mia"] = {"Miami"},
	["mib"] = {"Atatláhuca Mixtec"},
	["mic"] = {"Mi'kmaq", "Micmac"},
	["mid"] = {"Mandaic"},
	["mie"] = {"Ocotepec Mixtec"},
	["mif"] = {"Mofu-Gudur"},
	["mig"] = {"San Miguel El Grande Mixtec"},
	["mih"] = {"Chayuco Mixtec"},
	["mii"] = {"Chigmecatitlán Mixtec"},
	["mij"] = {"Abar", "Mungbam"},
	["mik"] = {"Mikasuki"},
	["mil"] = {"Peñoles Mixtec"},
	["mim"] = {"Alacatlatzala Mixtec"},
	["min"] = {"Minangkabau"},
	["mio"] = {"Pinotepa Nacional Mixtec"},
	["mip"] = {"Apasco-Apoala Mixtec"},
	["miq"] = {"Mískito"},
	["mir"] = {"Isthmus Mixe"},
	["mis"] = {"Uncoded languages"},
	["mit"] = {"Southern Puebla Mixtec"},
	["miu"] = {"Cacaloxtepec Mixtec"},
	["miw"] = {"Akoye"},
	["mix"] = {"Mixtepec Mixtec"},
	["miy"] = {"Ayutla Mixtec"},
	["miz"] = {"Coatzospan Mixtec"},
	["mjb"] = {"Makalero"},
	["mjc"] = {"San Juan Colorado Mixtec"},
	["mjd"] = {"Northwest Maidu"},
	["mje"] = {"Muskum"},
	["mjg"] = {"Tu"},
	["mjh"] = {"Mwera (Nyasa)"},
	["mji"] = {"Kim Mun"},
	["mjj"] = {"Mawak"},
	["mjk"] = {"Matukar"},
	["mjl"] = {"Mandeali"},
	["mjm"] = {"Medebur"},
	["mjn"] = {"Ma (Papua New Guinea)"},
	["mjo"] = {"Malankuravan"},
	["mjp"] = {"Malapandaram"},
	["mjq"] = {"Malaryan"},
	["mjr"] = {"Malavedan"},
	["mjs"] = {"Miship"},
	["mjt"] = {"Sauria Paharia"},
	["mju"] = {"Manna-Dora"},
	["mjv"] = {"Mannan"},
	["mjw"] = {"Karbi"},
	["mjx"] = {"Mahali"},
	["mjy"] = {"Mahican"},
	["mjz"] = {"Majhi"},
	["mka"] = {"Mbre"},
	["mkb"] = {"Mal Paharia"},
	["mkc"] = {"Siliput"},
	["mke"] = {"Mawchi"},
	["mkf"] = {"Miya"},
	["mkg"] = {"Mak (China)"},
	["mkh"] = {"Mon-Khmer languages"},
	["mki"] = {"Dhatki"},
	["mkj"] = {"Mokilese"},
	["mkk"] = {"Byep"},
	["mkl"] = {"Mokole"},
	["mkm"] = {"Moklen"},
	["mkn"] = {"Kupang Malay"},
	["mko"] = {"Mingang Doso"},
	["mkp"] = {"Moikodi"},
	["mkq"] = {"Bay Miwok"},
	["mkr"] = {"Malas"},
	["mks"] = {"Silacayoapan Mixtec"},
	["mkt"] = {"Vamale"},
	["mku"] = {"Konyanka Maninka"},
	["mkv"] = {"Mafea"},
	["mkw"] = {"Kituba (Congo)"},
	["mkx"] = {"Kinamiging Manobo"},
	["mky"] = {"East Makian"},
	["mkz"] = {"Makasae"},
	["mla"] = {"Malo"},
	["mlb"] = {"Mbule"},
	["mlc"] = {"Cao Lan"},
	["mle"] = {"Manambu"},
	["mlf"] = {"Mal"},
	["mlh"] = {"Mape"},
	["mli"] = {"Malimpung"},
	["mlj"] = {"Miltu"},
	["mlk"] = {"Ilwana", "Kiwilwana"},
	["mll"] = {"Malua Bay"},
	["mlm"] = {"Mulam"},
	["mln"] = {"Malango"},
	["mlo"] = {"Mlomp"},
	["mlp"] = {"Bargam"},
	["mlq"] = {"Western Maninkakan"},
	["mlr"] = {"Vame"},
	["mls"] = {"Masalit"},
	["mlu"] = {"To'abaita"},
	["mlv"] = {"Motlav", "Mwotlap"},
	["mlw"] = {"Moloko"},
	["mlx"] = {"Malfaxal", "Naha'ai"},
	["mlz"] = {"Malaynon"},
	["mma"] = {"Mama"},
	["mmb"] = {"Momina"},
	["mmc"] = {"Michoacán Mazahua"},
	["mmd"] = {"Maonan"},
	["mme"] = {"Mae"},
	["mmf"] = {"Mundat"},
	["mmg"] = {"North Ambrym"},
	["mmh"] = {"Mehináku"},
	["mmi"] = {"Hember Avu", "Amben", "Musar"},
	["mmj"] = {"Majhwar"},
	["mmk"] = {"Mukha-Dora"},
	["mml"] = {"Man Met"},
	["mmm"] = {"Maii"},
	["mmn"] = {"Mamanwa"},
	["mmo"] = {"Mangga Buang"},
	["mmp"] = {"Siawi"},
	["mmq"] = {"Musak"},
	["mmr"] = {"Western Xiangxi Miao"},
	["mmt"] = {"Malalamai"},
	["mmu"] = {"Mmaala"},
	["mmv"] = {"Miriti"},
	["mmw"] = {"Emae"},
	["mmx"] = {"Madak"},
	["mmy"] = {"Migaama"},
	["mmz"] = {"Mabaale"},
	["mna"] = {"Mbula"},
	["mnb"] = {"Muna"},
	["mnc"] = {"Manchu"},
	["mnd"] = {"Mondé"},
	["mne"] = {"Naba"},
	["mnf"] = {"Mundani"},
	["mng"] = {"Eastern Mnong"},
	["mnh"] = {"Mono (Democratic Republic of Congo)"},
	["mni"] = {"Manipuri"},
	["mnj"] = {"Munji"},
	["mnk"] = {"Mandinka"},
	["mnl"] = {"Tiale"},
	["mnm"] = {"Mapena"},
	["mnn"] = {"Southern Mnong"},
	["mno"] = {"Manobo languages"},
	["mnp"] = {"Min Bei Chinese"},
	["mnq"] = {"Minriq"},
	["mnr"] = {"Mono (USA)"},
	["mns"] = {"Mansi"},
	["mnu"] = {"Mer"},
	["mnv"] = {"Rennell-Bellona"},
	["mnw"] = {"Mon"},
	["mnx"] = {"Manikion"},
	["mny"] = {"Manyawa"},
	["mnz"] = {"Moni"},
	["moa"] = {"Mwan"},
	["moc"] = {"Mocoví"},
	["mod"] = {"Mobilian"},
	["moe"] = {"Innu", "Montagnais"},
	["mog"] = {"Mongondow"},
	["moh"] = {"Mohawk"},
	["moi"] = {"Mboi"},
	["moj"] = {"Monzombo"},
	["mok"] = {"Morori"},
	["mom"] = {"Mangue"},
	["moo"] = {"Monom"},
	["mop"] = {"Mopán Maya"},
	["moq"] = {"Mor (Bomberai Peninsula)"},
	["mor"] = {"Moro"},
	["mos"] = {"Mossi"},
	["mot"] = {"Barí"},
	["mou"] = {"Mogum"},
	["mov"] = {"Mohave"},
	["mow"] = {"Moi (Congo)"},
	["mox"] = {"Molima"},
	["moy"] = {"Shekkacho"},
	["moz"] = {"Mukulu", "Gergiko"},
	["mpa"] = {"Mpoto"},
	["mpb"] = {"Malak Malak", "Mullukmulluk"},
	["mpc"] = {"Mangarrayi"},
	["mpd"] = {"Machinere"},
	["mpe"] = {"Majang"},
	["mpg"] = {"Marba"},
	["mph"] = {"Maung"},
	["mpi"] = {"Mpade"},
	["mpj"] = {"Martu Wangka", "Wangkajunga"},
	["mpk"] = {"Mbara (Chad)"},
	["mpl"] = {"Middle Watut"},
	["mpm"] = {"Yosondúa Mixtec"},
	["mpn"] = {"Mindiri"},
	["mpo"] = {"Miu"},
	["mpp"] = {"Migabac"},
	["mpq"] = {"Matís"},
	["mpr"] = {"Vangunu"},
	["mps"] = {"Dadibi"},
	["mpt"] = {"Mian"},
	["mpu"] = {"Makuráp"},
	["mpv"] = {"Mungkip"},
	["mpw"] = {"Mapidian"},
	["mpx"] = {"Misima-Panaeati"},
	["mpy"] = {"Mapia"},
	["mpz"] = {"Mpi"},
	["mqa"] = {"Maba (Indonesia)"},
	["mqb"] = {"Mbuko"},
	["mqc"] = {"Mangole"},
	["mqe"] = {"Matepi"},
	["mqf"] = {"Momuna"},
	["mqg"] = {"Kota Bangun Kutai Malay"},
	["mqh"] = {"Tlazoyaltepec Mixtec"},
	["mqi"] = {"Mariri"},
	["mqj"] = {"Mamasa"},
	["mqk"] = {"Rajah Kabunsuwan Manobo"},
	["mql"] = {"Mbelime"},
	["mqm"] = {"South Marquesan"},
	["mqn"] = {"Moronene"},
	["mqo"] = {"Modole"},
	["mqp"] = {"Manipa"},
	["mqq"] = {"Minokok"},
	["mqr"] = {"Mander"},
	["mqs"] = {"West Makian"},
	["mqt"] = {"Mok"},
	["mqu"] = {"Mandari"},
	["mqv"] = {"Mosimo"},
	["mqw"] = {"Murupi"},
	["mqx"] = {"Mamuju"},
	["mqy"] = {"Manggarai"},
	["mqz"] = {"Pano"},
	["mra"] = {"Mlabri"},
	["mrb"] = {"Marino"},
	["mrc"] = {"Maricopa"},
	["mrd"] = {"Western Magar"},
	["mre"] = {"Martha's Vineyard Sign Language"},
	["mrf"] = {"Elseng"},
	["mrg"] = {"Mising"},
	["mrh"] = {"Mara Chin"},
	["mrj"] = {"Western Mari"},
	["mrk"] = {"Hmwaveke"},
	["mrl"] = {"Mortlockese"},
	["mrm"] = {"Merlav", "Mwerlap"},
	["mrn"] = {"Cheke Holo"},
	["mro"] = {"Mru"},
	["mrp"] = {"Morouas"},
	["mrq"] = {"North Marquesan"},
	["mrr"] = {"Maria (India)"},
	["mrs"] = {"Maragus"},
	["mrt"] = {"Marghi Central"},
	["mru"] = {"Mono (Cameroon)"},
	["mrv"] = {"Mangareva"},
	["mrw"] = {"Maranao"},
	["mrx"] = {"Maremgi", "Dineor"},
	["mry"] = {"Mandaya"},
	["mrz"] = {"Marind"},
	["msb"] = {"Masbatenyo"},
	["msc"] = {"Sankaran Maninka"},
	["msd"] = {"Yucatec Maya Sign Language"},
	["mse"] = {"Musey"},
	["msf"] = {"Mekwei"},
	["msg"] = {"Moraid"},
	["msh"] = {"Masikoro Malagasy"},
	["msi"] = {"Sabah Malay"},
	["msj"] = {"Ma (Democratic Republic of Congo)"},
	["msk"] = {"Mansaka"},
	["msl"] = {"Molof", "Poule"},
	["msm"] = {"Agusan Manobo"},
	["msn"] = {"Vurës"},
	["mso"] = {"Mombum"},
	["msp"] = {"Maritsauá"},
	["msq"] = {"Caac"},
	["msr"] = {"Mongolian Sign Language"},
	["mss"] = {"West Masela"},
	["msu"] = {"Musom"},
	["msv"] = {"Maslam"},
	["msw"] = {"Mansoanka"},
	["msx"] = {"Moresada"},
	["msy"] = {"Aruamu"},
	["msz"] = {"Momare"},
	["mta"] = {"Cotabato Manobo"},
	["mtb"] = {"Anyin Morofo"},
	["mtc"] = {"Munit"},
	["mtd"] = {"Mualang"},
	["mte"] = {"Mono (Solomon Islands)"},
	["mtf"] = {"Murik (Papua New Guinea)"},
	["mtg"] = {"Una"},
	["mth"] = {"Munggui"},
	["mti"] = {"Maiwa (Papua New Guinea)"},
	["mtj"] = {"Moskona"},
	["mtk"] = {"Mbe'"},
	["mtl"] = {"Montol"},
	["mtm"] = {"Mator"},
	["mtn"] = {"Matagalpa"},
	["mto"] = {"Totontepec Mixe"},
	["mtp"] = {"Wichí Lhamtés Nocten"},
	["mtq"] = {"Muong"},
	["mtr"] = {"Mewari"},
	["mts"] = {"Yora"},
	["mtt"] = {"Mota"},
	["mtu"] = {"Tututepec Mixtec"},
	["mtv"] = {"Asaro'o"},
	["mtw"] = {"Southern Binukidnon"},
	["mtx"] = {"Tidaá Mixtec"},
	["mty"] = {"Nabi"},
	["mua"] = {"Mundang"},
	["mub"] = {"Mubi"},
	["muc"] = {"Ajumbu"},
	["mud"] = {"Mednyj Aleut"},
	["mue"] = {"Media Lengua"},
	["mug"] = {"Musgu"},
	["muh"] = {"Mündü"},
	["mui"] = {"Musi"},
	["muj"] = {"Mabire"},
	["muk"] = {"Mugom"},
	["mul"] = {"Multiple languages"},
	["mum"] = {"Maiwala"},
	["mun"] = {"Munda languages"},
	["muo"] = {"Nyong"},
	["mup"] = {"Malvi"},
	["muq"] = {"Eastern Xiangxi Miao"},
	["mur"] = {"Murle"},
	["mus"] = {"Creek"},
	["mut"] = {"Western Muria"},
	["muu"] = {"Yaaku"},
	["muv"] = {"Muthuvan"},
	["mux"] = {"Bo-Ung"},
	["muy"] = {"Muyang"},
	["muz"] = {"Mursi"},
	["mva"] = {"Manam"},
	["mvb"] = {"Mattole"},
	["mvd"] = {"Mamboru"},
	["mve"] = {"Marwari (Pakistan)"},
	["mvf"] = {"Peripheral Mongolian"},
	["mvg"] = {"Yucuañe Mixtec"},
	["mvh"] = {"Mulgi"},
	["mvi"] = {"Miyako"},
	["mvk"] = {"Mekmek"},
	["mvl"] = {"Mbara (Australia)"},
	["mvn"] = {"Minaveha"},
	["mvo"] = {"Marovo"},
	["mvp"] = {"Duri"},
	["mvq"] = {"Moere"},
	["mvr"] = {"Marau"},
	["mvs"] = {"Massep"},
	["mvt"] = {"Mpotovoro"},
	["mvu"] = {"Marfa"},
	["mvv"] = {"Tagal Murut"},
	["mvw"] = {"Machinga"},
	["mvx"] = {"Meoswar"},
	["mvy"] = {"Indus Kohistani"},
	["mvz"] = {"Mesqan"},
	["mwa"] = {"Mwatebu"},
	["mwb"] = {"Juwal"},
	["mwc"] = {"Are"},
	["mwe"] = {"Mwera (Chimwera)"},
	["mwf"] = {"Murrinh-Patha"},
	["mwg"] = {"Aiklep"},
	["mwh"] = {"Mouk-Aria"},
	["mwi"] = {"Labo", "Ninde"},
	["mwk"] = {"Kita Maninkakan"},
	["mwl"] = {"Mirandese"},
	["mwm"] = {"Sar"},
	["mwn"] = {"Nyamwanga"},
	["mwo"] = {"Central Maewo"},
	["mwp"] = {"Kala Lagaw Ya"},
	["mwq"] = {"Mün Chin"},
	["mwr"] = {"Marwari"},
	["mws"] = {"Mwimbi-Muthambi"},
	["mwt"] = {"Moken"},
	["mwu"] = {"Mittu"},
	["mwv"] = {"Mentawai"},
	["mww"] = {"Hmong Daw"},
	["mwz"] = {"Moingi"},
	["mxa"] = {"Northwest Oaxaca Mixtec"},
	["mxb"] = {"Tezoatlán Mixtec"},
	["mxc"] = {"Manyika"},
	["mxd"] = {"Modang"},
	["mxe"] = {"Mele-Fila"},
	["mxf"] = {"Malgbe"},
	["mxg"] = {"Mbangala"},
	["mxh"] = {"Mvuba"},
	["mxi"] = {"Mozarabic"},
	["mxj"] = {"Miju-Mishmi", "Geman Deng"},
	["mxk"] = {"Monumbo"},
	["mxl"] = {"Maxi Gbe"},
	["mxm"] = {"Meramera"},
	["mxn"] = {"Moi (Indonesia)"},
	["mxo"] = {"Mbowe"},
	["mxp"] = {"Tlahuitoltepec Mixe"},
	["mxq"] = {"Juquila Mixe"},
	["mxr"] = {"Murik (Malaysia)"},
	["mxs"] = {"Huitepec Mixtec"},
	["mxt"] = {"Jamiltepec Mixtec"},
	["mxu"] = {"Mada (Cameroon)"},
	["mxv"] = {"Metlatónoc Mixtec"},
	["mxw"] = {"Namo"},
	["mxx"] = {"Mahou", "Mawukakan"},
	["mxy"] = {"Southeastern Nochixtlán Mixtec"},
	["mxz"] = {"Central Masela"},
	["myb"] = {"Mbay"},
	["myc"] = {"Mayeka"},
	["mye"] = {"Myene"},
	["myf"] = {"Bambassi"},
	["myg"] = {"Manta"},
	["myh"] = {"Makah"},
	["myj"] = {"Mangayat"},
	["myk"] = {"Mamara Senoufo"},
	["myl"] = {"Moma"},
	["mym"] = {"Me'en"},
	["myn"] = {"Mayan languages"},
	["myo"] = {"Anfillo"},
	["myp"] = {"Pirahã"},
	["myr"] = {"Muniche"},
	["mys"] = {"Mesmes"},
	["myu"] = {"Mundurukú"},
	["myv"] = {"Erzya"},
	["myw"] = {"Muyuw"},
	["myx"] = {"Masaaba"},
	["myy"] = {"Macuna"},
	["myz"] = {"Classical Mandaic"},
	["mza"] = {"Santa María Zacatepec Mixtec"},
	["mzb"] = {"Tumzabt"},
	["mzc"] = {"Madagascar Sign Language"},
	["mzd"] = {"Malimba"},
	["mze"] = {"Morawa"},
	["mzg"] = {"Monastic Sign Language"},
	["mzh"] = {"Wichí Lhamtés Güisnay"},
	["mzi"] = {"Ixcatlán Mazatec"},
	["mzj"] = {"Manya"},
	["mzk"] = {"Nigeria Mambila"},
	["mzl"] = {"Mazatlán Mixe"},
	["mzm"] = {"Mumuye"},
	["mzn"] = {"Mazanderani"},
	["mzo"] = {"Matipuhy"},
	["mzp"] = {"Movima"},
	["mzq"] = {"Mori Atas"},
	["mzr"] = {"Marúbo"},
	["mzs"] = {"Macanese"},
	["mzt"] = {"Mintil"},
	["mzu"] = {"Inapang"},
	["mzv"] = {"Manza"},
	["mzw"] = {"Deg"},
	["mzx"] = {"Mawayana"},
	["mzy"] = {"Mozambican Sign Language"},
	["mzz"] = {"Maiadomu"},
	["naa"] = {"Namla"},
	["nab"] = {"Southern Nambikuára"},
	["nac"] = {"Narak"},
	["nae"] = {"Naka'ela"},
	["naf"] = {"Nabak"},
	["nag"] = {"Naga Pidgin"},
	["nah"] = {"Nahuatl languages"},
	["nai"] = {"North American Indian languages"},
	["naj"] = {"Nalu"},
	["nak"] = {"Nakanai"},
	["nal"] = {"Nalik"},
	["nam"] = {"Ngan'gityemerri"},
	["nan"] = {"Min Nan Chinese"},
	["nao"] = {"Naaba"},
	["nap"] = {"Neapolitan"},
	["naq"] = {"Khoekhoe", "Nama (Namibia)"},
	["nar"] = {"Iguta"},
	["nas"] = {"Naasioi"},
	["nat"] = {"Ca̱hungwa̱rya̱", "Hungworo"},
	["naw"] = {"Nawuri"},
	["nax"] = {"Nakwi"},
	["nay"] = {"Ngarrindjeri"},
	["naz"] = {"Coatepec Nahuatl"},
	["nba"] = {"Nyemba"},
	["nbb"] = {"Ndoe"},
	["nbc"] = {"Chang Naga"},
	["nbd"] = {"Ngbinda"},
	["nbe"] = {"Konyak Naga"},
	["nbg"] = {"Nagarchal"},
	["nbh"] = {"Ngamo"},
	["nbi"] = {"Mao Naga"},
	["nbj"] = {"Ngarinyman"},
	["nbk"] = {"Nake"},
	["nbm"] = {"Ngbaka Ma'bo"},
	["nbn"] = {"Kuri"},
	["nbo"] = {"Nkukoli"},
	["nbp"] = {"Nnam"},
	["nbq"] = {"Nggem"},
	["nbr"] = {"Numana"},
	["nbs"] = {"Namibian Sign Language"},
	["nbt"] = {"Na"},
	["nbu"] = {"Rongmei Naga"},
	["nbv"] = {"Ngamambo"},
	["nbw"] = {"Southern Ngbandi"},
	["nby"] = {"Ningera"},
	["nca"] = {"Iyo"},
	["ncb"] = {"Central Nicobarese"},
	["ncc"] = {"Ponam"},
	["ncd"] = {"Nachering"},
	["nce"] = {"Yale"},
	["ncf"] = {"Notsi"},
	["ncg"] = {"Nisga'a"},
	["nch"] = {"Central Huasteca Nahuatl"},
	["nci"] = {"Classical Nahuatl"},
	["ncj"] = {"Northern Puebla Nahuatl"},
	["nck"] = {"Na-kara"},
	["ncl"] = {"Michoacán Nahuatl"},
	["ncm"] = {"Nambo"},
	["ncn"] = {"Nauna"},
	["nco"] = {"Sibe"},
	["ncq"] = {"Northern Katang"},
	["ncr"] = {"Ncane"},
	["ncs"] = {"Nicaraguan Sign Language"},
	["nct"] = {"Chothe Naga"},
	["ncu"] = {"Chumburung"},
	["ncx"] = {"Central Puebla Nahuatl"},
	["ncz"] = {"Natchez"},
	["nda"] = {"Ndasa"},
	["ndb"] = {"Kenswei Nsei"},
	["ndc"] = {"Ndau"},
	["ndd"] = {"Nde-Nsele-Nta"},
	["ndf"] = {"Nadruvian"},
	["ndg"] = {"Ndengereko"},
	["ndh"] = {"Ndali"},
	["ndi"] = {"Samba Leko"},
	["ndj"] = {"Ndamba"},
	["ndk"] = {"Ndaka"},
	["ndl"] = {"Ndolo"},
	["ndm"] = {"Ndam"},
	["ndn"] = {"Ngundi"},
	["ndp"] = {"Ndo"},
	["ndq"] = {"Ndombe"},
	["ndr"] = {"Ndoola"},
	["nds"] = {"Low German", "Low Saxon"},
	["ndt"] = {"Ndunga"},
	["ndu"] = {"Dugun"},
	["ndv"] = {"Ndut"},
	["ndw"] = {"Ndobo"},
	["ndx"] = {"Nduga"},
	["ndy"] = {"Lutos"},
	["ndz"] = {"Ndogo"},
	["nea"] = {"Eastern Ngad'a"},
	["neb"] = {"Toura (Côte d'Ivoire)"},
	["nec"] = {"Nedebang"},
	["ned"] = {"Nde-Gbite"},
	["nee"] = {"Nêlêmwa-Nixumwak"},
	["nef"] = {"Nefamese"},
	["neg"] = {"Negidal"},
	["neh"] = {"Nyenkha"},
	["nei"] = {"Neo-Hittite"},
	["nej"] = {"Neko"},
	["nek"] = {"Neku"},
	["nem"] = {"Nemi"},
	["nen"] = {"Nengone"},
	["neo"] = {"Ná-Meo"},
	["neq"] = {"North Central Mixe"},
	["ner"] = {"Yahadian"},
	["nes"] = {"Bhoti Kinnauri"},
	["net"] = {"Nete"},
	["neu"] = {"Neo"},
	["nev"] = {"Nyaheun"},
	["new"] = {"Nepal Bhasa", "Newar", "Newari"},
	["nex"] = {"Neme"},
	["ney"] = {"Neyo"},
	["nez"] = {"Nez Perce"},
	["nfa"] = {"Dhao"},
	["nfd"] = {"Ahwai"},
	["nfl"] = {"Ayiwo", "Äiwoo"},
	["nfr"] = {"Nafaanra"},
	["nfu"] = {"Mfumte"},
	["nga"] = {"Ngbaka"},
	["ngb"] = {"Northern Ngbandi"},
	["ngc"] = {"Ngombe (Democratic Republic of Congo)"},
	["ngd"] = {"Ngando (Central African Republic)"},
	["nge"] = {"Ngemba"},
	["ngf"] = {"Trans-New Guinea languages"},
	["ngg"] = {"Ngbaka Manza"},
	["ngh"] = {"Nǁng"},
	["ngi"] = {"Ngizim"},
	["ngj"] = {"Ngie"},
	["ngk"] = {"Dalabon"},
	["ngl"] = {"Lomwe"},
	["ngm"] = {"Ngatik Men's Creole"},
	["ngn"] = {"Ngwo"},
	["ngp"] = {"Ngulu"},
	["ngq"] = {"Ngurimi", "Ngoreme"},
	["ngr"] = {"Engdewu"},
	["ngs"] = {"Gvoko"},
	["ngt"] = {"Kriang", "Ngeq"},
	["ngu"] = {"Guerrero Nahuatl"},
	["ngv"] = {"Nagumi"},
	["ngw"] = {"Ngwaba"},
	["ngx"] = {"Nggwahyi"},
	["ngy"] = {"Tibea"},
	["ngz"] = {"Ngungwel"},
	["nha"] = {"Nhanda"},
	["nhb"] = {"Beng"},
	["nhc"] = {"Tabasco Nahuatl"},
	["nhd"] = {"Chiripá", "Ava Guaraní"},
	["nhe"] = {"Eastern Huasteca Nahuatl"},
	["nhf"] = {"Nhuwala"},
	["nhg"] = {"Tetelcingo Nahuatl"},
	["nhh"] = {"Nahari"},
	["nhi"] = {"Zacatlán-Ahuacatlán-Tepetzintla Nahuatl"},
	["nhk"] = {"Isthmus-Cosoleacaque Nahuatl"},
	["nhm"] = {"Morelos Nahuatl"},
	["nhn"] = {"Central Nahuatl"},
	["nho"] = {"Takuu"},
	["nhp"] = {"Isthmus-Pajapan Nahuatl"},
	["nhq"] = {"Huaxcaleca Nahuatl"},
	["nhr"] = {"Naro"},
	["nht"] = {"Ometepec Nahuatl"},
	["nhu"] = {"Noone"},
	["nhv"] = {"Temascaltepec Nahuatl"},
	["nhw"] = {"Western Huasteca Nahuatl"},
	["nhx"] = {"Isthmus-Mecayapan Nahuatl"},
	["nhy"] = {"Northern Oaxaca Nahuatl"},
	["nhz"] = {"Santa María La Alta Nahuatl"},
	["nia"] = {"Nias"},
	["nib"] = {"Nakame"},
	["nic"] = {"Niger-Kordofanian languages"},
	["nid"] = {"Ngandi"},
	["nie"] = {"Niellim"},
	["nif"] = {"Nek"},
	["nig"] = {"Ngalakgan"},
	["nih"] = {"Nyiha (Tanzania)"},
	["nii"] = {"Nii"},
	["nij"] = {"Ngaju"},
	["nik"] = {"Southern Nicobarese"},
	["nil"] = {"Nila"},
	["nim"] = {"Nilamba"},
	["nin"] = {"Ninzo"},
	["nio"] = {"Nganasan"},
	["niq"] = {"Nandi"},
	["nir"] = {"Nimboran"},
	["nis"] = {"Nimi"},
	["nit"] = {"Southeastern Kolami"},
	["niu"] = {"Niuean"},
	["niv"] = {"Gilyak"},
	["niw"] = {"Nimo"},
	["nix"] = {"Hema"},
	["niy"] = {"Ngiti"},
	["niz"] = {"Ningil"},
	["nja"] = {"Nzanyi"},
	["njb"] = {"Nocte Naga"},
	["njd"] = {"Ndonde Hamba"},
	["njh"] = {"Lotha Naga"},
	["nji"] = {"Gudanji"},
	["njj"] = {"Njen"},
	["njl"] = {"Njalgulgule"},
	["njm"] = {"Angami Naga"},
	["njn"] = {"Liangmai Naga"},
	["njo"] = {"Ao Naga"},
	["njr"] = {"Njerep"},
	["njs"] = {"Nisa"},
	["njt"] = {"Ndyuka-Trio Pidgin"},
	["nju"] = {"Ngadjunmaya"},
	["njx"] = {"Kunyi"},
	["njy"] = {"Njyem"},
	["njz"] = {"Nyishi"},
	["nka"] = {"Nkoya"},
	["nkb"] = {"Khoibu Naga"},
	["nkc"] = {"Nkongho"},
	["nkd"] = {"Koireng"},
	["nke"] = {"Duke"},
	["nkf"] = {"Inpui Naga"},
	["nkg"] = {"Nekgini"},
	["nkh"] = {"Khezha Naga"},
	["nki"] = {"Thangal Naga"},
	["nkj"] = {"Nakai"},
	["nkk"] = {"Nokuku"},
	["nkm"] = {"Namat"},
	["nkn"] = {"Nkangala"},
	["nko"] = {"Nkonya"},
	["nkp"] = {"Niuatoputapu"},
	["nkq"] = {"Nkami"},
	["nkr"] = {"Nukuoro"},
	["nks"] = {"North Asmat"},
	["nkt"] = {"Nyika (Tanzania)"},
	["nku"] = {"Bouna Kulango"},
	["nkv"] = {"Nyika (Malawi and Zambia)"},
	["nkw"] = {"Nkutu"},
	["nkx"] = {"Nkoroo"},
	["nkz"] = {"Nkari"},
	["nla"] = {"Ngombale"},
	["nlc"] = {"Nalca"},
	["nle"] = {"East Nyala"},
	["nlg"] = {"Gela"},
	["nli"] = {"Grangali"},
	["nlj"] = {"Nyali"},
	["nlk"] = {"Ninia Yali"},
	["nll"] = {"Nihali"},
	["nlm"] = {"Mankiyali"},
	["nlo"] = {"Ngul"},
	["nlq"] = {"Lao Naga"},
	["nlu"] = {"Nchumbulu"},
	["nlv"] = {"Orizaba Nahuatl"},
	["nlw"] = {"Walangama"},
	["nlx"] = {"Nahali"},
	["nly"] = {"Nyamal"},
	["nlz"] = {"Nalögo"},
	["nma"] = {"Maram Naga"},
	["nmb"] = {"Big Nambas", "V'ënen Taut"},
	["nmc"] = {"Ngam"},
	["nmd"] = {"Ndumu"},
	["nme"] = {"Mzieme Naga"},
	["nmf"] = {"Tangkhul Naga (India)"},
	["nmg"] = {"Kwasio"},
	["nmh"] = {"Monsang Naga"},
	["nmi"] = {"Nyam"},
	["nmj"] = {"Ngombe (Central African Republic)"},
	["nmk"] = {"Namakura"},
	["nml"] = {"Ndemli"},
	["nmm"] = {"Manangba"},
	["nmn"] = {"ǃXóõ"},
	["nmo"] = {"Moyon Naga"},
	["nmp"] = {"Nimanbur"},
	["nmq"] = {"Nambya"},
	["nmr"] = {"Nimbari"},
	["nms"] = {"Letemboi"},
	["nmt"] = {"Namonuito"},
	["nmu"] = {"Northeast Maidu"},
	["nmv"] = {"Ngamini"},
	["nmw"] = {"Nimoa", "Rifao"},
	["nmx"] = {"Nama (Papua New Guinea)"},
	["nmy"] = {"Namuyi"},
	["nmz"] = {"Nawdm"},
	["nna"] = {"Nyangumarta"},
	["nnb"] = {"Nande"},
	["nnc"] = {"Nancere"},
	["nnd"] = {"West Ambae"},
	["nne"] = {"Ngandyera"},
	["nnf"] = {"Ngaing"},
	["nng"] = {"Maring Naga"},
	["nnh"] = {"Ngiemboon"},
	["nni"] = {"North Nuaulu"},
	["nnj"] = {"Nyangatom"},
	["nnk"] = {"Nankina"},
	["nnl"] = {"Northern Rengma Naga"},
	["nnm"] = {"Namia"},
	["nnn"] = {"Ngete"},
	["nnp"] = {"Wancho Naga"},
	["nnq"] = {"Ngindo"},
	["nnr"] = {"Narungga"},
	["nnt"] = {"Nanticoke"},
	["nnu"] = {"Dwang"},
	["nnv"] = {"Nugunu (Australia)"},
	["nnw"] = {"Southern Nuni"},
	["nny"] = {"Nyangga"},
	["nnz"] = {"Nda'nda'"},
	["noa"] = {"Woun Meu"},
	["noc"] = {"Nuk"},
	["nod"] = {"Northern Thai"},
	["noe"] = {"Nimadi"},
	["nof"] = {"Nomane"},
	["nog"] = {"Nogai"},
	["noh"] = {"Nomu"},
	["noi"] = {"Noiri"},
	["noj"] = {"Nonuya"},
	["nok"] = {"Nooksack"},
	["nol"] = {"Nomlaki"},
	["non"] = {"Old Norse"},
	["nop"] = {"Numanggang"},
	["noq"] = {"Ngongo"},
	["nos"] = {"Eastern Nisu"},
	["not"] = {"Nomatsiguenga"},
	["nou"] = {"Ewage-Notu"},
	["nov"] = {"Novial"},
	["now"] = {"Nyambo"},
	["noy"] = {"Noy"},
	["noz"] = {"Nayi"},
	["npa"] = {"Nar Phu"},
	["npb"] = {"Nupbikha"},
	["npg"] = {"Ponyo-Gongwang Naga"},
	["nph"] = {"Phom Naga"},
	["npi"] = {"Nepali (individual language)"},
	["npl"] = {"Southeastern Puebla Nahuatl"},
	["npn"] = {"Mondropolon"},
	["npo"] = {"Pochuri Naga"},
	["nps"] = {"Nipsan"},
	["npu"] = {"Puimei Naga"},
	["npx"] = {"Noipx"},
	["npy"] = {"Napu"},
	["nqg"] = {"Southern Nago"},
	["nqk"] = {"Kura Ede Nago"},
	["nql"] = {"Ngendelengo"},
	["nqm"] = {"Ndom"},
	["nqn"] = {"Nen"},
	["nqo"] = {"N'Ko", "N’Ko"},
	["nqq"] = {"Kyan-Karyaw Naga"},
	["nqt"] = {"Nteng"},
	["nqy"] = {"Akyaung Ari Naga"},
	["nra"] = {"Ngom"},
	["nrb"] = {"Nara"},
	["nrc"] = {"Noric"},
	["nre"] = {"Southern Rengma Naga"},
	["nrf"] = {"Jèrriais", "Guernésiais", "Sercquiais"},
	["nrg"] = {"Narango"},
	["nri"] = {"Chokri Naga"},
	["nrk"] = {"Ngarla"},
	["nrl"] = {"Ngarluma"},
	["nrm"] = {"Narom"},
	["nrn"] = {"Norn"},
	["nrp"] = {"North Picene"},
	["nrr"] = {"Norra", "Nora"},
	["nrt"] = {"Northern Kalapuya"},
	["nru"] = {"Narua"},
	["nrx"] = {"Ngurmbur"},
	["nrz"] = {"Lala"},
	["nsa"] = {"Sangtam Naga"},
	["nsb"] = {"Lower Nossob"},
	["nsc"] = {"Nshi"},
	["nsd"] = {"Southern Nisu"},
	["nse"] = {"Nsenga"},
	["nsf"] = {"Northwestern Nisu"},
	["nsg"] = {"Ngasa"},
	["nsh"] = {"Ngoshie"},
	["nsi"] = {"Nigerian Sign Language"},
	["nsk"] = {"Naskapi"},
	["nsl"] = {"Norwegian Sign Language"},
	["nsm"] = {"Sumi Naga"},
	["nsn"] = {"Nehan"},
	["nso"] = {"Pedi", "Northern Sotho", "Sepedi"},
	["nsp"] = {"Nepalese Sign Language"},
	["nsq"] = {"Northern Sierra Miwok"},
	["nsr"] = {"Maritime Sign Language"},
	["nss"] = {"Nali"},
	["nst"] = {"Tase Naga"},
	["nsu"] = {"Sierra Negra Nahuatl"},
	["nsv"] = {"Southwestern Nisu"},
	["nsw"] = {"Navut"},
	["nsx"] = {"Nsongo"},
	["nsy"] = {"Nasal"},
	["nsz"] = {"Nisenan"},
	["ntd"] = {"Northern Tidung"},
	["ntg"] = {"Ngantangarra"},
	["nti"] = {"Natioro"},
	["ntj"] = {"Ngaanyatjarra"},
	["ntk"] = {"Ikoma-Nata-Isenye"},
	["ntm"] = {"Nateni"},
	["nto"] = {"Ntomba"},
	["ntp"] = {"Northern Tepehuan"},
	["ntr"] = {"Delo"},
	["ntu"] = {"Natügu"},
	["ntw"] = {"Nottoway"},
	["ntx"] = {"Tangkhul Naga (Myanmar)"},
	["nty"] = {"Mantsi"},
	["ntz"] = {"Natanzi"},
	["nua"] = {"Yuanga"},
	["nub"] = {"Nubian languages"},
	["nuc"] = {"Nukuini"},
	["nud"] = {"Ngala"},
	["nue"] = {"Ngundu"},
	["nuf"] = {"Nusu"},
	["nug"] = {"Nungali"},
	["nuh"] = {"Ndunda"},
	["nui"] = {"Ngumbi"},
	["nuj"] = {"Nyole"},
	["nuk"] = {"Nuu-chah-nulth", "Nuuchahnulth"},
	["nul"] = {"Nusa Laut"},
	["num"] = {"Niuafo'ou"},
	["nun"] = {"Anong"},
	["nuo"] = {"Nguôn"},
	["nup"] = {"Nupe-Nupe-Tako"},
	["nuq"] = {"Nukumanu"},
	["nur"] = {"Nukuria"},
	["nus"] = {"Nuer"},
	["nut"] = {"Nung (Viet Nam)"},
	["nuu"] = {"Ngbundu"},
	["nuv"] = {"Northern Nuni"},
	["nuw"] = {"Nguluwan"},
	["nux"] = {"Mehek"},
	["nuy"] = {"Nunggubuyu"},
	["nuz"] = {"Tlamacazapa Nahuatl"},
	["nvh"] = {"Nasarian"},
	["nvm"] = {"Namiae"},
	["nvo"] = {"Nyokon"},
	["nwa"] = {"Nawathinehena"},
	["nwb"] = {"Nyabwa"},
	["nwc"] = {"Classical Newari", "Classical Nepal Bhasa", "Old Newari"},
	["nwe"] = {"Ngwe"},
	["nwg"] = {"Ngayawung"},
	["nwi"] = {"Southwest Tanna"},
	["nwm"] = {"Nyamusa-Molo"},
	["nwo"] = {"Nauo"},
	["nwr"] = {"Nawaru"},
	["nww"] = {"Ndwewe"},
	["nwx"] = {"Middle Newar"},
	["nwy"] = {"Nottoway-Meherrin"},
	["nxa"] = {"Nauete"},
	["nxd"] = {"Ngando (Democratic Republic of Congo)"},
	["nxe"] = {"Nage"},
	["nxg"] = {"Ngad'a"},
	["nxi"] = {"Nindi"},
	["nxk"] = {"Koki Naga"},
	["nxl"] = {"South Nuaulu"},
	["nxm"] = {"Numidian"},
	["nxn"] = {"Ngawun"},
	["nxo"] = {"Ndambomo"},
	["nxq"] = {"Naxi"},
	["nxr"] = {"Ninggerum"},
	["nxx"] = {"Nafri"},
	["nyb"] = {"Nyangbo"},
	["nyc"] = {"Nyanga-li"},
	["nyd"] = {"Nyore", "Olunyole"},
	["nye"] = {"Nyengo"},
	["nyf"] = {"Giryama", "Kigiryama"},
	["nyg"] = {"Nyindu"},
	["nyh"] = {"Nyikina"},
	["nyi"] = {"Ama (Sudan)"},
	["nyj"] = {"Nyanga"},
	["nyk"] = {"Nyaneka"},
	["nyl"] = {"Nyeu"},
	["nym"] = {"Nyamwezi"},
	["nyn"] = {"Nyankole"},
	["nyo"] = {"Nyoro"},
	["nyp"] = {"Nyang'i"},
	["nyq"] = {"Nayini"},
	["nyr"] = {"Nyiha (Malawi)"},
	["nys"] = {"Nyungar"},
	["nyt"] = {"Nyawaygi"},
	["nyu"] = {"Nyungwe"},
	["nyv"] = {"Nyulnyul"},
	["nyw"] = {"Nyaw"},
	["nyx"] = {"Nganyaywana"},
	["nyy"] = {"Nyakyusa-Ngonde"},
	["nza"] = {"Tigon Mbembe"},
	["nzb"] = {"Njebi"},
	["nzd"] = {"Nzadi"},
	["nzi"] = {"Nzima"},
	["nzk"] = {"Nzakara"},
	["nzm"] = {"Zeme Naga"},
	["nzr"] = {"Dir-Nyamzak-Mbarimi"},
	["nzs"] = {"New Zealand Sign Language"},
	["nzu"] = {"Teke-Nzikou"},
	["nzy"] = {"Nzakambay"},
	["nzz"] = {"Nanga Dama Dogon"},
	["oaa"] = {"Orok"},
	["oac"] = {"Oroch"},
	["oak"] = {"Noakhali", "Noakhailla"},
	["oar"] = {"Old Aramaic (up to 700 BCE)", "Ancient Aramaic (up to 700 BCE)"},
	["oav"] = {"Old Avar"},
	["obi"] = {"Obispeño"},
	["obk"] = {"Southern Bontok"},
	["obl"] = {"Oblo"},
	["obm"] = {"Moabite"},
	["obo"] = {"Obo Manobo"},
	["obr"] = {"Old Burmese"},
	["obt"] = {"Old Breton"},
	["obu"] = {"Obulom"},
	["oca"] = {"Ocaina"},
	["och"] = {"Old Chinese"},
	["ocm"] = {"Old Cham"},
	["oco"] = {"Old Cornish"},
	["ocu"] = {"Atzingo Matlatzinca"},
	["oda"] = {"Odut"},
	["odk"] = {"Od"},
	["odt"] = {"Old Dutch"},
	["odu"] = {"Odual"},
	["ofo"] = {"Ofo"},
	["ofs"] = {"Old Frisian"},
	["ofu"] = {"Efutop"},
	["ogb"] = {"Ogbia"},
	["ogc"] = {"Ogbah"},
	["oge"] = {"Old Georgian"},
	["ogg"] = {"Ogbogolo"},
	["ogo"] = {"Khana"},
	["ogu"] = {"Ogbronuagum"},
	["oht"] = {"Old Hittite"},
	["ohu"] = {"Old Hungarian"},
	["oia"] = {"Oirata"},
	["oie"] = {"Okolie"},
	["oin"] = {"Inebu One"},
	["ojb"] = {"Northwestern Ojibwa"},
	["ojc"] = {"Central Ojibwa"},
	["ojg"] = {"Eastern Ojibwa"},
	["ojp"] = {"Old Japanese"},
	["ojs"] = {"Severn Ojibwa"},
	["ojv"] = {"Ontong Java"},
	["ojw"] = {"Western Ojibwa"},
	["oka"] = {"Okanagan"},
	["okb"] = {"Okobo"},
	["okc"] = {"Kobo"},
	["okd"] = {"Okodia"},
	["oke"] = {"Okpe (Southwestern Edo)"},
	["okg"] = {"Koko Babangk"},
	["okh"] = {"Koresh-e Rostam"},
	["oki"] = {"Okiek"},
	["okj"] = {"Oko-Juwoi"},
	["okk"] = {"Kwamtim One"},
	["okl"] = {"Old Kentish Sign Language"},
	["okm"] = {"Middle Korean (10th-16th cent.)"},
	["okn"] = {"Oki-No-Erabu"},
	["oko"] = {"Old Korean (3rd-9th cent.)"},
	["okr"] = {"Kirike"},
	["oks"] = {"Oko-Eni-Osayen"},
	["oku"] = {"Oku"},
	["okv"] = {"Orokaiva"},
	["okx"] = {"Okpe (Northwestern Edo)"},
	["okz"] = {"Old Khmer"},
	["ola"] = {"Walungge"},
	["old"] = {"Mochi"},
	["ole"] = {"Olekha"},
	["olk"] = {"Olkol"},
	["olm"] = {"Oloma"},
	["olo"] = {"Livvi"},
	["olr"] = {"Olrat"},
	["olt"] = {"Old Lithuanian"},
	["olu"] = {"Kuvale"},
	["oma"] = {"Omaha-Ponca"},
	["omb"] = {"East Ambae"},
	["omc"] = {"Mochica"},
	["omg"] = {"Omagua"},
	["omi"] = {"Omi"},
	["omk"] = {"Omok"},
	["oml"] = {"Ombo"},
	["omn"] = {"Minoan"},
	["omo"] = {"Utarmbung"},
	["omp"] = {"Old Manipuri"},
	["omq"] = {"Oto-Manguean languages"},
	["omr"] = {"Old Marathi"},
	["omt"] = {"Omotik"},
	["omu"] = {"Omurano"},
	["omv"] = {"Omotic languages"},
	["omw"] = {"South Tairora"},
	["omx"] = {"Old Mon"},
	["omy"] = {"Old Malay"},
	["ona"] = {"Ona"},
	["onb"] = {"Lingao"},
	["one"] = {"Oneida"},
	["ong"] = {"Olo"},
	["oni"] = {"Onin"},
	["onj"] = {"Onjob"},
	["onk"] = {"Kabore One"},
	["onn"] = {"Onobasulu"},
	["ono"] = {"Onondaga"},
	["onp"] = {"Sartang"},
	["onr"] = {"Northern One"},
	["ons"] = {"Ono"},
	["ont"] = {"Ontenu"},
	["onu"] = {"Unua"},
	["onw"] = {"Old Nubian"},
	["onx"] = {"Onin Based Pidgin"},
	["ood"] = {"Tohono O'odham"},
	["oog"] = {"Ong"},
	["oon"] = {"Önge"},
	["oor"] = {"Oorlams"},
	["oos"] = {"Old Ossetic"},
	["opa"] = {"Okpamheri"},
	["opk"] = {"Kopkaka"},
	["opm"] = {"Oksapmin"},
	["opo"] = {"Opao"},
	["opt"] = {"Opata"},
	["opy"] = {"Ofayé"},
	["ora"] = {"Oroha"},
	["orc"] = {"Orma"},
	["ore"] = {"Orejón"},
	["org"] = {"Oring"},
	["orh"] = {"Oroqen"},
	["orn"] = {"Orang Kanaq"},
	["oro"] = {"Orokolo"},
	["orr"] = {"Oruma"},
	["ors"] = {"Orang Seletar"},
	["ort"] = {"Adivasi Oriya"},
	["oru"] = {"Ormuri"},
	["orv"] = {"Old Russian"},
	["orw"] = {"Oro Win"},
	["orx"] = {"Oro"},
	["ory"] = {"Odia (individual language)", "Oriya (individual language)"},
	["orz"] = {"Ormu"},
	["osa"] = {"Osage"},
	["osc"] = {"Oscan"},
	["osi"] = {"Osing"},
	["osn"] = {"Old Sundanese"},
	["oso"] = {"Ososo"},
	["osp"] = {"Old Spanish"},
	["ost"] = {"Osatu"},
	["osu"] = {"Southern One"},
	["osx"] = {"Old Saxon"},
	["ota"] = {"Ottoman Turkish (1500-1928)"},
	["otb"] = {"Old Tibetan"},
	["otd"] = {"Ot Danum"},
	["ote"] = {"Mezquital Otomi"},
	["oti"] = {"Oti"},
	["otk"] = {"Old Turkish"},
	["otl"] = {"Tilapa Otomi"},
	["otm"] = {"Eastern Highland Otomi"},
	["otn"] = {"Tenango Otomi"},
	["oto"] = {"Otomian languages"},
	["otq"] = {"Querétaro Otomi"},
	["otr"] = {"Otoro"},
	["ots"] = {"Estado de México Otomi"},
	["ott"] = {"Temoaya Otomi"},
	["otu"] = {"Otuke"},
	["otw"] = {"Ottawa"},
	["otx"] = {"Texcatepec Otomi"},
	["oty"] = {"Old Tamil"},
	["otz"] = {"Ixtenco Otomi"},
	["oua"] = {"Tagargrent"},
	["oub"] = {"Glio-Oubi"},
	["oue"] = {"Oune"},
	["oui"] = {"Old Uighur"},
	["oum"] = {"Ouma"},
	["ovd"] = {"Elfdalian", "Övdalian"},
	["owi"] = {"Owiniga"},
	["owl"] = {"Old Welsh"},
	["oyb"] = {"Oy"},
	["oyd"] = {"Oyda"},
	["oym"] = {"Wayampi"},
	["oyy"] = {"Oya'oya"},
	["ozm"] = {"Koonzime"},
	["paa"] = {"Papuan languages"},
	["pab"] = {"Parecís"},
	["pac"] = {"Pacoh"},
	["pad"] = {"Paumarí"},
	["pae"] = {"Pagibete"},
	["paf"] = {"Paranawát"},
	["pag"] = {"Pangasinan"},
	["pah"] = {"Tenharim"},
	["pai"] = {"Pe"},
	["pak"] = {"Parakanã"},
	["pal"] = {"Pahlavi"},
	["pam"] = {"Pampanga", "Kapampangan"},
	["pao"] = {"Northern Paiute"},
	["pap"] = {"Papiamento"},
	["paq"] = {"Parya"},
	["par"] = {"Panamint", "Timbisha"},
	["pas"] = {"Papasena"},
	["pau"] = {"Palauan"},
	["pav"] = {"Pakaásnovos"},
	["paw"] = {"Pawnee"},
	["pax"] = {"Pankararé"},
	["pay"] = {"Pech"},
	["paz"] = {"Pankararú"},
	["pbb"] = {"Páez"},
	["pbc"] = {"Patamona"},
	["pbe"] = {"Mezontla Popoloca"},
	["pbf"] = {"Coyotepec Popoloca"},
	["pbg"] = {"Paraujano"},
	["pbh"] = {"E'ñapa Woromaipu"},
	["pbi"] = {"Parkwa"},
	["pbl"] = {"Mak (Nigeria)"},
	["pbm"] = {"Puebla Mazatec"},
	["pbn"] = {"Kpasam"},
	["pbo"] = {"Papel"},
	["pbp"] = {"Badyara"},
	["pbr"] = {"Pangwa"},
	["pbs"] = {"Central Pame"},
	["pbt"] = {"Southern Pashto"},
	["pbu"] = {"Northern Pashto"},
	["pbv"] = {"Pnar"},
	["pby"] = {"Pyu (Papua New Guinea)"},
	["pca"] = {"Santa Inés Ahuatempan Popoloca"},
	["pcb"] = {"Pear"},
	["pcc"] = {"Bouyei"},
	["pcd"] = {"Picard"},
	["pce"] = {"Ruching Palaung"},
	["pcf"] = {"Paliyan"},
	["pcg"] = {"Paniya"},
	["pch"] = {"Pardhan"},
	["pci"] = {"Duruwa"},
	["pcj"] = {"Parenga"},
	["pck"] = {"Paite Chin"},
	["pcl"] = {"Pardhi"},
	["pcm"] = {"Nigerian Pidgin"},
	["pcn"] = {"Piti"},
	["pcp"] = {"Pacahuara"},
	["pcw"] = {"Pyapun"},
	["pda"] = {"Anam"},
	["pdc"] = {"Pennsylvania German"},
	["pdi"] = {"Pa Di"},
	["pdn"] = {"Podena", "Fedan"},
	["pdo"] = {"Padoe"},
	["pdt"] = {"Plautdietsch"},
	["pdu"] = {"Kayan"},
	["pea"] = {"Peranakan Indonesian"},
	["peb"] = {"Eastern Pomo"},
	["ped"] = {"Mala (Papua New Guinea)"},
	["pee"] = {"Taje"},
	["pef"] = {"Northeastern Pomo"},
	["peg"] = {"Pengo"},
	["peh"] = {"Bonan"},
	["pei"] = {"Chichimeca-Jonaz"},
	["pej"] = {"Northern Pomo"},
	["pek"] = {"Penchal"},
	["pel"] = {"Pekal"},
	["pem"] = {"Phende"},
	["peo"] = {"Old Persian (ca. 600-400 B.C.)"},
	["pep"] = {"Kunja"},
	["peq"] = {"Southern Pomo"},
	["pes"] = {"Iranian Persian"},
	["pev"] = {"Pémono"},
	["pex"] = {"Petats"},
	["pey"] = {"Petjo"},
	["pez"] = {"Eastern Penan"},
	["pfa"] = {"Pááfang"},
	["pfe"] = {"Pere"},
	["pfl"] = {"Pfaelzisch"},
	["pga"] = {"Sudanese Creole Arabic"},
	["pgd"] = {"Gāndhārī"},
	["pgg"] = {"Pangwali"},
	["pgi"] = {"Pagi"},
	["pgk"] = {"Rerep"},
	["pgl"] = {"Primitive Irish"},
	["pgn"] = {"Paelignian"},
	["pgs"] = {"Pangseng"},
	["pgu"] = {"Pagu"},
	["pgz"] = {"Papua New Guinean Sign Language"},
	["pha"] = {"Pa-Hng"},
	["phd"] = {"Phudagi"},
	["phg"] = {"Phuong"},
	["phh"] = {"Phukha"},
	["phi"] = {"Philippine languages"},
	["phj"] = {"Pahari"},
	["phk"] = {"Phake"},
	["phl"] = {"Phalura", "Palula"},
	["phm"] = {"Phimbi"},
	["phn"] = {"Phoenician"},
	["pho"] = {"Phunoi"},
	["phq"] = {"Phana'"},
	["phr"] = {"Pahari-Potwari"},
	["pht"] = {"Phu Thai"},
	["phu"] = {"Phuan"},
	["phv"] = {"Pahlavani"},
	["phw"] = {"Phangduwali"},
	["pia"] = {"Pima Bajo"},
	["pib"] = {"Yine"},
	["pic"] = {"Pinji"},
	["pid"] = {"Piaroa"},
	["pie"] = {"Piro"},
	["pif"] = {"Pingelapese"},
	["pig"] = {"Pisabo"},
	["pih"] = {"Pitcairn-Norfolk"},
	["pij"] = {"Pijao"},
	["pil"] = {"Yom"},
	["pim"] = {"Powhatan"},
	["pin"] = {"Piame"},
	["pio"] = {"Piapoco"},
	["pip"] = {"Pero"},
	["pir"] = {"Piratapuyo"},
	["pis"] = {"Pijin"},
	["pit"] = {"Pitta Pitta"},
	["piu"] = {"Pintupi-Luritja"},
	["piv"] = {"Pileni", "Vaeakau-Taumako"},
	["piw"] = {"Pimbwe"},
	["pix"] = {"Piu"},
	["piy"] = {"Piya-Kwonci"},
	["piz"] = {"Pije"},
	["pjt"] = {"Pitjantjatjara"},
	["pka"] = {"Ardhamāgadhī Prākrit"},
	["pkb"] = {"Pokomo", "Kipfokomo"},
	["pkc"] = {"Paekche"},
	["pkg"] = {"Pak-Tong"},
	["pkh"] = {"Pankhu"},
	["pkn"] = {"Pakanha"},
	["pko"] = {"Pökoot"},
	["pkp"] = {"Pukapuka"},
	["pkr"] = {"Attapady Kurumba"},
	["pks"] = {"Pakistan Sign Language"},
	["pkt"] = {"Maleng"},
	["pku"] = {"Paku"},
	["pla"] = {"Miani"},
	["plb"] = {"Polonombauk"},
	["plc"] = {"Central Palawano"},
	["pld"] = {"Polari"},
	["ple"] = {"Palu'e"},
	["plf"] = {"Central Malayo-Polynesian languages"},
	["plg"] = {"Pilagá"},
	["plh"] = {"Paulohi"},
	["plk"] = {"Kohistani Shina"},
	["pll"] = {"Shwe Palaung"},
	["pln"] = {"Palenquero"},
	["plo"] = {"Oluta Popoluca"},
	["plq"] = {"Palaic"},
	["plr"] = {"Palaka Senoufo"},
	["pls"] = {"San Marcos Tlacoyalco Popoloca", "San Marcos Tlalcoyalco Popoloca"},
	["plt"] = {"Plateau Malagasy"},
	["plu"] = {"Palikúr"},
	["plv"] = {"Southwest Palawano"},
	["plw"] = {"Brooke's Point Palawano"},
	["ply"] = {"Bolyu"},
	["plz"] = {"Paluan"},
	["pma"] = {"Paama"},
	["pmb"] = {"Pambia"},
	["pmd"] = {"Pallanganmiddang"},
	["pme"] = {"Pwaamei"},
	["pmf"] = {"Pamona"},
	["pmh"] = {"Māhārāṣṭri Prākrit"},
	["pmi"] = {"Northern Pumi"},
	["pmj"] = {"Southern Pumi"},
	["pml"] = {"Lingua Franca"},
	["pmm"] = {"Pomo"},
	["pmn"] = {"Pam"},
	["pmo"] = {"Pom"},
	["pmq"] = {"Northern Pame"},
	["pmr"] = {"Paynamar"},
	["pms"] = {"Piemontese"},
	["pmt"] = {"Tuamotuan"},
	["pmw"] = {"Plains Miwok"},
	["pmx"] = {"Poumei Naga"},
	["pmy"] = {"Papuan Malay"},
	["pmz"] = {"Southern Pame"},
	["pna"] = {"Punan Bah-Biau"},
	["pnb"] = {"Western Panjabi"},
	["pnc"] = {"Pannei"},
	["pnd"] = {"Mpinda"},
	["pne"] = {"Western Penan"},
	["png"] = {"Pangu", "Pongu"},
	["pnh"] = {"Penrhyn"},
	["pni"] = {"Aoheng"},
	["pnj"] = {"Pinjarup"},
	["pnk"] = {"Paunaka"},
	["pnl"] = {"Paleni"},
	["pnm"] = {"Punan Batu 1"},
	["pnn"] = {"Pinai-Hagahai"},
	["pno"] = {"Panobo"},
	["pnp"] = {"Pancana"},
	["pnq"] = {"Pana (Burkina Faso)"},
	["pnr"] = {"Panim"},
	["pns"] = {"Ponosakan"},
	["pnt"] = {"Pontic"},
	["pnu"] = {"Jiongnai Bunu"},
	["pnv"] = {"Pinigura"},
	["pnw"] = {"Banyjima", "Panytyima"},
	["pnx"] = {"Phong-Kniang"},
	["pny"] = {"Pinyin"},
	["pnz"] = {"Pana (Central African Republic)"},
	["poc"] = {"Poqomam"},
	["poe"] = {"San Juan Atzingo Popoloca"},
	["pof"] = {"Poke"},
	["pog"] = {"Potiguára"},
	["poh"] = {"Poqomchi'"},
	["poi"] = {"Highland Popoluca"},
	["pok"] = {"Pokangá"},
	["pom"] = {"Southeastern Pomo"},
	["pon"] = {"Pohnpeian"},
	["poo"] = {"Central Pomo"},
	["pop"] = {"Pwapwâ"},
	["poq"] = {"Texistepec Popoluca"},
	["pos"] = {"Sayula Popoluca"},
	["pot"] = {"Potawatomi"},
	["pov"] = {"Upper Guinea Crioulo"},
	["pow"] = {"San Felipe Otlaltepec Popoloca"},
	["pox"] = {"Polabian"},
	["poy"] = {"Pogolo"},
	["poz"] = {"Malayo-Polynesian languages"},
	["ppe"] = {"Papi"},
	["ppi"] = {"Paipai"},
	["ppk"] = {"Uma"},
	["ppl"] = {"Pipil", "Nicarao"},
	["ppm"] = {"Papuma"},
	["ppn"] = {"Papapana"},
	["ppo"] = {"Folopa"},
	["ppp"] = {"Pelende"},
	["ppq"] = {"Pei"},
	["pps"] = {"San Luís Temalacayuca Popoloca"},
	["ppt"] = {"Pare"},
	["ppu"] = {"Papora"},
	["pqa"] = {"Pa'a"},
	["pqe"] = {"Eastern Malayo-Polynesian languages"},
	["pqm"] = {"Malecite-Passamaquoddy"},
	["pqw"] = {"Western Malayo-Polynesian languages"},
	["pra"] = {"Prakrit languages"},
	["prc"] = {"Parachi"},
	["prd"] = {"Parsi-Dari"},
	["pre"] = {"Principense"},
	["prf"] = {"Paranan"},
	["prg"] = {"Prussian"},
	["prh"] = {"Porohanon"},
	["pri"] = {"Paicî"},
	["prk"] = {"Parauk"},
	["prl"] = {"Peruvian Sign Language"},
	["prm"] = {"Kibiri"},
	["prn"] = {"Prasuni"},
	["pro"] = {"Old Provençal (to 1500)", "Old Occitan (to 1500)"},
	["prq"] = {"Ashéninka Perené"},
	["prr"] = {"Puri"},
	["prs"] = {"Dari", "Afghan Persian"},
	["prt"] = {"Phai"},
	["pru"] = {"Puragi"},
	["prw"] = {"Parawen"},
	["prx"] = {"Purik"},
	["prz"] = {"Providencia Sign Language"},
	["psa"] = {"Asue Awyu"},
	["psc"] = {"Iranian Sign Language", "Persian Sign Language"},
	["psd"] = {"Plains Indian Sign Language"},
	["pse"] = {"Central Malay"},
	["psg"] = {"Penang Sign Language"},
	["psh"] = {"Southwest Pashai", "Southwest Pashayi"},
	["psi"] = {"Southeast Pashai", "Southeast Pashayi"},
	["psl"] = {"Puerto Rican Sign Language"},
	["psm"] = {"Pauserna"},
	["psn"] = {"Panasuan"},
	["pso"] = {"Polish Sign Language"},
	["psp"] = {"Philippine Sign Language"},
	["psq"] = {"Pasi"},
	["psr"] = {"Portuguese Sign Language"},
	["pss"] = {"Kaulong"},
	["pst"] = {"Central Pashto"},
	["psu"] = {"Sauraseni Prākrit"},
	["psw"] = {"Port Sandwich"},
	["psy"] = {"Piscataway"},
	["pta"] = {"Pai Tavytera"},
	["pth"] = {"Pataxó Hã-Ha-Hãe"},
	["pti"] = {"Pindiini", "Wangkatha"},
	["ptn"] = {"Patani"},
	["pto"] = {"Zo'é"},
	["ptp"] = {"Patep"},
	["ptq"] = {"Pattapu"},
	["ptr"] = {"Piamatsina"},
	["ptt"] = {"Enrekang"},
	["ptu"] = {"Bambam"},
	["ptv"] = {"Port Vato"},
	["ptw"] = {"Pentlatch"},
	["pty"] = {"Pathiya"},
	["pua"] = {"Western Highland Purepecha"},
	["pub"] = {"Purum"},
	["puc"] = {"Punan Merap"},
	["pud"] = {"Punan Aput"},
	["pue"] = {"Puelche"},
	["puf"] = {"Punan Merah"},
	["pug"] = {"Phuie"},
	["pui"] = {"Puinave"},
	["puj"] = {"Punan Tubu"},
	["pum"] = {"Puma"},
	["puo"] = {"Puoc"},
	["pup"] = {"Pulabu"},
	["puq"] = {"Puquina"},
	["pur"] = {"Puruborá"},
	["put"] = {"Putoh"},
	["puu"] = {"Punu"},
	["puw"] = {"Puluwatese"},
	["pux"] = {"Puare"},
	["puy"] = {"Purisimeño"},
	["pwa"] = {"Pawaia"},
	["pwb"] = {"Panawa"},
	["pwg"] = {"Gapapaiwa"},
	["pwi"] = {"Patwin"},
	["pwm"] = {"Molbog"},
	["pwn"] = {"Paiwan"},
	["pwo"] = {"Pwo Western Karen"},
	["pwr"] = {"Powari"},
	["pww"] = {"Pwo Northern Karen"},
	["pxm"] = {"Quetzaltepec Mixe"},
	["pye"] = {"Pye Krumen"},
	["pym"] = {"Fyam"},
	["pyn"] = {"Poyanáwa"},
	["pys"] = {"Paraguayan Sign Language", "Lengua de Señas del Paraguay"},
	["pyu"] = {"Puyuma"},
	["pyx"] = {"Pyu (Myanmar)"},
	["pyy"] = {"Pyen"},
	["pze"] = {"Pesse"},
	["pzh"] = {"Pazeh"},
	["pzn"] = {"Jejara Naga", "Para Naga"},
	["qua"] = {"Quapaw"},
	["qub"] = {"Huallaga Huánuco Quechua"},
	["quc"] = {"K'iche'", "Quiché"},
	["qud"] = {"Calderón Highland Quichua"},
	["quf"] = {"Lambayeque Quechua"},
	["qug"] = {"Chimborazo Highland Quichua"},
	["quh"] = {"South Bolivian Quechua"},
	["qui"] = {"Quileute"},
	["quk"] = {"Chachapoyas Quechua"},
	["qul"] = {"North Bolivian Quechua"},
	["qum"] = {"Sipacapense"},
	["qun"] = {"Quinault"},
	["qup"] = {"Southern Pastaza Quechua"},
	["quq"] = {"Quinqui"},
	["qur"] = {"Yanahuanca Pasco Quechua"},
	["qus"] = {"Santiago del Estero Quichua"},
	["quv"] = {"Sacapulteco"},
	["quw"] = {"Tena Lowland Quichua"},
	["qux"] = {"Yauyos Quechua"},
	["quy"] = {"Ayacucho Quechua"},
	["quz"] = {"Cusco Quechua"},
	["qva"] = {"Ambo-Pasco Quechua"},
	["qvc"] = {"Cajamarca Quechua"},
	["qve"] = {"Eastern Apurímac Quechua"},
	["qvh"] = {"Huamalíes-Dos de Mayo Huánuco Quechua"},
	["qvi"] = {"Imbabura Highland Quichua"},
	["qvj"] = {"Loja Highland Quichua"},
	["qvl"] = {"Cajatambo North Lima Quechua"},
	["qvm"] = {"Margos-Yarowilca-Lauricocha Quechua"},
	["qvn"] = {"North Junín Quechua"},
	["qvo"] = {"Napo Lowland Quechua"},
	["qvp"] = {"Pacaraos Quechua"},
	["qvs"] = {"San Martín Quechua"},
	["qvw"] = {"Huaylla Wanca Quechua"},
	["qvy"] = {"Queyu"},
	["qvz"] = {"Northern Pastaza Quichua"},
	["qwa"] = {"Corongo Ancash Quechua"},
	["qwc"] = {"Classical Quechua"},
	["qwe"] = {"Quechuan (family)"},
	["qwh"] = {"Huaylas Ancash Quechua"},
	["qwm"] = {"Kuman (Russia)"},
	["qws"] = {"Sihuas Ancash Quechua"},
	["qwt"] = {"Kwalhioqua-Tlatskanai"},
	["qxa"] = {"Chiquián Ancash Quechua"},
	["qxc"] = {"Chincha Quechua"},
	["qxh"] = {"Panao Huánuco Quechua"},
	["qxl"] = {"Salasaca Highland Quichua"},
	["qxn"] = {"Northern Conchucos Ancash Quechua"},
	["qxo"] = {"Southern Conchucos Ancash Quechua"},
	["qxp"] = {"Puno Quechua"},
	["qxq"] = {"Qashqa'i"},
	["qxr"] = {"Cañar Highland Quichua"},
	["qxs"] = {"Southern Qiang"},
	["qxt"] = {"Santa Ana de Tusi Pasco Quechua"},
	["qxu"] = {"Arequipa-La Unión Quechua"},
	["qxw"] = {"Jauja Wanca Quechua"},
	["qya"] = {"Quenya"},
	["qyp"] = {"Quiripi"},
	["raa"] = {"Dungmali"},
	["rab"] = {"Camling"},
	["rac"] = {"Rasawa"},
	["rad"] = {"Rade"},
	["raf"] = {"Western Meohang"},
	["rag"] = {"Logooli", "Lulogooli"},
	["rah"] = {"Rabha"},
	["rai"] = {"Ramoaaina"},
	["raj"] = {"Rajasthani"},
	["rak"] = {"Tulu-Bohuai"},
	["ral"] = {"Ralte"},
	["ram"] = {"Canela"},
	["ran"] = {"Riantana"},
	["rao"] = {"Rao"},
	["rap"] = {"Rapanui"},
	["raq"] = {"Saam"},
	["rar"] = {"Rarotongan", "Cook Islands Maori"},
	["ras"] = {"Tegali"},
	["rat"] = {"Razajerdi"},
	["rau"] = {"Raute"},
	["rav"] = {"Sampang"},
	["raw"] = {"Rawang"},
	["rax"] = {"Rang"},
	["ray"] = {"Rapa"},
	["raz"] = {"Rahambuu"},
	["rbb"] = {"Rumai Palaung"},
	["rbk"] = {"Northern Bontok"},
	["rbl"] = {"Miraya Bikol"},
	["rbp"] = {"Barababaraba"},
	["rcf"] = {"Réunion Creole French"},
	["rdb"] = {"Rudbari"},
	["rea"] = {"Rerau"},
	["reb"] = {"Rembong"},
	["ree"] = {"Rejang Kayan"},
	["reg"] = {"Kara (Tanzania)"},
	["rei"] = {"Reli"},
	["rej"] = {"Rejang"},
	["rel"] = {"Rendille"},
	["rem"] = {"Remo"},
	["ren"] = {"Rengao"},
	["rer"] = {"Rer Bare"},
	["res"] = {"Reshe"},
	["ret"] = {"Retta"},
	["rey"] = {"Reyesano"},
	["rga"] = {"Roria"},
	["rge"] = {"Romano-Greek"},
	["rgk"] = {"Rangkas"},
	["rgn"] = {"Romagnol"},
	["rgr"] = {"Resígaro"},
	["rgs"] = {"Southern Roglai"},
	["rgu"] = {"Ringgou"},
	["rhg"] = {"Rohingya"},
	["rhp"] = {"Yahang"},
	["ria"] = {"Riang (India)"},
	["rib"] = {"Bribri Sign Language"},
	["rif"] = {"Tarifit"},
	["ril"] = {"Riang Lang", "Riang (Myanmar)"},
	["rim"] = {"Nyaturu"},
	["rin"] = {"Nungu"},
	["rir"] = {"Ribun"},
	["rit"] = {"Ritharrngu"},
	["riu"] = {"Riung"},
	["rjg"] = {"Rajong"},
	["rji"] = {"Raji"},
	["rjs"] = {"Rajbanshi"},
	["rka"] = {"Kraol"},
	["rkb"] = {"Rikbaktsa"},
	["rkh"] = {"Rakahanga-Manihiki"},
	["rki"] = {"Rakhine"},
	["rkm"] = {"Marka"},
	["rkt"] = {"Rangpuri", "Kamta"},
	["rkw"] = {"Arakwal"},
	["rma"] = {"Rama"},
	["rmb"] = {"Rembarrnga"},
	["rmc"] = {"Carpathian Romani"},
	["rmd"] = {"Traveller Danish"},
	["rme"] = {"Angloromani"},
	["rmf"] = {"Kalo Finnish Romani"},
	["rmg"] = {"Traveller Norwegian"},
	["rmh"] = {"Murkim"},
	["rmi"] = {"Lomavren"},
	["rmk"] = {"Romkun"},
	["rml"] = {"Baltic Romani"},
	["rmm"] = {"Roma"},
	["rmn"] = {"Balkan Romani"},
	["rmo"] = {"Sinte Romani"},
	["rmp"] = {"Rempi"},
	["rmq"] = {"Caló"},
	["rms"] = {"Romanian Sign Language"},
	["rmt"] = {"Domari"},
	["rmu"] = {"Tavringer Romani"},
	["rmv"] = {"Romanova"},
	["rmw"] = {"Welsh Romani"},
	["rmx"] = {"Romam"},
	["rmy"] = {"Vlax Romani"},
	["rmz"] = {"Marma"},
	["rnb"] = {"Brunca Sign Language"},
	["rnd"] = {"Ruund"},
	["rng"] = {"Ronga"},
	["rnl"] = {"Ranglong"},
	["rnn"] = {"Roon"},
	["rnp"] = {"Rongpo"},
	["rnr"] = {"Nari Nari"},
	["rnw"] = {"Rungwa"},
	["roa"] = {"Romance languages"},
	["rob"] = {"Tae'"},
	["roc"] = {"Cacgia Roglai"},
	["rod"] = {"Rogo"},
	["roe"] = {"Ronji"},
	["rof"] = {"Rombo"},
	["rog"] = {"Northern Roglai"},
	["rol"] = {"Romblomanon"},
	["rom"] = {"Romany"},
	["roo"] = {"Rotokas"},
	["rop"] = {"Kriol"},
	["ror"] = {"Rongga"},
	["rou"] = {"Runga"},
	["row"] = {"Dela-Oenale"},
	["rpn"] = {"Repanbitip"},
	["rpt"] = {"Rapting"},
	["rri"] = {"Ririo"},
	["rrm"] = {"Moriori"},
	["rro"] = {"Waima"},
	["rrt"] = {"Arritinngithigh"},
	["rsb"] = {"Romano-Serbian"},
	["rsk"] = {"Ruthenian", "Rusnak"},
	["rsl"] = {"Russian Sign Language"},
	["rsm"] = {"Miriwoong Sign Language"},
	["rsn"] = {"Rwandan Sign Language"},
	["rsw"] = {"Rishiwa"},
	["rtc"] = {"Rungtu Chin"},
	["rth"] = {"Ratahan"},
	["rtm"] = {"Rotuman"},
	["rts"] = {"Yurats"},
	["rtw"] = {"Rathawi"},
	["rub"] = {"Gungu"},
	["ruc"] = {"Ruuli"},
	["rue"] = {"Rusyn"},
	["ruf"] = {"Luguru"},
	["rug"] = {"Roviana"},
	["ruh"] = {"Ruga"},
	["rui"] = {"Rufiji"},
	["ruk"] = {"Che"},
	["ruo"] = {"Istro Romanian"},
	["rup"] = {"Macedo-Romanian", "Aromanian", "Arumanian"},
	["ruq"] = {"Megleno Romanian"},
	["rut"] = {"Rutul"},
	["ruu"] = {"Lanas Lobu"},
	["ruy"] = {"Mala (Nigeria)"},
	["ruz"] = {"Ruma"},
	["rwa"] = {"Rawo"},
	["rwk"] = {"Rwa"},
	["rwl"] = {"Ruwila"},
	["rwm"] = {"Amba (Uganda)"},
	["rwo"] = {"Rawa"},
	["rwr"] = {"Marwari (India)"},
	["rxd"] = {"Ngardi"},
	["rxw"] = {"Karuwali", "Garuwali"},
	["ryn"] = {"Northern Amami-Oshima"},
	["rys"] = {"Yaeyama"},
	["ryu"] = {"Central Okinawan"},
	["rzh"] = {"Rāziḥī"},
	["saa"] = {"Saba"},
	["sab"] = {"Buglere"},
	["sac"] = {"Meskwaki"},
	["sad"] = {"Sandawe"},
	["sae"] = {"Sabanê"},
	["saf"] = {"Safaliba"},
	["sah"] = {"Yakut"},
	["sai"] = {"South American Indian languages"},
	["saj"] = {"Sahu"},
	["sak"] = {"Sake"},
	["sal"] = {"Salishan languages"},
	["sam"] = {"Samaritan Aramaic"},
	["sao"] = {"Sause"},
	["saq"] = {"Samburu"},
	["sar"] = {"Saraveca"},
	["sas"] = {"Sasak"},
	["sat"] = {"Santali"},
	["sau"] = {"Saleman"},
	["sav"] = {"Saafi-Saafi"},
	["saw"] = {"Sawi"},
	["sax"] = {"Sa"},
	["say"] = {"Saya"},
	["saz"] = {"Saurashtra"},
	["sba"] = {"Ngambay"},
	["sbb"] = {"Simbo"},
	["sbc"] = {"Kele (Papua New Guinea)"},
	["sbd"] = {"Southern Samo"},
	["sbe"] = {"Saliba"},
	["sbf"] = {"Chabu", "Shabo"},
	["sbg"] = {"Seget"},
	["sbh"] = {"Sori-Harengan"},
	["sbi"] = {"Seti"},
	["sbj"] = {"Surbakhal"},
	["sbk"] = {"Safwa"},
	["sbl"] = {"Botolan Sambal"},
	["sbm"] = {"Sagala"},
	["sbn"] = {"Sindhi Bhil"},
	["sbo"] = {"Sabüm"},
	["sbp"] = {"Sangu (Tanzania)"},
	["sbq"] = {"Sileibi"},
	["sbr"] = {"Sembakung Murut"},
	["sbs"] = {"Subiya"},
	["sbt"] = {"Kimki"},
	["sbu"] = {"Stod Bhoti"},
	["sbv"] = {"Sabine"},
	["sbw"] = {"Simba"},
	["sbx"] = {"Seberuang"},
	["sby"] = {"Soli"},
	["sbz"] = {"Sara Kaba"},
	["scb"] = {"Chut"},
	["sce"] = {"Dongxiang"},
	["scf"] = {"San Miguel Creole French"},
	["scg"] = {"Sanggau"},
	["sch"] = {"Sakachep"},
	["sci"] = {"Sri Lankan Creole Malay"},
	["sck"] = {"Sadri"},
	["scl"] = {"Shina"},
	["scn"] = {"Sicilian"},
	["sco"] = {"Scots"},
	["scp"] = {"Hyolmo", "Helambu Sherpa"},
	["scq"] = {"Sa'och"},
	["scs"] = {"North Slavey"},
	["sct"] = {"Southern Katang"},
	["scu"] = {"Shumcho"},
	["scv"] = {"Sheni"},
	["scw"] = {"Sha"},
	["scx"] = {"Sicel"},
	["sda"] = {"Toraja-Sa'dan"},
	["sdb"] = {"Shabak"},
	["sdc"] = {"Sassarese Sardinian"},
	["sde"] = {"Surubu"},
	["sdf"] = {"Sarli"},
	["sdg"] = {"Savi"},
	["sdh"] = {"Southern Kurdish"},
	["sdj"] = {"Suundi"},
	["sdk"] = {"Sos Kundi"},
	["sdl"] = {"Saudi Arabian Sign Language"},
	["sdn"] = {"Gallurese Sardinian"},
	["sdo"] = {"Bukar-Sadung Bidayuh"},
	["sdp"] = {"Sherdukpen"},
	["sdq"] = {"Semandang"},
	["sdr"] = {"Oraon Sadri"},
	["sds"] = {"Sened"},
	["sdt"] = {"Shuadit"},
	["sdu"] = {"Sarudu"},
	["sdv"] = {"Eastern Sudanic languages"},
	["sdx"] = {"Sibu Melanau"},
	["sdz"] = {"Sallands"},
	["sea"] = {"Semai"},
	["seb"] = {"Shempire Senoufo"},
	["sec"] = {"Sechelt"},
	["sed"] = {"Sedang"},
	["see"] = {"Seneca"},
	["sef"] = {"Cebaara Senoufo"},
	["seg"] = {"Segeju"},
	["seh"] = {"Sena"},
	["sei"] = {"Seri"},
	["sej"] = {"Sene"},
	["sek"] = {"Sekani"},
	["sel"] = {"Selkup"},
	["sem"] = {"Semitic languages"},
	["sen"] = {"Nanerigé Sénoufo"},
	["seo"] = {"Suarmin"},
	["sep"] = {"Sìcìté Sénoufo"},
	["seq"] = {"Senara Sénoufo"},
	["ser"] = {"Serrano"},
	["ses"] = {"Koyraboro Senni Songhai"},
	["set"] = {"Sentani"},
	["seu"] = {"Serui-Laut"},
	["sev"] = {"Nyarafolo Senoufo"},
	["sew"] = {"Sewa Bay"},
	["sey"] = {"Secoya"},
	["sez"] = {"Senthang Chin"},
	["sfb"] = {"Langue des signes de Belgique Francophone", "French Belgian Sign Language"},
	["sfe"] = {"Eastern Subanen"},
	["sfm"] = {"Small Flowery Miao"},
	["sfs"] = {"South African Sign Language"},
	["sfw"] = {"Sehwi"},
	["sga"] = {"Old Irish (to 900)"},
	["sgb"] = {"Mag-antsi Ayta"},
	["sgc"] = {"Kipsigis"},
	["sgd"] = {"Surigaonon"},
	["sge"] = {"Segai"},
	["sgg"] = {"Swiss-German Sign Language"},
	["sgh"] = {"Shughni"},
	["sgi"] = {"Suga"},
	["sgj"] = {"Surgujia"},
	["sgk"] = {"Sangkong"},
	["sgm"] = {"Singa"},
	["sgn"] = {"Sign languages"},
	["sgp"] = {"Singpho"},
	["sgr"] = {"Sangisari"},
	["sgs"] = {"Samogitian"},
	["sgt"] = {"Brokpake"},
	["sgu"] = {"Salas"},
	["sgw"] = {"Sebat Bet Gurage"},
	["sgx"] = {"Sierra Leone Sign Language"},
	["sgy"] = {"Sanglechi"},
	["sgz"] = {"Sursurunga"},
	["sha"] = {"Shall-Zwall"},
	["shb"] = {"Ninam"},
	["shc"] = {"Sonde"},
	["shd"] = {"Kundal Shahi"},
	["she"] = {"Sheko"},
	["shg"] = {"Shua"},
	["shh"] = {"Shoshoni"},
	["shi"] = {"Tachelhit"},
	["shj"] = {"Shatt"},
	["shk"] = {"Shilluk"},
	["shl"] = {"Shendu"},
	["shm"] = {"Shahrudi"},
	["shn"] = {"Shan"},
	["sho"] = {"Shanga"},
	["shp"] = {"Shipibo-Conibo"},
	["shq"] = {"Sala"},
	["shr"] = {"Shi"},
	["shs"] = {"Shuswap"},
	["sht"] = {"Shasta"},
	["shu"] = {"Chadian Arabic"},
	["shv"] = {"Shehri"},
	["shw"] = {"Shwai"},
	["shx"] = {"She"},
	["shy"] = {"Tachawit"},
	["shz"] = {"Syenara Senoufo"},
	["sia"] = {"Akkala Sami"},
	["sib"] = {"Sebop"},
	["sid"] = {"Sidamo"},
	["sie"] = {"Simaa"},
	["sif"] = {"Siamou"},
	["sig"] = {"Paasaal"},
	["sih"] = {"Zire", "Sîshëë"},
	["sii"] = {"Shom Peng"},
	["sij"] = {"Numbami"},
	["sik"] = {"Sikiana"},
	["sil"] = {"Tumulung Sisaala"},
	["sim"] = {"Mende (Papua New Guinea)"},
	["sio"] = {"Siouan languages"},
	["sip"] = {"Sikkimese"},
	["siq"] = {"Sonia"},
	["sir"] = {"Siri"},
	["sis"] = {"Siuslaw"},
	["sit"] = {"Sino-Tibetan languages"},
	["siu"] = {"Sinagen"},
	["siv"] = {"Sumariup"},
	["siw"] = {"Siwai"},
	["six"] = {"Sumau"},
	["siy"] = {"Sivandi"},
	["siz"] = {"Siwi"},
	["sja"] = {"Epena"},
	["sjb"] = {"Sajau Basap"},
	["sjc"] = {"Shaojiang Chinese"},
	["sjd"] = {"Kildin Sami"},
	["sje"] = {"Pite Sami"},
	["sjg"] = {"Assangori"},
	["sjk"] = {"Kemi Sami"},
	["sjl"] = {"Sajalong", "Miji"},
	["sjm"] = {"Mapun"},
	["sjn"] = {"Sindarin"},
	["sjo"] = {"Xibe"},
	["sjp"] = {"Surjapuri"},
	["sjr"] = {"Siar-Lak"},
	["sjs"] = {"Senhaja De Srair"},
	["sjt"] = {"Ter Sami"},
	["sju"] = {"Ume Sami"},
	["sjw"] = {"Shawnee"},
	["ska"] = {"Skagit"},
	["skb"] = {"Saek"},
	["skc"] = {"Ma Manda"},
	["skd"] = {"Southern Sierra Miwok"},
	["ske"] = {"Seke (Vanuatu)"},
	["skf"] = {"Sakirabiá"},
	["skg"] = {"Sakalava Malagasy"},
	["skh"] = {"Sikule"},
	["ski"] = {"Sika"},
	["skj"] = {"Seke (Nepal)"},
	["skm"] = {"Kutong"},
	["skn"] = {"Kolibugan Subanon"},
	["sko"] = {"Seko Tengah"},
	["skp"] = {"Sekapan"},
	["skq"] = {"Sininkere"},
	["skr"] = {"Saraiki", "Seraiki"},
	["sks"] = {"Maia"},
	["skt"] = {"Sakata"},
	["sku"] = {"Sakao"},
	["skv"] = {"Skou"},
	["skw"] = {"Skepi Creole Dutch"},
	["skx"] = {"Seko Padang"},
	["sky"] = {"Sikaiana"},
	["skz"] = {"Sekar"},
	["sla"] = {"Slavic languages"},
	["slc"] = {"Sáliba"},
	["sld"] = {"Sissala"},
	["sle"] = {"Sholaga"},
	["slf"] = {"Swiss-Italian Sign Language"},
	["slg"] = {"Selungai Murut"},
	["slh"] = {"Southern Puget Sound Salish"},
	["sli"] = {"Lower Silesian"},
	["slj"] = {"Salumá"},
	["sll"] = {"Salt-Yui"},
	["slm"] = {"Pangutaran Sama"},
	["sln"] = {"Salinan"},
	["slp"] = {"Lamaholot"},
	["slr"] = {"Salar"},
	["sls"] = {"Singapore Sign Language"},
	["slt"] = {"Sila"},
	["slu"] = {"Selaru"},
	["slw"] = {"Sialum"},
	["slx"] = {"Salampasu"},
	["sly"] = {"Selayar"},
	["slz"] = {"Ma'ya"},
	["sma"] = {"Southern Sami"},
	["smb"] = {"Simbari"},
	["smc"] = {"Som"},
	["smf"] = {"Auwe"},
	["smg"] = {"Simbali"},
	["smh"] = {"Samei"},
	["smi"] = {"Sami languages"},
	["smj"] = {"Lule Sami"},
	["smk"] = {"Bolinao"},
	["sml"] = {"Central Sama"},
	["smm"] = {"Musasa"},
	["smn"] = {"Inari Sami"},
	["smp"] = {"Samaritan"},
	["smq"] = {"Samo"},
	["smr"] = {"Simeulue"},
	["sms"] = {"Skolt Sami"},
	["smt"] = {"Simte"},
	["smu"] = {"Somray"},
	["smv"] = {"Samvedi"},
	["smw"] = {"Sumbawa"},
	["smx"] = {"Samba"},
	["smy"] = {"Semnani"},
	["smz"] = {"Simeku"},
	["snc"] = {"Sinaugoro"},
	["sne"] = {"Bau Bidayuh"},
	["snf"] = {"Noon"},
	["sng"] = {"Sanga (Democratic Republic of Congo)"},
	["sni"] = {"Sensi"},
	["snj"] = {"Riverain Sango"},
	["snk"] = {"Soninke"},
	["snl"] = {"Sangil"},
	["snm"] = {"Southern Ma'di"},
	["snn"] = {"Siona"},
	["sno"] = {"Snohomish"},
	["snp"] = {"Siane"},
	["snq"] = {"Sangu (Gabon)"},
	["snr"] = {"Sihan"},
	["sns"] = {"South West Bay", "Nahavaq"},
	["snu"] = {"Senggi", "Viid"},
	["snv"] = {"Sa'ban"},
	["snw"] = {"Selee"},
	["snx"] = {"Sam"},
	["sny"] = {"Saniyo-Hiyewe"},
	["snz"] = {"Kou"},
	["soa"] = {"Thai Song"},
	["sob"] = {"Sobei"},
	["soc"] = {"So (Democratic Republic of Congo)"},
	["sod"] = {"Songoora"},
	["soe"] = {"Songomeno"},
	["sog"] = {"Sogdian"},
	["soh"] = {"Aka"},
	["soi"] = {"Sonha"},
	["soj"] = {"Soi"},
	["sok"] = {"Sokoro"},
	["sol"] = {"Solos"},
	["son"] = {"Songhai languages"},
	["soo"] = {"Songo"},
	["sop"] = {"Songe"},
	["soq"] = {"Kanasi"},
	["sor"] = {"Somrai"},
	["sos"] = {"Seeku"},
	["sou"] = {"Southern Thai"},
	["sov"] = {"Sonsorol"},
	["sow"] = {"Sowanda"},
	["sox"] = {"Swo"},
	["soy"] = {"Miyobe"},
	["soz"] = {"Temi"},
	["spb"] = {"Sepa (Indonesia)"},
	["spc"] = {"Sapé"},
	["spd"] = {"Saep"},
	["spe"] = {"Sepa (Papua New Guinea)"},
	["spg"] = {"Sian"},
	["spi"] = {"Saponi"},
	["spk"] = {"Sengo"},
	["spl"] = {"Selepet"},
	["spm"] = {"Akukem"},
	["spn"] = {"Sanapaná"},
	["spo"] = {"Spokane"},
	["spp"] = {"Supyire Senoufo"},
	["spq"] = {"Loreto-Ucayali Spanish"},
	["spr"] = {"Saparua"},
	["sps"] = {"Saposa"},
	["spt"] = {"Spiti Bhoti"},
	["spu"] = {"Sapuan"},
	["spv"] = {"Sambalpuri", "Kosli"},
	["spx"] = {"South Picene"},
	["spy"] = {"Sabaot"},
	["sqa"] = {"Shama-Sambuga"},
	["sqh"] = {"Shau"},
	["sqj"] = {"Albanian languages"},
	["sqk"] = {"Albanian Sign Language"},
	["sqm"] = {"Suma"},
	["sqn"] = {"Susquehannock"},
	["sqo"] = {"Sorkhei"},
	["sqq"] = {"Sou"},
	["sqr"] = {"Siculo Arabic"},
	["sqs"] = {"Sri Lankan Sign Language"},
	["sqt"] = {"Soqotri"},
	["squ"] = {"Squamish"},
	["sqx"] = {"Kufr Qassem Sign Language (KQSL)"},
	["sra"] = {"Saruga"},
	["srb"] = {"Sora"},
	["src"] = {"Logudorese Sardinian"},
	["sre"] = {"Sara"},
	["srf"] = {"Nafi"},
	["srg"] = {"Sulod"},
	["srh"] = {"Sarikoli"},
	["sri"] = {"Siriano"},
	["srk"] = {"Serudung Murut"},
	["srl"] = {"Isirawa"},
	["srm"] = {"Saramaccan"},
	["srn"] = {"Sranan Tongo"},
	["sro"] = {"Campidanese Sardinian"},
	["srq"] = {"Sirionó"},
	["srr"] = {"Serer"},
	["srs"] = {"Sarsi"},
	["srt"] = {"Sauri"},
	["sru"] = {"Suruí"},
	["srv"] = {"Southern Sorsoganon"},
	["srw"] = {"Serua"},
	["srx"] = {"Sirmauri"},
	["sry"] = {"Sera"},
	["srz"] = {"Shahmirzadi"},
	["ssa"] = {"Nilo-Saharan languages"},
	["ssb"] = {"Southern Sama"},
	["ssc"] = {"Suba-Simbiti"},
	["ssd"] = {"Siroi"},
	["sse"] = {"Balangingi", "Bangingih Sama"},
	["ssf"] = {"Thao"},
	["ssg"] = {"Seimat"},
	["ssh"] = {"Shihhi Arabic"},
	["ssi"] = {"Sansi"},
	["ssj"] = {"Sausi"},
	["ssk"] = {"Sunam"},
	["ssl"] = {"Western Sisaala"},
	["ssm"] = {"Semnam"},
	["ssn"] = {"Waata"},
	["sso"] = {"Sissano"},
	["ssp"] = {"Spanish Sign Language"},
	["ssq"] = {"So'a"},
	["ssr"] = {"Swiss-French Sign Language"},
	["sss"] = {"Sô"},
	["sst"] = {"Sinasina"},
	["ssu"] = {"Susuami"},
	["ssv"] = {"Shark Bay"},
	["ssx"] = {"Samberigi"},
	["ssy"] = {"Saho"},
	["ssz"] = {"Sengseng"},
	["sta"] = {"Settla"},
	["stb"] = {"Northern Subanen"},
	["std"] = {"Sentinel"},
	["ste"] = {"Liana-Seti"},
	["stf"] = {"Seta"},
	["stg"] = {"Trieng"},
	["sth"] = {"Shelta"},
	["sti"] = {"Bulo Stieng"},
	["stj"] = {"Matya Samo"},
	["stk"] = {"Arammba"},
	["stl"] = {"Stellingwerfs"},
	["stm"] = {"Setaman"},
	["stn"] = {"Owa"},
	["sto"] = {"Stoney"},
	["stp"] = {"Southeastern Tepehuan"},
	["stq"] = {"Saterfriesisch"},
	["str"] = {"Straits Salish"},
	["sts"] = {"Shumashti"},
	["stt"] = {"Budeh Stieng"},
	["stu"] = {"Samtao"},
	["stv"] = {"Silt'e"},
	["stw"] = {"Satawalese"},
	["sty"] = {"Siberian Tatar"},
	["sua"] = {"Sulka"},
	["sub"] = {"Suku"},
	["suc"] = {"Western Subanon"},
	["sue"] = {"Suena"},
	["sug"] = {"Suganga"},
	["sui"] = {"Suki"},
	["suj"] = {"Shubi"},
	["suk"] = {"Sukuma"},
	["suo"] = {"Bouni"},
	["suq"] = {"Tirmaga-Chai Suri", "Suri"},
	["sur"] = {"Mwaghavul"},
	["sus"] = {"Susu"},
	["sut"] = {"Subtiaba"},
	["suv"] = {"Puroik"},
	["suw"] = {"Sumbwa"},
	["sux"] = {"Sumerian"},
	["suy"] = {"Suyá"},
	["suz"] = {"Sunwar"},
	["sva"] = {"Svan"},
	["svb"] = {"Ulau-Suain"},
	["svc"] = {"Vincentian Creole English"},
	["sve"] = {"Serili"},
	["svk"] = {"Slovakian Sign Language"},
	["svm"] = {"Slavomolisano"},
	["svs"] = {"Savosavo"},
	["svx"] = {"Skalvian"},
	["swb"] = {"Maore Comorian"},
	["swc"] = {"Congo Swahili"},
	["swf"] = {"Sere"},
	["swg"] = {"Swabian"},
	["swh"] = {"Swahili (individual language)", "Kiswahili"},
	["swi"] = {"Sui"},
	["swj"] = {"Sira"},
	["swk"] = {"Malawi Sena"},
	["swl"] = {"Swedish Sign Language"},
	["swm"] = {"Samosa"},
	["swn"] = {"Sawknah"},
	["swo"] = {"Shanenawa"},
	["swp"] = {"Suau"},
	["swq"] = {"Sharwa"},
	["swr"] = {"Saweru"},
	["sws"] = {"Seluwasan"},
	["swt"] = {"Sawila"},
	["swu"] = {"Suwawa"},
	["swv"] = {"Shekhawati"},
	["sww"] = {"Sowa"},
	["swx"] = {"Suruahá"},
	["swy"] = {"Sarua"},
	["sxb"] = {"Suba"},
	["sxc"] = {"Sicanian"},
	["sxe"] = {"Sighu"},
	["sxg"] = {"Shuhi", "Shixing"},
	["sxk"] = {"Southern Kalapuya"},
	["sxl"] = {"Selian"},
	["sxm"] = {"Samre"},
	["sxn"] = {"Sangir"},
	["sxo"] = {"Sorothaptic"},
	["sxr"] = {"Saaroa"},
	["sxs"] = {"Sasaru"},
	["sxu"] = {"Upper Saxon"},
	["sxw"] = {"Saxwe Gbe"},
	["sya"] = {"Siang"},
	["syb"] = {"Central Subanen"},
	["syc"] = {"Classical Syriac"},
	["syd"] = {"Samoyedic languages"},
	["syi"] = {"Seki"},
	["syk"] = {"Sukur"},
	["syl"] = {"Sylheti"},
	["sym"] = {"Maya Samo"},
	["syn"] = {"Senaya"},
	["syo"] = {"Suoy"},
	["syr"] = {"Syriac"},
	["sys"] = {"Sinyar"},
	["syw"] = {"Kagate"},
	["syx"] = {"Samay"},
	["syy"] = {"Al-Sayyid Bedouin Sign Language"},
	["sza"] = {"Semelai"},
	["szb"] = {"Ngalum"},
	["szc"] = {"Semaq Beri"},
	["sze"] = {"Seze"},
	["szg"] = {"Sengele"},
	["szl"] = {"Silesian"},
	["szn"] = {"Sula"},
	["szp"] = {"Suabo"},
	["szs"] = {"Solomon Islands Sign Language"},
	["szv"] = {"Isu (Fako Division)"},
	["szw"] = {"Sawai"},
	["szy"] = {"Sakizaya"},
	["taa"] = {"Lower Tanana"},
	["tab"] = {"Tabassaran"},
	["tac"] = {"Lowland Tarahumara"},
	["tad"] = {"Tause"},
	["tae"] = {"Tariana"},
	["taf"] = {"Tapirapé"},
	["tag"] = {"Tagoi"},
	["tai"] = {"Tai languages"},
	["taj"] = {"Eastern Tamang"},
	["tak"] = {"Tala"},
	["tal"] = {"Tal"},
	["tan"] = {"Tangale"},
	["tao"] = {"Yami"},
	["tap"] = {"Taabwa"},
	["taq"] = {"Tamasheq"},
	["tar"] = {"Central Tarahumara"},
	["tas"] = {"Tay Boi"},
	["tau"] = {"Upper Tanana"},
	["tav"] = {"Tatuyo"},
	["taw"] = {"Tai"},
	["tax"] = {"Tamki"},
	["tay"] = {"Atayal"},
	["taz"] = {"Tocho"},
	["tba"] = {"Aikanã"},
	["tbc"] = {"Takia"},
	["tbd"] = {"Kaki Ae"},
	["tbe"] = {"Tanimbili"},
	["tbf"] = {"Mandara"},
	["tbg"] = {"North Tairora"},
	["tbh"] = {"Dharawal", "Thurawal"},
	["tbi"] = {"Gaam"},
	["tbj"] = {"Tiang"},
	["tbk"] = {"Calamian Tagbanwa"},
	["tbl"] = {"Tboli"},
	["tbm"] = {"Tagbu"},
	["tbn"] = {"Barro Negro Tunebo"},
	["tbo"] = {"Tawala"},
	["tbp"] = {"Taworta", "Diebroud"},
	["tbq"] = {"Tibeto-Burman languages"},
	["tbr"] = {"Tumtum"},
	["tbs"] = {"Tanguat"},
	["tbt"] = {"Tembo (Kitembo)"},
	["tbu"] = {"Tubar"},
	["tbv"] = {"Tobo"},
	["tbw"] = {"Tagbanwa"},
	["tbx"] = {"Kapin"},
	["tby"] = {"Tabaru"},
	["tbz"] = {"Ditammari"},
	["tca"] = {"Ticuna"},
	["tcb"] = {"Tanacross"},
	["tcc"] = {"Datooga"},
	["tcd"] = {"Tafi"},
	["tce"] = {"Southern Tutchone"},
	["tcf"] = {"Malinaltepec Me'phaa", "Malinaltepec Tlapanec"},
	["tcg"] = {"Tamagario"},
	["tch"] = {"Turks And Caicos Creole English"},
	["tci"] = {"Wára"},
	["tck"] = {"Tchitchege"},
	["tcl"] = {"Taman (Myanmar)"},
	["tcm"] = {"Tanahmerah"},
	["tcn"] = {"Tichurong"},
	["tco"] = {"Taungyo"},
	["tcp"] = {"Tawr Chin"},
	["tcq"] = {"Kaiy"},
	["tcs"] = {"Torres Strait Creole", "Yumplatok"},
	["tct"] = {"T'en"},
	["tcu"] = {"Southeastern Tarahumara"},
	["tcw"] = {"Tecpatlán Totonac"},
	["tcx"] = {"Toda"},
	["tcy"] = {"Tulu"},
	["tcz"] = {"Thado Chin"},
	["tda"] = {"Tagdal"},
	["tdb"] = {"Panchpargania"},
	["tdc"] = {"Emberá-Tadó"},
	["tdd"] = {"Tai Nüa"},
	["tde"] = {"Tiranige Diga Dogon"},
	["tdf"] = {"Talieng"},
	["tdg"] = {"Western Tamang"},
	["tdh"] = {"Thulung"},
	["tdi"] = {"Tomadino"},
	["tdj"] = {"Tajio"},
	["tdk"] = {"Tambas"},
	["tdl"] = {"Sur"},
	["tdm"] = {"Taruma"},
	["tdn"] = {"Tondano"},
	["tdo"] = {"Teme"},
	["tdq"] = {"Tita"},
	["tdr"] = {"Todrah"},
	["tds"] = {"Doutai"},
	["tdt"] = {"Tetun Dili"},
	["tdv"] = {"Toro"},
	["tdx"] = {"Tandroy-Mahafaly Malagasy"},
	["tdy"] = {"Tadyawan"},
	["tea"] = {"Temiar"},
	["teb"] = {"Tetete"},
	["tec"] = {"Terik"},
	["ted"] = {"Tepo Krumen"},
	["tee"] = {"Huehuetla Tepehua"},
	["tef"] = {"Teressa"},
	["teg"] = {"Teke-Tege"},
	["teh"] = {"Tehuelche"},
	["tei"] = {"Torricelli"},
	["tek"] = {"Ibali Teke"},
	["tem"] = {"Timne"},
	["ten"] = {"Tama (Colombia)"},
	["teo"] = {"Teso"},
	["tep"] = {"Tepecano"},
	["teq"] = {"Temein"},
	["ter"] = {"Tereno"},
	["tes"] = {"Tengger"},
	["tet"] = {"Tetum"},
	["teu"] = {"Soo"},
	["tev"] = {"Teor"},
	["tew"] = {"Tewa (USA)"},
	["tex"] = {"Tennet"},
	["tey"] = {"Tulishi"},
	["tez"] = {"Tetserret"},
	["tfi"] = {"Tofin Gbe"},
	["tfn"] = {"Tanaina"},
	["tfo"] = {"Tefaro"},
	["tfr"] = {"Teribe"},
	["tft"] = {"Ternate"},
	["tga"] = {"Sagalla"},
	["tgb"] = {"Tobilung"},
	["tgc"] = {"Tigak"},
	["tgd"] = {"Ciwogai"},
	["tge"] = {"Eastern Gorkha Tamang"},
	["tgf"] = {"Chalikha"},
	["tgh"] = {"Tobagonian Creole English"},
	["tgi"] = {"Lawunuia"},
	["tgj"] = {"Tagin"},
	["tgn"] = {"Tandaganon"},
	["tgo"] = {"Sudest"},
	["tgp"] = {"Tangoa"},
	["tgq"] = {"Tring"},
	["tgr"] = {"Tareng"},
	["tgs"] = {"Nume"},
	["tgt"] = {"Central Tagbanwa"},
	["tgu"] = {"Tanggu"},
	["tgv"] = {"Tingui-Boto"},
	["tgw"] = {"Tagwana Senoufo"},
	["tgx"] = {"Tagish"},
	["tgy"] = {"Togoyo"},
	["tgz"] = {"Tagalaka"},
	["thd"] = {"Kuuk Thaayorre", "Thayore"},
	["the"] = {"Chitwania Tharu"},
	["thf"] = {"Thangmi"},
	["thh"] = {"Northern Tarahumara"},
	["thi"] = {"Tai Long"},
	["thk"] = {"Tharaka", "Kitharaka"},
	["thl"] = {"Dangaura Tharu"},
	["thm"] = {"Aheu"},
	["thn"] = {"Thachanadan"},
	["thp"] = {"Thompson"},
	["thq"] = {"Kochila Tharu"},
	["thr"] = {"Rana Tharu"},
	["ths"] = {"Thakali"},
	["tht"] = {"Tahltan"},
	["thu"] = {"Thuri"},
	["thv"] = {"Tahaggart Tamahaq"},
	["thy"] = {"Tha"},
	["thz"] = {"Tayart Tamajeq"},
	["tia"] = {"Tidikelt Tamazight"},
	["tic"] = {"Tira"},
	["tif"] = {"Tifal"},
	["tig"] = {"Tigre"},
	["tih"] = {"Timugon Murut"},
	["tii"] = {"Tiene"},
	["tij"] = {"Tilung"},
	["tik"] = {"Tikar"},
	["til"] = {"Tillamook"},
	["tim"] = {"Timbe"},
	["tin"] = {"Tindi"},
	["tio"] = {"Teop"},
	["tip"] = {"Trimuris"},
	["tiq"] = {"Tiéfo"},
	["tis"] = {"Masadiit Itneg"},
	["tit"] = {"Tinigua"},
	["tiu"] = {"Adasen"},
	["tiv"] = {"Tiv"},
	["tiw"] = {"Tiwi"},
	["tix"] = {"Southern Tiwa"},
	["tiy"] = {"Tiruray"},
	["tiz"] = {"Tai Hongjin"},
	["tja"] = {"Tajuasohn"},
	["tjg"] = {"Tunjung"},
	["tji"] = {"Northern Tujia"},
	["tjj"] = {"Tjungundji"},
	["tjl"] = {"Tai Laing"},
	["tjm"] = {"Timucua"},
	["tjn"] = {"Tonjon"},
	["tjo"] = {"Temacine Tamazight"},
	["tjp"] = {"Tjupany"},
	["tjs"] = {"Southern Tujia"},
	["tju"] = {"Tjurruru"},
	["tjw"] = {"Djabwurrung"},
	["tka"] = {"Truká"},
	["tkb"] = {"Buksa"},
	["tkd"] = {"Tukudede"},
	["tke"] = {"Takwane"},
	["tkf"] = {"Tukumanféd"},
	["tkg"] = {"Tesaka Malagasy"},
	["tkl"] = {"Tokelau"},
	["tkm"] = {"Takelma"},
	["tkn"] = {"Toku-No-Shima"},
	["tkp"] = {"Tikopia"},
	["tkq"] = {"Tee"},
	["tkr"] = {"Tsakhur"},
	["tks"] = {"Takestani"},
	["tkt"] = {"Kathoriya Tharu"},
	["tku"] = {"Upper Necaxa Totonac"},
	["tkv"] = {"Mur Pano"},
	["tkw"] = {"Teanu"},
	["tkx"] = {"Tangko"},
	["tkz"] = {"Takua"},
	["tla"] = {"Southwestern Tepehuan"},
	["tlb"] = {"Tobelo"},
	["tlc"] = {"Yecuatla Totonac"},
	["tld"] = {"Talaud"},
	["tlf"] = {"Telefol"},
	["tlg"] = {"Tofanma"},
	["tlh"] = {"Klingon", "tlhIngan Hol"},
	["tli"] = {"Tlingit"},
	["tlj"] = {"Talinga-Bwisi"},
	["tlk"] = {"Taloki"},
	["tll"] = {"Tetela"},
	["tlm"] = {"Tolomako"},
	["tln"] = {"Talondo'"},
	["tlo"] = {"Talodi"},
	["tlp"] = {"Filomena Mata-Coahuitlán Totonac"},
	["tlq"] = {"Tai Loi"},
	["tlr"] = {"Talise"},
	["tls"] = {"Tambotalo"},
	["tlt"] = {"Sou Nama", "Teluti"},
	["tlu"] = {"Tulehu"},
	["tlv"] = {"Taliabu"},
	["tlx"] = {"Khehek"},
	["tly"] = {"Talysh"},
	["tma"] = {"Tama (Chad)"},
	["tmb"] = {"Katbol", "Avava"},
	["tmc"] = {"Tumak"},
	["tmd"] = {"Haruai"},
	["tme"] = {"Tremembé"},
	["tmf"] = {"Toba-Maskoy"},
	["tmg"] = {"Ternateño"},
	["tmh"] = {"Tamashek"},
	["tmi"] = {"Tutuba"},
	["tmj"] = {"Samarokena"},
	["tml"] = {"Tamnim Citak"},
	["tmm"] = {"Tai Thanh"},
	["tmn"] = {"Taman (Indonesia)"},
	["tmo"] = {"Temoq"},
	["tmq"] = {"Tumleo"},
	["tmr"] = {"Jewish Babylonian Aramaic (ca. 200-1200 CE)"},
	["tms"] = {"Tima"},
	["tmt"] = {"Tasmate"},
	["tmu"] = {"Iau"},
	["tmv"] = {"Tembo (Motembo)"},
	["tmw"] = {"Temuan"},
	["tmy"] = {"Tami"},
	["tmz"] = {"Tamanaku"},
	["tna"] = {"Tacana"},
	["tnb"] = {"Western Tunebo"},
	["tnc"] = {"Tanimuca-Retuarã"},
	["tnd"] = {"Angosturas Tunebo"},
	["tng"] = {"Tobanga"},
	["tnh"] = {"Maiani"},
	["tni"] = {"Tandia"},
	["tnk"] = {"Kwamera"},
	["tnl"] = {"Lenakel"},
	["tnm"] = {"Tabla"},
	["tnn"] = {"North Tanna"},
	["tno"] = {"Toromono"},
	["tnp"] = {"Whitesands"},
	["tnq"] = {"Taino"},
	["tnr"] = {"Ménik"},
	["tns"] = {"Tenis"},
	["tnt"] = {"Tontemboan"},
	["tnu"] = {"Tay Khang"},
	["tnv"] = {"Tangchangya"},
	["tnw"] = {"Tonsawang"},
	["tnx"] = {"Tanema"},
	["tny"] = {"Tongwe"},
	["tnz"] = {"Ten'edn"},
	["tob"] = {"Toba"},
	["toc"] = {"Coyutla Totonac"},
	["tod"] = {"Toma"},
	["tof"] = {"Gizrra"},
	["tog"] = {"Tonga (Nyasa)"},
	["toh"] = {"Gitonga"},
	["toi"] = {"Tonga (Zambia)"},
	["toj"] = {"Tojolabal"},
	["tok"] = {"Toki Pona"},
	["tol"] = {"Tolowa"},
	["tom"] = {"Tombulu"},
	["too"] = {"Xicotepec De Juárez Totonac"},
	["top"] = {"Papantla Totonac"},
	["toq"] = {"Toposa"},
	["tor"] = {"Togbo-Vara Banda"},
	["tos"] = {"Highland Totonac"},
	["tou"] = {"Tho"},
	["tov"] = {"Upper Taromi"},
	["tow"] = {"Jemez"},
	["tox"] = {"Tobian"},
	["toy"] = {"Topoiyo"},
	["toz"] = {"To"},
	["tpa"] = {"Taupota"},
	["tpc"] = {"Azoyú Me'phaa", "Azoyú Tlapanec"},
	["tpe"] = {"Tippera"},
	["tpf"] = {"Tarpia"},
	["tpg"] = {"Kula"},
	["tpi"] = {"Tok Pisin"},
	["tpj"] = {"Tapieté"},
	["tpk"] = {"Tupinikin"},
	["tpl"] = {"Tlacoapa Me'phaa", "Tlacoapa Tlapanec"},
	["tpm"] = {"Tampulma"},
	["tpn"] = {"Tupinambá"},
	["tpo"] = {"Tai Pao"},
	["tpp"] = {"Pisaflores Tepehua"},
	["tpq"] = {"Tukpa"},
	["tpr"] = {"Tuparí"},
	["tpt"] = {"Tlachichilco Tepehua"},
	["tpu"] = {"Tampuan"},
	["tpv"] = {"Tanapag"},
	["tpx"] = {"Acatepec Me'phaa", "Acatepec Tlapanec"},
	["tpy"] = {"Trumai"},
	["tpz"] = {"Tinputz"},
	["tqb"] = {"Tembé"},
	["tql"] = {"Lehali"},
	["tqm"] = {"Turumsa"},
	["tqn"] = {"Tenino"},
	["tqo"] = {"Toaripi"},
	["tqp"] = {"Tomoip"},
	["tqq"] = {"Tunni"},
	["tqr"] = {"Torona"},
	["tqt"] = {"Western Totonac"},
	["tqu"] = {"Touo"},
	["tqw"] = {"Tonkawa"},
	["tra"] = {"Tirahi"},
	["trb"] = {"Terebu"},
	["trc"] = {"Copala Triqui"},
	["trd"] = {"Turi"},
	["tre"] = {"East Tarangan"},
	["trf"] = {"Trinidadian Creole English"},
	["trg"] = {"Lishán Didán"},
	["trh"] = {"Turaka"},
	["tri"] = {"Trió"},
	["trj"] = {"Toram"},
	["trk"] = {"Turkic languages"},
	["trl"] = {"Traveller Scottish"},
	["trm"] = {"Tregami"},
	["trn"] = {"Trinitario"},
	["tro"] = {"Tarao Naga"},
	["trp"] = {"Kok Borok"},
	["trq"] = {"San Martín Itunyoso Triqui"},
	["trr"] = {"Taushiro"},
	["trs"] = {"Chicahuaxtla Triqui"},
	["trt"] = {"Tunggare"},
	["tru"] = {"Turoyo", "Surayt"},
	["trv"] = {"Sediq", "Seediq", "Taroko"},
	["trw"] = {"Torwali"},
	["trx"] = {"Tringgus-Sembaan Bidayuh"},
	["try"] = {"Turung"},
	["trz"] = {"Torá"},
	["tsa"] = {"Tsaangi"},
	["tsb"] = {"Tsamai"},
	["tsc"] = {"Tswa"},
	["tsd"] = {"Tsakonian"},
	["tse"] = {"Tunisian Sign Language"},
	["tsg"] = {"Tausug"},
	["tsh"] = {"Tsuvan"},
	["tsi"] = {"Tsimshian"},
	["tsj"] = {"Tshangla"},
	["tsk"] = {"Tseku"},
	["tsl"] = {"Ts'ün-Lao"},
	["tsm"] = {"Turkish Sign Language", "Türk İşaret Dili"},
	["tsp"] = {"Northern Toussian"},
	["tsq"] = {"Thai Sign Language"},
	["tsr"] = {"Akei"},
	["tss"] = {"Taiwan Sign Language"},
	["tst"] = {"Tondi Songway Kiini"},
	["tsu"] = {"Tsou"},
	["tsv"] = {"Tsogo"},
	["tsw"] = {"Tsishingini"},
	["tsx"] = {"Mubami"},
	["tsy"] = {"Tebul Sign Language"},
	["tsz"] = {"Purepecha"},
	["tta"] = {"Tutelo"},
	["ttb"] = {"Gaa"},
	["ttc"] = {"Tektiteko"},
	["ttd"] = {"Tauade"},
	["tte"] = {"Bwanabwana"},
	["ttf"] = {"Tuotomb"},
	["ttg"] = {"Tutong"},
	["tth"] = {"Upper Ta'oih"},
	["tti"] = {"Tobati"},
	["ttj"] = {"Tooro"},
	["ttk"] = {"Totoro"},
	["ttl"] = {"Totela"},
	["ttm"] = {"Northern Tutchone"},
	["ttn"] = {"Towei"},
	["tto"] = {"Lower Ta'oih"},
	["ttp"] = {"Tombelala"},
	["ttq"] = {"Tawallammat Tamajaq"},
	["ttr"] = {"Tera"},
	["tts"] = {"Northeastern Thai"},
	["ttt"] = {"Muslim Tat"},
	["ttu"] = {"Torau"},
	["ttv"] = {"Titan"},
	["ttw"] = {"Long Wat"},
	["tty"] = {"Sikaritai"},
	["ttz"] = {"Tsum"},
	["tua"] = {"Wiarumus"},
	["tub"] = {"Tübatulabal"},
	["tuc"] = {"Mutu"},
	["tud"] = {"Tuxá"},
	["tue"] = {"Tuyuca"},
	["tuf"] = {"Central Tunebo"},
	["tug"] = {"Tunia"},
	["tuh"] = {"Taulil"},
	["tui"] = {"Tupuri"},
	["tuj"] = {"Tugutil"},
	["tul"] = {"Tula"},
	["tum"] = {"Tumbuka"},
	["tun"] = {"Tunica"},
	["tuo"] = {"Tucano"},
	["tup"] = {"Tupi languages"},
	["tuq"] = {"Tedaga"},
	["tus"] = {"Tuscarora"},
	["tut"] = {"Altaic languages"},
	["tuu"] = {"Tututni"},
	["tuv"] = {"Turkana"},
	["tuw"] = {"Tungus languages"},
	["tux"] = {"Tuxináwa"},
	["tuy"] = {"Tugen"},
	["tuz"] = {"Turka"},
	["tva"] = {"Vaghua"},
	["tvd"] = {"Tsuvadi"},
	["tve"] = {"Te'un"},
	["tvi"] = {"Tulai"},
	["tvk"] = {"Southeast Ambrym"},
	["tvl"] = {"Tuvalu"},
	["tvm"] = {"Tela-Masbuar"},
	["tvn"] = {"Tavoyan"},
	["tvo"] = {"Tidore"},
	["tvs"] = {"Taveta"},
	["tvt"] = {"Tutsa Naga"},
	["tvu"] = {"Tunen"},
	["tvw"] = {"Sedoa"},
	["tvx"] = {"Taivoan"},
	["tvy"] = {"Timor Pidgin"},
	["twa"] = {"Twana"},
	["twb"] = {"Western Tawbuid"},
	["twc"] = {"Teshenawa"},
	["twd"] = {"Twents"},
	["twe"] = {"Tewa (Indonesia)"},
	["twf"] = {"Northern Tiwa"},
	["twg"] = {"Tereweng"},
	["twh"] = {"Tai Dón"},
	["twl"] = {"Tawara"},
	["twm"] = {"Tawang Monpa"},
	["twn"] = {"Twendi"},
	["two"] = {"Tswapong"},
	["twp"] = {"Ere"},
	["twq"] = {"Tasawaq"},
	["twr"] = {"Southwestern Tarahumara"},
	["twt"] = {"Turiwára"},
	["twu"] = {"Termanu"},
	["tww"] = {"Tuwari"},
	["twx"] = {"Tewe"},
	["twy"] = {"Tawoyan"},
	["txa"] = {"Tombonuo"},
	["txb"] = {"Tokharian B"},
	["txc"] = {"Tsetsaut"},
	["txe"] = {"Totoli"},
	["txg"] = {"Tangut"},
	["txh"] = {"Thracian"},
	["txi"] = {"Ikpeng"},
	["txj"] = {"Tarjumo"},
	["txm"] = {"Tomini"},
	["txn"] = {"West Tarangan"},
	["txo"] = {"Toto"},
	["txq"] = {"Tii"},
	["txr"] = {"Tartessian"},
	["txs"] = {"Tonsea"},
	["txt"] = {"Citak"},
	["txu"] = {"Kayapó"},
	["txx"] = {"Tatana"},
	["txy"] = {"Tanosy Malagasy"},
	["tya"] = {"Tauya"},
	["tye"] = {"Kyanga"},
	["tyh"] = {"O'du"},
	["tyi"] = {"Teke-Tsaayi"},
	["tyj"] = {"Tai Do", "Tai Yo"},
	["tyl"] = {"Thu Lao"},
	["tyn"] = {"Kombai"},
	["typ"] = {"Thaypan"},
	["tyr"] = {"Tai Daeng"},
	["tys"] = {"Tày Sa Pa"},
	["tyt"] = {"Tày Tac"},
	["tyu"] = {"Kua"},
	["tyv"] = {"Tuvinian"},
	["tyx"] = {"Teke-Tyee"},
	["tyy"] = {"Tiyaa"},
	["tyz"] = {"Tày"},
	["tza"] = {"Tanzanian Sign Language"},
	["tzh"] = {"Tzeltal"},
	["tzj"] = {"Tz'utujil"},
	["tzl"] = {"Talossan"},
	["tzm"] = {"Central Atlas Tamazight"},
	["tzn"] = {"Tugun"},
	["tzo"] = {"Tzotzil"},
	["tzx"] = {"Tabriak"},
	["uam"] = {"Uamué"},
	["uan"] = {"Kuan"},
	["uar"] = {"Tairuma"},
	["uba"] = {"Ubang"},
	["ubi"] = {"Ubi"},
	["ubl"] = {"Buhi'non Bikol"},
	["ubr"] = {"Ubir"},
	["ubu"] = {"Umbu-Ungu"},
	["uby"] = {"Ubykh"},
	["uda"] = {"Uda"},
	["ude"] = {"Udihe"},
	["udg"] = {"Muduga"},
	["udi"] = {"Udi"},
	["udj"] = {"Ujir"},
	["udl"] = {"Wuzlam"},
	["udm"] = {"Udmurt"},
	["udu"] = {"Uduk"},
	["ues"] = {"Kioko"},
	["ufi"] = {"Ufim"},
	["uga"] = {"Ugaritic"},
	["ugb"] = {"Kuku-Ugbanh"},
	["uge"] = {"Ughele"},
	["ugh"] = {"Kubachi"},
	["ugn"] = {"Ugandan Sign Language"},
	["ugo"] = {"Ugong"},
	["ugy"] = {"Uruguayan Sign Language"},
	["uha"] = {"Uhami"},
	["uhn"] = {"Damal"},
	["uis"] = {"Uisai"},
	["uiv"] = {"Iyive"},
	["uji"] = {"Tanjijili"},
	["uka"] = {"Kaburi"},
	["ukg"] = {"Ukuriguma"},
	["ukh"] = {"Ukhwejo"},
	["uki"] = {"Kui (India)"},
	["ukk"] = {"Muak Sa-aak"},
	["ukl"] = {"Ukrainian Sign Language"},
	["ukp"] = {"Ukpe-Bayobiri"},
	["ukq"] = {"Ukwa"},
	["uks"] = {"Urubú-Kaapor Sign Language", "Kaapor Sign Language"},
	["uku"] = {"Ukue"},
	["ukv"] = {"Kuku"},
	["ukw"] = {"Ukwuani-Aboh-Ndoni"},
	["uky"] = {"Kuuk-Yak"},
	["ula"] = {"Fungwa"},
	["ulb"] = {"Ulukwumi"},
	["ulc"] = {"Ulch"},
	["ule"] = {"Lule"},
	["ulf"] = {"Usku", "Afra"},
	["uli"] = {"Ulithian"},
	["ulk"] = {"Meriam Mir"},
	["ull"] = {"Ullatan"},
	["ulm"] = {"Ulumanda'"},
	["uln"] = {"Unserdeutsch"},
	["ulu"] = {"Uma' Lung"},
	["ulw"] = {"Ulwa"},
	["uly"] = {"Buli"},
	["uma"] = {"Umatilla"},
	["umb"] = {"Umbundu"},
	["umc"] = {"Marrucinian"},
	["umd"] = {"Umbindhamu"},
	["umg"] = {"Morrobalama", "Umbuygamu"},
	["umi"] = {"Ukit"},
	["umm"] = {"Umon"},
	["umn"] = {"Makyan Naga"},
	["umo"] = {"Umotína"},
	["ump"] = {"Umpila"},
	["umr"] = {"Umbugarla"},
	["ums"] = {"Pendau"},
	["umu"] = {"Munsee"},
	["una"] = {"North Watut"},
	["und"] = {"Undetermined"},
	["une"] = {"Uneme"},
	["ung"] = {"Ngarinyin"},
	["uni"] = {"Uni"},
	["unk"] = {"Enawené-Nawé"},
	["unm"] = {"Unami"},
	["unn"] = {"Kurnai"},
	["unr"] = {"Mundari"},
	["unu"] = {"Unubahe"},
	["unx"] = {"Munda"},
	["unz"] = {"Unde Kaili"},
	["uon"] = {"Kulon"},
	["upi"] = {"Umeda"},
	["upv"] = {"Uripiv-Wala-Rano-Atchin"},
	["ura"] = {"Urarina"},
	["urb"] = {"Urubú-Kaapor", "Kaapor"},
	["urc"] = {"Urningangg"},
	["ure"] = {"Uru"},
	["urf"] = {"Uradhi"},
	["urg"] = {"Urigina"},
	["urh"] = {"Urhobo"},
	["uri"] = {"Urim"},
	["urj"] = {"Uralic languages"},
	["urk"] = {"Urak Lawoi'"},
	["url"] = {"Urali"},
	["urm"] = {"Urapmin"},
	["urn"] = {"Uruangnirin"},
	["uro"] = {"Ura (Papua New Guinea)"},
	["urp"] = {"Uru-Pa-In"},
	["urr"] = {"Lehalurup", "Löyöp"},
	["urt"] = {"Urat"},
	["uru"] = {"Urumi"},
	["urv"] = {"Uruava"},
	["urw"] = {"Sop"},
	["urx"] = {"Urimo"},
	["ury"] = {"Orya"},
	["urz"] = {"Uru-Eu-Wau-Wau"},
	["usa"] = {"Usarufa"},
	["ush"] = {"Ushojo"},
	["usi"] = {"Usui"},
	["usk"] = {"Usaghade"},
	["usp"] = {"Uspanteco"},
	["uss"] = {"us-Saare"},
	["usu"] = {"Uya"},
	["uta"] = {"Otank"},
	["ute"] = {"Ute-Southern Paiute"},
	["uth"] = {"ut-Hun"},
	["utp"] = {"Amba (Solomon Islands)"},
	["utr"] = {"Etulo"},
	["utu"] = {"Utu"},
	["uum"] = {"Urum"},
	["uur"] = {"Ura (Vanuatu)"},
	["uuu"] = {"U"},
	["uve"] = {"West Uvean", "Fagauvea"},
	["uvh"] = {"Uri"},
	["uvl"] = {"Lote"},
	["uwa"] = {"Kuku-Uwanh"},
	["uya"] = {"Doko-Uyanga"},
	["uzn"] = {"Northern Uzbek"},
	["uzs"] = {"Southern Uzbek"},
	["vaa"] = {"Vaagri Booli"},
	["vae"] = {"Vale"},
	["vaf"] = {"Vafsi"},
	["vag"] = {"Vagla"},
	["vah"] = {"Varhadi-Nagpuri"},
	["vai"] = {"Vai"},
	["vaj"] = {"Sekele", "Northwestern ǃKung", "Vasekele"},
	["val"] = {"Vehes"},
	["vam"] = {"Vanimo"},
	["van"] = {"Valman"},
	["vao"] = {"Vao"},
	["vap"] = {"Vaiphei"},
	["var"] = {"Huarijio"},
	["vas"] = {"Vasavi"},
	["vau"] = {"Vanuma"},
	["vav"] = {"Varli"},
	["vay"] = {"Wayu"},
	["vbb"] = {"Southeast Babar"},
	["vbk"] = {"Southwestern Bontok"},
	["vec"] = {"Venetian"},
	["ved"] = {"Veddah"},
	["vel"] = {"Veluws"},
	["vem"] = {"Vemgo-Mabas"},
	["veo"] = {"Ventureño"},
	["vep"] = {"Veps"},
	["ver"] = {"Mom Jango"},
	["vgr"] = {"Vaghri"},
	["vgt"] = {"Vlaamse Gebarentaal", "Flemish Sign Language"},
	["vic"] = {"Virgin Islands Creole English"},
	["vid"] = {"Vidunda"},
	["vif"] = {"Vili"},
	["vig"] = {"Viemo"},
	["vil"] = {"Vilela"},
	["vin"] = {"Vinza"},
	["vis"] = {"Vishavan"},
	["vit"] = {"Viti"},
	["viv"] = {"Iduna"},
	["vjk"] = {"Bajjika"},
	["vka"] = {"Kariyarra"},
	["vkj"] = {"Kujarge"},
	["vkk"] = {"Kaur"},
	["vkl"] = {"Kulisusu"},
	["vkm"] = {"Kamakan"},
	["vkn"] = {"Koro Nulu"},
	["vko"] = {"Kodeoha"},
	["vkp"] = {"Korlai Creole Portuguese"},
	["vkt"] = {"Tenggarong Kutai Malay"},
	["vku"] = {"Kurrama"},
	["vkz"] = {"Koro Zuba"},
	["vlp"] = {"Valpei"},
	["vls"] = {"Vlaams"},
	["vma"] = {"Martuyhunira"},
	["vmb"] = {"Barbaram"},
	["vmc"] = {"Juxtlahuaca Mixtec"},
	["vmd"] = {"Mudu Koraga"},
	["vme"] = {"East Masela"},
	["vmf"] = {"Mainfränkisch"},
	["vmg"] = {"Lungalunga"},
	["vmh"] = {"Maraghei"},
	["vmi"] = {"Miwa"},
	["vmj"] = {"Ixtayutla Mixtec"},
	["vmk"] = {"Makhuwa-Shirima"},
	["vml"] = {"Malgana"},
	["vmm"] = {"Mitlatongo Mixtec"},
	["vmp"] = {"Soyaltepec Mazatec"},
	["vmq"] = {"Soyaltepec Mixtec"},
	["vmr"] = {"Marenje"},
	["vms"] = {"Moksela"},
	["vmu"] = {"Muluridyi"},
	["vmv"] = {"Valley Maidu"},
	["vmw"] = {"Makhuwa"},
	["vmx"] = {"Tamazola Mixtec"},
	["vmy"] = {"Ayautla Mazatec"},
	["vmz"] = {"Mazatlán Mazatec"},
	["vnk"] = {"Vano", "Lovono"},
	["vnm"] = {"Vinmavis", "Neve'ei"},
	["vnp"] = {"Vunapu"},
	["vor"] = {"Voro"},
	["vot"] = {"Votic"},
	["vra"] = {"Vera'a"},
	["vro"] = {"Võro"},
	["vrs"] = {"Varisi"},
	["vrt"] = {"Burmbar", "Banam Bay"},
	["vsi"] = {"Moldova Sign Language"},
	["vsl"] = {"Venezuelan Sign Language"},
	["vsn"] = {"Vedic Sanskrit"},
	["vsv"] = {"Valencian Sign Language", "Llengua de signes valenciana"},
	["vto"] = {"Vitou"},
	["vum"] = {"Vumbu"},
	["vun"] = {"Vunjo"},
	["vut"] = {"Vute"},
	["vwa"] = {"Awa (China)"},
	["waa"] = {"Walla Walla"},
	["wab"] = {"Wab"},
	["wac"] = {"Wasco-Wishram"},
	["wad"] = {"Wamesa", "Wondama"},
	["wae"] = {"Walser"},
	["waf"] = {"Wakoná"},
	["wag"] = {"Wa'ema"},
	["wah"] = {"Watubela"},
	["wai"] = {"Wares"},
	["waj"] = {"Waffa"},
	["wak"] = {"Wakashan languages"},
	["wal"] = {"Wolaytta", "Wolaitta"},
	["wam"] = {"Wampanoag"},
	["wan"] = {"Wan"},
	["wao"] = {"Wappo"},
	["wap"] = {"Wapishana"},
	["waq"] = {"Wagiman"},
	["war"] = {"Waray (Philippines)"},
	["was"] = {"Washo"},
	["wat"] = {"Kaninuwa"},
	["wau"] = {"Waurá"},
	["wav"] = {"Waka"},
	["waw"] = {"Waiwai"},
	["wax"] = {"Watam", "Marangis"},
	["way"] = {"Wayana"},
	["waz"] = {"Wampur"},
	["wba"] = {"Warao"},
	["wbb"] = {"Wabo"},
	["wbe"] = {"Waritai"},
	["wbf"] = {"Wara"},
	["wbh"] = {"Wanda"},
	["wbi"] = {"Vwanji"},
	["wbj"] = {"Alagwa"},
	["wbk"] = {"Waigali"},
	["wbl"] = {"Wakhi"},
	["wbm"] = {"Wa"},
	["wbp"] = {"Warlpiri"},
	["wbq"] = {"Waddar"},
	["wbr"] = {"Wagdi"},
	["wbs"] = {"West Bengal Sign Language"},
	["wbt"] = {"Warnman"},
	["wbv"] = {"Wajarri"},
	["wbw"] = {"Woi"},
	["wca"] = {"Yanomámi"},
	["wci"] = {"Waci Gbe"},
	["wdd"] = {"Wandji"},
	["wdg"] = {"Wadaginam"},
	["wdj"] = {"Wadjiginy"},
	["wdk"] = {"Wadikali"},
	["wdt"] = {"Wendat"},
	["wdu"] = {"Wadjigu"},
	["wdy"] = {"Wadjabangayi"},
	["wea"] = {"Wewaw"},
	["wec"] = {"Wè Western"},
	["wed"] = {"Wedau"},
	["weg"] = {"Wergaia"},
	["weh"] = {"Weh"},
	["wei"] = {"Kiunum"},
	["wem"] = {"Weme Gbe"},
	["wen"] = {"Sorbian languages"},
	["weo"] = {"Wemale"},
	["wep"] = {"Westphalien"},
	["wer"] = {"Weri"},
	["wes"] = {"Cameroon Pidgin"},
	["wet"] = {"Perai"},
	["weu"] = {"Rawngtu Chin"},
	["wew"] = {"Wejewa"},
	["wfg"] = {"Yafi", "Zorop"},
	["wga"] = {"Wagaya"},
	["wgb"] = {"Wagawaga"},
	["wgg"] = {"Wangkangurru", "Wangganguru"},
	["wgi"] = {"Wahgi"},
	["wgo"] = {"Waigeo"},
	["wgu"] = {"Wirangu"},
	["wgy"] = {"Warrgamay"},
	["wha"] = {"Sou Upaa", "Manusela"},
	["whg"] = {"North Wahgi"},
	["whk"] = {"Wahau Kenyah"},
	["whu"] = {"Wahau Kayan"},
	["wib"] = {"Southern Toussian"},
	["wic"] = {"Wichita"},
	["wie"] = {"Wik-Epa"},
	["wif"] = {"Wik-Keyangan"},
	["wig"] = {"Wik Ngathan"},
	["wih"] = {"Wik-Me'anha"},
	["wii"] = {"Minidien"},
	["wij"] = {"Wik-Iiyanh"},
	["wik"] = {"Wikalkan"},
	["wil"] = {"Wilawila"},
	["wim"] = {"Wik-Mungkan"},
	["win"] = {"Ho-Chunk"},
	["wir"] = {"Wiraféd"},
	["wiu"] = {"Wiru"},
	["wiv"] = {"Vitu"},
	["wiy"] = {"Wiyot"},
	["wja"] = {"Waja"},
	["wji"] = {"Warji"},
	["wka"] = {"Kw'adza"},
	["wkb"] = {"Kumbaran"},
	["wkd"] = {"Wakde", "Mo"},
	["wkl"] = {"Kalanadi"},
	["wkr"] = {"Keerray-Woorroong"},
	["wku"] = {"Kunduvadi"},
	["wkw"] = {"Wakawaka"},
	["wky"] = {"Wangkayutyuru"},
	["wla"] = {"Walio"},
	["wlc"] = {"Mwali Comorian"},
	["wle"] = {"Wolane"},
	["wlg"] = {"Kunbarlang"},
	["wlh"] = {"Welaun"},
	["wli"] = {"Waioli"},
	["wlk"] = {"Wailaki"},
	["wll"] = {"Wali (Sudan)"},
	["wlm"] = {"Middle Welsh"},
	["wlo"] = {"Wolio"},
	["wlr"] = {"Wailapa"},
	["wls"] = {"Wallisian"},
	["wlu"] = {"Wuliwuli"},
	["wlv"] = {"Wichí Lhamtés Vejoz"},
	["wlw"] = {"Walak"},
	["wlx"] = {"Wali (Ghana)"},
	["wly"] = {"Waling"},
	["wma"] = {"Mawa (Nigeria)"},
	["wmb"] = {"Wambaya"},
	["wmc"] = {"Wamas"},
	["wmd"] = {"Mamaindé"},
	["wme"] = {"Wambule"},
	["wmg"] = {"Western Minyag"},
	["wmh"] = {"Waima'a"},
	["wmi"] = {"Wamin"},
	["wmm"] = {"Maiwa (Indonesia)"},
	["wmn"] = {"Waamwang"},
	["wmo"] = {"Wom (Papua New Guinea)"},
	["wms"] = {"Wambon"},
	["wmt"] = {"Walmajarri"},
	["wmw"] = {"Mwani"},
	["wmx"] = {"Womo"},
	["wnb"] = {"Mokati"},
	["wnc"] = {"Wantoat"},
	["wnd"] = {"Wandarang"},
	["wne"] = {"Waneci"},
	["wng"] = {"Wanggom"},
	["wni"] = {"Ndzwani Comorian"},
	["wnk"] = {"Wanukaka"},
	["wnm"] = {"Wanggamala"},
	["wnn"] = {"Wunumara"},
	["wno"] = {"Wano"},
	["wnp"] = {"Wanap"},
	["wnu"] = {"Usan"},
	["wnw"] = {"Wintu"},
	["wny"] = {"Wanyi", "Waanyi"},
	["woa"] = {"Kuwema", "Tyaraity"},
	["wob"] = {"Wè Northern"},
	["woc"] = {"Wogeo"},
	["wod"] = {"Wolani"},
	["woe"] = {"Woleaian"},
	["wof"] = {"Gambian Wolof"},
	["wog"] = {"Wogamusin"},
	["woi"] = {"Kamang"},
	["wok"] = {"Longto"},
	["wom"] = {"Wom (Nigeria)"},
	["won"] = {"Wongo"},
	["woo"] = {"Manombai"},
	["wor"] = {"Woria"},
	["wos"] = {"Hanga Hundi"},
	["wow"] = {"Wawonii"},
	["woy"] = {"Weyto"},
	["wpc"] = {"Maco"},
	["wrb"] = {"Waluwarra", "Warluwara"},
	["wrg"] = {"Warungu", "Gudjal"},
	["wrh"] = {"Wiradjuri"},
	["wri"] = {"Wariyangga"},
	["wrk"] = {"Garrwa"},
	["wrl"] = {"Warlmanpa"},
	["wrm"] = {"Warumungu"},
	["wrn"] = {"Warnang"},
	["wro"] = {"Worrorra"},
	["wrp"] = {"Waropen"},
	["wrr"] = {"Wardaman"},
	["wrs"] = {"Waris"},
	["wru"] = {"Waru"},
	["wrv"] = {"Waruna"},
	["wrw"] = {"Gugu Warra"},
	["wrx"] = {"Wae Rana"},
	["wry"] = {"Merwari"},
	["wrz"] = {"Waray (Australia)"},
	["wsa"] = {"Warembori"},
	["wsg"] = {"Adilabad Gondi"},
	["wsi"] = {"Wusi"},
	["wsk"] = {"Waskia"},
	["wsr"] = {"Owenia"},
	["wss"] = {"Wasa"},
	["wsu"] = {"Wasu"},
	["wsv"] = {"Wotapuri-Katarqalai"},
	["wtb"] = {"Matambwe"},
	["wtf"] = {"Watiwa"},
	["wth"] = {"Wathawurrung"},
	["wti"] = {"Berta"},
	["wtk"] = {"Watakataui"},
	["wtm"] = {"Mewati"},
	["wtw"] = {"Wotu"},
	["wua"] = {"Wikngenchera"},
	["wub"] = {"Wunambal"},
	["wud"] = {"Wudu"},
	["wuh"] = {"Wutunhua"},
	["wul"] = {"Silimo"},
	["wum"] = {"Wumbvu"},
	["wun"] = {"Bungu"},
	["wur"] = {"Wurrugu"},
	["wut"] = {"Wutung"},
	["wuu"] = {"Wu Chinese"},
	["wuv"] = {"Wuvulu-Aua"},
	["wux"] = {"Wulna"},
	["wuy"] = {"Wauyai"},
	["wwa"] = {"Waama"},
	["wwb"] = {"Wakabunga"},
	["wwo"] = {"Wetamut", "Dorig"},
	["wwr"] = {"Warrwa"},
	["www"] = {"Wawa"},
	["wxa"] = {"Waxianghua"},
	["wxw"] = {"Wardandi"},
	["wyb"] = {"Wangaaybuwan-Ngiyambaa"},
	["wyi"] = {"Woiwurrung"},
	["wym"] = {"Wymysorys"},
	["wyn"] = {"Wyandot"},
	["wyr"] = {"Wayoró"},
	["wyy"] = {"Western Fijian"},
	["xaa"] = {"Andalusian Arabic"},
	["xab"] = {"Sambe"},
	["xac"] = {"Kachari"},
	["xad"] = {"Adai"},
	["xae"] = {"Aequian"},
	["xag"] = {"Aghwan"},
	["xai"] = {"Kaimbé"},
	["xaj"] = {"Ararandewára"},
	["xak"] = {"Máku"},
	["xal"] = {"Kalmyk", "Oirat"},
	["xam"] = {"ǀXam"},
	["xan"] = {"Xamtanga"},
	["xao"] = {"Khao"},
	["xap"] = {"Apalachee"},
	["xaq"] = {"Aquitanian"},
	["xar"] = {"Karami"},
	["xas"] = {"Kamas"},
	["xat"] = {"Katawixi"},
	["xau"] = {"Kauwera"},
	["xav"] = {"Xavánte"},
	["xaw"] = {"Kawaiisu"},
	["xay"] = {"Kayan Mahakam"},
	["xbb"] = {"Lower Burdekin"},
	["xbc"] = {"Bactrian"},
	["xbd"] = {"Bindal"},
	["xbe"] = {"Bigambal"},
	["xbg"] = {"Bunganditj"},
	["xbi"] = {"Kombio"},
	["xbj"] = {"Birrpayi"},
	["xbm"] = {"Middle Breton"},
	["xbn"] = {"Kenaboi"},
	["xbo"] = {"Bolgarian"},
	["xbp"] = {"Bibbulman"},
	["xbr"] = {"Kambera"},
	["xbw"] = {"Kambiwá"},
	["xby"] = {"Batjala", "Batyala"},
	["xcb"] = {"Cumbric"},
	["xcc"] = {"Camunic"},
	["xce"] = {"Celtiberian"},
	["xcg"] = {"Cisalpine Gaulish"},
	["xch"] = {"Chemakum", "Chimakum"},
	["xcl"] = {"Classical Armenian"},
	["xcm"] = {"Comecrudo"},
	["xcn"] = {"Cotoname"},
	["xco"] = {"Chorasmian"},
	["xcr"] = {"Carian"},
	["xct"] = {"Classical Tibetan"},
	["xcu"] = {"Curonian"},
	["xcv"] = {"Chuvantsy"},
	["xcw"] = {"Coahuilteco"},
	["xcy"] = {"Cayuse"},
	["xda"] = {"Darkinyung"},
	["xdc"] = {"Dacian"},
	["xdk"] = {"Dharuk"},
	["xdm"] = {"Edomite"},
	["xdo"] = {"Kwandu"},
	["xdq"] = {"Kaitag"},
	["xdy"] = {"Malayic Dayak"},
	["xeb"] = {"Eblan"},
	["xed"] = {"Hdi"},
	["xeg"] = {"ǁXegwi"},
	["xel"] = {"Kelo"},
	["xem"] = {"Kembayan"},
	["xep"] = {"Epi-Olmec"},
	["xer"] = {"Xerénte"},
	["xes"] = {"Kesawai"},
	["xet"] = {"Xetá"},
	["xeu"] = {"Keoru-Ahia"},
	["xfa"] = {"Faliscan"},
	["xga"] = {"Galatian"},
	["xgb"] = {"Gbin"},
	["xgd"] = {"Gudang"},
	["xgf"] = {"Gabrielino-Fernandeño"},
	["xgg"] = {"Goreng"},
	["xgi"] = {"Garingbal"},
	["xgl"] = {"Galindan"},
	["xgm"] = {"Dharumbal", "Guwinmal"},
	["xgn"] = {"Mongolian languages"},
	["xgr"] = {"Garza"},
	["xgu"] = {"Unggumi"},
	["xgw"] = {"Guwa"},
	["xha"] = {"Harami"},
	["xhc"] = {"Hunnic"},
	["xhd"] = {"Hadrami"},
	["xhe"] = {"Khetrani"},
	["xhm"] = {"Middle Khmer (1400 to 1850 CE)"},
	["xhr"] = {"Hernican"},
	["xht"] = {"Hattic"},
	["xhu"] = {"Hurrian"},
	["xhv"] = {"Khua"},
	["xib"] = {"Iberian"},
	["xii"] = {"Xiri"},
	["xil"] = {"Illyrian"},
	["xin"] = {"Xinca"},
	["xir"] = {"Xiriâna"},
	["xis"] = {"Kisan"},
	["xiv"] = {"Indus Valley Language"},
	["xiy"] = {"Xipaya"},
	["xjb"] = {"Minjungbal"},
	["xjt"] = {"Jaitmatang"},
	["xka"] = {"Kalkoti"},
	["xkb"] = {"Northern Nago"},
	["xkc"] = {"Kho'ini"},
	["xkd"] = {"Mendalam Kayan"},
	["xke"] = {"Kereho"},
	["xkf"] = {"Khengkha"},
	["xkg"] = {"Kagoro"},
	["xki"] = {"Kenyan Sign Language"},
	["xkj"] = {"Kajali"},
	["xkk"] = {"Kachok", "Kaco'"},
	["xkl"] = {"Mainstream Kenyah"},
	["xkn"] = {"Kayan River Kayan"},
	["xko"] = {"Kiorr"},
	["xkp"] = {"Kabatei"},
	["xkq"] = {"Koroni"},
	["xkr"] = {"Xakriabá"},
	["xks"] = {"Kumbewaha"},
	["xkt"] = {"Kantosi"},
	["xku"] = {"Kaamba"},
	["xkv"] = {"Kgalagadi"},
	["xkw"] = {"Kembra"},
	["xkx"] = {"Karore"},
	["xky"] = {"Uma' Lasan"},
	["xkz"] = {"Kurtokha"},
	["xla"] = {"Kamula"},
	["xlb"] = {"Loup B"},
	["xlc"] = {"Lycian"},
	["xld"] = {"Lydian"},
	["xle"] = {"Lemnian"},
	["xlg"] = {"Ligurian (Ancient)"},
	["xli"] = {"Liburnian"},
	["xln"] = {"Alanic"},
	["xlo"] = {"Loup A"},
	["xlp"] = {"Lepontic"},
	["xls"] = {"Lusitanian"},
	["xlu"] = {"Cuneiform Luwian"},
	["xly"] = {"Elymian"},
	["xma"] = {"Mushungulu"},
	["xmb"] = {"Mbonga"},
	["xmc"] = {"Makhuwa-Marrevone"},
	["xmd"] = {"Mbudum"},
	["xme"] = {"Median"},
	["xmf"] = {"Mingrelian"},
	["xmg"] = {"Mengaka"},
	["xmh"] = {"Kugu-Muminh"},
	["xmj"] = {"Majera"},
	["xmk"] = {"Ancient Macedonian"},
	["xml"] = {"Malaysian Sign Language"},
	["xmm"] = {"Manado Malay"},
	["xmn"] = {"Manichaean Middle Persian"},
	["xmo"] = {"Morerebi"},
	["xmp"] = {"Kuku-Mu'inh"},
	["xmq"] = {"Kuku-Mangk"},
	["xmr"] = {"Meroitic"},
	["xms"] = {"Moroccan Sign Language"},
	["xmt"] = {"Matbat"},
	["xmu"] = {"Kamu"},
	["xmv"] = {"Antankarana Malagasy", "Tankarana Malagasy"},
	["xmw"] = {"Tsimihety Malagasy"},
	["xmx"] = {"Salawati", "Maden"},
	["xmy"] = {"Mayaguduna"},
	["xmz"] = {"Mori Bawah"},
	["xna"] = {"Ancient North Arabian"},
	["xnb"] = {"Kanakanabu"},
	["xnd"] = {"Na-Dene languages"},
	["xng"] = {"Middle Mongolian"},
	["xnh"] = {"Kuanhua"},
	["xni"] = {"Ngarigu"},
	["xnj"] = {"Ngoni (Tanzania)"},
	["xnk"] = {"Nganakarti"},
	["xnm"] = {"Ngumbarl"},
	["xnn"] = {"Northern Kankanay"},
	["xno"] = {"Anglo-Norman"},
	["xnq"] = {"Ngoni (Mozambique)"},
	["xnr"] = {"Kangri"},
	["xns"] = {"Kanashi"},
	["xnt"] = {"Narragansett"},
	["xnu"] = {"Nukunul"},
	["xny"] = {"Nyiyaparli"},
	["xnz"] = {"Kenzi", "Mattoki"},
	["xoc"] = {"O'chi'chi'"},
	["xod"] = {"Kokoda"},
	["xog"] = {"Soga"},
	["xoi"] = {"Kominimung"},
	["xok"] = {"Xokleng"},
	["xom"] = {"Komo (Sudan)"},
	["xon"] = {"Konkomba"},
	["xoo"] = {"Xukurú"},
	["xop"] = {"Kopar"},
	["xor"] = {"Korubo"},
	["xow"] = {"Kowaki"},
	["xpa"] = {"Pirriya"},
	["xpb"] = {"Northeastern Tasmanian", "Pyemmairrener"},
	["xpc"] = {"Pecheneg"},
	["xpd"] = {"Oyster Bay Tasmanian"},
	["xpe"] = {"Liberia Kpelle"},
	["xpf"] = {"Southeast Tasmanian", "Nuenonne"},
	["xpg"] = {"Phrygian"},
	["xph"] = {"North Midlands Tasmanian", "Tyerrenoterpanner"},
	["xpi"] = {"Pictish"},
	["xpj"] = {"Mpalitjanh"},
	["xpk"] = {"Kulina Pano"},
	["xpl"] = {"Port Sorell Tasmanian"},
	["xpm"] = {"Pumpokol"},
	["xpn"] = {"Kapinawá"},
	["xpo"] = {"Pochutec"},
	["xpp"] = {"Puyo-Paekche"},
	["xpq"] = {"Mohegan-Pequot"},
	["xpr"] = {"Parthian"},
	["xps"] = {"Pisidian"},
	["xpt"] = {"Punthamara"},
	["xpu"] = {"Punic"},
	["xpv"] = {"Northern Tasmanian", "Tommeginne"},
	["xpw"] = {"Northwestern Tasmanian", "Peerapper"},
	["xpx"] = {"Southwestern Tasmanian", "Toogee"},
	["xpy"] = {"Puyo"},
	["xpz"] = {"Bruny Island Tasmanian"},
	["xqa"] = {"Karakhanid"},
	["xqt"] = {"Qatabanian"},
	["xra"] = {"Krahô"},
	["xrb"] = {"Eastern Karaboro"},
	["xrd"] = {"Gundungurra"},
	["xre"] = {"Kreye"},
	["xrg"] = {"Minang"},
	["xri"] = {"Krikati-Timbira"},
	["xrm"] = {"Armazic"},
	["xrn"] = {"Arin"},
	["xrr"] = {"Raetic"},
	["xrt"] = {"Aranama-Tamique"},
	["xru"] = {"Marriammu"},
	["xrw"] = {"Karawa"},
	["xsa"] = {"Sabaean"},
	["xsb"] = {"Sambal"},
	["xsc"] = {"Scythian"},
	["xsd"] = {"Sidetic"},
	["xse"] = {"Sempan"},
	["xsh"] = {"Shamang"},
	["xsi"] = {"Sio"},
	["xsj"] = {"Subi"},
	["xsl"] = {"South Slavey"},
	["xsm"] = {"Kasem"},
	["xsn"] = {"Sanga (Nigeria)"},
	["xso"] = {"Solano"},
	["xsp"] = {"Silopi"},
	["xsq"] = {"Makhuwa-Saka"},
	["xsr"] = {"Sherpa"},
	["xsu"] = {"Sanumá"},
	["xsv"] = {"Sudovian"},
	["xsy"] = {"Saisiyat"},
	["xta"] = {"Alcozauca Mixtec"},
	["xtb"] = {"Chazumba Mixtec"},
	["xtc"] = {"Katcha-Kadugli-Miri"},
	["xtd"] = {"Diuxi-Tilantongo Mixtec"},
	["xte"] = {"Ketengban"},
	["xtg"] = {"Transalpine Gaulish"},
	["xth"] = {"Yitha Yitha"},
	["xti"] = {"Sinicahua Mixtec"},
	["xtj"] = {"San Juan Teita Mixtec"},
	["xtl"] = {"Tijaltepec Mixtec"},
	["xtm"] = {"Magdalena Peñasco Mixtec"},
	["xtn"] = {"Northern Tlaxiaco Mixtec"},
	["xto"] = {"Tokharian A"},
	["xtp"] = {"San Miguel Piedras Mixtec"},
	["xtq"] = {"Tumshuqese"},
	["xtr"] = {"Early Tripuri"},
	["xts"] = {"Sindihui Mixtec"},
	["xtt"] = {"Tacahua Mixtec"},
	["xtu"] = {"Cuyamecalco Mixtec"},
	["xtv"] = {"Thawa"},
	["xtw"] = {"Tawandê"},
	["xty"] = {"Yoloxochitl Mixtec"},
	["xua"] = {"Alu Kurumba"},
	["xub"] = {"Betta Kurumba"},
	["xud"] = {"Umiida"},
	["xug"] = {"Kunigami"},
	["xuj"] = {"Jennu Kurumba"},
	["xul"] = {"Ngunawal", "Nunukul"},
	["xum"] = {"Umbrian"},
	["xun"] = {"Unggaranggu"},
	["xuo"] = {"Kuo"},
	["xup"] = {"Upper Umpqua"},
	["xur"] = {"Urartian"},
	["xut"] = {"Kuthant"},
	["xuu"] = {"Kxoe", "Khwedam"},
	["xve"] = {"Venetic"},
	["xvi"] = {"Kamviri"},
	["xvn"] = {"Vandalic"},
	["xvo"] = {"Volscian"},
	["xvs"] = {"Vestinian"},
	["xwa"] = {"Kwaza"},
	["xwc"] = {"Woccon"},
	["xwd"] = {"Wadi Wadi"},
	["xwe"] = {"Xwela Gbe"},
	["xwg"] = {"Kwegu"},
	["xwj"] = {"Wajuk"},
	["xwk"] = {"Wangkumara"},
	["xwl"] = {"Western Xwla Gbe"},
	["xwo"] = {"Written Oirat"},
	["xwr"] = {"Kwerba Mamberamo"},
	["xwt"] = {"Wotjobaluk"},
	["xww"] = {"Wemba Wemba"},
	["xxb"] = {"Boro (Ghana)"},
	["xxk"] = {"Ke'o"},
	["xxm"] = {"Minkin"},
	["xxr"] = {"Koropó"},
	["xxt"] = {"Tambora"},
	["xya"] = {"Yaygir"},
	["xyb"] = {"Yandjibara"},
	["xyj"] = {"Mayi-Yapi"},
	["xyk"] = {"Mayi-Kulan"},
	["xyl"] = {"Yalakalore"},
	["xyt"] = {"Mayi-Thakurti"},
	["xyy"] = {"Yorta Yorta"},
	["xzh"] = {"Zhang-Zhung"},
	["xzm"] = {"Zemgalian"},
	["xzp"] = {"Ancient Zapotec"},
	["yaa"] = {"Yaminahua"},
	["yab"] = {"Yuhup"},
	["yac"] = {"Pass Valley Yali"},
	["yad"] = {"Yagua"},
	["yae"] = {"Pumé"},
	["yaf"] = {"Yaka (Democratic Republic of Congo)"},
	["yag"] = {"Yámana"},
	["yah"] = {"Yazgulyam"},
	["yai"] = {"Yagnobi"},
	["yaj"] = {"Banda-Yangere"},
	["yak"] = {"Yakama"},
	["yal"] = {"Yalunka"},
	["yam"] = {"Yamba"},
	["yan"] = {"Mayangna"},
	["yao"] = {"Yao"},
	["yap"] = {"Yapese"},
	["yaq"] = {"Yaqui"},
	["yar"] = {"Yabarana"},
	["yas"] = {"Nugunu (Cameroon)"},
	["yat"] = {"Yambeta"},
	["yau"] = {"Yuwana"},
	["yav"] = {"Yangben"},
	["yaw"] = {"Yawalapití"},
	["yax"] = {"Yauma"},
	["yay"] = {"Agwagwune"},
	["yaz"] = {"Lokaa"},
	["yba"] = {"Yala"},
	["ybb"] = {"Yemba"},
	["ybe"] = {"West Yugur"},
	["ybh"] = {"Yakha"},
	["ybi"] = {"Yamphu"},
	["ybj"] = {"Hasha"},
	["ybk"] = {"Bokha"},
	["ybl"] = {"Yukuben"},
	["ybm"] = {"Yaben"},
	["ybn"] = {"Yabaâna"},
	["ybo"] = {"Yabong"},
	["ybx"] = {"Yawiyo"},
	["yby"] = {"Yaweyuha"},
	["ych"] = {"Chesu"},
	["ycl"] = {"Lolopo"},
	["ycn"] = {"Yucuna"},
	["ycp"] = {"Chepya"},
	["ycr"] = {"Yilan Creole"},
	["yda"] = {"Yanda"},
	["ydd"] = {"Eastern Yiddish"},
	["yde"] = {"Yangum Dey"},
	["ydg"] = {"Yidgha"},
	["ydk"] = {"Yoidik"},
	["yea"] = {"Ravula"},
	["yec"] = {"Yeniche"},
	["yee"] = {"Yimas"},
	["yei"] = {"Yeni"},
	["yej"] = {"Yevanic"},
	["yel"] = {"Yela"},
	["yer"] = {"Tarok"},
	["yes"] = {"Nyankpa"},
	["yet"] = {"Yetfa"},
	["yeu"] = {"Yerukula"},
	["yev"] = {"Yapunda"},
	["yey"] = {"Yeyi"},
	["yga"] = {"Malyangapa"},
	["ygi"] = {"Yiningayi"},
	["ygl"] = {"Yangum Gel"},
	["ygm"] = {"Yagomi"},
	["ygp"] = {"Gepo"},
	["ygr"] = {"Yagaria"},
	["ygs"] = {"Yolŋu Sign Language"},
	["ygu"] = {"Yugul"},
	["ygw"] = {"Yagwoia"},
	["yha"] = {"Baha Buyang"},
	["yhd"] = {"Judeo-Iraqi Arabic"},
	["yhl"] = {"Hlepho Phowa"},
	["yhs"] = {"Yan-nhaŋu Sign Language"},
	["yia"] = {"Yinggarda"},
	["yif"] = {"Ache"},
	["yig"] = {"Wusa Nasu"},
	["yih"] = {"Western Yiddish"},
	["yii"] = {"Yidiny"},
	["yij"] = {"Yindjibarndi"},
	["yik"] = {"Dongshanba Lalo"},
	["yil"] = {"Yindjilandji"},
	["yim"] = {"Yimchungru Naga"},
	["yin"] = {"Riang Lai", "Yinchia"},
	["yip"] = {"Pholo"},
	["yiq"] = {"Miqie"},
	["yir"] = {"North Awyu"},
	["yis"] = {"Yis"},
	["yit"] = {"Eastern Lalu"},
	["yiu"] = {"Awu"},
	["yiv"] = {"Northern Nisu"},
	["yix"] = {"Axi Yi"},
	["yiz"] = {"Azhe"},
	["yka"] = {"Yakan"},
	["ykg"] = {"Northern Yukaghir"},
	["ykh"] = {"Khamnigan Mongol"},
	["yki"] = {"Yoke"},
	["ykk"] = {"Yakaikeke"},
	["ykl"] = {"Khlula"},
	["ykm"] = {"Kap"},
	["ykn"] = {"Kua-nsi"},
	["yko"] = {"Yasa"},
	["ykr"] = {"Yekora"},
	["ykt"] = {"Kathu"},
	["yku"] = {"Kuamasi"},
	["yky"] = {"Yakoma"},
	["yla"] = {"Yaul"},
	["ylb"] = {"Yaleba"},
	["yle"] = {"Yele"},
	["ylg"] = {"Yelogu"},
	["yli"] = {"Angguruk Yali"},
	["yll"] = {"Yil"},
	["ylm"] = {"Limi"},
	["yln"] = {"Langnian Buyang"},
	["ylo"] = {"Naluo Yi"},
	["ylr"] = {"Yalarnnga"},
	["ylu"] = {"Aribwaung"},
	["yly"] = {"Nyâlayu", "Nyelâyu"},
	["ymb"] = {"Yambes"},
	["ymc"] = {"Southern Muji"},
	["ymd"] = {"Muda"},
	["yme"] = {"Yameo"},
	["ymg"] = {"Yamongeri"},
	["ymh"] = {"Mili"},
	["ymi"] = {"Moji"},
	["ymk"] = {"Makwe"},
	["yml"] = {"Iamalele"},
	["ymm"] = {"Maay"},
	["ymn"] = {"Yamna", "Sunum"},
	["ymo"] = {"Yangum Mon"},
	["ymp"] = {"Yamap"},
	["ymq"] = {"Qila Muji"},
	["ymr"] = {"Malasar"},
	["yms"] = {"Mysian"},
	["ymx"] = {"Northern Muji"},
	["ymz"] = {"Muzi"},
	["yna"] = {"Aluo"},
	["ynb"] = {"Yamben"},
	["ynd"] = {"Yandruwandha"},
	["yne"] = {"Lang'e"},
	["yng"] = {"Yango"},
	["ynk"] = {"Naukan Yupik"},
	["ynl"] = {"Yangulam"},
	["ynn"] = {"Yana"},
	["yno"] = {"Yong"},
	["ynq"] = {"Yendang"},
	["yns"] = {"Yansi"},
	["ynu"] = {"Yahuna"},
	["yob"] = {"Yoba"},
	["yog"] = {"Yogad"},
	["yoi"] = {"Yonaguni"},
	["yok"] = {"Yokuts"},
	["yol"] = {"Yola"},
	["yom"] = {"Yombe"},
	["yon"] = {"Yongkom"},
	["yot"] = {"Yotti"},
	["yox"] = {"Yoron"},
	["yoy"] = {"Yoy"},
	["ypa"] = {"Phala"},
	["ypb"] = {"Labo Phowa"},
	["ypg"] = {"Phola"},
	["yph"] = {"Phupha"},
	["ypk"] = {"Yupik languages"},
	["ypm"] = {"Phuma"},
	["ypn"] = {"Ani Phowa"},
	["ypo"] = {"Alo Phola"},
	["ypp"] = {"Phupa"},
	["ypz"] = {"Phuza"},
	["yra"] = {"Yerakai"},
	["yrb"] = {"Yareba"},
	["yre"] = {"Yaouré"},
	["yrk"] = {"Nenets"},
	["yrl"] = {"Nhengatu"},
	["yrm"] = {"Yirrk-Mel"},
	["yrn"] = {"Yerong"},
	["yro"] = {"Yaroamë"},
	["yrs"] = {"Yarsun"},
	["yrw"] = {"Yarawata"},
	["yry"] = {"Yarluyandi"},
	["ysc"] = {"Yassic"},
	["ysd"] = {"Samatao"},
	["ysg"] = {"Sonaga"},
	["ysl"] = {"Yugoslavian Sign Language"},
	["ysm"] = {"Myanmar Sign Language"},
	["ysn"] = {"Sani"},
	["yso"] = {"Nisi (China)"},
	["ysp"] = {"Southern Lolopo"},
	["ysr"] = {"Sirenik Yupik"},
	["yss"] = {"Yessan-Mayo"},
	["ysy"] = {"Sanie"},
	["yta"] = {"Talu"},
	["ytl"] = {"Tanglang"},
	["ytp"] = {"Thopho"},
	["ytw"] = {"Yout Wam"},
	["yty"] = {"Yatay"},
	["yua"] = {"Yucateco", "Yucatec Maya"},
	["yub"] = {"Yugambal"},
	["yuc"] = {"Yuchi"},
	["yud"] = {"Judeo-Tripolitanian Arabic"},
	["yue"] = {"Yue Chinese", "Cantonese"},
	["yuf"] = {"Havasupai-Walapai-Yavapai"},
	["yug"] = {"Yug"},
	["yui"] = {"Yurutí"},
	["yuj"] = {"Karkar-Yuri"},
	["yuk"] = {"Yuki"},
	["yul"] = {"Yulu"},
	["yum"] = {"Quechan"},
	["yun"] = {"Bena (Nigeria)"},
	["yup"] = {"Yukpa"},
	["yuq"] = {"Yuqui"},
	["yur"] = {"Yurok"},
	["yut"] = {"Yopno"},
	["yuw"] = {"Yau (Morobe Province)"},
	["yux"] = {"Southern Yukaghir"},
	["yuy"] = {"East Yugur"},
	["yuz"] = {"Yuracare"},
	["yva"] = {"Yawa"},
	["yvt"] = {"Yavitero"},
	["ywa"] = {"Kalou"},
	["ywg"] = {"Yinhawangka"},
	["ywl"] = {"Western Lalu"},
	["ywn"] = {"Yawanawa"},
	["ywq"] = {"Wuding-Luquan Yi"},
	["ywr"] = {"Yawuru"},
	["ywt"] = {"Xishanba Lalo", "Central Lalo"},
	["ywu"] = {"Wumeng Nasu"},
	["yww"] = {"Yawarawarga"},
	["yxa"] = {"Mayawali"},
	["yxg"] = {"Yagara"},
	["yxl"] = {"Yardliyawarra"},
	["yxm"] = {"Yinwum"},
	["yxu"] = {"Yuyu"},
	["yxy"] = {"Yabula Yabula"},
	["yyr"] = {"Yir Yoront"},
	["yyu"] = {"Yau (Sandaun Province)"},
	["yyz"] = {"Ayizi"},
	["yzg"] = {"E'ma Buyang"},
	["yzk"] = {"Zokhuo"},
	["zaa"] = {"Sierra de Juárez Zapotec"},
	["zab"] = {"Western Tlacolula Valley Zapotec", "San Juan Guelavía Zapotec"},
	["zac"] = {"Ocotlán Zapotec"},
	["zad"] = {"Cajonos Zapotec"},
	["zae"] = {"Yareni Zapotec"},
	["zaf"] = {"Ayoquesco Zapotec"},
	["zag"] = {"Zaghawa"},
	["zah"] = {"Zangwal"},
	["zai"] = {"Isthmus Zapotec"},
	["zaj"] = {"Zaramo"},
	["zak"] = {"Zanaki"},
	["zal"] = {"Zauzou"},
	["zam"] = {"Miahuatlán Zapotec"},
	["zao"] = {"Ozolotepec Zapotec"},
	["zap"] = {"Zapotec"},
	["zaq"] = {"Aloápam Zapotec"},
	["zar"] = {"Rincón Zapotec"},
	["zas"] = {"Santo Domingo Albarradas Zapotec"},
	["zat"] = {"Tabaa Zapotec"},
	["zau"] = {"Zangskari"},
	["zav"] = {"Yatzachi Zapotec"},
	["zaw"] = {"Mitla Zapotec"},
	["zax"] = {"Xadani Zapotec"},
	["zay"] = {"Zayse-Zergulla", "Zaysete"},
	["zaz"] = {"Zari"},
	["zba"] = {"Balaibalan"},
	["zbc"] = {"Central Berawan"},
	["zbe"] = {"East Berawan"},
	["zbl"] = {"Blissymbols", "Bliss", "Blissymbolics"},
	["zbt"] = {"Batui"},
	["zbu"] = {"Bu (Bauchi State)"},
	["zbw"] = {"West Berawan"},
	["zca"] = {"Coatecas Altas Zapotec"},
	["zcd"] = {"Las Delicias Zapotec"},
	["zch"] = {"Central Hongshuihe Zhuang"},
	["zdj"] = {"Ngazidja Comorian"},
	["zea"] = {"Zeeuws"},
	["zeg"] = {"Zenag"},
	["zeh"] = {"Eastern Hongshuihe Zhuang"},
	["zem"] = {"Zeem"},
	["zen"] = {"Zenaga"},
	["zga"] = {"Kinga"},
	["zgb"] = {"Guibei Zhuang"},
	["zgh"] = {"Standard Moroccan Tamazight"},
	["zgm"] = {"Minz Zhuang"},
	["zgn"] = {"Guibian Zhuang"},
	["zgr"] = {"Magori"},
	["zhb"] = {"Zhaba"},
	["zhd"] = {"Dai Zhuang"},
	["zhi"] = {"Zhire"},
	["zhn"] = {"Nong Zhuang"},
	["zhw"] = {"Zhoa"},
	["zhx"] = {"Chinese (family)"},
	["zia"] = {"Zia"},
	["zib"] = {"Zimbabwe Sign Language"},
	["zik"] = {"Zimakani"},
	["zil"] = {"Zialo"},
	["zim"] = {"Mesme"},
	["zin"] = {"Zinza"},
	["ziw"] = {"Zigula"},
	["ziz"] = {"Zizilivakan"},
	["zka"] = {"Kaimbulawa"},
	["zkd"] = {"Kadu"},
	["zkg"] = {"Koguryo"},
	["zkh"] = {"Khorezmian"},
	["zkk"] = {"Karankawa"},
	["zkn"] = {"Kanan"},
	["zko"] = {"Kott"},
	["zkp"] = {"São Paulo Kaingáng"},
	["zkr"] = {"Zakhring"},
	["zkt"] = {"Kitan"},
	["zku"] = {"Kaurna"},
	["zkv"] = {"Krevinian"},
	["zkz"] = {"Khazar"},
	["zla"] = {"Zula"},
	["zle"] = {"East Slavic languages"},
	["zlj"] = {"Liujiang Zhuang"},
	["zlm"] = {"Malay (individual language)"},
	["zln"] = {"Lianshan Zhuang"},
	["zlq"] = {"Liuqian Zhuang"},
	["zls"] = {"South Slavic languages"},
	["zlu"] = {"Zul"},
	["zlw"] = {"West Slavic languages"},
	["zma"] = {"Manda (Australia)"},
	["zmb"] = {"Zimba"},
	["zmc"] = {"Margany"},
	["zmd"] = {"Maridan"},
	["zme"] = {"Mangerr"},
	["zmf"] = {"Mfinu"},
	["zmg"] = {"Marti Ke"},
	["zmh"] = {"Makolkol"},
	["zmi"] = {"Negeri Sembilan Malay"},
	["zmj"] = {"Maridjabin"},
	["zmk"] = {"Mandandanyi"},
	["zml"] = {"Matngala"},
	["zmm"] = {"Marimanindji", "Marramaninyshi"},
	["zmn"] = {"Mbangwe"},
	["zmo"] = {"Molo"},
	["zmp"] = {"Mpuono"},
	["zmq"] = {"Mituku"},
	["zmr"] = {"Maranunggu"},
	["zms"] = {"Mbesa"},
	["zmt"] = {"Maringarr"},
	["zmu"] = {"Muruwari"},
	["zmv"] = {"Mbariman-Gudhinma"},
	["zmw"] = {"Mbo (Democratic Republic of Congo)"},
	["zmx"] = {"Bomitaba"},
	["zmy"] = {"Mariyedi"},
	["zmz"] = {"Mbandja"},
	["zna"] = {"Zan Gula"},
	["znd"] = {"Zande languages"},
	["zne"] = {"Zande (individual language)"},
	["zng"] = {"Mang"},
	["znk"] = {"Manangkari"},
	["zns"] = {"Mangas"},
	["zoc"] = {"Copainalá Zoque"},
	["zoh"] = {"Chimalapa Zoque"},
	["zom"] = {"Zou"},
	["zoo"] = {"Asunción Mixtepec Zapotec"},
	["zoq"] = {"Tabasco Zoque"},
	["zor"] = {"Rayón Zoque"},
	["zos"] = {"Francisco León Zoque"},
	["zpa"] = {"Lachiguiri Zapotec"},
	["zpb"] = {"Yautepec Zapotec"},
	["zpc"] = {"Choapan Zapotec"},
	["zpd"] = {"Southeastern Ixtlán Zapotec"},
	["zpe"] = {"Petapa Zapotec"},
	["zpf"] = {"San Pedro Quiatoni Zapotec"},
	["zpg"] = {"Guevea De Humboldt Zapotec"},
	["zph"] = {"Totomachapan Zapotec"},
	["zpi"] = {"Santa María Quiegolani Zapotec"},
	["zpj"] = {"Quiavicuzas Zapotec"},
	["zpk"] = {"Tlacolulita Zapotec"},
	["zpl"] = {"Lachixío Zapotec"},
	["zpm"] = {"Mixtepec Zapotec"},
	["zpn"] = {"Santa Inés Yatzechi Zapotec"},
	["zpo"] = {"Amatlán Zapotec"},
	["zpp"] = {"El Alto Zapotec"},
	["zpq"] = {"Zoogocho Zapotec"},
	["zpr"] = {"Santiago Xanica Zapotec"},
	["zps"] = {"Coatlán Zapotec"},
	["zpt"] = {"San Vicente Coatlán Zapotec"},
	["zpu"] = {"Yalálag Zapotec"},
	["zpv"] = {"Chichicapan Zapotec"},
	["zpw"] = {"Zaniza Zapotec"},
	["zpx"] = {"San Baltazar Loxicha Zapotec"},
	["zpy"] = {"Mazaltepec Zapotec"},
	["zpz"] = {"Texmelucan Zapotec"},
	["zqe"] = {"Qiubei Zhuang"},
	["zra"] = {"Kara (Korea)"},
	["zrg"] = {"Mirgan"},
	["zrn"] = {"Zerenkel"},
	["zro"] = {"Záparo"},
	["zrp"] = {"Zarphatic"},
	["zrs"] = {"Mairasi"},
	["zsa"] = {"Sarasira"},
	["zsk"] = {"Kaskean"},
	["zsl"] = {"Zambian Sign Language"},
	["zsm"] = {"Standard Malay"},
	["zsr"] = {"Southern Rincon Zapotec"},
	["zsu"] = {"Sukurum"},
	["zte"] = {"Elotepec Zapotec"},
	["ztg"] = {"Xanaguía Zapotec"},
	["ztl"] = {"Lapaguía-Guivini Zapotec"},
	["ztm"] = {"San Agustín Mixtepec Zapotec"},
	["ztn"] = {"Santa Catarina Albarradas Zapotec"},
	["ztp"] = {"Loxicha Zapotec"},
	["ztq"] = {"Quioquitani-Quierí Zapotec"},
	["zts"] = {"Tilquiapan Zapotec"},
	["ztt"] = {"Tejalapan Zapotec"},
	["ztu"] = {"Güilá Zapotec"},
	["ztx"] = {"Zaachila Zapotec"},
	["zty"] = {"Yatee Zapotec"},
	["zuh"] = {"Tokano"},
	["zum"] = {"Kumzari"},
	["zun"] = {"Zuni"},
	["zuy"] = {"Zumaya"},
	["zwa"] = {"Zay"},
	["zxx"] = {"No linguistic content", "Not applicable"},
	["zyb"] = {"Yongbei Zhuang"},
	["zyg"] = {"Yang Zhuang"},
	["zyj"] = {"Youjiang Zhuang"},
	["zyn"] = {"Yongnan Zhuang"},
	["zyp"] = {"Zyphe Chin"},
	["zza"] = {"Zaza", "Dimili", "Dimli (macrolanguage)", "Kirdki", "Kirmanjki (macrolanguage)", "Zazaki"},
	["zzj"] = {"Zuojiang Zhuang"}
	}

local deprecated = {
	["in"] = {"Indonesian"},
	["iw"] = {"Hebrew"},
	["ji"] = {"Yiddish"},
	["jw"] = {"Javanese"},
	["mo"] = {"Moldavian", "Moldovan"},
	["aam"] = {"Aramanik"},
	["adp"] = {"Adap"},
	["agp"] = {"Paranan"},
	["ais"] = {"Nataoran Amis"},
	["ajp"] = {"South Levantine Arabic"},
	["ajt"] = {"Judeo-Tunisian Arabic"},
	["aoh"] = {"Arma"},
	["asd"] = {"Asas"},
	["aue"] = {"ǂKxʼauǁʼein"},
	["ayx"] = {"Ayi (China)"},
	["ayy"] = {"Tayabas Ayta"},
	["baz"] = {"Tunen"},
	["bbz"] = {"Babalia Creole Arabic"},
	["bgm"] = {"Baga Mboteni"},
	["bhk"] = {"Albay Bicolano"},
	["bic"] = {"Bikaru"},
	["bij"] = {"Vaghat-Ya-Bijim-Legeri"},
	["bjd"] = {"Bandjigali"},
	["bjq"] = {"Southern Betsimisaraka Malagasy"},
	["bkb"] = {"Finallig"},
	["blg"] = {"Balau"},
	["bmy"] = {"Bemba (Democratic Republic of Congo)"},
	["bpb"] = {"Barbacoas"},
	["btb"] = {"Beti (Cameroon)"},
	["btl"] = {"Bhatola"},
	["bxx"] = {"Borna (Democratic Republic of Congo)"},
	["byy"] = {"Buya"},
	["cbe"] = {"Chipiajes"},
	["cbh"] = {"Cagua"},
	["cca"] = {"Cauca"},
	["ccq"] = {"Chaungtha"},
	["cdg"] = {"Chamari"},
	["cjr"] = {"Chorotega"},
	["cka"] = {"Khumi Awa Chin"},
	["cmk"] = {"Chimakum"},
	["coy"] = {"Coyaima"},
	["cqu"] = {"Chilean Quechua"},
	["cug"] = {"Chungmboko", "Cung"},
	["cum"] = {"Cumeral"},
	["daf"] = {"Dan"},
	["dap"] = {"Nisi (India)"},
	["dek"] = {"Dek"},
	["dgu"] = {"Degaru"},
	["dha"] = {"Dhanwar (India)"},
	["dit"] = {"Dirari"},
	["djl"] = {"Djiwarli"},
	["dkl"] = {"Kolum So Dogon"},
	["drh"] = {"Darkhat"},
	["drr"] = {"Dororo"},
	["drw"] = {"Darwazi"},
	["dud"] = {"Hun-Saare"},
	["duj"] = {"Dhuwal"},
	["dwl"] = {"Walo Kumbe Dogon"},
	["ekc"] = {"Eastern Karnic"},
	["elp"] = {"Elpaputih"},
	["emo"] = {"Emok"},
	["gav"] = {"Gabutamon"},
	["gbc"] = {"Garawa"},
	["gfx"] = {"Mangetti Dune ǃXung"},
	["ggn"] = {"Eastern Gurung"},
	["ggo"] = {"Southern Gondi"},
	["ggr"] = {"Aghu Tharnggalu"},
	["gio"] = {"Gelao"},
	["gji"] = {"Geji"},
	["gli"] = {"Guliguli"},
	["gti"] = {"Gbati-ri"},
	["guv"] = {"Gey"},
	["hrr"] = {"Horuru"},
	["iap"] = {"Iapama"},
	["ibi"] = {"Ibilo"},
	["ill"] = {"Iranun"},
	["ilw"] = {"Talur"},
	["ime"] = {"Imeraguen"},
	["izi"] = {"Izi-Ezaa-Ikwo-Mgbo"},
	["jar"] = {"Jarawa (Nigeria)"},
	["jeg"] = {"Jeng"},
	["kbf"] = {"Kakauhua"},
	["kdv"] = {"Kado"},
	["kgc"] = {"Kasseng"},
	["kgd"] = {"Kataang"},
	["kgh"] = {"Upper Tanudan Kalinga"},
	["kgm"] = {"Karipúna"},
	["kjf"] = {"Khalaj [Indo-Iranian]"},
	["koj"] = {"Sara Dunjo"},
	["kox"] = {"Coxima"},
	["kpp"] = {"Paku Karen"},
	["krm"] = {"Krim"},
	["ksa"] = {"Shuwa-Zamani"},
	["ktr"] = {"Kota Marudu Tinagas"},
	["kvs"] = {"Kunggara"},
	["kwq"] = {"Kwak"},
	["kxe"] = {"Kakihum"},
	["kxl"] = {"Nepali Kurux"},
	["kxu"] = {"Kui (India)"},
	["kzh"] = {"Kenuzi-Dongola"},
	["kzj"] = {"Coastal Kadazan"},
	["kzt"] = {"Tambunan Dusun"},
	["lak"] = {"Laka (Nigeria)"},
	["lba"] = {"Lui"},
	["leg"] = {"Lengua"},
	["lii"] = {"Lingkhim"},
	["llo"] = {"Khlor"},
	["lmm"] = {"Lamam"},
	["lmz"] = {"Lumbee"},
	["lno"] = {"Lango (South Sudan)"},
	["lsg"] = {"Lyons Sign Language"},
	["meg"] = {"Mea"},
	["mgx"] = {"Omati"},
	["mhh"] = {"Maskoy Pidgin"},
	["mja"] = {"Mahei"},
	["mld"] = {"Malakhel"},
	["mnt"] = {"Maykulan"},
	["mof"] = {"Mohegan-Montauk-Narragansett"},
	["mst"] = {"Cataelano Mandaya"},
	["mvm"] = {"Muya"},
	["mwd"] = {"Mudbura"},
	["mwj"] = {"Maligo"},
	["mwx"] = {"Mediak"},
	["mwy"] = {"Mosiro"},
	["myd"] = {"Maramba"},
	["myi"] = {"Mina (India)"},
	["myq"] = {"Forest Maninka"},
	["myt"] = {"Sangab Mandaya"},
	["nad"] = {"Nijadali"},
	["nbf"] = {"Naxi"},
	["nbx"] = {"Ngura"},
	["ncp"] = {"Ndaktup"},
	["ngo"] = {"Ngoni"},
	["nln"] = {"Durango Nahuatl"},
	["nlr"] = {"Ngarla"},
	["nns"] = {"Ningye"},
	["nnx"] = {"Ngong"},
	["nom"] = {"Nocamán"},
	["noo"] = {"Nootka"},
	["nte"] = {"Nathembo"},
	["nts"] = {"Natagaimas"},
	["nxu"] = {"Narau"},
	["ome"] = {"Omejes"},
	["oun"] = {"ǃOǃung"},
	["pat"] = {"Papitalai"},
	["pbz"] = {"Palu"},
	["pcr"] = {"Panang"},
	["pgy"] = {"Pongyong"},
	["pii"] = {"Pini"},
	["plj"] = {"Polci"},
	["plp"] = {"Palpa"},
	["pmc"] = {"Palumata"},
	["pmk"] = {"Pamlico"},
	["pmu"] = {"Mirpur Panjabi"},
	["pod"] = {"Ponares"},
	["ppa"] = {"Pao"},
	["ppr"] = {"Piru"},
	["prb"] = {"Lua'"},
	["prp"] = {"Parsi"},
	["pry"] = {"Pray 3"},
	["puk"] = {"Pu Ko"},
	["puz"] = {"Purum Naga"},
	["rie"] = {"Rien"},
	["rmr"] = {"Caló"},
	["rna"] = {"Runa"},
	["rsi"] = {"Rennellese Sign Language"},
	["sap"] = {"Sanapaná"},
	["sca"] = {"Sansu"},
	["sdm"] = {"Semandang"},
	["sgl"] = {"Sanglechi-Ishkashimi"},
	["sgo"] = {"Songa"},
	["skk"] = {"Sok"},
	["slq"] = {"Salchuq"},
	["smd"] = {"Sama"},
	["snb"] = {"Sebuyau"},
	["snh"] = {"Shinabo"},
	["sul"] = {"Surigaonon"},
	["sum"] = {"Sumo-Mayangna"},
	["svr"] = {"Savara"},
	["szd"] = {"Seru"},
	["tbb"] = {"Tapeba"},
	["tdu"] = {"Tempasuk Dusun"},
	["tgg"] = {"Tangga"},
	["thc"] = {"Tai Hang Tong"},
	["thw"] = {"Thudam"},
	["thx"] = {"The"},
	["tid"] = {"Tidong"},
	["tie"] = {"Tingal"},
	["tkk"] = {"Takpa"},
	["tlw"] = {"South Wemale"},
	["tmk"] = {"Northwestern Tamang"},
	["tmp"] = {"Tai Mène"},
	["tne"] = {"Tinoc Kallahan"},
	["tnf"] = {"Tangshewi"},
	["toe"] = {"Tomedes"},
	["tpw"] = {"Tupí"},
	["tsf"] = {"Southwestern Tamang"},
	["unp"] = {"Worora"},
	["uok"] = {"Uokha"},
	["uun"] = {"Kulon-Pazeh"},
	["vki"] = {"Ija-Zuba"},
	["wgw"] = {"Wagawaga"},
	["wit"] = {"Wintu"},
	["wiw"] = {"Wirangu"},
	["wra"] = {"Warapu"},
	["wrd"] = {"Warduji"},
	["wya"] = {"Wyandot"},
	["xba"] = {"Kamba (Brazil)"},
	["xbx"] = {"Kabixí"},
	["xia"] = {"Xiandao"},
	["xip"] = {"Xipináwa"},
	["xkh"] = {"Karahawyana"},
	["xrq"] = {"Karranga"},
	["xss"] = {"Assan"},
	["xtz"] = {"Tasmanian"},
	["ybd"] = {"Yangbye"},
	["yds"] = {"Yiddish Sign Language"},
	["yen"] = {"Yendang"},
	["yiy"] = {"Yir Yoront"},
	["yma"] = {"Yamphe"},
	["ymt"] = {"Mator-Taygi-Karagas"},
	["ynh"] = {"Yangho"},
	["yos"] = {"Yos"},
	["yri"] = {"Yarí"},
	["yuu"] = {"Yugh"},
	["zir"] = {"Ziriya"},
	["zkb"] = {"Koibal"},
	["zua"] = {"Zeem"}
	}

return {
	active = active,
	deprecated = deprecated,
	}</text>
      <sha1>a37a7qn7q3pp5b1ubqv5ajmr80durdr</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/data/iana scripts</title>
    <ns>828</ns>
    <id>229</id>
    <revision>
      <id>446</id>
      <parentid>445</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>445</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7512" sha1="baei359k08wd4y1c873jadr1pmnznyi" xml:space="preserve">-- File-Date: 2025-05-15
return {
	["Adlm"] = {"Adlam"},
	["Afak"] = {"Afaka"},
	["Aghb"] = {"Caucasian Albanian"},
	["Ahom"] = {"Ahom", "Tai Ahom"},
	["Arab"] = {"Arabic"},
	["Aran"] = {"Arabic (Nastaliq variant)"},
	["Armi"] = {"Imperial Aramaic"},
	["Armn"] = {"Armenian"},
	["Avst"] = {"Avestan"},
	["Bali"] = {"Balinese"},
	["Bamu"] = {"Bamum"},
	["Bass"] = {"Bassa Vah"},
	["Batk"] = {"Batak"},
	["Beng"] = {"Bengali", "Bangla"},
	["Berf"] = {"Beria Erfe"},
	["Bhks"] = {"Bhaiksuki"},
	["Blis"] = {"Blissymbols"},
	["Bopo"] = {"Bopomofo"},
	["Brah"] = {"Brahmi"},
	["Brai"] = {"Braille"},
	["Bugi"] = {"Buginese"},
	["Buhd"] = {"Buhid"},
	["Cakm"] = {"Chakma"},
	["Cans"] = {"Unified Canadian Aboriginal Syllabics"},
	["Cari"] = {"Carian"},
	["Cham"] = {"Cham"},
	["Cher"] = {"Cherokee"},
	["Chis"] = {"Chisoi"},
	["Chrs"] = {"Chorasmian"},
	["Cirt"] = {"Cirth"},
	["Copt"] = {"Coptic"},
	["Cpmn"] = {"Cypro-Minoan"},
	["Cprt"] = {"Cypriot syllabary"},
	["Cyrl"] = {"Cyrillic"},
	["Cyrs"] = {"Cyrillic (Old Church Slavonic variant)"},
	["Deva"] = {"Devanagari", "Nagari"},
	["Diak"] = {"Dives Akuru"},
	["Dogr"] = {"Dogra"},
	["Dsrt"] = {"Deseret", "Mormon"},
	["Dupl"] = {"Duployan shorthand", "Duployan stenography"},
	["Egyd"] = {"Egyptian demotic"},
	["Egyh"] = {"Egyptian hieratic"},
	["Egyp"] = {"Egyptian hieroglyphs"},
	["Elba"] = {"Elbasan"},
	["Elym"] = {"Elymaic"},
	["Ethi"] = {"Ethiopic", "Geʻez", "Ge'ez"},
	["Gara"] = {"Garay"},
	["Geok"] = {"Khutsuri (Asomtavruli and Nuskhuri)"},
	["Geor"] = {"Georgian (Mkhedruli and Mtavruli)"},
	["Glag"] = {"Glagolitic"},
	["Gong"] = {"Gunjala Gondi"},
	["Gonm"] = {"Masaram Gondi"},
	["Goth"] = {"Gothic"},
	["Gran"] = {"Grantha"},
	["Grek"] = {"Greek"},
	["Gujr"] = {"Gujarati"},
	["Gukh"] = {"Gurung Khema"},
	["Guru"] = {"Gurmukhi"},
	["Hanb"] = {"Han with Bopomofo (alias for Han + Bopomofo)"},
	["Hang"] = {"Hangul", "Hangŭl", "Hangeul"},
	["Hani"] = {"Han", "Hanzi", "Kanji", "Hanja"},
	["Hano"] = {"Hanunoo", "Hanunóo"},
	["Hans"] = {"Han (Simplified variant)"},
	["Hant"] = {"Han (Traditional variant)"},
	["Hatr"] = {"Hatran"},
	["Hebr"] = {"Hebrew"},
	["Hira"] = {"Hiragana"},
	["Hluw"] = {"Anatolian Hieroglyphs", "Luwian Hieroglyphs", "Hittite Hieroglyphs"},
	["Hmng"] = {"Pahawh Hmong"},
	["Hmnp"] = {"Nyiakeng Puachue Hmong"},
	["Hntl"] = {"Han (Traditional variant) with Latin (alias for Hant + Latn)"},
	["Hrkt"] = {"Japanese syllabaries (alias for Hiragana + Katakana)"},
	["Hung"] = {"Old Hungarian", "Hungarian Runic"},
	["Inds"] = {"Indus", "Harappan"},
	["Ital"] = {"Old Italic (Etruscan, Oscan, etc.)"},
	["Jamo"] = {"Jamo (alias for Jamo subset of Hangul)"},
	["Java"] = {"Javanese"},
	["Jpan"] = {"Japanese (alias for Han + Hiragana + Katakana)"},
	["Jurc"] = {"Jurchen"},
	["Kali"] = {"Kayah Li"},
	["Kana"] = {"Katakana"},
	["Kawi"] = {"Kawi"},
	["Khar"] = {"Kharoshthi"},
	["Khmr"] = {"Khmer"},
	["Khoj"] = {"Khojki"},
	["Kitl"] = {"Khitan large script"},
	["Kits"] = {"Khitan small script"},
	["Knda"] = {"Kannada"},
	["Kore"] = {"Korean (alias for Hangul + Han)"},
	["Kpel"] = {"Kpelle"},
	["Krai"] = {"Kirat Rai"},
	["Kthi"] = {"Kaithi"},
	["Lana"] = {"Tai Tham", "Lanna"},
	["Laoo"] = {"Lao"},
	["Latf"] = {"Latin (Fraktur variant)"},
	["Latg"] = {"Latin (Gaelic variant)"},
	["Latn"] = {"Latin"},
	["Leke"] = {"Leke"},
	["Lepc"] = {"Lepcha", "Róng"},
	["Limb"] = {"Limbu"},
	["Lina"] = {"Linear A"},
	["Linb"] = {"Linear B"},
	["Lisu"] = {"Lisu", "Fraser"},
	["Loma"] = {"Loma"},
	["Lyci"] = {"Lycian"},
	["Lydi"] = {"Lydian"},
	["Mahj"] = {"Mahajani"},
	["Maka"] = {"Makasar"},
	["Mand"] = {"Mandaic", "Mandaean"},
	["Mani"] = {"Manichaean"},
	["Marc"] = {"Marchen"},
	["Maya"] = {"Mayan hieroglyphs"},
	["Medf"] = {"Medefaidrin", "Oberi Okaime", "Oberi Ɔkaimɛ"},
	["Mend"] = {"Mende Kikakui"},
	["Merc"] = {"Meroitic Cursive"},
	["Mero"] = {"Meroitic Hieroglyphs"},
	["Mlym"] = {"Malayalam"},
	["Modi"] = {"Modi", "Moḍī"},
	["Mong"] = {"Mongolian"},
	["Moon"] = {"Moon", "Moon code", "Moon script", "Moon type"},
	["Mroo"] = {"Mro", "Mru"},
	["Mtei"] = {"Meitei Mayek", "Meithei", "Meetei"},
	["Mult"] = {"Multani"},
	["Mymr"] = {"Myanmar", "Burmese"},
	["Nagm"] = {"Nag Mundari"},
	["Nand"] = {"Nandinagari"},
	["Narb"] = {"Old North Arabian", "Ancient North Arabian"},
	["Nbat"] = {"Nabataean"},
	["Newa"] = {"Newa", "Newar", "Newari", "Nepāla lipi"},
	["Nkdb"] = {"Naxi Dongba", "na²¹ɕi³³ to³³ba²¹", "Nakhi Tomba"},
	["Nkgb"] = {"Naxi Geba", "na²¹ɕi³³ gʌ²¹ba²¹", "'Na-'Khi ²Ggŏ-¹baw", "Nakhi Geba"},
	["Nkoo"] = {"N’Ko", "N'Ko"},
	["Nshu"] = {"Nüshu"},
	["Ogam"] = {"Ogham"},
	["Olck"] = {"Ol Chiki", "Ol Cemet'", "Ol", "Santali"},
	["Onao"] = {"Ol Onal"},
	["Orkh"] = {"Old Turkic", "Orkhon Runic"},
	["Orya"] = {"Oriya", "Odia"},
	["Osge"] = {"Osage"},
	["Osma"] = {"Osmanya"},
	["Ougr"] = {"Old Uyghur"},
	["Palm"] = {"Palmyrene"},
	["Pauc"] = {"Pau Cin Hau"},
	["Pcun"] = {"Proto-Cuneiform"},
	["Pelm"] = {"Proto-Elamite"},
	["Perm"] = {"Old Permic"},
	["Phag"] = {"Phags-pa"},
	["Phli"] = {"Inscriptional Pahlavi"},
	["Phlp"] = {"Psalter Pahlavi"},
	["Phlv"] = {"Book Pahlavi"},
	["Phnx"] = {"Phoenician"},
	["Piqd"] = {"Klingon (KLI pIqaD)"},
	["Plrd"] = {"Miao", "Pollard"},
	["Prti"] = {"Inscriptional Parthian"},
	["Psin"] = {"Proto-Sinaitic"},
	["Ranj"] = {"Ranjana"},
	["Rjng"] = {"Rejang", "Redjang", "Kaganga"},
	["Rohg"] = {"Hanifi Rohingya"},
	["Roro"] = {"Rongorongo"},
	["Runr"] = {"Runic"},
	["Samr"] = {"Samaritan"},
	["Sara"] = {"Sarati"},
	["Sarb"] = {"Old South Arabian"},
	["Saur"] = {"Saurashtra"},
	["Seal"] = {"Seal", "Small Seal"},
	["Sgnw"] = {"SignWriting"},
	["Shaw"] = {"Shavian", "Shaw"},
	["Shrd"] = {"Sharada", "Śāradā"},
	["Shui"] = {"Shuishu"},
	["Sidd"] = {"Siddham", "Siddhaṃ", "Siddhamātṛkā"},
	["Sidt"] = {"Sidetic"},
	["Sind"] = {"Khudawadi", "Sindhi"},
	["Sinh"] = {"Sinhala"},
	["Sogd"] = {"Sogdian"},
	["Sogo"] = {"Old Sogdian"},
	["Sora"] = {"Sora Sompeng"},
	["Soyo"] = {"Soyombo"},
	["Sund"] = {"Sundanese"},
	["Sunu"] = {"Sunuwar"},
	["Sylo"] = {"Syloti Nagri"},
	["Syrc"] = {"Syriac"},
	["Syre"] = {"Syriac (Estrangelo variant)"},
	["Syrj"] = {"Syriac (Western variant)"},
	["Syrn"] = {"Syriac (Eastern variant)"},
	["Tagb"] = {"Tagbanwa"},
	["Takr"] = {"Takri", "Ṭākrī", "Ṭāṅkrī"},
	["Tale"] = {"Tai Le"},
	["Talu"] = {"New Tai Lue"},
	["Taml"] = {"Tamil"},
	["Tang"] = {"Tangut"},
	["Tavt"] = {"Tai Viet"},
	["Tayo"] = {"Tai Yo"},
	["Telu"] = {"Telugu"},
	["Teng"] = {"Tengwar"},
	["Tfng"] = {"Tifinagh", "Berber"},
	["Tglg"] = {"Tagalog", "Baybayin", "Alibata"},
	["Thaa"] = {"Thaana"},
	["Thai"] = {"Thai"},
	["Tibt"] = {"Tibetan"},
	["Tirh"] = {"Tirhuta"},
	["Tnsa"] = {"Tangsa"},
	["Todr"] = {"Todhri"},
	["Tols"] = {"Tolong Siki"},
	["Toto"] = {"Toto"},
	["Tutg"] = {"Tulu-Tigalari"},
	["Ugar"] = {"Ugaritic"},
	["Vaii"] = {"Vai"},
	["Visp"] = {"Visible Speech"},
	["Vith"] = {"Vithkuqi"},
	["Wara"] = {"Warang Citi", "Varang Kshiti"},
	["Wcho"] = {"Wancho"},
	["Wole"] = {"Woleai"},
	["Xpeo"] = {"Old Persian"},
	["Xsux"] = {"Sumero-Akkadian cuneiform"},
	["Yezi"] = {"Yezidi"},
	["Yiii"] = {"Yi"},
	["Zanb"] = {"Zanabazar Square", "Zanabazarin Dörböljin Useg", "Xewtee Dörböljin Bicig", "Horizontal Square Script"},
	["Zinh"] = {"Code for inherited script"},
	["Zmth"] = {"Mathematical notation"},
	["Zsye"] = {"Symbols (Emoji variant)"},
	["Zsym"] = {"Symbols"},
	["Zxxx"] = {"Code for unwritten documents"},
	["Zyyy"] = {"Code for undetermined script"},
	["Zzzz"] = {"Code for uncoded script"}
	}</text>
      <sha1>baei359k08wd4y1c873jadr1pmnznyi</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/data/iana regions</title>
    <ns>828</ns>
    <id>230</id>
    <revision>
      <id>448</id>
      <parentid>447</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>447</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="8031" sha1="okjow5aolabn36s80d14dqtjo8u4ph0" xml:space="preserve">-- File-Date: 2025-05-15
return {
	["AC"] = {"Ascension Island"},
	["AD"] = {"Andorra"},
	["AE"] = {"United Arab Emirates"},
	["AF"] = {"Afghanistan"},
	["AG"] = {"Antigua and Barbuda"},
	["AI"] = {"Anguilla"},
	["AL"] = {"Albania"},
	["AM"] = {"Armenia"},
	["AO"] = {"Angola"},
	["AQ"] = {"Antarctica"},
	["AR"] = {"Argentina"},
	["AS"] = {"American Samoa"},
	["AT"] = {"Austria"},
	["AU"] = {"Australia"},
	["AW"] = {"Aruba"},
	["AX"] = {"Åland Islands"},
	["AZ"] = {"Azerbaijan"},
	["BA"] = {"Bosnia and Herzegovina"},
	["BB"] = {"Barbados"},
	["BD"] = {"Bangladesh"},
	["BE"] = {"Belgium"},
	["BF"] = {"Burkina Faso"},
	["BG"] = {"Bulgaria"},
	["BH"] = {"Bahrain"},
	["BI"] = {"Burundi"},
	["BJ"] = {"Benin"},
	["BL"] = {"Saint Barthélemy"},
	["BM"] = {"Bermuda"},
	["BN"] = {"Brunei Darussalam"},
	["BO"] = {"Bolivia"},
	["BQ"] = {"Bonaire, Sint Eustatius and Saba"},
	["BR"] = {"Brazil"},
	["BS"] = {"Bahamas"},
	["BT"] = {"Bhutan"},
	["BV"] = {"Bouvet Island"},
	["BW"] = {"Botswana"},
	["BY"] = {"Belarus"},
	["BZ"] = {"Belize"},
	["CA"] = {"Canada"},
	["CC"] = {"Cocos (Keeling) Islands"},
	["CD"] = {"The Democratic Republic of the Congo"},
	["CF"] = {"Central African Republic"},
	["CG"] = {"Congo"},
	["CH"] = {"Switzerland"},
	["CI"] = {"Côte d'Ivoire"},
	["CK"] = {"Cook Islands"},
	["CL"] = {"Chile"},
	["CM"] = {"Cameroon"},
	["CN"] = {"China"},
	["CO"] = {"Colombia"},
	["CP"] = {"Clipperton Island"},
	["CQ"] = {"Sark"},
	["CR"] = {"Costa Rica"},
	["CU"] = {"Cuba"},
	["CV"] = {"Cabo Verde", "Cape Verde"},
	["CW"] = {"Curaçao"},
	["CX"] = {"Christmas Island"},
	["CY"] = {"Cyprus"},
	["CZ"] = {"Czechia", "Czech Republic"},
	["DE"] = {"Germany"},
	["DG"] = {"Diego Garcia"},
	["DJ"] = {"Djibouti"},
	["DK"] = {"Denmark"},
	["DM"] = {"Dominica"},
	["DO"] = {"Dominican Republic"},
	["DZ"] = {"Algeria"},
	["EA"] = {"Ceuta, Melilla"},
	["EC"] = {"Ecuador"},
	["EE"] = {"Estonia"},
	["EG"] = {"Egypt"},
	["EH"] = {"Western Sahara"},
	["ER"] = {"Eritrea"},
	["ES"] = {"Spain"},
	["ET"] = {"Ethiopia"},
	["EU"] = {"European Union"},
	["EZ"] = {"Eurozone"},
	["FI"] = {"Finland"},
	["FJ"] = {"Fiji"},
	["FK"] = {"Falkland Islands (Malvinas)"},
	["FM"] = {"Federated States of Micronesia"},
	["FO"] = {"Faroe Islands"},
	["FR"] = {"France"},
	["GA"] = {"Gabon"},
	["GB"] = {"United Kingdom"},
	["GD"] = {"Grenada"},
	["GE"] = {"Georgia"},
	["GF"] = {"French Guiana"},
	["GG"] = {"Guernsey"},
	["GH"] = {"Ghana"},
	["GI"] = {"Gibraltar"},
	["GL"] = {"Greenland"},
	["GM"] = {"Gambia"},
	["GN"] = {"Guinea"},
	["GP"] = {"Guadeloupe"},
	["GQ"] = {"Equatorial Guinea"},
	["GR"] = {"Greece"},
	["GS"] = {"South Georgia and the South Sandwich Islands"},
	["GT"] = {"Guatemala"},
	["GU"] = {"Guam"},
	["GW"] = {"Guinea-Bissau"},
	["GY"] = {"Guyana"},
	["HK"] = {"Hong Kong"},
	["HM"] = {"Heard Island and McDonald Islands"},
	["HN"] = {"Honduras"},
	["HR"] = {"Croatia"},
	["HT"] = {"Haiti"},
	["HU"] = {"Hungary"},
	["IC"] = {"Canary Islands"},
	["ID"] = {"Indonesia"},
	["IE"] = {"Ireland"},
	["IL"] = {"Israel"},
	["IM"] = {"Isle of Man"},
	["IN"] = {"India"},
	["IO"] = {"British Indian Ocean Territory"},
	["IQ"] = {"Iraq"},
	["IR"] = {"Islamic Republic of Iran"},
	["IS"] = {"Iceland"},
	["IT"] = {"Italy"},
	["JE"] = {"Jersey"},
	["JM"] = {"Jamaica"},
	["JO"] = {"Jordan"},
	["JP"] = {"Japan"},
	["KE"] = {"Kenya"},
	["KG"] = {"Kyrgyzstan"},
	["KH"] = {"Cambodia"},
	["KI"] = {"Kiribati"},
	["KM"] = {"Comoros"},
	["KN"] = {"Saint Kitts and Nevis"},
	["KP"] = {"Democratic People's Republic of Korea"},
	["KR"] = {"Republic of Korea"},
	["KW"] = {"Kuwait"},
	["KY"] = {"Cayman Islands"},
	["KZ"] = {"Kazakhstan"},
	["LA"] = {"Lao People's Democratic Republic"},
	["LB"] = {"Lebanon"},
	["LC"] = {"Saint Lucia"},
	["LI"] = {"Liechtenstein"},
	["LK"] = {"Sri Lanka"},
	["LR"] = {"Liberia"},
	["LS"] = {"Lesotho"},
	["LT"] = {"Lithuania"},
	["LU"] = {"Luxembourg"},
	["LV"] = {"Latvia"},
	["LY"] = {"Libya"},
	["MA"] = {"Morocco"},
	["MC"] = {"Monaco"},
	["MD"] = {"Moldova"},
	["ME"] = {"Montenegro"},
	["MF"] = {"Saint Martin (French part)"},
	["MG"] = {"Madagascar"},
	["MH"] = {"Marshall Islands"},
	["MK"] = {"North Macedonia"},
	["ML"] = {"Mali"},
	["MM"] = {"Myanmar"},
	["MN"] = {"Mongolia"},
	["MO"] = {"Macao"},
	["MP"] = {"Northern Mariana Islands"},
	["MQ"] = {"Martinique"},
	["MR"] = {"Mauritania"},
	["MS"] = {"Montserrat"},
	["MT"] = {"Malta"},
	["MU"] = {"Mauritius"},
	["MV"] = {"Maldives"},
	["MW"] = {"Malawi"},
	["MX"] = {"Mexico"},
	["MY"] = {"Malaysia"},
	["MZ"] = {"Mozambique"},
	["NA"] = {"Namibia"},
	["NC"] = {"New Caledonia"},
	["NE"] = {"Niger"},
	["NF"] = {"Norfolk Island"},
	["NG"] = {"Nigeria"},
	["NI"] = {"Nicaragua"},
	["NL"] = {"Netherlands"},
	["NO"] = {"Norway"},
	["NP"] = {"Nepal"},
	["NR"] = {"Nauru"},
	["NU"] = {"Niue"},
	["NZ"] = {"New Zealand"},
	["OM"] = {"Oman"},
	["PA"] = {"Panama"},
	["PE"] = {"Peru"},
	["PF"] = {"French Polynesia"},
	["PG"] = {"Papua New Guinea"},
	["PH"] = {"Philippines"},
	["PK"] = {"Pakistan"},
	["PL"] = {"Poland"},
	["PM"] = {"Saint Pierre and Miquelon"},
	["PN"] = {"Pitcairn"},
	["PR"] = {"Puerto Rico"},
	["PS"] = {"State of Palestine"},
	["PT"] = {"Portugal"},
	["PW"] = {"Palau"},
	["PY"] = {"Paraguay"},
	["QA"] = {"Qatar"},
	["RE"] = {"Réunion"},
	["RO"] = {"Romania"},
	["RS"] = {"Serbia"},
	["RU"] = {"Russian Federation"},
	["RW"] = {"Rwanda"},
	["SA"] = {"Saudi Arabia"},
	["SB"] = {"Solomon Islands"},
	["SC"] = {"Seychelles"},
	["SD"] = {"Sudan"},
	["SE"] = {"Sweden"},
	["SG"] = {"Singapore"},
	["SH"] = {"Saint Helena, Ascension and Tristan da Cunha"},
	["SI"] = {"Slovenia"},
	["SJ"] = {"Svalbard and Jan Mayen"},
	["SK"] = {"Slovakia"},
	["SL"] = {"Sierra Leone"},
	["SM"] = {"San Marino"},
	["SN"] = {"Senegal"},
	["SO"] = {"Somalia"},
	["SR"] = {"Suriname"},
	["SS"] = {"South Sudan"},
	["ST"] = {"Sao Tome and Principe"},
	["SV"] = {"El Salvador"},
	["SX"] = {"Sint Maarten (Dutch part)"},
	["SY"] = {"Syrian Arab Republic"},
	["SZ"] = {"Eswatini", "eSwatini", "Swaziland"},
	["TA"] = {"Tristan da Cunha"},
	["TC"] = {"Turks and Caicos Islands"},
	["TD"] = {"Chad"},
	["TF"] = {"French Southern Territories"},
	["TG"] = {"Togo"},
	["TH"] = {"Thailand"},
	["TJ"] = {"Tajikistan"},
	["TK"] = {"Tokelau"},
	["TL"] = {"Timor-Leste"},
	["TM"] = {"Turkmenistan"},
	["TN"] = {"Tunisia"},
	["TO"] = {"Tonga"},
	["TR"] = {"Türkiye", "Turkey"},
	["TT"] = {"Trinidad and Tobago"},
	["TV"] = {"Tuvalu"},
	["TW"] = {"Taiwan, Province of China"},
	["TZ"] = {"United Republic of Tanzania"},
	["UA"] = {"Ukraine"},
	["UG"] = {"Uganda"},
	["UM"] = {"United States Minor Outlying Islands"},
	["UN"] = {"United Nations"},
	["US"] = {"United States"},
	["UY"] = {"Uruguay"},
	["UZ"] = {"Uzbekistan"},
	["VA"] = {"Holy See (Vatican City State)"},
	["VC"] = {"Saint Vincent and the Grenadines"},
	["VE"] = {"Venezuela"},
	["VG"] = {"British Virgin Islands"},
	["VI"] = {"U.S. Virgin Islands"},
	["VN"] = {"Viet Nam"},
	["VU"] = {"Vanuatu"},
	["WF"] = {"Wallis and Futuna"},
	["WS"] = {"Samoa"},
	["YE"] = {"Yemen"},
	["YT"] = {"Mayotte"},
	["ZA"] = {"South Africa"},
	["ZM"] = {"Zambia"},
	["ZW"] = {"Zimbabwe"},
	["001"] = {"World"},
	["002"] = {"Africa"},
	["003"] = {"North America"},
	["005"] = {"South America"},
	["009"] = {"Oceania"},
	["011"] = {"Western Africa"},
	["013"] = {"Central America"},
	["014"] = {"Eastern Africa"},
	["015"] = {"Northern Africa"},
	["017"] = {"Middle Africa"},
	["018"] = {"Southern Africa"},
	["019"] = {"Americas"},
	["021"] = {"Northern America"},
	["029"] = {"Caribbean"},
	["030"] = {"Eastern Asia"},
	["034"] = {"Southern Asia"},
	["035"] = {"South-Eastern Asia"},
	["039"] = {"Southern Europe"},
	["053"] = {"Australia and New Zealand"},
	["054"] = {"Melanesia"},
	["057"] = {"Micronesia"},
	["061"] = {"Polynesia"},
	["142"] = {"Asia"},
	["143"] = {"Central Asia"},
	["145"] = {"Western Asia"},
	["150"] = {"Europe"},
	["151"] = {"Eastern Europe"},
	["154"] = {"Northern Europe"},
	["155"] = {"Western Europe"},
	["202"] = {"Sub-Saharan Africa"},
	["419"] = {"Latin America and the Caribbean"}
	}</text>
      <sha1>okjow5aolabn36s80d14dqtjo8u4ph0</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/data/iana variants</title>
    <ns>828</ns>
    <id>231</id>
    <revision>
      <id>450</id>
      <parentid>449</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>449</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="14015" sha1="9sg32gq5oeheouplvn3rf2kd4ykwj0x" xml:space="preserve">-- File-Date: 2025-05-15
return {
	["1606nict"] = {
		["descriptions"] = {"Late Middle French (to 1606)"},
		["prefixes"] = {"frm"},
		},
	["1694acad"] = {
		["descriptions"] = {"Early Modern French"},
		["prefixes"] = {"fr"},
		},
	["1901"] = {
		["descriptions"] = {"Traditional German orthography"},
		["prefixes"] = {"de"},
		},
	["1959acad"] = {
		["descriptions"] = {"\"Academic\" (\"governmental\") variant of Belarusian as codified in 1959"},
		["prefixes"] = {"be"},
		},
	["1994"] = {
		["descriptions"] = {"Standardized Resian orthography"},
		["prefixes"] = {"sl-rozaj", "sl-rozaj-biske", "sl-rozaj-njiva", "sl-rozaj-osojs", "sl-rozaj-solba"},
		},
	["1996"] = {
		["descriptions"] = {"German orthography of 1996"},
		["prefixes"] = {"de"},
		},
	["abl1943"] = {
		["descriptions"] = {"Orthographic formulation of 1943 - Official in Brazil (Formulário Ortográfico de 1943 - Oficial no Brasil)"},
		["prefixes"] = {"pt-br"},
		},
	["akuapem"] = {
		["descriptions"] = {"Akuapem Twi"},
		["prefixes"] = {"tw"},
		},
	["alalc97"] = {
		["descriptions"] = {"ALA-LC Romanization, 1997 edition"},
		["prefixes"] = {},
		},
	["aluku"] = {
		["descriptions"] = {"Aluku dialect", "Boni dialect"},
		["prefixes"] = {"djk"},
		},
	["anpezo"] = {
		["descriptions"] = {"Anpezo standard of Ladin"},
		["prefixes"] = {"lld"},
		},
	["ao1990"] = {
		["descriptions"] = {"Portuguese Language Orthographic Agreement of 1990 (Acordo Ortográfico da Língua Portuguesa de 1990)"},
		["prefixes"] = {"pt", "gl"},
		},
	["aranes"] = {
		["descriptions"] = {"Aranese"},
		["prefixes"] = {"oc"},
		},
	["arkaika"] = {
		["descriptions"] = {"Arcaicam Esperantom", "Arkaika Esperanto"},
		["prefixes"] = {"eo"},
		},
	["asante"] = {
		["descriptions"] = {"Asante Twi", "Ashanti Twi"},
		["prefixes"] = {"tw"},
		},
	["auvern"] = {
		["descriptions"] = {"Auvergnat"},
		["prefixes"] = {"oc"},
		},
	["baku1926"] = {
		["descriptions"] = {"Unified Turkic Latin Alphabet (Historical)"},
		["prefixes"] = {"az", "ba", "crh", "kk", "krc", "ky", "sah", "tk", "tt", "uz"},
		},
	["balanka"] = {
		["descriptions"] = {"The Balanka dialect of Anii"},
		["prefixes"] = {"blo"},
		},
	["barla"] = {
		["descriptions"] = {"The Barlavento dialect group of Kabuverdianu"},
		["prefixes"] = {"kea"},
		},
	["basiceng"] = {
		["descriptions"] = {"Basic English"},
		["prefixes"] = {"en"},
		},
	["bauddha"] = {
		["descriptions"] = {"Buddhist Hybrid Sanskrit"},
		["prefixes"] = {"sa"},
		},
	["bciav"] = {
		["descriptions"] = {"BCI Blissymbolics AV"},
		["prefixes"] = {"zbl"},
		},
	["bcizbl"] = {
		["descriptions"] = {"BCI Blissymbolics"},
		["prefixes"] = {"zbl"},
		},
	["biscayan"] = {
		["descriptions"] = {"Biscayan dialect of Basque"},
		["prefixes"] = {"eu"},
		},
	["biske"] = {
		["descriptions"] = {"The San Giorgio dialect of Resian", "The Bila dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["blasl"] = {
		["descriptions"] = {"Black American Sign Language dialect"},
		["prefixes"] = {"ase", "sgn-ase"},
		},
	["bohoric"] = {
		["descriptions"] = {"Slovene in Bohorič alphabet"},
		["prefixes"] = {"sl"},
		},
	["boont"] = {
		["descriptions"] = {"Boontling"},
		["prefixes"] = {"en"},
		},
	["bornholm"] = {
		["descriptions"] = {"Bornholmsk"},
		["prefixes"] = {"da"},
		},
	["cisaup"] = {
		["descriptions"] = {"Cisalpine"},
		["prefixes"] = {"oc"},
		},
	["colb1945"] = {
		["descriptions"] = {"Portuguese-Brazilian Orthographic Convention of 1945 (Convenção Ortográfica Luso-Brasileira de 1945)"},
		["prefixes"] = {"pt"},
		},
	["cornu"] = {
		["descriptions"] = {"Cornu-English", "Cornish English", "Anglo-Cornish"},
		["prefixes"] = {"en"},
		},
	["creiss"] = {
		["descriptions"] = {"Occitan variants of the Croissant area"},
		["prefixes"] = {"oc"},
		},
	["dajnko"] = {
		["descriptions"] = {"Slovene in Dajnko alphabet"},
		["prefixes"] = {"sl"},
		},
	["ekavsk"] = {
		["descriptions"] = {"Serbian with Ekavian pronunciation"},
		["prefixes"] = {"sr", "sr-latn", "sr-cyrl"},
		},
	["emodeng"] = {
		["descriptions"] = {"Early Modern English (1500-1700)"},
		["prefixes"] = {"en"},
		},
	["fascia"] = {
		["descriptions"] = {"Fascia standard of Ladin"},
		["prefixes"] = {"lld"},
		},
	["fodom"] = {
		["descriptions"] = {"Fodom standard of Ladin"},
		["prefixes"] = {"lld"},
		},
	["fonipa"] = {
		["descriptions"] = {"International Phonetic Alphabet"},
		["prefixes"] = {},
		},
	["fonkirsh"] = {
		["descriptions"] = {"Kirshenbaum Phonetic Alphabet"},
		["prefixes"] = {},
		},
	["fonnapa"] = {
		["descriptions"] = {"North American Phonetic Alphabet", "Americanist Phonetic Notation"},
		["prefixes"] = {},
		},
	["fonupa"] = {
		["descriptions"] = {"Uralic Phonetic Alphabet"},
		["prefixes"] = {},
		},
	["fonxsamp"] = {
		["descriptions"] = {"X-SAMPA transcription"},
		["prefixes"] = {},
		},
	["gallo"] = {
		["descriptions"] = {"Gallo"},
		["prefixes"] = {"fr"},
		},
	["gascon"] = {
		["descriptions"] = {"Gascon"},
		["prefixes"] = {"oc"},
		},
	["gherd"] = {
		["descriptions"] = {"Gherdëina standard of Ladin"},
		["prefixes"] = {"lld"},
		},
	["grclass"] = {
		["descriptions"] = {"Classical Occitan orthography"},
		["prefixes"] = {"oc", "oc-aranes", "oc-auvern", "oc-cisaup", "oc-creiss", "oc-gascon", "oc-lemosin", "oc-lengadoc", "oc-nicard", "oc-provenc", "oc-vivaraup"},
		},
	["grital"] = {
		["descriptions"] = {"Italian-inspired Occitan orthography"},
		["prefixes"] = {"oc", "oc-cisaup", "oc-nicard", "oc-provenc"},
		},
	["grmistr"] = {
		["descriptions"] = {"Mistralian or Mistralian-inspired Occitan orthography"},
		["prefixes"] = {"oc", "oc-aranes", "oc-auvern", "oc-cisaup", "oc-creiss", "oc-gascon", "oc-lemosin", "oc-lengadoc", "oc-nicard", "oc-provenc", "oc-vivaraup"},
		},
	["hanoi"] = {
		["descriptions"] = {"The Hà Nội variant of Vietnamese"},
		["prefixes"] = {"vi"},
		},
	["hepburn"] = {
		["descriptions"] = {"Hepburn romanization"},
		["prefixes"] = {"ja-latn"},
		},
	["hognorsk"] = {
		["descriptions"] = {"Norwegian in Høgnorsk (High Norwegian) orthography"},
		["prefixes"] = {"nn"},
		},
	["hsistemo"] = {
		["descriptions"] = {"Standard H-system orthographic fallback for spelling Esperanto"},
		["prefixes"] = {"eo"},
		},
	["huett"] = {
		["descriptions"] = {"The Huế (province Thừa Thiên) variant of Vietnamese"},
		["prefixes"] = {"vi"},
		},
	["ijekavsk"] = {
		["descriptions"] = {"Serbian with Ijekavian pronunciation"},
		["prefixes"] = {"sr", "sr-latn", "sr-cyrl"},
		},
	["itihasa"] = {
		["descriptions"] = {"Epic Sanskrit"},
		["prefixes"] = {"sa"},
		},
	["ivanchov"] = {
		["descriptions"] = {"Bulgarian in 1899 orthography"},
		["prefixes"] = {"bg"},
		},
	["jauer"] = {
		["descriptions"] = {"Jauer dialect of Romansh"},
		["prefixes"] = {"rm"},
		},
	["jyutping"] = {
		["descriptions"] = {"Jyutping Cantonese Romanization"},
		["prefixes"] = {"yue"},
		},
	["kkcor"] = {
		["descriptions"] = {"Common Cornish orthography of Revived Cornish"},
		["prefixes"] = {"kw"},
		},
	["kleinsch"] = {
		["descriptions"] = {"Kleinschmidt orthography", "Allattaasitaamut"},
		["prefixes"] = {"kl", "kl-tunumiit"},
		},
	["kociewie"] = {
		["descriptions"] = {"The Kociewie dialect of Polish"},
		["prefixes"] = {"pl"},
		},
	["kscor"] = {
		["descriptions"] = {"Standard Cornish orthography of Revived Cornish", "Kernowek Standard"},
		["prefixes"] = {"kw"},
		},
	["leidentr"] = {
		["descriptions"] = {"Ancient Egyptian in Leiden Unified Transliteration"},
		["prefixes"] = {"egy"},
		},
	["lemosin"] = {
		["descriptions"] = {"Limousin"},
		["prefixes"] = {"oc"},
		},
	["lengadoc"] = {
		["descriptions"] = {"Languedocien"},
		["prefixes"] = {"oc"},
		},
	["lipaw"] = {
		["descriptions"] = {"The Lipovaz dialect of Resian", "The Lipovec dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["ltg1929"] = {
		["descriptions"] = {"The Latgalian language orthography codified in 1929"},
		["prefixes"] = {"ltg"},
		},
	["ltg2007"] = {
		["descriptions"] = {"The Latgalian language orthography codified in the language law in 2007"},
		["prefixes"] = {"ltg"},
		},
	["luna1918"] = {
		["descriptions"] = {"Post-1917 Russian orthography"},
		["prefixes"] = {"ru"},
		},
	["mdcegyp"] = {
		["descriptions"] = {"Ancient Egyptian hieroglyphs encoded in Manuel de Codage"},
		["prefixes"] = {"egy"},
		},
	["mdctrans"] = {
		["descriptions"] = {"Ancient Egyptian transliteration encoded in Manuel de Codage"},
		["prefixes"] = {"egy"},
		},
	["metelko"] = {
		["descriptions"] = {"Slovene in Metelko alphabet"},
		["prefixes"] = {"sl"},
		},
	["monoton"] = {
		["descriptions"] = {"Monotonic Greek"},
		["prefixes"] = {"el"},
		},
	["ndyuka"] = {
		["descriptions"] = {"Ndyuka dialect", "Aukan dialect"},
		["prefixes"] = {"djk"},
		},
	["nedis"] = {
		["descriptions"] = {"Natisone dialect", "Nadiza dialect"},
		["prefixes"] = {"sl"},
		},
	["newfound"] = {
		["descriptions"] = {"Newfoundland English"},
		["prefixes"] = {"en-ca"},
		},
	["nicard"] = {
		["descriptions"] = {"Niçard"},
		["prefixes"] = {"oc"},
		},
	["njiva"] = {
		["descriptions"] = {"The Gniva dialect of Resian", "The Njiva dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["nulik"] = {
		["descriptions"] = {"Volapük nulik", "Volapük perevidöl", "Volapük nulädik", "de Jong's Volapük", "New Volapük", "Revised Volapük", "Modern Volapük"},
		["prefixes"] = {"vo"},
		},
	["osojs"] = {
		["descriptions"] = {"The Oseacco dialect of Resian", "The Osojane dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["oxendict"] = {
		["descriptions"] = {"Oxford English Dictionary spelling"},
		["prefixes"] = {"en"},
		},
	["pahawh2"] = {
		["descriptions"] = {"Pahawh Hmong Second Stage Reduced orthography"},
		["prefixes"] = {"mww", "hnj"},
		},
	["pahawh3"] = {
		["descriptions"] = {"Pahawh Hmong Third Stage Reduced orthography"},
		["prefixes"] = {"mww", "hnj"},
		},
	["pahawh4"] = {
		["descriptions"] = {"Pahawh Hmong Final Version orthography"},
		["prefixes"] = {"mww", "hnj"},
		},
	["pamaka"] = {
		["descriptions"] = {"Pamaka dialect"},
		["prefixes"] = {"djk"},
		},
	["peano"] = {
		["descriptions"] = {"Latino Sine Flexione", "Interlingua de API", "Interlingua de Peano"},
		["prefixes"] = {"la"},
		},
	["pehoeji"] = {
		["descriptions"] = {"Hokkien Vernacular Romanization System", "Pe̍h-ōe-jī orthography/romanization"},
		["prefixes"] = {"nan-latn"},
		},
	["petr1708"] = {
		["descriptions"] = {"Petrine orthography"},
		["prefixes"] = {"ru"},
		},
	["pinyin"] = {
		["descriptions"] = {"Pinyin romanization"},
		["prefixes"] = {"zh-latn", "bo-latn"},
		},
	["polyton"] = {
		["descriptions"] = {"Polytonic Greek"},
		["prefixes"] = {"el"},
		},
	["provenc"] = {
		["descriptions"] = {"Provençal"},
		["prefixes"] = {"oc"},
		},
	["puter"] = {
		["descriptions"] = {"Puter idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["rigik"] = {
		["descriptions"] = {"Volapük rigik", "Schleyer's Volapük", "Original Volapük", "Classic Volapük"},
		["prefixes"] = {"vo"},
		},
	["rozaj"] = {
		["descriptions"] = {"Resian", "Resianic", "Rezijan"},
		["prefixes"] = {"sl"},
		},
	["rumgr"] = {
		["descriptions"] = {"Rumantsch Grischun"},
		["prefixes"] = {"rm"},
		},
	["saigon"] = {
		["descriptions"] = {"The Sài Gòn variant of Vietnamese"},
		["prefixes"] = {"vi"},
		},
	["scotland"] = {
		["descriptions"] = {"Scottish Standard English"},
		["prefixes"] = {"en"},
		},
	["scouse"] = {
		["descriptions"] = {"Scouse"},
		["prefixes"] = {"en"},
		},
	["simple"] = {
		["descriptions"] = {"Simplified form"},
		["prefixes"] = {},
		},
	["solba"] = {
		["descriptions"] = {"The Stolvizza dialect of Resian", "The Solbica dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["sotav"] = {
		["descriptions"] = {"The Sotavento dialect group of Kabuverdianu"},
		["prefixes"] = {"kea"},
		},
	["spanglis"] = {
		["descriptions"] = {"Spanglish"},
		["prefixes"] = {"en", "es"},
		},
	["surmiran"] = {
		["descriptions"] = {"Surmiran idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["sursilv"] = {
		["descriptions"] = {"Sursilvan idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["sutsilv"] = {
		["descriptions"] = {"Sutsilvan idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["synnejyl"] = {
		["descriptions"] = {"Synnejysk", "South Jutish"},
		["prefixes"] = {"da"},
		},
	["tailo"] = {
		["descriptions"] = {"Taiwanese Hokkien Romanization System for Hokkien languages", "Tâi-lô orthography/romanization"},
		["prefixes"] = {"nan-latn"},
		},
	["tarask"] = {
		["descriptions"] = {"Belarusian in Taraskievica orthography"},
		["prefixes"] = {"be"},
		},
	["tongyong"] = {
		["descriptions"] = {"Tongyong Pinyin romanization"},
		["prefixes"] = {"zh-latn"},
		},
	["tunumiit"] = {
		["descriptions"] = {"Tunumiisiut", "East Greenlandic", "Østgrønlandsk"},
		["prefixes"] = {"kl"},
		},
	["uccor"] = {
		["descriptions"] = {"Unified Cornish orthography of Revived Cornish"},
		["prefixes"] = {"kw"},
		},
	["ucrcor"] = {
		["descriptions"] = {"Unified Cornish Revised orthography of Revived Cornish"},
		["prefixes"] = {"kw"},
		},
	["ulster"] = {
		["descriptions"] = {"Ulster dialect of Scots"},
		["prefixes"] = {"sco"},
		},
	["unifon"] = {
		["descriptions"] = {"Unifon phonetic alphabet"},
		["prefixes"] = {"en", "hup", "kyh", "tol", "yur"},
		},
	["valbadia"] = {
		["descriptions"] = {"Val Badia standard of Ladin"},
		["prefixes"] = {"lld"},
		},
	["valencia"] = {
		["descriptions"] = {"Valencian"},
		["prefixes"] = {"ca"},
		},
	["vallader"] = {
		["descriptions"] = {"Vallader idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["vecdruka"] = {
		["descriptions"] = {"Latvian orthography used before 1920s (\"vecā druka\")"},
		["prefixes"] = {"lv"},
		},
	["vivaraup"] = {
		["descriptions"] = {"Vivaro-Alpine"},
		["prefixes"] = {"oc"},
		},
	["wadegile"] = {
		["descriptions"] = {"Wade-Giles romanization"},
		["prefixes"] = {"zh-latn"},
		},
	["xsistemo"] = {
		["descriptions"] = {"Standard X-system orthographic fallback for spelling Esperanto"},
		["prefixes"] = {"eo"},
		}
	}</text>
      <sha1>9sg32gq5oeheouplvn3rf2kd4ykwj0x</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/data/iana suppressed scripts</title>
    <ns>828</ns>
    <id>232</id>
    <revision>
      <id>452</id>
      <parentid>451</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>451</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1281" sha1="ptt84tws2xn1g5qrdcwhnh57gx9uy2a" xml:space="preserve">-- File-Date: 2025-05-15
return {
	["Arab"] = {"ar", "fa", "ps", "ur"},
	["Armn"] = {"hy"},
	["Beng"] = {"as", "bn"},
	["Blis"] = {"zbl"},
	["Cyrl"] = {"ab", "be", "bg", "kk", "mk", "ru", "uk"},
	["Deva"] = {"hi", "mr", "ne", "kok", "mai"},
	["Ethi"] = {"am", "ti"},
	["Geor"] = {"ka"},
	["Grek"] = {"el"},
	["Gujr"] = {"gu"},
	["Guru"] = {"pa"},
	["Hebr"] = {"he", "iw", "yi"},
	["Jpan"] = {"ja"},
	["Khmr"] = {"km"},
	["Knda"] = {"kn"},
	["Kore"] = {"ko"},
	["Laoo"] = {"lo"},
	["Latn"] = {"af", "ay", "bs", "ca", "ch", "cs", "cy", "da", "de", "en", "eo",
				"es", "et", "eu", "fi", "fj", "fo", "fr", "fy", "ga", "gl", "gn",
				"gv", "hr", "ht", "hu", "id", "in", "is", "it", "kl", "la", "lb",
				"ln", "lt", "lv", "mg", "mh", "mo", "ms", "mt", "na", "nb", "nd",
				"nl", "nn", "no", "nr", "ny", "om", "pl", "pt", "qu", "rm", "rn",
				"ro", "rw", "sg", "sk", "sl", "sm", "so", "sq", "ss", "st", "sv",
				"sw", "tl", "tn", "to", "tr", "ts", "ve", "vi", "xh", "zu", "dsb",
				"frr", "frs", "gsw", "hsb", "men", "nds", "niu", "nso", "tem", "tkl", "tmh",
				"tpi", "tvl"},
	["Mlym"] = {"ml"},
	["Mymr"] = {"my"},
	["Nkoo"] = {"nqo"},
	["Orya"] = {"or"},
	["Sinh"] = {"si"},
	["Taml"] = {"ta"},
	["Telu"] = {"te"},
	["Thaa"] = {"dv"},
	["Thai"] = {"th"},
	["Tibt"] = {"dz"}
	}</text>
      <sha1>ptt84tws2xn1g5qrdcwhnh57gx9uy2a</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sister project/styles.css</title>
    <ns>10</ns>
    <id>233</id>
    <revision>
      <id>454</id>
      <parentid>453</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>453</origin>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="516" sha1="ii6vtyyv9bno3fjba6s3ebb14g1f2j5" xml:space="preserve">/* {{pp-template|small=yes}} */
@media print {
	body.ns-0 .sistersitebox {
		display: none !important;
	}
}

/* The Wiktionary logo needs a white background in dark mode since it is a transparent SVG */
@media screen {
  html.skin-theme-clientpref-night .sistersitebox img[src*="Wiktionary-logo-en-v2.svg"] {
      background-color: white;
  }
}
@media screen and (prefers-color-scheme: dark) {
	html.skin-theme-clientpref-os .sistersitebox img[src*="Wiktionary-logo-en-v2.svg"] {
      background-color: white;
	}
}</text>
      <sha1>ii6vtyyv9bno3fjba6s3ebb14g1f2j5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/langx</title>
    <ns>828</ns>
    <id>234</id>
    <revision>
      <id>456</id>
      <parentid>455</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>455</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6762" sha1="gwqe7k12n9zu6mivhd6gqfmpab6pi7r" xml:space="preserve">--[[--------------------------&lt; R T L _ T &gt;--------------------------------------------------------------------

table of language tags that render text right-to-left

Data in this table scraped from {{lang-xx}} templates that set |rtl=yes

keys (tags) in this table must be lowercase.

TODO: in the long run, do we need this table?  Can't {{langx}} apply dir="rtl" attribute automatically?

]]

local rtl_t = {
----------&lt; I S O 6 3 9 - 1 &gt;----------
	['ae'] = true,
	['ar'] = true,
	['fa'] = true,
	['he'] = true,
	['ku'] = true,
	['ps'] = true,
	['sd'] = true,
	['ur'] = true,
	['yi'] = true,

----------&lt; I S O 6 3 9 - 2 , - 3 &gt;----------
	['acm'] = true,
	['aeb'] = true,
	['aec'] = true,
	['afb'] = true,
	['aii'] = true,
	['aij'] = true,
	['aiq'] = true,
	['ajp'] = true,
	['amw'] = true,
	['apc'] = true,
	['arb'] = true,
	['arc'] = true,
	['arq'] = true,
	['ary'] = true,
	['arz'] = true,
	['ayn'] = true,
	['bal'] = true,
	['bdz'] = true,
	['bej'] = true,
	['bgn'] = true,
	['bqi'] = true,
	['brh'] = true,
	['bsk'] = true,
	['ckb'] = true,
	['cld'] = true,
	['deh'] = true,
	['gay'] = true,
	['gbz'] = true,
	['glk'] = true,
	['hac'] = true,
	['haz'] = true,
	['hbo'] = true,
	['hnd'] = true,
	['hno'] = true,
	['jog'] = true,
	['jrb'] = true,
	['jye'] = true,
	['khw'] = true,
	['kls'] = true,
	['kvx'] = true,
	['lrc'] = true,
	['lss'] = true,
	['luz'] = true,
	['mey'] = true,
	['mid'] = true,
	['mki'] = true,
	['mnj'] = true,
	['mwr'] = true,
	['myz'] = true,
	['mzb'] = true,
	['mzn'] = true,
	['nlm'] = true,
	['nqo'] = true,
	['oru'] = true,
	['ota'] = true,
	['otk'] = true,
	['pal'] = true,
	['pes'] = true,
	['prs'] = true,
	['prx'] = true,
	['rif'] = true,
	['rys'] = true,
	['sbn'] = true,
	['scl'] = true,
	['sgh'] = true,
	['siz'] = true,
	['skr'] = true,
	['sqo'] = true,
	['sqr'] = true,
	['srh'] = true,
	['syc'] = true,
	['syr'] = true,
	['tru'] = true,
	['ttt'] = true,
	['wbl'] = true,
	['wne'] = true,
	['xaa'] = true,
	['xdm'] = true,
	['xhe'] = true,
	['xqa'] = true,
	['ydg'] = true,
	}


--[[--------------------------&lt; S C R I P T _ T &gt;--------------------------------------------------------------

table of language tags that use script subtags

Data in this table scraped from {{lang-xx}} templates that set |script=&lt;script tag&gt;

keys (tags) in this table must be lowercase.

]]

local script_t = {
----------&lt; I S O 6 3 9 - 1 &gt;----------
	['ce'] = 'Cyrl',
	['ff'] = 'Latn',
	['sh'] = 'Latn',

----------&lt; I S O 6 3 9 - 2 , - 3 &gt;----------
	['bft'] = 'Aran',
	['brx'] = 'Deva',
	['bsk'] = 'Aran',
	['chr'] = 'Cher',
	['dgo'] = 'Deva',
	['dng'] = 'Cyrl',
	['dyu'] = 'Latn',
	['ess'] = 'Latn',
	['evn'] = 'Cyrl',
	['sat'] = 'Olck',
	['shn'] = 'Mymr',
	}


--[[--------------------------&lt; S I Z E _ T &gt;------------------------------------------------------------------

table of language tags that use |size=

Data in this table scraped from {{lang-xx}} templates that set |size=&lt;size&gt;

keys (tags) in this table must be lowercase.

]]

local size_t = {
	['bft'] = '125%',
	}


--[[--------------------------&lt; L I N K _ T &gt;------------------------------------------------------------------

table of language tags that use |link=

Data in this table scraped from {{lang-xx}} templates that set |link=

keys (tags) in this table must be lowercase.

]]

local link_t = {
	['en'] = 'no',
	}


--[[--------------------------&lt; U N S U P P O R T E D _ T &gt;----------------------------------------------------

these are language tags from {{lang-??}} templates that should not be converted to {{langx}} during the transition
from {{lang-??}} to {{langx|??}}.

this table used to add a category when {{langx}} templates are encountered with these language tags.

initial contents of this table copied from Wikipedia:Templates_for_discussion/Log/2024_September_27/lang-%3F%3F_templates#excluded_templates

2024-11-15: now that the conversion of the {{lang-??}} templates is complete, and User:Monkbot/task 20 has
completed its work, and now that Module:Lang detects unsupported parameters, those valid IETF tags listed here
can be stricken so that valid use of those tags with {{langx|&lt;tag&gt;|...}} can be allowed.

]]

local unsupported_t = {
	['bcs'] = true,																-- bcs is IANA Kohumono language not Bosnian/Croatian/Serbian grouped under tag sh
	['crh3'] = true,															-- being deleted; convert to something like {{lang-sr-latn-cyrl}}?
	['est-sea'] = true,															-- {{Language with name}} wrapper; convert to private use tag: et-x-seto?
	['fra-frc'] = true,															-- {{Language with name}} wrapper; convert to private use tag: fr-x-frainc?
	['grc-gre'] = true,															-- currently (2024-11-15) being discussed for deletion
	['my-name-mlcts'] = true,													-- wrapper around {{lang-my-Mymr}} to render a {{lang-??}}-like result
	['sq-definite'] = true,														-- definiteness is a linguistic construct
	['su-fonts'] = true,														-- styling
	['uniturk'] = true,															-- a writing system
	['1ca'] = true,																-- uses {{lang}} and trk-Arab-TR; add that tag to ~/data for Old Anatolian Turkish?

--	['ast-leo'] = true,															-- deleted; use ast-es
--	['lmo-cr'] = true,															-- deleted; use lmo-x-cremish
--	['lmo-it'] = true,															-- deleted; use lmo-x-berg
--	['pun'] = true,																-- deleted; was a template dab
--	['sa2'] = true,																-- deleted; use {{lang}}

--	['bcs-latn-cyrl'] = true,													-- {{lang-x2}} template wrappers; these tags not valid
--	['cnr-cyrl-latn'] = true,
--	['cnr-latn-cyrl'] = true,
--	['sh-cyrl-latn'] = true,
--	['sh-latn-cyrl'] = true,
--	['sr-cyrl-latn'] = true,
--	['sr-latn-cyrl'] = true,
--	['uz-cyrl-latn'] = true,
--	['uz-latn-cyrl'] = true,

--	['cnr-cyrl'] = true,														-- valid IETF tags; no reason to prevent their use with {{langx}}
--	['cnr-latn'] = true,
--	['hmd'] = true,
--	['ka'] = true,
--	['ku-arab'] = true,
--	['mnc'] = true,
--	['my-mymr'] = true,
--	['rus'] = true,																-- sort of valid IETF tag; should be promoted to 'ru'
--	['sh-cyrl'] = true,
--	['sh-latn'] = true,
--	['sr'] = true,																-- per Template_talk:Lang#tracking_sr_usage_with_issues; discussion died nothing being done
--	['sr-cyrl'] = true,
--	['sr-latn'] = true,
--	['uz-latn'] = true,
--	['zh'] = true,

--	Moldovan Cyrillic															-- now a redirect to Lang-ro-Cyrl
--	['vi-chunom'] = true,														-- now a redirect to {{Chunom}}
--	['vi-hantu'] = true,														-- now a redirect to {{Chuhan}}
	}


--[[--------------------------&lt; E X P O R T S &gt;----------------------------------------------------------------
]]

return {
	link_t = link_t,
	rtl_t = rtl_t,
	script_t = script_t,
	size_t = size_t,
	unsupported_t = unsupported_t,
	}</text>
      <sha1>gwqe7k12n9zu6mivhd6gqfmpab6pi7r</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/configuration</title>
    <ns>828</ns>
    <id>235</id>
    <revision>
      <id>458</id>
      <parentid>457</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>457</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12136" sha1="gumagybz6wmxuy56etpm67aoy5tbxxl" xml:space="preserve">--[[--------------------------&lt; T E M P L A T E S _ T &gt;--------------------------------------------------------
]]

local templates_t = {
	lang = 'Lang',
	langx = 'Langx',
	langxx = 'Lang-xx',
	transliteration = 'Transliteration',
	}


--[[--------------------------&lt; K N O W N _ P A R A M S &gt;------------------------------------------------------

lists of all parameters known to {{lang}}, {{langx}}, {{lang-xx}} templates.

Exception: |fn= is known to {{lang}} but is not a 'lang' template;  that parameter causes the module to call the
specified lang(), lang_xx_inherit(), or lang_xx_italic() function.  These separate functions set |fn= to nill
and then do the known-param checking on the other template parameters

]]

local known_params_t = {
	['common_params_all_t'] = {													-- these parameters common to {{lang}}, {{langx}}, and {{lang-xx}}
		['code'] = true,
		['text'] = true,
		['rtl'] = true,
		['italic'] = true,
		['italics'] = true,
		['i'] = true,
		['size'] = true,
		['proto'] = true,
		['nocat'] = true,
		['cat'] = true,

		['template'] = true,													-- supplied by external templates to provide template name for error messaging ({{nihongo}}, etc)
		},
	
	['params_lang_t'] = {														-- unique to {{lang}}
		[1] = true,																-- alias of |code=
		[2] = true,																-- alias of |text=
		},

	['params_x_t'] = {															-- common to {{langx}} and {{lang-xx}}
		['translit'] = true,
		['translit-std'] = true,
		['translit-script'] = true,
		['translation'] = true,
		['lit='] = true,
		['label'] = true,
		['link'] = true,
		['links'] = true,
		['lit'] = true,
		['engvar'] = true,
		},

	['params_langx_t'] = {														-- unique to {{langx}}
		[1] = true,																-- alias of |code=
		[2] = true,																-- alias of |text=
		[3] = true,																-- alias of |translit=
		[4] = true,																-- alias of |translation=
		},

	['params_lang_xx_t'] = {													-- unique to {{lang-xx}}
		[1] = true,																-- alias of |text=
		[2] = true,																-- alias of |translit=
		[3] = true,																-- alias of |translation=
		['script'] = true,														-- these needed to override default params in {{lang-??}} templates
		['region'] = true,
		['variant'] = true,
		},
	}


--[[--------------------------&lt; E N G _ V A R &gt;----------------------------------------------------------------

Used at en.wiki so that spelling of 'romanized' (US, default) can be changed to 'romanised' to match the envar
specified by a {{Use xxx English}}.  Not likely useful outside of en.wiki

This is accomplished by setting |engvar=gb; can, should be omitted in articles that use American English; no
need for the clutter.

]]

local engvar_sel_t = {															-- select either UK English or US English
	['au'] = 'gb_t',															-- these match IANA region codes (except in lower case)
	['ca'] = 'us_t',
	['gb'] = 'gb_t',
	['ie'] = 'gb_t',
	['in'] = 'gb_t',
	['nz'] = 'gb_t',
	['us'] = 'us_t',															-- default engvar
	['za'] = 'gb_t'
	};

local engvar_t = {
	['gb_t'] = {
		['romanisz_lc'] = 'romanisation',										-- lower case
		['romanisz_uc'] = 'Romanisation',										-- upper case; unused can be deleted
		['romanisz_pt'] = 'romanised',											-- past tense
		},
	['us_t'] = {																-- default engvar
		['romanisz_lc'] = 'romanization',										-- lower case
		['romanisz_uc'] = 'Romanization',										-- upper case; unused can be deleted
		['romanisz_pt'] = 'romanized',											-- past tense
		}
	}

local default_engvar = 'us_t';


--[[
=============================&lt;&lt; M E S S A G I N G   T A B L E S &gt;&gt;=============================================

these tables are for internationalization.  Messages or fragments thereof are mostly grouped by function name.
Some messages are shared by functions other than the function table that lists the message or fragment.

]]


--[[--------------------------&lt; K E Y W O R D S _ T &gt;----------------------------------------------------------
]]

local keywords_t = {
	['affirmative'] = 'yes',
	['negative'] = 'no',
	['unset'] = 'unset',
	['invert'] = 'invert',
	['default'] = 'default',
	}


--[[--------------------------&lt; M I S C _ T E X T _ T &gt;--------------------------------------------------------



]]

local misc_text_t = {
	['error'] = 'Error',														-- make_error_msg(), tag_from_name()
	['language'] = 'language',													-- make_translit(), lang_xx(), name_from_tag()
	['help'] = 'help',
	}


--[[--------------------------&lt; M A K E _ E R R O R _ M S G _ T &gt;----------------------------------------------
]]

local make_error_msg_t = {
	['xlit_err_cat'] = 'Transliteration template errors',
	['lang_err_cat'] = 'Lang and lang-xx template errors',
	['undefined'] = 'undefined',
	}
	

--[[--------------------------&lt; V A L I D A T E _ I T A L I C _ T &gt;--------------------------------------------
]]

local parameter_validate_t = {
	['invalid_param'] = 'invalid parameter: &amp;#124;$1=',							-- $1 is parameter name
	}


--[[--------------------------&lt; V A L I D A T E _ I T A L I C _ T &gt;--------------------------------------------
]]

local validate_italic_t = {
	['multi_italic'] = 'only one of &amp;#124;italic=, &amp;#124;italics=, or &amp;#124;i= can be specified',
	}
	

--[[--------------------------&lt; V A L I D A T E _ T E X T _ T &gt;------------------------------------------------
]]

local validate_text_t = {
	['no_text'] = 'no text',
	['malformed_markup'] = 'text has malformed markup',
	['italic_markup'] = 'text has italic markup',
	}


--[[--------------------------&lt; T E X T _ S C R I P T _ M A T C H _ T E S T _ T &gt;------------------------------
]]

local text_script_match_test_t = {
	['latn_txt_mismatch'] = 'Latn text/non-Latn script subtag mismatch',
	['latn_scr_mismatch'] = 'Non-latn text (pos $1: $2)/Latn script subtag mismatch',	-- $1 identifies offending character's position; $2 is the character
	}


--[[--------------------------&lt; L A N G _ T &gt;------------------------------------------------------------------
]]

local lang_t = {
	['conflict_n_param'] = 'conflicting: {{{$1}}} and &amp;#124;$2=',				-- $1 is positional param number, $2 is named param; shared with _lang_xx()
	['conflict_n_param_types'] = {
		['code'] = 'code',
		['text'] = 'text',
		['translit'] = 'translit',
		},
	['invalid_proto'] = 'invalid &amp;#124;proto=: $1',								-- _lang_xx also emits this message
	}
	
	
--[[--------------------------&lt; L A N G _ X X _ T &gt;------------------------------------------------------------
]]

local lang_xx_t	= {
	['conflict_n_lit'] = 'conflicting: {{{$1}}} and &amp;#124;lit= or &amp;#124;translation=',	-- $1 is positional parameter; can be either 3 ({{lang-??}}) or 4 ({{langx}})
	['conflict_lit'] = 'conflicting: &amp;#124;lit= and &amp;#124;translation=',
	['conflict_link'] = 'conflicting: &amp;#124;links= and &amp;#124;link=',
	['invalid_xlit_std'] = 'invalid translit-std',
	['romanization'] = 'Romanization of',
	['translit_nonlatn'] = 'transliteration text not Latin script (pos $1: $2)',	-- _xlit() also emits this message; $1 identifies offending character's position; $2 is the character
	['xlit_of_latn'] = 'transliteration of latn script',
	}


--[[--------------------------&lt; T A G _ F R O M _ N A M E _ T &gt;------------------------------------------------
]]

local tag_from_name_t = {
	['lang_not_found'] = 'language: $1 not found',								-- $1 is language name parameter value
	['missing_lang_name'] = 'missing language name',
	}


--[[--------------------------&lt; T R A N S L _ T &gt;--------------------------------------------------------------
]]

local transl_t = {
	['unrecog_xlit_std'] = 'unrecognized transliteration standard: $1',			-- $1 is |translit_std- parameter value
	['no_text'] = 'no text',
	['missing_lang_scr'] = 'missing language / script code',
	['unrecog_lang_scr'] = 'unrecognized language / script code: $1',			-- $1 is the language/script code
	}


--[[--------------------------&lt; G E T _ I E T F _ P A R T S _ T &gt;----------------------------------------------
]]

local get_ietf_parts_t = {
	['maint_promo_cat'] = 'Lang and lang-xx code promoted to ISO 639-1|$1',		-- $1 is ISO 639-2/3 subtag
	['maint_promo_msg'] = 'code: $1 promoted to code: $2',						-- $1 is ISO 639-2/3 subtag, $2 is synonymous ISO 639-1 subtag

	['missing_lang_tag'] = 'missing language tag',								-- also used in _langx()
	['redundant_scr'] = 'redundant script tag',
	['redundant_reg'] = 'redundant region tag',
	['redundant_var'] = 'redundant variant tag',
	['unrecog_tag'] = 'unrecognized language tag: $1',							-- $1 is the whole language tag
	['unrecog_code'] = 'unrecognized language code: $1',						-- $1 is code
	['unrecog_reg_code'] = 'unrecognized region: $1 for code: $2',				-- $1 is region, $2 is code
	['unrecog_scr_code'] = 'unrecognized script: $1 for code: $2',				-- $1 is script, $2 is code
	['script_code'] = 'script: $1 not supported for code: $2',					-- $1 is script, $2 is code
	['unrecog_var'] = 'unrecognized variant: $1',								-- $1 is variant
	['unrecog_var_code'] = 'unrecognized variant: $1 for code: $2',				-- $1 is variant, $2 is code
	['unrecog_var_code_scr'] = 'unrecognized variant: $1 for code-script pair: $2-$3',	-- $1 is variant, $2 is code, $3 is script
	['unrecog_var_code_reg'] = 'unrecognized variant: $1 for code-region pair: $2-$3',	-- $1 is variant, $2 is code, $3 is region
	['unrecog_pri'] = 'unrecognized private tag: $1',							-- $1 is private tag
	}


--[[--------------------------&lt; L A N G U A G E _ N A M E _ G E T _ T &gt;----------------------------------------
]]

local language_name_get_t = {
	['deprecated_cat'] = 'Lang and lang-xx using deprecated ISO 639 codes|$1',	-- $1 is deprecated ISO 639 subtag
	['deprecated_msg'] = 'code: $1 is deprecated',								-- $1 is deprecated ISO 639 subtag
	}


--[[--------------------------&lt; H T M L _ T I T L E _ T E X T _ T &gt;--------------------------------------------
]]

local make_text_html_t = {
	['zxx'] = 'text',															-- for zxx no linguistic content
	['collective'] = 'collective text',											-- for collective languages
	['individual'] = 'language text',											-- for individual languages
	}


--[[--------------------------&lt; T R A N S L A T I O N _ M A K E _ T &gt;------------------------------------------
]]

local translation_make_t = {
	['lit_xlation'] = 'Literal translation',									-- article title fragment and HTML title attribute
	['lit_abbr'] = 'lit.',
	}


--[[--------------------------&lt; M A K E _ C A T E G O R Y _ T &gt;------------------------------------------------
]]

local make_category_t = {
	['collective_cat'] = 'Category:Articles with text in',						-- for collective languages
	['cat_prefix'] = 'Category:Articles containing',							-- prefix for explicitly cited and individual languages
	['explicit_cat'] = 'explicitly cited',										-- for explicitly citing this wiki's language
	['cat_postfix'] = 'language text',											-- postfix for individual languages
	}
	

--[[--------------------------&lt; M A K E _ T R A N S L I T _ T &gt;------------------------------------------------
]]

local make_translit_t = {
	['script'] = 'script',
	['transliteration'] = 'transliteration',
	}


--[[--------------------------&lt; E X P O R T S &gt;----------------------------------------------------------------
]]

return {
	known_params_t = known_params_t,
	templates_t = templates_t,

	default_engvar = default_engvar,											-- engvar support not likely useful outside of en.wiki
	engvar_t = engvar_t,
	engvar_sel_t = engvar_sel_t,

	get_ietf_parts_t = get_ietf_parts_t,										-- messaging tables
	keywords_t = keywords_t,
	lang_t = lang_t,
	lang_xx_t = lang_xx_t,
	language_name_get_t = language_name_get_t,
	make_category_t = make_category_t,
	make_error_msg_t = make_error_msg_t,
	make_text_html_t = make_text_html_t,
	make_translit_t = make_translit_t,
	misc_text_t = misc_text_t,
	parameter_validate_t = parameter_validate_t,
	tag_from_name_t = tag_from_name_t,
	text_script_match_test_t = text_script_match_test_t,
	transl_t = transl_t,
	translation_make_t = translation_make_t,
	validate_italic_t = validate_italic_t,
	validate_text_t = validate_text_t,
	}</text>
      <sha1>gumagybz6wmxuy56etpm67aoy5tbxxl</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/data/is latn data</title>
    <ns>828</ns>
    <id>236</id>
    <revision>
      <id>460</id>
      <parentid>459</parentid>
      <timestamp>2025-07-09T04:31:43Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <origin>459</origin>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="19389" sha1="rljbhpqu41mlqzfdirdyfrjiqatx80d" xml:space="preserve">--[[--------------------------&lt; S I N G L E S _ T &gt;-----------------------------------------------------------

list of Latn and Zyyy (common) codepoints that are not included in &lt;ranges_t&gt; taken from Module:Unicode data/scripts
and a local copy of https://www.unicode.org/Public/16.0.0/ucd/ScriptExtensions.txt

]]

local singles_t = {
	[170] = true,																-- 00AA
	[186] = true,																-- 00BA
	[215] = true,																-- 00D7
	[247] = true,																-- 00F7
	[787] = true,																-- 0313
	[800] = true,																-- 0320
	[856] = true,																-- 0358
	[862] = true,																-- 035E
	[884] = true,																-- 0374
	[894] = true,																-- 037E
	[901] = true,																-- 0385
	[903] = true,																-- 0387
	[1541] = true,																-- 0605
	[1548] = true,																-- 060C
	[1563] = true,																-- 061B
	[1567] = true,																-- 061F
	[1600] = true,																-- 0640
	[1757] = true,																-- 06DD
	[2274] = true,																-- 08E2
	[3647] = true,																-- 0E3F
	[4347] = true,																-- 10FB
	[6149] = true,																-- 1805
	[7379] = true,																-- 1CD3
	[7393] = true,																-- 1CE1
	[7418] = true,																-- 1CFA
	[7672] = true,																-- 1DF8
	[8305] = true,																-- 2071
	[8319] = true,																-- 207F
	[8432] = true,																-- 20F0
	[8498] = true,																-- 2132
	[8526] = true,																-- 214E
	[12294] = true,																-- 3006
	[12448] = true,																-- 30A0
	[12783] = true,																-- 31EF
	[13055] = true,																-- 32FF
	[42963] = true,																-- A7D3
	[43310] = true,																-- A92E
	[43471] = true,																-- A9CF
	[43867] = true,																-- AB5B
	[65279] = true,																-- FEFF
	[65392] = true,																-- FF70
	[119970] = true,															-- 1D4A2
	[119995] = true,															-- 1D4BB
	[120134] = true,															-- 1D546
	[129008] = true,															-- 1F7F0
	[917505] = true,															-- E0001
	}


--[[--------------------------&lt; R A N G E S _ T &gt;-------------------------------------------------------------

list of Latn and Zyyy (common) codepoints taken from Module:Unicode data/scripts and a local copy of
https://www.unicode.org/Public/16.0.0/ucd/ScriptExtensions.txt

]]

local ranges_t = {
	{0, 169},																	-- 0000..00A9
	{171, 185},																	-- 00AB..00B9
	{187, 214},																	-- 00BB..00D6
	{216, 246},																	-- 00D8..00F6
	{248, 745},																	-- 00F8..02E9
	{748, 782},																	-- 02EC..030E
	{784, 785},																	-- 0310..0311
	{803, 805},																	-- 0323..0325
	{813, 814},																	-- 032D..032E
	{816, 817},																	-- 0330..0331
	{867, 879},																	-- 0363..036F
	{1157, 1158},																-- 0485..0486
	{2385, 2386},																-- 0951..0952
	{2404, 2405},																-- 0964..0965
	{4053, 4056},																-- 0FD5..0FD8
	{5867, 5869},																-- 16EB..16ED
	{5941, 5942},																-- 1735..1736
	{6146, 6147},																-- 1802..1803
	{7401, 7404},																-- 1CE9..1CEC
	{7406, 7411},																-- 1CEE..1CF3
	{7413, 7415},																-- 1CF5..1CF7
	{7424, 7461},																-- 1D00..1D25
	{7468, 7516},																-- 1D2C..1D5C
	{7522, 7525},																-- 1D62..1D65
	{7531, 7543},																-- 1D6B..1D77
	{7545, 7614},																-- 1D79..1DBE
	{7680, 7935},																-- 1E00..1EFF
	{8192, 8203},																-- 2000..200B
	{8206, 8292},																-- 200E..2064
	{8294, 8304},																-- 2066..2070
	{8308, 8318},																-- 2074..207E
	{8320, 8334},																-- 2080..208E
	{8336, 8348},																-- 2090..209C
	{8352, 8384},																-- 20A0..20C0
	{8448, 8485},																-- 2100..2125
	{8487, 8497},																-- 2127..2131
	{8499, 8525},																-- 2133..214D
	{8527, 8587},																-- 214F..218B
	{8592, 9257},																-- 2190..2429
	{9280, 9290},																-- 2440..244A
	{9312, 10239},																-- 2460..27FF
	{10496, 11123},																-- 2900..2B73
	{11126, 11157},																-- 2B76..2B95
	{11159, 11263},																-- 2B97..2BFF
	{11360, 11391},																-- 2C60..2C7F
	{11776, 11869},																-- 2E00..2E5D
	{12272, 12292},																-- 2FF0..3004
	{12296, 12320},																-- 3008..3020
	{12336, 12343},																-- 3030..3037
	{12348, 12351},																-- 303C..303F
	{12443, 12444},																-- 309B..309C
	{12539, 12540},																-- 30FB..30FC
	{12688, 12703},																-- 3190..319F
	{12736, 12773},																-- 31C0..31E5
	{12832, 12895},																-- 3220..325F
	{12927, 13007},																-- 327F..32CF
	{13144, 13311},																-- 3358..33FF
	{19904, 19967},																-- 4DC0..4DFF
	{42752, 42957},																-- A700..A7CD
	{42960, 42961},																-- A7D0..A7D1
	{42965, 42972},																-- A7D5..A7DC
	{42994, 43007},																-- A7F2..A7FF
	{43056, 43065},																-- A830..A839
	{43824, 43866},																-- AB30..AB5A
	{43868, 43876},																-- AB5C..AB64
	{43878, 43883},																-- AB66..AB6B
	{64256, 64262},																-- FB00..FB06
	{64830, 64831},																-- FD3E..FD3F
	{65040, 65049},																-- FE10..FE19
	{65072, 65106},																-- FE30..FE52
	{65108, 65126},																-- FE54..FE66
	{65128, 65131},																-- FE68..FE6B
	{65281, 65381},																-- FF01..FF65
	{65438, 65439},																-- FF9E..FF9F
	{65504, 65510},																-- FFE0..FFE6
	{65512, 65518},																-- FFE8..FFEE
	{65529, 65533},																-- FFF9..FFFD
	{65792, 65794},																-- 10100..10102
	{65799, 65843},																-- 10107..10133
	{65847, 65855},																-- 10137..1013F
	{65936, 65948},																-- 10190..1019C
	{66000, 66044},																-- 101D0..101FC
	{66273, 66299},																-- 102E1..102FB
	{67456, 67461},																-- 10780..10785
	{67463, 67504},																-- 10787..107B0
	{67506, 67514},																-- 107B2..107BA
	{113824, 113827},															-- 1BCA0..1BCA3
	{117760, 118009},															-- 1CC00..1CCF9
	{118016, 118451},															-- 1CD00..1CEB3
	{118608, 118723},															-- 1CF50..1CFC3
	{118784, 119029},															-- 1D000..1D0F5
	{119040, 119078},															-- 1D100..1D126
	{119081, 119142},															-- 1D129..1D166
	{119146, 119162},															-- 1D16A..1D17A
	{119171, 119172},															-- 1D183..1D184
	{119180, 119209},															-- 1D18C..1D1A9
	{119214, 119274},															-- 1D1AE..1D1EA
	{119488, 119507},															-- 1D2C0..1D2D3
	{119520, 119539},															-- 1D2E0..1D2F3
	{119552, 119638},															-- 1D300..1D356
	{119648, 119672},															-- 1D360..1D378
	{119808, 119892},															-- 1D400..1D454
	{119894, 119964},															-- 1D456..1D49C
	{119966, 119967},															-- 1D49E..1D49F
	{119973, 119974},															-- 1D4A5..1D4A6
	{119977, 119980},															-- 1D4A9..1D4AC
	{119982, 119993},															-- 1D4AE..1D4B9
	{119997, 120003},															-- 1D4BD..1D4C3
	{120005, 120069},															-- 1D4C5..1D505
	{120071, 120074},															-- 1D507..1D50A
	{120077, 120084},															-- 1D50D..1D514
	{120086, 120092},															-- 1D516..1D51C
	{120094, 120121},															-- 1D51E..1D539
	{120123, 120126},															-- 1D53B..1D53E
	{120128, 120132},															-- 1D540..1D544
	{120138, 120144},															-- 1D54A..1D550
	{120146, 120485},															-- 1D552..1D6A5
	{120488, 120779},															-- 1D6A8..1D7CB
	{120782, 120831},															-- 1D7CE..1D7FF
	{122624, 122654},															-- 1DF00..1DF1E
	{122661, 122666},															-- 1DF25..1DF2A
	{126065, 126132},															-- 1EC71..1ECB4
	{126209, 126269},															-- 1ED01..1ED3D
	{126976, 127019},															-- 1F000..1F02B
	{127024, 127123},															-- 1F030..1F093
	{127136, 127150},															-- 1F0A0..1F0AE
	{127153, 127167},															-- 1F0B1..1F0BF
	{127169, 127183},															-- 1F0C1..1F0CF
	{127185, 127221},															-- 1F0D1..1F0F5
	{127232, 127405},															-- 1F100..1F1AD
	{127462, 127487},															-- 1F1E6..1F1FF
	{127489, 127490},															-- 1F201..1F202
	{127504, 127547},															-- 1F210..1F23B
	{127552, 127560},															-- 1F240..1F248
	{127568, 127569},															-- 1F250..1F251
	{127584, 127589},															-- 1F260..1F265
	{127744, 128727},															-- 1F300..1F6D7
	{128732, 128748},															-- 1F6DC..1F6EC
	{128752, 128764},															-- 1F6F0..1F6FC
	{128768, 128886},															-- 1F700..1F776
	{128891, 128985},															-- 1F77B..1F7D9
	{128992, 129003},															-- 1F7E0..1F7EB
	{129024, 129035},															-- 1F800..1F80B
	{129040, 129095},															-- 1F810..1F847
	{129104, 129113},															-- 1F850..1F859
	{129120, 129159},															-- 1F860..1F887
	{129168, 129197},															-- 1F890..1F8AD
	{129200, 129211},															-- 1F8B0..1F8BB
	{129216, 129217},															-- 1F8C0..1F8C1
	{129280, 129619},															-- 1F900..1FA53
	{129632, 129645},															-- 1FA60..1FA6D
	{129648, 129660},															-- 1FA70..1FA7C
	{129664, 129673},															-- 1FA80..1FA89
	{129679, 129734},															-- 1FA8F..1FAC6
	{129742, 129756},															-- 1FACE..1FADC
	{129759, 129769},															-- 1FADF..1FAE9
	{129776, 129784},															-- 1FAF0..1FAF8
	{129792, 129938},															-- 1FB00..1FB92
	{129940, 130041},															-- 1FB94..1FBF9
	{917536, 917631},															-- E0020..E007F
	}


--[[--------------------------&lt; S P E C I A L S _ T &gt;---------------------------------------------------------

list of individual language-specific non-Latn and non-Zyyy codepoints; these codepoints commonly used in
transliterations.  This list is manually currated so is most likely incomplete.

keys to &lt;specials_t&gt; are decimal codepoints; other keys are language tags (always lowercase) of language
transliterations that use these non-Latn codepoints.

]]

local specials_t = {
	[788] = {																	-- U+0314: COMBINING REVERSED COMMA ABOVE
			["hy"] = true,														-- Armenian
			},
	[794] = {																	-- U+031A: COMBINING LEFT ANGLE ABOVE
			["ltc"] = true,														-- Middle Chinese; is this really IPA?
			},
	[795] = {																	-- U+031B: COMBINING HORN
			["th"] = true,														-- Thai
			},
	[806] = {																	-- U+0326: COMBINING COMMA BELOW
			["ab"] = true,														-- Abkhaz
			["kca"] = true,														-- Khanty
			["xal"] = true,														-- Kalmyk or Oirat
			},
	[807] = {																	-- U+0327: COMBINING CEDILLA
			["fa"] = true,														-- Persian
			},
	[809] = {																	-- U+0329: COMBINING VERTICAL LINE BELOW
			["ab"] = true,														-- Abkhaz
			["sa"] = true,														-- Sanskrit
			},
	[815] = {																	-- U+032F: COMBINING INVERTED BREVE BELOW
			["mong"] = true,													-- Mongolian
			["xsc"] = true,														-- Scythian
			},
	[818] = {																	-- U+0332: COMBINING LOW LINE
			["ar"] = true,														-- Arabic
			["hbo"] = true,														-- Ancient Hebrew
			["he"] = true,														-- Hebrew
			["jpa"] = true,														-- Jewish Palestinian Aramaic
			["mdh"] = true,														-- Maguindanaon
			["otk"] = true,														-- Old Turkish
			},
	[831] = {																	-- U+033F: COMBINING DOUBLE OVERLINE
			["mnp"] = true,														-- Northern Min Chinese, Jian'ou dialect
			},
	[855] = {																	-- U+0357: COMBINING RIGHT HALF RING ABOVE
			["egy"] = true,														-- Ancient Egyptian
			},
	[863] = {																	-- U+035F: COMBINING DOUBLE MACRON BELOW
			["am"] = true,														-- Amharic
			["ar"] = true,														-- Arabic
			["dv"] = true,														-- Dhivehi, Divehi, or Maldivian
			["fa"] = true,														-- Persian
			["hi"] = true,														-- Hindi
			["inc"] = true,														-- Indic languages
			["ur"] = true,														-- Urdu
			},
	[864] = {																	-- U+0360: COMBINING DOUBLE TILDE
			["hi"] = true,														-- Hindi
			},
	[865] = {																	-- U+0361: COMBINING DOUBLE INVERTED BREVE
			["be"] = true,														-- Belarusian
			["ltc"] = true,														-- Middle Chinese; is this really IPA?
			["ru"] = true,														-- Russian
			["rue"] = true, 													-- Rusyn
			["sem"] = true,														-- Semitic languages
			["sit"] = true,														-- Sino-Tibetan languages
			["tt"] = true,														-- Tatar
			},
	[916] = {																	-- U+0394: GREEK CAPITAL LETTER DELTA
			["xsc"] = true,														-- Scythian
			},
	[920] = {																	-- U+0398: GREEK CAPITAL LETTER THETA
			["ae"] = true,														-- Avestan
			},
	[934] = {																	-- U+03A6: GREEK CAPITAL LETTER PHI
			["xle"] = true,														-- Lemnian
			},
	[945] = {																	-- U+03B1: GREEK SMALL LETTER ALPHA
			["apc"] = true,														-- Levantine Arabic
			},
	[946] = {																	-- U+03B2: GREEK SMALL LETTER BETA
			["ae"] = true,														-- Avestan
			["gha"] = true,														-- Ghadamès
			["ougr"] = true,													-- Old Uyghur
			["sem"] = true,														-- Semitic languages
			["syc"] = true,														-- Classical Syriac
			["wuu"] = true,														-- Shanghainese variety of Wu Chinese
			},
	[947] = {																	-- U+03B3: GREEK SMALL LETTER GAMMA
			["ae"] = true,														-- Avestan
			["ltc"] = true,														-- Late Middle Chinese
			["mn"] = true,														-- Mongolian
			["och"] = true,														-- Old Chinese
			["ougr"] = true,													-- Old Uyghur
			["pal"] = true,														-- Middle Persian
			["syc"] = true,														-- Classical Syriac
			["syr"] = true,														-- Syriac
			["xal"] = true,														-- Kalmyk or Oirat
			["xng"] = true,														-- Middle Mongolian
			["xsc"] = true,														-- Scythian
			["mong"] = true,													-- Mongolian
			},
	[948] = {																	-- U+03B4: GREEK SMALL LETTER DELTA
			["ae"] = true,														-- Avestan
			["ougr"] = true,													-- Old Uyghur
			["sog"] = true,														-- Sogdian
			["sogd"] = true,													-- Sogdian
			["syc"] = true,														-- Classical Syriac
			["xpr"] = true,														-- Parthian
			["xsc"] = true,														-- Scythian
			["xsc-x-pontic"] = true,											-- Pontic Scythian
			},
	[952] = {																	-- U+03B8: GREEK SMALL LETTER THETA
			["ae"] = true,														-- Avestan
			["ba"] = true,														-- Bashkir
			["cms"] = true,														-- Messapic
			["ett"] = true,														-- Etruscan
			["hur"] = true,														-- Halkomelem
			["ira"] = true,														-- Iranian languages
			["my"] = true,														-- Burmese
			["pal"] = true,														-- Middle Persian (Pahlavi)
			["peo"] = true,														-- Old Persian
			["sa"] = true,														-- Sanskrit
			["sem"] = true,														-- Semitic languages
			["syc"] = true,														-- Classical Syriac
			["syr"] = true,														-- Syriac
			["xpg"] = true,														-- Phrygian
			["xpr"] = true,														-- Parthian
			["xsc"] = true,														-- Scythian
			},
	[955] = {																	-- U+03BB: GREEK SMALL LETTER LAMDA
			["xcr"] = true,														-- Carian
			["xld"] = true,														-- Lydian
			},
	[963] = {																	-- U+03C3: GREEK SMALL LETTER SIGMA
			["ett"] = true,														-- Etruscan
			},
	[964] = {																	-- U+03C4: GREEK SMALL LETTER TAU
			["xld"] = true,														-- Lydian
			},
	[966] = {																	-- U+03C6: GREEK SMALL LETTER PHI
			["ett"] = true,														-- Etruscan
			},
	[967] = {																	-- U+03C7: GREEK SMALL LETTER CHI
			["ett"] = true,														-- Etruscan
			["gem"] = true,														-- Germanic languages
			["kbd"] = true,														-- Kabardian
			["ltc"] = true,														-- Late Middle Chinese
			["och"] = true,														-- Old Chinese
			["xlc"] = true,														-- Lycian
			["xle"] = true,														-- Lemnian
			},
	[968] = {																	-- U+03C8: GREEK SMALL LETTER PSI
			["ett"] = true,														-- Etruscan
			},
	[977] = {																	-- U+03D1: GREEK THETA SYMBOL
			["ae"] = true,														-- Avestan
			["xme"] = true,														-- Median
			["xsc"] = true,														-- Scythian
			["xsc-x-pontic"] = true,											-- Pontic Scythian
			},
	[1098] = {																	-- U+044A: CYRILLIC SMALL LETTER HARD SIGN
			["ady"] = true,														-- Adyghe
			["cu"] = true,														-- Church Slavic
			["zls"] = true,														-- South Slavic languages
			},
	[1100] = {																	-- U+044C: CYRILLIC SMALL LETTER SOFT SIGN
			["az"] = true,														-- Azerbaijani
			["cu"] = true,														-- Church Slavonic
			["dng"] = true,														-- Dungan
			["ru"] = true,														-- Russian
			["tt"] = true,														-- Tatar
			["tyv"] = true,														-- Tuvinian
			},
	[1278] = {																	-- U+04FE: CYRILLIC CAPITAL LETTER HA WITH STROKE
			["av"] = true,														-- Avar
			},
	[1279] = {																	-- U+04FF: CYRILLIC SMALL LETTER HA WITH STROKE
			["av"] = true,														-- Avar
			},
	[8113] = {																	-- U+1FB1: GREEK SMALL LETTER ALPHA WITH MACRON
			["apc"] = true,														-- Levantine Arabic
			},
	[8190] = {																	-- U+1FFE: GREEK DASIA
			["ar"] = true,														-- Arabic (Ayin)
			["xcl"] = true,														-- Classical Armenian
			},
	[19978] = {																	-- U+4E0A: [CJK Unified Ideographs]
			["wuu"] = true,														-- Wu Chinese tone marker
			},
	[20837] = {																	-- U+5165: [CJK Unified Ideographs]
			["wuu"] = true,														-- Wu Chinese tone marker
			},
	[21435] = {																	-- U+53BB: [CJK Unified Ideographs]
			["wuu"] = true,														-- Wu Chinese tone marker
			},
	[24179] = {																	-- U+5E73: [CJK Unified Ideographs]
			["wuu"] = true,														-- Wu Chinese tone marker
			},
	[38451] = {																	-- U+9633: [CJK Unified Ideographs] (Yang)
			["wuu"] = true,														-- Suzhou dialect of Wu Chinese tone marker --[[Suzhou dialect#Tones]]
			},
	[38452] = {																	-- U+9634: [CJK Unified Ideographs] (Yin)
			["wuu"] = true,														-- Suzhou dialect of Wu Chinese tone marker --[[Suzhou dialect#Tones]]
			},
	[65056] = {																	-- U+FE20: COMBINING LIGATURE LEFT HALF
			["ru"] = true,														-- Russian
			},
	[65057] = {																	-- U+FE21: COMBINING LIGATURE RIGHT HALF
			["ru"] = true,														-- Russian
			},
	}


--[[--------------------------&lt; E X P O R T S &gt;---------------------------------------------------------------
]]

return {
	ranges_t = ranges_t,
	singles_t = singles_t,
	specials_t = specials_t,
	
	sizeof_ranges_t = #ranges_t,
	}</text>
      <sha1>rljbhpqu41mlqzfdirdyfrjiqatx80d</sha1>
    </revision>
  </page>
  <page>
    <title>MediaWiki:Common.css</title>
    <ns>8</ns>
    <id>237</id>
    <revision>
      <id>461</id>
      <timestamp>2025-07-09T04:36:05Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "/*  * This is the CSS common to all desktop skins on en.Wikipedia.  * Styling inside .mw-parser-output should generally use TemplateStyles.  */ /* Reset italic styling set by user agent */ cite, dfn { 	font-style: inherit; }  /* Straight quote marks for &lt;q&gt; */ q { 	quotes: '"' '"' "'" "'"; }  /* Avoid collision of blockquote with floating elements by swapping margin and padding */ blockquote { 	overflow: hidden; 	margin: 1em 0; 	padding: 0 40px; }  /* Consistent size for..."</comment>
      <origin>461</origin>
      <model>css</model>
      <format>text/css</format>
      <text bytes="10785" sha1="isol0gdkkvnw30gfxq367nnhl5s2a6r" xml:space="preserve">/*
 * This is the CSS common to all desktop skins on en.Wikipedia.
 * Styling inside .mw-parser-output should generally use TemplateStyles.
 */
/* Reset italic styling set by user agent */
cite,
dfn {
	font-style: inherit;
}

/* Straight quote marks for &lt;q&gt; */
q {
	quotes: '"' '"' "'" "'";
}

/* Avoid collision of blockquote with floating elements by swapping margin and padding */
blockquote {
	overflow: hidden;
	margin: 1em 0;
	padding: 0 40px;
}

/* Consistent size for &lt;small&gt;, &lt;sub&gt; and &lt;sup&gt; */
small {
	font-size: 85%;
}

.mw-body-content sub,
.mw-body-content sup {
	font-size: 80%;
}

/* Same spacing for indented and unindented paragraphs on talk pages */
.ns-talk .mw-body-content dd {
	margin-top: 0.4em;
	margin-bottom: 0.4em;
}

/* Reduce page jumps by hiding collapsed/dismissed content */
.client-js .collapsible:not( .mw-made-collapsible).collapsed &gt; tbody &gt; tr:not(:first-child),

/* Avoid FOUC/reflows on collapsed elements. */
/* This copies MediaWiki's solution for T42812 to apply to innercollapse/outercollapse (T325115). */
/* TODO: Use :is() selector at some reasonable future when support is good for Most Clients */
/* Reference: https://gerrit.wikimedia.org/g/mediawiki/core/+/ecda06cb2aef55b77c4b4d7ecda492d634419ead/resources/src/jquery/jquery.makeCollapsible.styles.less#75 */
.client-js .outercollapse .innercollapse.mw-collapsible:not( .mw-made-collapsible ) &gt; p,
.client-js .outercollapse .innercollapse.mw-collapsible:not( .mw-made-collapsible ) &gt; table,
.client-js .outercollapse .innercollapse.mw-collapsible:not( .mw-made-collapsible ) &gt; thead + tbody,
.client-js .outercollapse .innercollapse.mw-collapsible:not( .mw-made-collapsible ) tr:not( :first-child ),
.client-js .outercollapse .innercollapse.mw-collapsible:not( .mw-made-collapsible ) .mw-collapsible-content,

/* Hide charinsert base for those not using the gadget */
#editpage-specialchars {
	display: none;
}

/* Different margin on references */
.references {
	margin-bottom: 0.5em;
}

/* Cite customizations */
span[ rel="mw:referencedBy" ] {
	counter-reset: mw-ref-linkback 0;
}

span[ rel='mw:referencedBy' ] &gt; a::before {
	content: counter( mw-ref-linkback, lower-alpha );
	font-size: 80%;
	font-weight: bold;
	font-style: italic;
}

a[ rel="mw:referencedBy" ]::before {
	font-weight: bold;
	content: "^";
}

span[ rel="mw:referencedBy" ]::before {
	content: "^ ";
}

/* Styling for jQuery makeCollapsible, matching that of collapseButton */
.mw-parser-output .mw-collapsible-toggle:not(.mw-ui-button) {
	font-weight: normal;
	padding-right: 0.2em;
	padding-left: 0.2em;
}

.mw-collapsible-leftside-toggle .mw-collapsible-toggle {
	/* @noflip */
	float: left;
}

/* Lists in wikitable data cells are always left-aligned */
.wikitable td ul,
.wikitable td ol,
.wikitable td dl {
	/* @noflip */
	text-align: left;
}

/* Change the external link icon to a PDF icon for all PDF files */
.mw-parser-output a[href$=".pdf"].external,
.mw-parser-output a[href*=".pdf?"].external,
.mw-parser-output a[href*=".pdf#"].external,
.mw-parser-output a[href$=".PDF"].external,
.mw-parser-output a[href*=".PDF?"].external,
.mw-parser-output a[href*=".PDF#"].external {
	background: url("//upload.wikimedia.org/wikipedia/commons/4/4d/Icon_pdf_file.png") no-repeat right;
	/* @noflip */
	padding: 8px 18px 8px 0;
}

/* System messages styled similarly to fmbox */
/* for .mw-warning-with-logexcerpt, behavior of this line differs between
 * the edit-protected notice and the special:Contribs for blocked users
 * The latter has specificity of 3 classes so we have to triple up here.
 */
.mw-warning-with-logexcerpt.mw-warning-with-logexcerpt.mw-warning-with-logexcerpt,
div.mw-lag-warn-high,
div.mw-cascadeprotectedwarning,
div#mw-protect-cascadeon {
	clear: both;
	margin: 0.2em 0;
	border: 1px solid #bb7070;
	background-color: var(--background-color-error-subtle, #ffdbdb);
	padding: 0.25em 0.9em;
	box-sizing: border-box;
}

/* default colors for partial block message */
/* gotta get over the hump introduced by the triple class above */
.mw-contributions-blocked-notice-partial .mw-warning-with-logexcerpt.mw-warning-with-logexcerpt {
	border-color: #fc3;
	background-color: var(--background-color-warning-subtle, #fef6e7);
}

/* Minimum thumb width */
@media (min-width: 640px) {
	figure[typeof~='mw:File/Thumb'],
	figure[typeof~='mw:File/Frame'],
	.thumbinner {
		min-width: 100px;
	}
}

/* Prevent floating boxes from overlapping any category listings,
   file histories, edit previews, and edit [Show changes] views. */
#mw-subcategories,
#mw-pages,
#mw-category-media,
#filehistory,
#wikiPreview,
#wikiDiff {
	clear: both;
}

/* Hide stuff meant for accounts with special permissions. Made visible again in
   [[MediaWiki:Group-checkuser.css]], [[MediaWiki:Group-sysop.css]], [[MediaWiki:Group-abusefilter.css]],
   [[MediaWiki:Group-abusefilter-helper.css]], [[MediaWiki:Group-patroller.css]],
   [[MediaWiki:Group-templateeditor.css]], [[MediaWiki:Group-extendedmover.css]],
   [[MediaWiki:Group-extendedconfirmed.css]], and [[Mediawiki:Group-autoconfirmed.css]]. */
.checkuser-show,
.sysop-show,
.abusefilter-show,
.abusefilter-helper-show,
.patroller-show,
.templateeditor-show,
.extendedmover-show,
.extendedconfirmed-show,
.autoconfirmed-show,
.user-show {
	display: none;
}

/* Hide the redlink generated by {{Editnotice}},
   this overrides the ".sysop-show { display: none; }" above that applies
   to the same link as well. See [[phab:T45013]]

   Hide the images in editnotices to keep them readable in VE view.
   Long term, editnotices should become a core feature so that they can be designed responsive. */
.ve-ui-mwNoticesPopupTool-item .editnotice-redlink,
.ve-ui-mwNoticesPopupTool-item .mbox-image,
.ve-ui-mwNoticesPopupTool-item .mbox-imageright {
	display: none !important;
}

/* Remove bullets when there are multiple edit page warnings */
ul.permissions-errors {
	margin: 0;
}

ul.permissions-errors &gt; li {
	list-style: none;
}

/* larger inline math */
span.mwe-math-mathml-inline {
	font-size: 118%;
}

/* Make &lt;math display="block"&gt; be left aligned with one space indent for 
 * compatibility with style conventions
 */
.mwe-math-fallback-image-display,
.mwe-math-mathml-display {
	margin-left: 1.6em !important;
	margin-top: 0.6em;
	margin-bottom: 0.6em;
}

.mwe-math-mathml-display math {
	display: inline;
}

@media screen {
	/* Put a chequered background behind images, only visible if they have transparency,
	 * except on main, user, and portal namespaces
	 */
	body:not(.ns-0):not(.ns-2):not(.ns-100) .gallerybox .thumb img {
		background: #fff url(//upload.wikimedia.org/wikipedia/commons/5/5d/Checker-16x16.png) repeat;
	}

	/* Display "From Wikipedia, the free encyclopedia" in skins that support it,
	   do not apply to print mode */
	#siteSub {
		display: block;
	}
	
	/* Make the list of references smaller
	 * Keep in sync with Template:Refbegin/styles.css
	 * And Template:Reflist/styles.css
	 */
	.references {
		font-size: 90%;
	}
}

/* Hide FlaggedRevs notice UI when there are no pending changes */
.flaggedrevs_draft_synced,
.flaggedrevs_stable_synced,
/* "Temporary" to remove links in sidebar T255381 */
#t-upload,
/* Hide broken download box on Special:Book pending T285400 */
.mw-special-Book #coll-downloadbox {
	display: none;
}

/*
 * BELOW HERE THERE BE SOONTOBE TEMPLATESTYLES THINGS;
 * SEE [[MediaWiki talk:Common.css/to do]]
 * CSS is separated by component (which is why media queries are not joined)
 */

/* Infoboxes */
.infobox {
	border: 1px solid #a2a9b1;
	color: black;
	padding: 0.2em;
	font-size: 88%;
	line-height: 1.5em;
	border-spacing: 3px;
}

@media screen {
	.infobox {
		background-color: #f8f9fa;
    }
}

@media (max-width: 640px) {
	.infobox {
		width: 100%;
	}
    
	.infobox .nowrap {
		white-space: normal;
	}
}

@media (min-width: 640px) {
	.infobox {
		/* @noflip */
		margin: 0.5em 0 0.5em 1em;
		/* @noflip */
		float: right;
		/* @noflip */
		clear: right;
		width: 22em;
	}
}

.infobox-header,
.infobox-label,
.infobox-above,
.infobox-full-data,
.infobox-data,
.infobox-below,
.infobox-subheader,
.infobox-image,
.infobox-navbar,
/* Remove element selector when every .infobox thing is using the standard module/templates  */
.infobox th,
.infobox td {
	vertical-align: top;
}

.infobox-label,
.infobox-data,
/* Remove element selector when every .infobox thing is using the standard module/templates  */
.infobox th,
.infobox td {
	/* @noflip */
	text-align: left;
}

/* Remove .infobox when element selectors above are removed */
.infobox .infobox-above,
.infobox .infobox-title,
/* Remove element selector when every .infobox thing is using the standard module/templates  */
.infobox caption {
	font-size: 125%;
	font-weight: bold;
	text-align: center;
}

.infobox-title,
/* Remove element selector when every .infobox thing is using the standard module/templates  */
.infobox caption {
	padding: 0.2em;
}

/* Remove .infobox when element selectors above are removed */
.infobox .infobox-header,
.infobox .infobox-subheader,
.infobox .infobox-image,
.infobox .infobox-full-data,
.infobox .infobox-below {
	text-align: center;
}

/* Remove .infobox when element selectors above are removed */
.infobox .infobox-navbar {
	/* @noflip */
	text-align: right;
}

/* Normal font styling for wikitable row headers with scope="row" tag */
.wikitable.plainrowheaders th[scope=row],
.wikitable.plainrowheaders th[scope=rowgroup] {
	font-weight: normal;
	/* @noflip */
	text-align: left;
}

/* Remove underlines from certain links */
.nounderlines a,
.IPA a:link,
.IPA a:visited {
	text-decoration: none !important;
}

/* Prevent line breaks in silly places where desired (nowrap)
   and links when we don't want them to (nowraplinks a) */
.nowrap,
.nowraplinks a {
	white-space: nowrap;
}

/* But allow wrapping where desired: */
.wrap,
.wraplinks a {
	white-space: normal;
}

/* texhtml class for inline math (based on generic times-serif class) */
/* remove spans when this is TemplateStyled */
span.texhtml {
	font-family: "Nimbus Roman No9 L", "Times New Roman", Times, serif;
	font-size: 118%;
	line-height: 1;
	/* Force tabular and lining display for texhtml */
	font-variant-numeric: lining-nums tabular-nums;
	font-kerning: none;
}

span.texhtml span.texhtml {
	font-size: 100%;
}

@media (min-width: 640px) {
	span.texhtml {
		white-space: nowrap;
	}
}

/* Prevent flags in tables from collapsing: Fix for T116318
 * TODO: Remove when [[phab:T368469]] merges [[phab:T367463]] for the other skins
 */
@media (max-width: 640px) {
	.flagicon a &gt; img,
	.flagicon noscript &gt; img {
		max-width: none !important;
	}
}

@media screen {
	.nochecker .gallerybox .thumb img {
		background-image: none;
	}
}

/*
 * Put anything you mean to be a sitewide addition above the TemplateStyles
 * comment above.
 */</text>
      <sha1>isol0gdkkvnw30gfxq367nnhl5s2a6r</sha1>
    </revision>
  </page>
  <page>
    <title>MediaWiki:Common.js</title>
    <ns>8</ns>
    <id>238</id>
    <revision>
      <id>462</id>
      <timestamp>2025-07-09T04:36:45Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "/**  * Keep code in MediaWiki:Common.js to a minimum as it is unconditionally  * loaded for all users on every wiki page. If possible create a gadget that is  * enabled by default instead of adding it here (since gadgets are fully  * optimized ResourceLoader modules with possibility to add dependencies etc.)  *  * Since Common.js isn't a gadget, there is no place to declare its  * dependencies, so we have to lazy load them with mw.loader.using on demand and  * then execu..."</comment>
      <origin>462</origin>
      <model>javascript</model>
      <format>text/javascript</format>
      <text bytes="4606" sha1="6jgb7dsuya96vrcft2s1fo949ms69c8" xml:space="preserve">/**
 * Keep code in MediaWiki:Common.js to a minimum as it is unconditionally
 * loaded for all users on every wiki page. If possible create a gadget that is
 * enabled by default instead of adding it here (since gadgets are fully
 * optimized ResourceLoader modules with possibility to add dependencies etc.)
 *
 * Since Common.js isn't a gadget, there is no place to declare its
 * dependencies, so we have to lazy load them with mw.loader.using on demand and
 * then execute the rest in the callback. In most cases these dependencies will
 * be loaded (or loading) already and the callback will not be delayed. In case a
 * dependency hasn't arrived yet it'll make sure those are loaded before this.
 */

/* global mw, $ */
/* jshint strict:false, browser:true */

mw.loader.using( [ 'mediawiki.util' ] ).done( function () {
	/* Begin of mw.loader.using callback */

	/**
	 * Map addPortletLink to mw.util
	 * @deprecated: Use mw.util.addPortletLink instead.
	 */
	mw.log.deprecate( window, 'addPortletLink', mw.util.addPortletLink, 'Use mw.util.addPortletLink instead' );

	/**
	 * @source www.mediawiki.org/wiki/Snippets/Load_JS_and_CSS_by_URL
	 * @rev 6
	 */
	var extraCSS = mw.util.getParamValue( 'withCSS' ),
		extraJS = mw.util.getParamValue( 'withJS' );

	if ( extraCSS ) {
		if ( extraCSS.match( /^MediaWiki:[^&amp;&lt;&gt;=%#]*\.css$/ ) ) {
			mw.loader.load( '/w/index.php?title=' + extraCSS + '&amp;action=raw&amp;ctype=text/css', 'text/css' );
		} else {
			mw.notify( 'Only pages from the MediaWiki namespace are allowed.', { title: 'Invalid withCSS value' } );
		}
	}

	if ( extraJS ) {
		if ( extraJS.match( /^MediaWiki:[^&amp;&lt;&gt;=%#]*\.js$/ ) ) {
			mw.loader.load( '/w/index.php?title=' + extraJS + '&amp;action=raw&amp;ctype=text/javascript' );
		} else {
			mw.notify( 'Only pages from the MediaWiki namespace are allowed.', { title: 'Invalid withJS value' } );
		}
	}

	/**
	 * Collapsible tables; reimplemented with mw-collapsible
	 * Styling is also in place to avoid FOUC
	 *
	 * Allows tables to be collapsed, showing only the header. See [[Help:Collapsing]].
	 * @version 3.0.0 (2018-05-20)
	 * @source https://www.mediawiki.org/wiki/MediaWiki:Gadget-collapsibleTables.js
	 * @author [[User:R. Koot]]
	 * @author [[User:Krinkle]]
	 * @author [[User:TheDJ]]
	 * @deprecated Since MediaWiki 1.20: Use class="mw-collapsible" instead which
	 * is supported in MediaWiki core. Shimmable since MediaWiki 1.32
	 *
	 * @param {jQuery} $content
	 */
	function makeCollapsibleMwCollapsible( $content ) {
		var $tables = $content
			.find( 'table.collapsible:not(.mw-collapsible)' )
			.addClass( 'mw-collapsible' );

		$.each( $tables, function ( index, table ) {
			// mw.log.warn( 'This page is using the deprecated class collapsible. Please replace it with mw-collapsible.');
			if ( $( table ).hasClass( 'collapsed' ) ) {
				$( table ).addClass( 'mw-collapsed' );
				// mw.log.warn( 'This page is using the deprecated class collapsed. Please replace it with mw-collapsed.');
			}
		} );
		if ( $tables.length &gt; 0 ) {
			mw.loader.using( 'jquery.makeCollapsible' ).then( function () {
				$tables.makeCollapsible();
			} );
		}
	}
	mw.hook( 'wikipage.content' ).add( makeCollapsibleMwCollapsible );

	/**
	 * Add support to mw-collapsible for autocollapse, innercollapse and outercollapse
	 *
	 * Maintainers: TheDJ
	 */
	function mwCollapsibleSetup( $collapsibleContent ) {
		var $element,
			$toggle,
			autoCollapseThreshold = 2;
		$.each( $collapsibleContent, function ( index, element ) {
			$element = $( element );
			if ( $element.hasClass( 'collapsible' ) ) {
				$element.find( 'tr:first &gt; th:first' ).prepend( $element.find( 'tr:first &gt; * &gt; .mw-collapsible-toggle' ) );
			}
			if ( $collapsibleContent.length &gt;= autoCollapseThreshold &amp;&amp; $element.hasClass( 'autocollapse' ) ) {
				$element.data( 'mw-collapsible' ).collapse();
			} else if ( $element.hasClass( 'innercollapse' ) ) {
				if ( $element.parents( '.outercollapse' ).length &gt; 0 ) {
					$element.data( 'mw-collapsible' ).collapse();
				}
			}
			// because of colored backgrounds, style the link in the text color
			// to ensure accessible contrast
			$toggle = $element.find( '.mw-collapsible-toggle' );
			if ( $toggle.length ) {
				// Make the toggle inherit text color (Updated for T333357 2023-04-29)
				if ( $toggle.parent()[ 0 ].style.color ) {
					$toggle.css( 'color', 'inherit' );
					$toggle.find( '.mw-collapsible-text' ).css( 'color', 'inherit' );
				}
			}
		} );
	}

	mw.hook( 'wikipage.collapsibleContent' ).add( mwCollapsibleSetup );

	/* End of mw.loader.using callback */
} );
/* DO NOT ADD CODE BELOW THIS LINE */</text>
      <sha1>6jgb7dsuya96vrcft2s1fo949ms69c8</sha1>
    </revision>
  </page>
  <page>
    <title>File:Wii-Console.png.png</title>
    <ns>6</ns>
    <id>239</id>
    <revision>
      <id>464</id>
      <timestamp>2025-07-09T04:42:50Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <origin>464</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3" sha1="528vfisb3785bw0trivg8iap745h3dc" xml:space="preserve">Wii</text>
      <sha1>528vfisb3785bw0trivg8iap745h3dc</sha1>
    </revision>
  </page>
  <page>
    <title>Wii</title>
    <ns>0</ns>
    <id>240</id>
    <revision>
      <id>466</id>
      <parentid>465</parentid>
      <timestamp>2025-07-09T04:43:59Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <comment>/* WII */</comment>
      <origin>466</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="44" sha1="ooqnz0n5lghnp5dxfvqglils4t3o44x" xml:space="preserve">[[File:Wii-Console.png|thumb]]

Nintendo Wii</text>
      <sha1>ooqnz0n5lghnp5dxfvqglils4t3o44x</sha1>
    </revision>
  </page>
  <page>
    <title>File:Wii-Console.png</title>
    <ns>6</ns>
    <id>241</id>
    <revision>
      <id>467</id>
      <timestamp>2025-07-09T04:44:59Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <origin>467</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="0" sha1="phoiac9h4m842xq45sp7s6u21eteeq1" xml:space="preserve" />
      <sha1>phoiac9h4m842xq45sp7s6u21eteeq1</sha1>
    </revision>
  </page>
  <page>
    <title>File:Legend of Zelda Skyward Sword boxart.png</title>
    <ns>6</ns>
    <id>242</id>
    <revision>
      <id>468</id>
      <timestamp>2025-07-09T04:45:34Z</timestamp>
      <contributor>
        <username>Giantbomb</username>
        <id>1</id>
      </contributor>
      <origin>468</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="0" sha1="phoiac9h4m842xq45sp7s6u21eteeq1" xml:space="preserve" />
      <sha1>phoiac9h4m842xq45sp7s6u21eteeq1</sha1>
    </revision>
  </page>
</mediawiki>
